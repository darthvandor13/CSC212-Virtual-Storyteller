<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.combinatorics.perm_groups.PermutationGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1combinatorics.html">combinatorics</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1combinatorics_1_1perm__groups.html">perm_groups</a></li><li class="navelem"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html">PermutationGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sympy.combinatorics.perm_groups.PermutationGroup Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for sympy.combinatorics.perm_groups.PermutationGroup:</div>
<div class="dyncontent">
<div class="center"><img src="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup__inherit__graph.png" border="0" usemap="#asympy_8combinatorics_8perm__groups_8PermutationGroup_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sympy.combinatorics.perm_groups.PermutationGroup:</div>
<div class="dyncontent">
<div class="center"><img src="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup__coll__graph.png" border="0" usemap="#asympy_8combinatorics_8perm__groups_8PermutationGroup_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0de7b92db97d96cc13cd6c290e20e083"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0de7b92db97d96cc13cd6c290e20e083">__new__</a> (cls, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, dups=True, **kwargs)</td></tr>
<tr class="separator:a0de7b92db97d96cc13cd6c290e20e083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0716b231b058e2931ac2fa9042e0a2a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0716b231b058e2931ac2fa9042e0a2a8">__init__</a> (self, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, **kwargs)</td></tr>
<tr class="separator:a0716b231b058e2931ac2fa9042e0a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b4a02f47aae013546c54e6e2495526"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04b4a02f47aae013546c54e6e2495526">__getitem__</a> (self, i)</td></tr>
<tr class="separator:a04b4a02f47aae013546c54e6e2495526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdccfccd6b33b5af6ea9a9337f8cf4e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#afdccfccd6b33b5af6ea9a9337f8cf4e5">__contains__</a> (self, i)</td></tr>
<tr class="separator:afdccfccd6b33b5af6ea9a9337f8cf4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab803e52d9fad6c542fc2fcba7132a5d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ab803e52d9fad6c542fc2fcba7132a5d8">__len__</a> (self)</td></tr>
<tr class="separator:ab803e52d9fad6c542fc2fcba7132a5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf887fdd0e60658e26b388cde24ccab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a8cf887fdd0e60658e26b388cde24ccab">equals</a> (self, other)</td></tr>
<tr class="separator:a8cf887fdd0e60658e26b388cde24ccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e07ca01da5a3cd76bc306cbffed5987"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a8e07ca01da5a3cd76bc306cbffed5987">__mul__</a> (self, other)</td></tr>
<tr class="separator:a8e07ca01da5a3cd76bc306cbffed5987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c7e522087fd136432d29cf2032ac0e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a> (self)</td></tr>
<tr class="separator:a04c7e522087fd136432d29cf2032ac0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6597e1e817ffc343a95a7b796a696b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a3d6597e1e817ffc343a95a7b796a696b">baseswap</a> (self, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a>, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a9f013092f2523ad34848ea3286967c2e">strong_gens</a>, pos, randomized=False, transversals=None, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aac38d09a5423c85cd1c37778a4774766">basic_orbits</a>=None, strong_gens_distr=None)</td></tr>
<tr class="separator:a3d6597e1e817ffc343a95a7b796a696b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac38d09a5423c85cd1c37778a4774766"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aac38d09a5423c85cd1c37778a4774766">basic_orbits</a> (self)</td></tr>
<tr class="separator:aac38d09a5423c85cd1c37778a4774766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff132d2b0e6a4f7b16abf151f4caafc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a6ff132d2b0e6a4f7b16abf151f4caafc">basic_stabilizers</a> (self)</td></tr>
<tr class="separator:a6ff132d2b0e6a4f7b16abf151f4caafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f82634a58a706253c7caea8588d284"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa6f82634a58a706253c7caea8588d284">basic_transversals</a> (self)</td></tr>
<tr class="separator:aa6f82634a58a706253c7caea8588d284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7490dd3c6da951d96ab928fe5e893ce3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a7490dd3c6da951d96ab928fe5e893ce3">composition_series</a> (self)</td></tr>
<tr class="separator:a7490dd3c6da951d96ab928fe5e893ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246f19ba3baa008220b54728b3e2d72f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a246f19ba3baa008220b54728b3e2d72f">coset_transversal</a> (self, H)</td></tr>
<tr class="separator:a246f19ba3baa008220b54728b3e2d72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017b7db6f1fedc8494f42d5e108002a6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a017b7db6f1fedc8494f42d5e108002a6">coset_table</a> (self, H)</td></tr>
<tr class="separator:a017b7db6f1fedc8494f42d5e108002a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2235023c8ae310df7091c9eea52078e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2235023c8ae310df7091c9eea52078e6">center</a> (self)</td></tr>
<tr class="separator:a2235023c8ae310df7091c9eea52078e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c9a1124a5d165c3857e42710227cf7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a60c9a1124a5d165c3857e42710227cf7">centralizer</a> (self, other)</td></tr>
<tr class="separator:a60c9a1124a5d165c3857e42710227cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd565b0ad59da694ea28b0bc98cdd09d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#afd565b0ad59da694ea28b0bc98cdd09d">commutator</a> (self, G, H)</td></tr>
<tr class="separator:afd565b0ad59da694ea28b0bc98cdd09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb8ef9c8b0e992a4b904e55605ff7f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa1eb8ef9c8b0e992a4b904e55605ff7f">coset_factor</a> (self, g, factor_index=False)</td></tr>
<tr class="separator:aa1eb8ef9c8b0e992a4b904e55605ff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fa299e9d3b67a43b9437c10499113b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ad5fa299e9d3b67a43b9437c10499113b">generator_product</a> (self, g, original=False)</td></tr>
<tr class="separator:ad5fa299e9d3b67a43b9437c10499113b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dafce9e16e750217e5b56ceae873a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ac1dafce9e16e750217e5b56ceae873a5">coset_rank</a> (self, g)</td></tr>
<tr class="separator:ac1dafce9e16e750217e5b56ceae873a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19554681aebe72cd83ee8b6b7d73fdc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa19554681aebe72cd83ee8b6b7d73fdc">coset_unrank</a> (self, rank, af=False)</td></tr>
<tr class="separator:aa19554681aebe72cd83ee8b6b7d73fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79383116523bc879cf6463def1f4d266"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a79383116523bc879cf6463def1f4d266">degree</a> (self)</td></tr>
<tr class="separator:a79383116523bc879cf6463def1f4d266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bd0df5d92c30bc675b2a8411393e22"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a96bd0df5d92c30bc675b2a8411393e22">identity</a> (self)</td></tr>
<tr class="separator:a96bd0df5d92c30bc675b2a8411393e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896cb7478e42f44c2c61108cfdbfe717"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a896cb7478e42f44c2c61108cfdbfe717">elements</a> (self)</td></tr>
<tr class="separator:a896cb7478e42f44c2c61108cfdbfe717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30446ba845d5b811ff455a5289911c51"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a30446ba845d5b811ff455a5289911c51">derived_series</a> (self)</td></tr>
<tr class="separator:a30446ba845d5b811ff455a5289911c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76116697ea2112a4dfdb517871edd16"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ad76116697ea2112a4dfdb517871edd16">derived_subgroup</a> (self)</td></tr>
<tr class="separator:ad76116697ea2112a4dfdb517871edd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9e5d43c0c64b1c275bfa6653e805f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a1d9e5d43c0c64b1c275bfa6653e805f6">generate</a> (self, method=&quot;coset&quot;, af=False)</td></tr>
<tr class="separator:a1d9e5d43c0c64b1c275bfa6653e805f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9072b36546fb25ae06052aec93597ae9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a9072b36546fb25ae06052aec93597ae9">generate_dimino</a> (self, af=False)</td></tr>
<tr class="separator:a9072b36546fb25ae06052aec93597ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395ab6a0b05cb6063132f9faa9f50447"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a395ab6a0b05cb6063132f9faa9f50447">generate_schreier_sims</a> (self, af=False)</td></tr>
<tr class="separator:a395ab6a0b05cb6063132f9faa9f50447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acb6230f24e98620528b8104b43e5cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a6acb6230f24e98620528b8104b43e5cb">generators</a> (self)</td></tr>
<tr class="separator:a6acb6230f24e98620528b8104b43e5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e2dce2cdfa37fd05d09a87f5334385"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ad0e2dce2cdfa37fd05d09a87f5334385">contains</a> (self, g, strict=True)</td></tr>
<tr class="separator:ad0e2dce2cdfa37fd05d09a87f5334385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150928c8161147932617c38dd1623e88"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a150928c8161147932617c38dd1623e88">is_perfect</a> (self)</td></tr>
<tr class="separator:a150928c8161147932617c38dd1623e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a60cbfce2006021ac8e3bd41caec72"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ae8a60cbfce2006021ac8e3bd41caec72">is_abelian</a> (self)</td></tr>
<tr class="separator:ae8a60cbfce2006021ac8e3bd41caec72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4a2bd2eb937cbec1f9626e89e102c4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a6a4a2bd2eb937cbec1f9626e89e102c4">abelian_invariants</a> (self)</td></tr>
<tr class="separator:a6a4a2bd2eb937cbec1f9626e89e102c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf30365aa16d94011e76553f8d2f1bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2bf30365aa16d94011e76553f8d2f1bc">is_elementary</a> (self, p)</td></tr>
<tr class="separator:a2bf30365aa16d94011e76553f8d2f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a6832ed209ffdaf2bf528e3407d1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a689a6832ed209ffdaf2bf528e3407d1c">is_alt_sym</a> (self, eps=0.05, _random_prec=None)</td></tr>
<tr class="separator:a689a6832ed209ffdaf2bf528e3407d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaacd70fef3e7bd0aa06ecbc68c5f733"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#adaacd70fef3e7bd0aa06ecbc68c5f733">is_nilpotent</a> (self)</td></tr>
<tr class="separator:adaacd70fef3e7bd0aa06ecbc68c5f733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08a60a2f43c68f1a56e569b65f0fea6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#af08a60a2f43c68f1a56e569b65f0fea6">is_normal</a> (self, gr, strict=True)</td></tr>
<tr class="separator:af08a60a2f43c68f1a56e569b65f0fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4cab8bcce55d13493906e4db9dae6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2fb4cab8bcce55d13493906e4db9dae6">is_primitive</a> (self, randomized=True)</td></tr>
<tr class="separator:a2fb4cab8bcce55d13493906e4db9dae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e65d45c135d454fbe32493757d1f3ee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2e65d45c135d454fbe32493757d1f3ee">minimal_blocks</a> (self, randomized=True)</td></tr>
<tr class="separator:a2e65d45c135d454fbe32493757d1f3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4cfcd0e2b6a91ffcad895823b0ade"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a1cb4cfcd0e2b6a91ffcad895823b0ade">is_solvable</a> (self)</td></tr>
<tr class="separator:a1cb4cfcd0e2b6a91ffcad895823b0ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c18fbaf345a33ee70e9c4f67496bb2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0c18fbaf345a33ee70e9c4f67496bb2e">is_subgroup</a> (self, G, strict=True)</td></tr>
<tr class="separator:a0c18fbaf345a33ee70e9c4f67496bb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb595484067ff05b4d9834c61cbe5759"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#acb595484067ff05b4d9834c61cbe5759">is_polycyclic</a> (self)</td></tr>
<tr class="separator:acb595484067ff05b4d9834c61cbe5759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dcb1e94d17f08834d7b40323f36d4b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a90dcb1e94d17f08834d7b40323f36d4b">is_transitive</a> (self, strict=True)</td></tr>
<tr class="separator:a90dcb1e94d17f08834d7b40323f36d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6993aff9524bfdc43a8e4949b5915231"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a6993aff9524bfdc43a8e4949b5915231">is_trivial</a> (self)</td></tr>
<tr class="separator:a6993aff9524bfdc43a8e4949b5915231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2379ca9d76560e0135f601e68af3f88e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2379ca9d76560e0135f601e68af3f88e">lower_central_series</a> (self)</td></tr>
<tr class="separator:a2379ca9d76560e0135f601e68af3f88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f36da80262829f87bad2c3a695e882"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ab7f36da80262829f87bad2c3a695e882">max_div</a> (self)</td></tr>
<tr class="separator:ab7f36da80262829f87bad2c3a695e882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d33347199ac473b0ac402b3b0ac43"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a169d33347199ac473b0ac402b3b0ac43">minimal_block</a> (self, points)</td></tr>
<tr class="separator:a169d33347199ac473b0ac402b3b0ac43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f259a5c75b9220d96be8561a5bc978"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa4f259a5c75b9220d96be8561a5bc978">conjugacy_class</a> (self, x)</td></tr>
<tr class="separator:aa4f259a5c75b9220d96be8561a5bc978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d54fefe645f67e30d1cc0d5d8e9578"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#af8d54fefe645f67e30d1cc0d5d8e9578">conjugacy_classes</a> (self)</td></tr>
<tr class="separator:af8d54fefe645f67e30d1cc0d5d8e9578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7c38e8e29c220cd77270339a10381"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#afff7c38e8e29c220cd77270339a10381">normal_closure</a> (self, other, k=10)</td></tr>
<tr class="separator:afff7c38e8e29c220cd77270339a10381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460f8946cdf683163d59c7072ee3d29e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a460f8946cdf683163d59c7072ee3d29e">orbit</a> (self, alpha, action='tuples')</td></tr>
<tr class="separator:a460f8946cdf683163d59c7072ee3d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bcbd4af19aa06fd3d7b39a8001152e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#af9bcbd4af19aa06fd3d7b39a8001152e">orbit_rep</a> (self, alpha, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2029b24877b1c045bd2908c4cade1014">schreier_vector</a>=None)</td></tr>
<tr class="separator:af9bcbd4af19aa06fd3d7b39a8001152e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b16152823083ed1567e6a429d41b791"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0b16152823083ed1567e6a429d41b791">orbit_transversal</a> (self, alpha, pairs=False)</td></tr>
<tr class="separator:a0b16152823083ed1567e6a429d41b791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc238571a25fd13082c6d46091020ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aadc238571a25fd13082c6d46091020ef">orbits</a> (self, rep=False)</td></tr>
<tr class="separator:aadc238571a25fd13082c6d46091020ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c13a15c002cd1300b1c80328aa9295"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa4c13a15c002cd1300b1c80328aa9295">order</a> (self)</td></tr>
<tr class="separator:aa4c13a15c002cd1300b1c80328aa9295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2778845a2bf4331713ab1921abfb6d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ae2778845a2bf4331713ab1921abfb6d5">index</a> (self, H)</td></tr>
<tr class="separator:ae2778845a2bf4331713ab1921abfb6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547e87e4cd7a0da5d6f326b58090141c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a547e87e4cd7a0da5d6f326b58090141c">is_symmetric</a> (self)</td></tr>
<tr class="separator:a547e87e4cd7a0da5d6f326b58090141c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292e6ce31910b86f3f77913ae800dfc8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a292e6ce31910b86f3f77913ae800dfc8">is_alternating</a> (self)</td></tr>
<tr class="separator:a292e6ce31910b86f3f77913ae800dfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c458a1a52990c3caa1bc221e231543"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#af5c458a1a52990c3caa1bc221e231543">is_cyclic</a> (self)</td></tr>
<tr class="separator:af5c458a1a52990c3caa1bc221e231543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0681d8380ee0c5aec16a08b20269eb7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0681d8380ee0c5aec16a08b20269eb7d">is_dihedral</a> (self)</td></tr>
<tr class="separator:a0681d8380ee0c5aec16a08b20269eb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72db2b8d8d1a352cc9c1243b0ba4fc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ae72db2b8d8d1a352cc9c1243b0ba4fc0">pointwise_stabilizer</a> (self, points, incremental=True)</td></tr>
<tr class="separator:ae72db2b8d8d1a352cc9c1243b0ba4fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fbc74df7792666e509a0e352c0d912"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a68fbc74df7792666e509a0e352c0d912">make_perm</a> (self, n, seed=None)</td></tr>
<tr class="separator:a68fbc74df7792666e509a0e352c0d912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49a5e8efd11953b733a223ac3390a00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ad49a5e8efd11953b733a223ac3390a00">random</a> (self, af=False)</td></tr>
<tr class="separator:ad49a5e8efd11953b733a223ac3390a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec91e456ad70949d6efdc32db13c719b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aec91e456ad70949d6efdc32db13c719b">random_pr</a> (self, gen_count=11, iterations=50, _random_prec=None)</td></tr>
<tr class="separator:aec91e456ad70949d6efdc32db13c719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d35747d13633478618d900a2d03f48b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a8d35747d13633478618d900a2d03f48b">random_stab</a> (self, alpha, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2029b24877b1c045bd2908c4cade1014">schreier_vector</a>=None, _random_prec=None)</td></tr>
<tr class="separator:a8d35747d13633478618d900a2d03f48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7f034b7d590a0c2c6189abb28baf8c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0b7f034b7d590a0c2c6189abb28baf8c">schreier_sims</a> (self)</td></tr>
<tr class="separator:a0b7f034b7d590a0c2c6189abb28baf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a74d41168516ae30d8cbbb83250a5a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0a74d41168516ae30d8cbbb83250a5a0">schreier_sims_incremental</a> (self, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a>=None, gens=None, slp_dict=False)</td></tr>
<tr class="separator:a0a74d41168516ae30d8cbbb83250a5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300fff1c31c164aebcd65aa7de0ad9e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a4300fff1c31c164aebcd65aa7de0ad9e">schreier_sims_random</a> (self, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a>=None, gens=None, consec_succ=10, _random_prec=None)</td></tr>
<tr class="separator:a4300fff1c31c164aebcd65aa7de0ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2029b24877b1c045bd2908c4cade1014"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2029b24877b1c045bd2908c4cade1014">schreier_vector</a> (self, alpha)</td></tr>
<tr class="separator:a2029b24877b1c045bd2908c4cade1014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2c65f749705c1d6225f5cede73607a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aed2c65f749705c1d6225f5cede73607a">stabilizer</a> (self, alpha)</td></tr>
<tr class="separator:aed2c65f749705c1d6225f5cede73607a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f013092f2523ad34848ea3286967c2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a9f013092f2523ad34848ea3286967c2e">strong_gens</a> (self)</td></tr>
<tr class="separator:a9f013092f2523ad34848ea3286967c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410e5597d9b807557eb1e2f592ad9f27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a410e5597d9b807557eb1e2f592ad9f27">subgroup</a> (self, gens)</td></tr>
<tr class="separator:a410e5597d9b807557eb1e2f592ad9f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d83084c8aee9c5523cf088fb86a528"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a01d83084c8aee9c5523cf088fb86a528">subgroup_search</a> (self, prop, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a>=None, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a9f013092f2523ad34848ea3286967c2e">strong_gens</a>=None, tests=None, init_subgroup=None)</td></tr>
<tr class="separator:a01d83084c8aee9c5523cf088fb86a528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f12bb2b2db5b430bc0c8eb7315d624e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a4f12bb2b2db5b430bc0c8eb7315d624e">transitivity_degree</a> (self)</td></tr>
<tr class="separator:a4f12bb2b2db5b430bc0c8eb7315d624e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c04cac1689a54103a100bba4e5465"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a5e1c04cac1689a54103a100bba4e5465">sylow_subgroup</a> (self, p)</td></tr>
<tr class="separator:a5e1c04cac1689a54103a100bba4e5465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c8a9d6afdf7a904fbb740393bcfb81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a66c8a9d6afdf7a904fbb740393bcfb81">strong_presentation</a> (self)</td></tr>
<tr class="separator:a66c8a9d6afdf7a904fbb740393bcfb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b047df87817392d91ac7e0c52fa4c6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a18b047df87817392d91ac7e0c52fa4c6">presentation</a> (self, eliminate_gens=True)</td></tr>
<tr class="separator:a18b047df87817392d91ac7e0c52fa4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d2abb845ab6c72606666e67322bf4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a772d2abb845ab6c72606666e67322bf4">polycyclic_group</a> (self)</td></tr>
<tr class="separator:a772d2abb845ab6c72606666e67322bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de7b92db97d96cc13cd6c290e20e083"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0de7b92db97d96cc13cd6c290e20e083">__new__</a> (cls, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, dups=True, **kwargs)</td></tr>
<tr class="separator:a0de7b92db97d96cc13cd6c290e20e083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0716b231b058e2931ac2fa9042e0a2a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0716b231b058e2931ac2fa9042e0a2a8">__init__</a> (self, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, **kwargs)</td></tr>
<tr class="separator:a0716b231b058e2931ac2fa9042e0a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b4a02f47aae013546c54e6e2495526"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04b4a02f47aae013546c54e6e2495526">__getitem__</a> (self, i)</td></tr>
<tr class="separator:a04b4a02f47aae013546c54e6e2495526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdccfccd6b33b5af6ea9a9337f8cf4e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#afdccfccd6b33b5af6ea9a9337f8cf4e5">__contains__</a> (self, i)</td></tr>
<tr class="separator:afdccfccd6b33b5af6ea9a9337f8cf4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab803e52d9fad6c542fc2fcba7132a5d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ab803e52d9fad6c542fc2fcba7132a5d8">__len__</a> (self)</td></tr>
<tr class="separator:ab803e52d9fad6c542fc2fcba7132a5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf887fdd0e60658e26b388cde24ccab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a8cf887fdd0e60658e26b388cde24ccab">equals</a> (self, other)</td></tr>
<tr class="separator:a8cf887fdd0e60658e26b388cde24ccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e07ca01da5a3cd76bc306cbffed5987"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a8e07ca01da5a3cd76bc306cbffed5987">__mul__</a> (self, other)</td></tr>
<tr class="separator:a8e07ca01da5a3cd76bc306cbffed5987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c7e522087fd136432d29cf2032ac0e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a> (self)</td></tr>
<tr class="separator:a04c7e522087fd136432d29cf2032ac0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6597e1e817ffc343a95a7b796a696b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a3d6597e1e817ffc343a95a7b796a696b">baseswap</a> (self, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a>, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a9f013092f2523ad34848ea3286967c2e">strong_gens</a>, pos, randomized=False, transversals=None, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aac38d09a5423c85cd1c37778a4774766">basic_orbits</a>=None, strong_gens_distr=None)</td></tr>
<tr class="separator:a3d6597e1e817ffc343a95a7b796a696b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac38d09a5423c85cd1c37778a4774766"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aac38d09a5423c85cd1c37778a4774766">basic_orbits</a> (self)</td></tr>
<tr class="separator:aac38d09a5423c85cd1c37778a4774766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff132d2b0e6a4f7b16abf151f4caafc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a6ff132d2b0e6a4f7b16abf151f4caafc">basic_stabilizers</a> (self)</td></tr>
<tr class="separator:a6ff132d2b0e6a4f7b16abf151f4caafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f82634a58a706253c7caea8588d284"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa6f82634a58a706253c7caea8588d284">basic_transversals</a> (self)</td></tr>
<tr class="separator:aa6f82634a58a706253c7caea8588d284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7490dd3c6da951d96ab928fe5e893ce3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a7490dd3c6da951d96ab928fe5e893ce3">composition_series</a> (self)</td></tr>
<tr class="separator:a7490dd3c6da951d96ab928fe5e893ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246f19ba3baa008220b54728b3e2d72f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a246f19ba3baa008220b54728b3e2d72f">coset_transversal</a> (self, H)</td></tr>
<tr class="separator:a246f19ba3baa008220b54728b3e2d72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017b7db6f1fedc8494f42d5e108002a6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a017b7db6f1fedc8494f42d5e108002a6">coset_table</a> (self, H)</td></tr>
<tr class="separator:a017b7db6f1fedc8494f42d5e108002a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2235023c8ae310df7091c9eea52078e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2235023c8ae310df7091c9eea52078e6">center</a> (self)</td></tr>
<tr class="separator:a2235023c8ae310df7091c9eea52078e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c9a1124a5d165c3857e42710227cf7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a60c9a1124a5d165c3857e42710227cf7">centralizer</a> (self, other)</td></tr>
<tr class="separator:a60c9a1124a5d165c3857e42710227cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd565b0ad59da694ea28b0bc98cdd09d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#afd565b0ad59da694ea28b0bc98cdd09d">commutator</a> (self, G, H)</td></tr>
<tr class="separator:afd565b0ad59da694ea28b0bc98cdd09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb8ef9c8b0e992a4b904e55605ff7f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa1eb8ef9c8b0e992a4b904e55605ff7f">coset_factor</a> (self, g, factor_index=False)</td></tr>
<tr class="separator:aa1eb8ef9c8b0e992a4b904e55605ff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fa299e9d3b67a43b9437c10499113b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ad5fa299e9d3b67a43b9437c10499113b">generator_product</a> (self, g, original=False)</td></tr>
<tr class="separator:ad5fa299e9d3b67a43b9437c10499113b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dafce9e16e750217e5b56ceae873a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ac1dafce9e16e750217e5b56ceae873a5">coset_rank</a> (self, g)</td></tr>
<tr class="separator:ac1dafce9e16e750217e5b56ceae873a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19554681aebe72cd83ee8b6b7d73fdc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa19554681aebe72cd83ee8b6b7d73fdc">coset_unrank</a> (self, rank, af=False)</td></tr>
<tr class="separator:aa19554681aebe72cd83ee8b6b7d73fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79383116523bc879cf6463def1f4d266"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a79383116523bc879cf6463def1f4d266">degree</a> (self)</td></tr>
<tr class="separator:a79383116523bc879cf6463def1f4d266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bd0df5d92c30bc675b2a8411393e22"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a96bd0df5d92c30bc675b2a8411393e22">identity</a> (self)</td></tr>
<tr class="separator:a96bd0df5d92c30bc675b2a8411393e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896cb7478e42f44c2c61108cfdbfe717"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a896cb7478e42f44c2c61108cfdbfe717">elements</a> (self)</td></tr>
<tr class="separator:a896cb7478e42f44c2c61108cfdbfe717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30446ba845d5b811ff455a5289911c51"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a30446ba845d5b811ff455a5289911c51">derived_series</a> (self)</td></tr>
<tr class="separator:a30446ba845d5b811ff455a5289911c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76116697ea2112a4dfdb517871edd16"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ad76116697ea2112a4dfdb517871edd16">derived_subgroup</a> (self)</td></tr>
<tr class="separator:ad76116697ea2112a4dfdb517871edd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9e5d43c0c64b1c275bfa6653e805f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a1d9e5d43c0c64b1c275bfa6653e805f6">generate</a> (self, method=&quot;coset&quot;, af=False)</td></tr>
<tr class="separator:a1d9e5d43c0c64b1c275bfa6653e805f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9072b36546fb25ae06052aec93597ae9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a9072b36546fb25ae06052aec93597ae9">generate_dimino</a> (self, af=False)</td></tr>
<tr class="separator:a9072b36546fb25ae06052aec93597ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395ab6a0b05cb6063132f9faa9f50447"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a395ab6a0b05cb6063132f9faa9f50447">generate_schreier_sims</a> (self, af=False)</td></tr>
<tr class="separator:a395ab6a0b05cb6063132f9faa9f50447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acb6230f24e98620528b8104b43e5cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a6acb6230f24e98620528b8104b43e5cb">generators</a> (self)</td></tr>
<tr class="separator:a6acb6230f24e98620528b8104b43e5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e2dce2cdfa37fd05d09a87f5334385"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ad0e2dce2cdfa37fd05d09a87f5334385">contains</a> (self, g, strict=True)</td></tr>
<tr class="separator:ad0e2dce2cdfa37fd05d09a87f5334385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150928c8161147932617c38dd1623e88"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a150928c8161147932617c38dd1623e88">is_perfect</a> (self)</td></tr>
<tr class="separator:a150928c8161147932617c38dd1623e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a60cbfce2006021ac8e3bd41caec72"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ae8a60cbfce2006021ac8e3bd41caec72">is_abelian</a> (self)</td></tr>
<tr class="separator:ae8a60cbfce2006021ac8e3bd41caec72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4a2bd2eb937cbec1f9626e89e102c4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a6a4a2bd2eb937cbec1f9626e89e102c4">abelian_invariants</a> (self)</td></tr>
<tr class="separator:a6a4a2bd2eb937cbec1f9626e89e102c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf30365aa16d94011e76553f8d2f1bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2bf30365aa16d94011e76553f8d2f1bc">is_elementary</a> (self, p)</td></tr>
<tr class="separator:a2bf30365aa16d94011e76553f8d2f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a6832ed209ffdaf2bf528e3407d1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a689a6832ed209ffdaf2bf528e3407d1c">is_alt_sym</a> (self, eps=0.05, _random_prec=None)</td></tr>
<tr class="separator:a689a6832ed209ffdaf2bf528e3407d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaacd70fef3e7bd0aa06ecbc68c5f733"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#adaacd70fef3e7bd0aa06ecbc68c5f733">is_nilpotent</a> (self)</td></tr>
<tr class="separator:adaacd70fef3e7bd0aa06ecbc68c5f733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08a60a2f43c68f1a56e569b65f0fea6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#af08a60a2f43c68f1a56e569b65f0fea6">is_normal</a> (self, gr, strict=True)</td></tr>
<tr class="separator:af08a60a2f43c68f1a56e569b65f0fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4cab8bcce55d13493906e4db9dae6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2fb4cab8bcce55d13493906e4db9dae6">is_primitive</a> (self, randomized=True)</td></tr>
<tr class="separator:a2fb4cab8bcce55d13493906e4db9dae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e65d45c135d454fbe32493757d1f3ee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2e65d45c135d454fbe32493757d1f3ee">minimal_blocks</a> (self, randomized=True)</td></tr>
<tr class="separator:a2e65d45c135d454fbe32493757d1f3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4cfcd0e2b6a91ffcad895823b0ade"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a1cb4cfcd0e2b6a91ffcad895823b0ade">is_solvable</a> (self)</td></tr>
<tr class="separator:a1cb4cfcd0e2b6a91ffcad895823b0ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c18fbaf345a33ee70e9c4f67496bb2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0c18fbaf345a33ee70e9c4f67496bb2e">is_subgroup</a> (self, G, strict=True)</td></tr>
<tr class="separator:a0c18fbaf345a33ee70e9c4f67496bb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb595484067ff05b4d9834c61cbe5759"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#acb595484067ff05b4d9834c61cbe5759">is_polycyclic</a> (self)</td></tr>
<tr class="separator:acb595484067ff05b4d9834c61cbe5759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dcb1e94d17f08834d7b40323f36d4b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a90dcb1e94d17f08834d7b40323f36d4b">is_transitive</a> (self, strict=True)</td></tr>
<tr class="separator:a90dcb1e94d17f08834d7b40323f36d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6993aff9524bfdc43a8e4949b5915231"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a6993aff9524bfdc43a8e4949b5915231">is_trivial</a> (self)</td></tr>
<tr class="separator:a6993aff9524bfdc43a8e4949b5915231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2379ca9d76560e0135f601e68af3f88e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2379ca9d76560e0135f601e68af3f88e">lower_central_series</a> (self)</td></tr>
<tr class="separator:a2379ca9d76560e0135f601e68af3f88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f36da80262829f87bad2c3a695e882"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ab7f36da80262829f87bad2c3a695e882">max_div</a> (self)</td></tr>
<tr class="separator:ab7f36da80262829f87bad2c3a695e882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d33347199ac473b0ac402b3b0ac43"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a169d33347199ac473b0ac402b3b0ac43">minimal_block</a> (self, points)</td></tr>
<tr class="separator:a169d33347199ac473b0ac402b3b0ac43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f259a5c75b9220d96be8561a5bc978"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa4f259a5c75b9220d96be8561a5bc978">conjugacy_class</a> (self, x)</td></tr>
<tr class="separator:aa4f259a5c75b9220d96be8561a5bc978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d54fefe645f67e30d1cc0d5d8e9578"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#af8d54fefe645f67e30d1cc0d5d8e9578">conjugacy_classes</a> (self)</td></tr>
<tr class="separator:af8d54fefe645f67e30d1cc0d5d8e9578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7c38e8e29c220cd77270339a10381"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#afff7c38e8e29c220cd77270339a10381">normal_closure</a> (self, other, k=10)</td></tr>
<tr class="separator:afff7c38e8e29c220cd77270339a10381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460f8946cdf683163d59c7072ee3d29e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a460f8946cdf683163d59c7072ee3d29e">orbit</a> (self, alpha, action='tuples')</td></tr>
<tr class="separator:a460f8946cdf683163d59c7072ee3d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bcbd4af19aa06fd3d7b39a8001152e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#af9bcbd4af19aa06fd3d7b39a8001152e">orbit_rep</a> (self, alpha, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2029b24877b1c045bd2908c4cade1014">schreier_vector</a>=None)</td></tr>
<tr class="separator:af9bcbd4af19aa06fd3d7b39a8001152e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b16152823083ed1567e6a429d41b791"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0b16152823083ed1567e6a429d41b791">orbit_transversal</a> (self, alpha, pairs=False)</td></tr>
<tr class="separator:a0b16152823083ed1567e6a429d41b791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc238571a25fd13082c6d46091020ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aadc238571a25fd13082c6d46091020ef">orbits</a> (self, rep=False)</td></tr>
<tr class="separator:aadc238571a25fd13082c6d46091020ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c13a15c002cd1300b1c80328aa9295"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aa4c13a15c002cd1300b1c80328aa9295">order</a> (self)</td></tr>
<tr class="separator:aa4c13a15c002cd1300b1c80328aa9295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2778845a2bf4331713ab1921abfb6d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ae2778845a2bf4331713ab1921abfb6d5">index</a> (self, H)</td></tr>
<tr class="separator:ae2778845a2bf4331713ab1921abfb6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547e87e4cd7a0da5d6f326b58090141c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a547e87e4cd7a0da5d6f326b58090141c">is_symmetric</a> (self)</td></tr>
<tr class="separator:a547e87e4cd7a0da5d6f326b58090141c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292e6ce31910b86f3f77913ae800dfc8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a292e6ce31910b86f3f77913ae800dfc8">is_alternating</a> (self)</td></tr>
<tr class="separator:a292e6ce31910b86f3f77913ae800dfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c458a1a52990c3caa1bc221e231543"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#af5c458a1a52990c3caa1bc221e231543">is_cyclic</a> (self)</td></tr>
<tr class="separator:af5c458a1a52990c3caa1bc221e231543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0681d8380ee0c5aec16a08b20269eb7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0681d8380ee0c5aec16a08b20269eb7d">is_dihedral</a> (self)</td></tr>
<tr class="separator:a0681d8380ee0c5aec16a08b20269eb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72db2b8d8d1a352cc9c1243b0ba4fc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ae72db2b8d8d1a352cc9c1243b0ba4fc0">pointwise_stabilizer</a> (self, points, incremental=True)</td></tr>
<tr class="separator:ae72db2b8d8d1a352cc9c1243b0ba4fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fbc74df7792666e509a0e352c0d912"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a68fbc74df7792666e509a0e352c0d912">make_perm</a> (self, n, seed=None)</td></tr>
<tr class="separator:a68fbc74df7792666e509a0e352c0d912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49a5e8efd11953b733a223ac3390a00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ad49a5e8efd11953b733a223ac3390a00">random</a> (self, af=False)</td></tr>
<tr class="separator:ad49a5e8efd11953b733a223ac3390a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec91e456ad70949d6efdc32db13c719b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aec91e456ad70949d6efdc32db13c719b">random_pr</a> (self, gen_count=11, iterations=50, _random_prec=None)</td></tr>
<tr class="separator:aec91e456ad70949d6efdc32db13c719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d35747d13633478618d900a2d03f48b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a8d35747d13633478618d900a2d03f48b">random_stab</a> (self, alpha, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2029b24877b1c045bd2908c4cade1014">schreier_vector</a>=None, _random_prec=None)</td></tr>
<tr class="separator:a8d35747d13633478618d900a2d03f48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7f034b7d590a0c2c6189abb28baf8c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0b7f034b7d590a0c2c6189abb28baf8c">schreier_sims</a> (self)</td></tr>
<tr class="separator:a0b7f034b7d590a0c2c6189abb28baf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a74d41168516ae30d8cbbb83250a5a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a0a74d41168516ae30d8cbbb83250a5a0">schreier_sims_incremental</a> (self, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a>=None, gens=None, slp_dict=False)</td></tr>
<tr class="separator:a0a74d41168516ae30d8cbbb83250a5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300fff1c31c164aebcd65aa7de0ad9e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a4300fff1c31c164aebcd65aa7de0ad9e">schreier_sims_random</a> (self, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a>=None, gens=None, consec_succ=10, _random_prec=None)</td></tr>
<tr class="separator:a4300fff1c31c164aebcd65aa7de0ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2029b24877b1c045bd2908c4cade1014"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a2029b24877b1c045bd2908c4cade1014">schreier_vector</a> (self, alpha)</td></tr>
<tr class="separator:a2029b24877b1c045bd2908c4cade1014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2c65f749705c1d6225f5cede73607a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#aed2c65f749705c1d6225f5cede73607a">stabilizer</a> (self, alpha)</td></tr>
<tr class="separator:aed2c65f749705c1d6225f5cede73607a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f013092f2523ad34848ea3286967c2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a9f013092f2523ad34848ea3286967c2e">strong_gens</a> (self)</td></tr>
<tr class="separator:a9f013092f2523ad34848ea3286967c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410e5597d9b807557eb1e2f592ad9f27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a410e5597d9b807557eb1e2f592ad9f27">subgroup</a> (self, gens)</td></tr>
<tr class="separator:a410e5597d9b807557eb1e2f592ad9f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d83084c8aee9c5523cf088fb86a528"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a01d83084c8aee9c5523cf088fb86a528">subgroup_search</a> (self, prop, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a04c7e522087fd136432d29cf2032ac0e">base</a>=None, <a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a9f013092f2523ad34848ea3286967c2e">strong_gens</a>=None, tests=None, init_subgroup=None)</td></tr>
<tr class="separator:a01d83084c8aee9c5523cf088fb86a528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f12bb2b2db5b430bc0c8eb7315d624e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a4f12bb2b2db5b430bc0c8eb7315d624e">transitivity_degree</a> (self)</td></tr>
<tr class="separator:a4f12bb2b2db5b430bc0c8eb7315d624e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c04cac1689a54103a100bba4e5465"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a5e1c04cac1689a54103a100bba4e5465">sylow_subgroup</a> (self, p)</td></tr>
<tr class="separator:a5e1c04cac1689a54103a100bba4e5465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c8a9d6afdf7a904fbb740393bcfb81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a66c8a9d6afdf7a904fbb740393bcfb81">strong_presentation</a> (self)</td></tr>
<tr class="separator:a66c8a9d6afdf7a904fbb740393bcfb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b047df87817392d91ac7e0c52fa4c6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a18b047df87817392d91ac7e0c52fa4c6">presentation</a> (self, eliminate_gens=True)</td></tr>
<tr class="separator:a18b047df87817392d91ac7e0c52fa4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d2abb845ab6c72606666e67322bf4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a772d2abb845ab6c72606666e67322bf4">polycyclic_group</a> (self)</td></tr>
<tr class="separator:a772d2abb845ab6c72606666e67322bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsympy_1_1core_1_1basic_1_1Basic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html">sympy.core.basic.Basic</a></td></tr>
<tr class="memitem:a5d18036145283b11e1f650776c1f0e22 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a5d18036145283b11e1f650776c1f0e22">__sympy__</a> (self)</td></tr>
<tr class="separator:a5d18036145283b11e1f650776c1f0e22 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8087a561468ff3614076528fe5234040 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a8087a561468ff3614076528fe5234040">__init_subclass__</a> (cls)</td></tr>
<tr class="separator:a8087a561468ff3614076528fe5234040 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde0f6f0a0324a94e13d185e637b47bc inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#adde0f6f0a0324a94e13d185e637b47bc">__new__</a> (cls, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>)</td></tr>
<tr class="separator:adde0f6f0a0324a94e13d185e637b47bc inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1784a0126b9660a0f4be4954b77f763d inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a1784a0126b9660a0f4be4954b77f763d">copy</a> (self)</td></tr>
<tr class="separator:a1784a0126b9660a0f4be4954b77f763d inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b877e93be3f152c9a2e9a2f97eea6b inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a99b877e93be3f152c9a2e9a2f97eea6b">__getnewargs__</a> (self)</td></tr>
<tr class="separator:a99b877e93be3f152c9a2e9a2f97eea6b inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e9d419b35f83b17ac17ca743cee8a0 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac8e9d419b35f83b17ac17ca743cee8a0">__getstate__</a> (self)</td></tr>
<tr class="separator:ac8e9d419b35f83b17ac17ca743cee8a0 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481e2990b243629e571c1d244d9636bf inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a481e2990b243629e571c1d244d9636bf">__setstate__</a> (self, state)</td></tr>
<tr class="separator:a481e2990b243629e571c1d244d9636bf inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3db06fa79ba0cc8b491f14312987ef inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a7e3db06fa79ba0cc8b491f14312987ef">__reduce_ex__</a> (self, protocol)</td></tr>
<tr class="separator:a7e3db06fa79ba0cc8b491f14312987ef inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe72a4c59075abceae781b8fb54cdbd inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#adfe72a4c59075abceae781b8fb54cdbd">__hash__</a> (self)</td></tr>
<tr class="separator:adfe72a4c59075abceae781b8fb54cdbd inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415cf97375b06660d7027f8fdfe62311 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a415cf97375b06660d7027f8fdfe62311">assumptions0</a> (self)</td></tr>
<tr class="separator:a415cf97375b06660d7027f8fdfe62311 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af27cd22a5e436e5f82326c667ed1a3 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a8af27cd22a5e436e5f82326c667ed1a3">compare</a> (self, other)</td></tr>
<tr class="separator:a8af27cd22a5e436e5f82326c667ed1a3 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af525647e6d67a46904a8689936e761cd inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#af525647e6d67a46904a8689936e761cd">fromiter</a> (cls, <a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, **assumptions)</td></tr>
<tr class="separator:af525647e6d67a46904a8689936e761cd inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df18d55206536bd09f38633e7aa3740 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0df18d55206536bd09f38633e7aa3740">class_key</a> (cls)</td></tr>
<tr class="separator:a0df18d55206536bd09f38633e7aa3740 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2fce898d6bd6c7bcca15c152ebe5ac inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0c2fce898d6bd6c7bcca15c152ebe5ac">sort_key</a> (self, order=None)</td></tr>
<tr class="separator:a0c2fce898d6bd6c7bcca15c152ebe5ac inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8046d46b74bd8d9d45a2380a492f0373 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a8046d46b74bd8d9d45a2380a492f0373">__eq__</a> (self, other)</td></tr>
<tr class="separator:a8046d46b74bd8d9d45a2380a492f0373 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909829a9b65f4d924b80e641cb312074 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a909829a9b65f4d924b80e641cb312074">__ne__</a> (self, other)</td></tr>
<tr class="separator:a909829a9b65f4d924b80e641cb312074 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f4dd79d0ebac319ef2bb3bf542e92 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a4d8f4dd79d0ebac319ef2bb3bf542e92">dummy_eq</a> (self, other, symbol=None)</td></tr>
<tr class="separator:a4d8f4dd79d0ebac319ef2bb3bf542e92 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262512832bca33148a1d027306b9241c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a262512832bca33148a1d027306b9241c">atoms</a> (self, *types)</td></tr>
<tr class="separator:a262512832bca33148a1d027306b9241c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ed4874e5567750ae696af0d3f39a9 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">set[<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html">Basic</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a1d9ed4874e5567750ae696af0d3f39a9">free_symbols</a> (self)</td></tr>
<tr class="separator:a1d9ed4874e5567750ae696af0d3f39a9 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124d55a59e9b462d3f27193b60a72e78 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a124d55a59e9b462d3f27193b60a72e78">expr_free_symbols</a> (self)</td></tr>
<tr class="separator:a124d55a59e9b462d3f27193b60a72e78 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9c9758382e8b3c0961dd9cce3fada0 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#acc9c9758382e8b3c0961dd9cce3fada0">as_dummy</a> (self)</td></tr>
<tr class="separator:acc9c9758382e8b3c0961dd9cce3fada0 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e02e72632a8630a52346fdcab326c8 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a36e02e72632a8630a52346fdcab326c8">canonical_variables</a> (self)</td></tr>
<tr class="separator:a36e02e72632a8630a52346fdcab326c8 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36f4c1bbe310293a5b9fd681a983590 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#af36f4c1bbe310293a5b9fd681a983590">rcall</a> (self, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>)</td></tr>
<tr class="separator:af36f4c1bbe310293a5b9fd681a983590 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781c3ff0bb865a9cca06bfd053f3a80 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a1781c3ff0bb865a9cca06bfd053f3a80">is_hypergeometric</a> (self, k)</td></tr>
<tr class="separator:a1781c3ff0bb865a9cca06bfd053f3a80 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe68bea97ecab6a727e773847319b68 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a3fe68bea97ecab6a727e773847319b68">is_comparable</a> (self)</td></tr>
<tr class="separator:a3fe68bea97ecab6a727e773847319b68 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f34341fac5026a14214b4829fb8f7c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a33f34341fac5026a14214b4829fb8f7c">func</a> (self)</td></tr>
<tr class="separator:a33f34341fac5026a14214b4829fb8f7c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f01a9439d24153e2602e3edc4de4d1 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html">Basic</a>,...]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a> (self)</td></tr>
<tr class="separator:ac2f01a9439d24153e2602e3edc4de4d1 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e13176cfec3baaf071755e22a44a71 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ae2e13176cfec3baaf071755e22a44a71">as_content_primitive</a> (self, radical=False, clear=True)</td></tr>
<tr class="separator:ae2e13176cfec3baaf071755e22a44a71 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1265aa585da5d52ce98ed768454a0d08 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a1265aa585da5d52ce98ed768454a0d08">subs</a> (self, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, **kwargs)</td></tr>
<tr class="separator:a1265aa585da5d52ce98ed768454a0d08 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfda6d07719128e0156017d1f04a5fc inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a2cfda6d07719128e0156017d1f04a5fc">xreplace</a> (self, rule)</td></tr>
<tr class="separator:a2cfda6d07719128e0156017d1f04a5fc inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114391c7f958541242547d2e677255a8 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a114391c7f958541242547d2e677255a8">has</a> (self, *patterns)</td></tr>
<tr class="separator:a114391c7f958541242547d2e677255a8 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5914780dea3f52b21965ea84620b4041 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a5914780dea3f52b21965ea84620b4041">has_xfree</a> (self, set[<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html">Basic</a>] s)</td></tr>
<tr class="separator:a5914780dea3f52b21965ea84620b4041 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6510e3178119a8642cd23af9b85af2 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a2a6510e3178119a8642cd23af9b85af2">has_free</a> (self, *patterns)</td></tr>
<tr class="separator:a2a6510e3178119a8642cd23af9b85af2 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2a73f20ab7179161c9cfebc93a3bec inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a9f2a73f20ab7179161c9cfebc93a3bec">replace</a> (self, query, value, map=False, simultaneous=True, exact=None)</td></tr>
<tr class="separator:a9f2a73f20ab7179161c9cfebc93a3bec inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9dd0426d6830739a9da8635740547d inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0f9dd0426d6830739a9da8635740547d">find</a> (self, query, group=False)</td></tr>
<tr class="separator:a0f9dd0426d6830739a9da8635740547d inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a21686fb3c39e396649006c233e416a inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a7a21686fb3c39e396649006c233e416a">count</a> (self, query)</td></tr>
<tr class="separator:a7a21686fb3c39e396649006c233e416a inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b90862e5fc6fc47878a477de79559c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ad9b90862e5fc6fc47878a477de79559c">matches</a> (self, expr, repl_dict=None, old=False)</td></tr>
<tr class="separator:ad9b90862e5fc6fc47878a477de79559c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83e0bf056ce2a046f5c593ae654983e inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ab83e0bf056ce2a046f5c593ae654983e">match</a> (self, pattern, old=False)</td></tr>
<tr class="separator:ab83e0bf056ce2a046f5c593ae654983e inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e4437563b08a39848f583863cfdc4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a763e4437563b08a39848f583863cfdc4">count_ops</a> (self, visual=None)</td></tr>
<tr class="separator:a763e4437563b08a39848f583863cfdc4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7df640aa205aeb0eaf60783da39955b inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ad7df640aa205aeb0eaf60783da39955b">doit</a> (self, **hints)</td></tr>
<tr class="separator:ad7df640aa205aeb0eaf60783da39955b inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74e8d4f9b750aa13ce66025a487f9a4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#aa74e8d4f9b750aa13ce66025a487f9a4">simplify</a> (self, **kwargs)</td></tr>
<tr class="separator:aa74e8d4f9b750aa13ce66025a487f9a4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed808a1351ad1913e1a2c86886e8da4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0ed808a1351ad1913e1a2c86886e8da4">refine</a> (self, assumption=True)</td></tr>
<tr class="separator:a0ed808a1351ad1913e1a2c86886e8da4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf160793376f345c7374e5e08e8352f3 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#abf160793376f345c7374e5e08e8352f3">rewrite</a> (self, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, deep=True, **hints)</td></tr>
<tr class="separator:abf160793376f345c7374e5e08e8352f3 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10baa584425c6feadb4469a5a77a87bb inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a10baa584425c6feadb4469a5a77a87bb">could_extract_minus_sign</a> (self)</td></tr>
<tr class="separator:a10baa584425c6feadb4469a5a77a87bb inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075c3233d3275cdf25c399d64ef9a277 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a075c3233d3275cdf25c399d64ef9a277">is_same</a> (a, b, approx=None)</td></tr>
<tr class="separator:a075c3233d3275cdf25c399d64ef9a277 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d18036145283b11e1f650776c1f0e22 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a5d18036145283b11e1f650776c1f0e22">__sympy__</a> (self)</td></tr>
<tr class="separator:a5d18036145283b11e1f650776c1f0e22 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8087a561468ff3614076528fe5234040 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a8087a561468ff3614076528fe5234040">__init_subclass__</a> (cls)</td></tr>
<tr class="separator:a8087a561468ff3614076528fe5234040 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde0f6f0a0324a94e13d185e637b47bc inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#adde0f6f0a0324a94e13d185e637b47bc">__new__</a> (cls, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>)</td></tr>
<tr class="separator:adde0f6f0a0324a94e13d185e637b47bc inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1784a0126b9660a0f4be4954b77f763d inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a1784a0126b9660a0f4be4954b77f763d">copy</a> (self)</td></tr>
<tr class="separator:a1784a0126b9660a0f4be4954b77f763d inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b877e93be3f152c9a2e9a2f97eea6b inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a99b877e93be3f152c9a2e9a2f97eea6b">__getnewargs__</a> (self)</td></tr>
<tr class="separator:a99b877e93be3f152c9a2e9a2f97eea6b inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e9d419b35f83b17ac17ca743cee8a0 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac8e9d419b35f83b17ac17ca743cee8a0">__getstate__</a> (self)</td></tr>
<tr class="separator:ac8e9d419b35f83b17ac17ca743cee8a0 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481e2990b243629e571c1d244d9636bf inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a481e2990b243629e571c1d244d9636bf">__setstate__</a> (self, state)</td></tr>
<tr class="separator:a481e2990b243629e571c1d244d9636bf inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3db06fa79ba0cc8b491f14312987ef inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a7e3db06fa79ba0cc8b491f14312987ef">__reduce_ex__</a> (self, protocol)</td></tr>
<tr class="separator:a7e3db06fa79ba0cc8b491f14312987ef inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe72a4c59075abceae781b8fb54cdbd inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#adfe72a4c59075abceae781b8fb54cdbd">__hash__</a> (self)</td></tr>
<tr class="separator:adfe72a4c59075abceae781b8fb54cdbd inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415cf97375b06660d7027f8fdfe62311 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a415cf97375b06660d7027f8fdfe62311">assumptions0</a> (self)</td></tr>
<tr class="separator:a415cf97375b06660d7027f8fdfe62311 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af27cd22a5e436e5f82326c667ed1a3 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a8af27cd22a5e436e5f82326c667ed1a3">compare</a> (self, other)</td></tr>
<tr class="separator:a8af27cd22a5e436e5f82326c667ed1a3 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af525647e6d67a46904a8689936e761cd inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#af525647e6d67a46904a8689936e761cd">fromiter</a> (cls, <a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, **assumptions)</td></tr>
<tr class="separator:af525647e6d67a46904a8689936e761cd inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df18d55206536bd09f38633e7aa3740 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0df18d55206536bd09f38633e7aa3740">class_key</a> (cls)</td></tr>
<tr class="separator:a0df18d55206536bd09f38633e7aa3740 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2fce898d6bd6c7bcca15c152ebe5ac inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0c2fce898d6bd6c7bcca15c152ebe5ac">sort_key</a> (self, order=None)</td></tr>
<tr class="separator:a0c2fce898d6bd6c7bcca15c152ebe5ac inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8046d46b74bd8d9d45a2380a492f0373 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a8046d46b74bd8d9d45a2380a492f0373">__eq__</a> (self, other)</td></tr>
<tr class="separator:a8046d46b74bd8d9d45a2380a492f0373 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909829a9b65f4d924b80e641cb312074 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a909829a9b65f4d924b80e641cb312074">__ne__</a> (self, other)</td></tr>
<tr class="separator:a909829a9b65f4d924b80e641cb312074 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f4dd79d0ebac319ef2bb3bf542e92 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a4d8f4dd79d0ebac319ef2bb3bf542e92">dummy_eq</a> (self, other, symbol=None)</td></tr>
<tr class="separator:a4d8f4dd79d0ebac319ef2bb3bf542e92 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262512832bca33148a1d027306b9241c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a262512832bca33148a1d027306b9241c">atoms</a> (self, *types)</td></tr>
<tr class="separator:a262512832bca33148a1d027306b9241c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ed4874e5567750ae696af0d3f39a9 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">set[<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html">Basic</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a1d9ed4874e5567750ae696af0d3f39a9">free_symbols</a> (self)</td></tr>
<tr class="separator:a1d9ed4874e5567750ae696af0d3f39a9 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124d55a59e9b462d3f27193b60a72e78 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a124d55a59e9b462d3f27193b60a72e78">expr_free_symbols</a> (self)</td></tr>
<tr class="separator:a124d55a59e9b462d3f27193b60a72e78 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9c9758382e8b3c0961dd9cce3fada0 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#acc9c9758382e8b3c0961dd9cce3fada0">as_dummy</a> (self)</td></tr>
<tr class="separator:acc9c9758382e8b3c0961dd9cce3fada0 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e02e72632a8630a52346fdcab326c8 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a36e02e72632a8630a52346fdcab326c8">canonical_variables</a> (self)</td></tr>
<tr class="separator:a36e02e72632a8630a52346fdcab326c8 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36f4c1bbe310293a5b9fd681a983590 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#af36f4c1bbe310293a5b9fd681a983590">rcall</a> (self, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>)</td></tr>
<tr class="separator:af36f4c1bbe310293a5b9fd681a983590 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781c3ff0bb865a9cca06bfd053f3a80 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a1781c3ff0bb865a9cca06bfd053f3a80">is_hypergeometric</a> (self, k)</td></tr>
<tr class="separator:a1781c3ff0bb865a9cca06bfd053f3a80 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe68bea97ecab6a727e773847319b68 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a3fe68bea97ecab6a727e773847319b68">is_comparable</a> (self)</td></tr>
<tr class="separator:a3fe68bea97ecab6a727e773847319b68 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f34341fac5026a14214b4829fb8f7c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a33f34341fac5026a14214b4829fb8f7c">func</a> (self)</td></tr>
<tr class="separator:a33f34341fac5026a14214b4829fb8f7c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f01a9439d24153e2602e3edc4de4d1 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html">Basic</a>,...]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a> (self)</td></tr>
<tr class="separator:ac2f01a9439d24153e2602e3edc4de4d1 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e13176cfec3baaf071755e22a44a71 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ae2e13176cfec3baaf071755e22a44a71">as_content_primitive</a> (self, radical=False, clear=True)</td></tr>
<tr class="separator:ae2e13176cfec3baaf071755e22a44a71 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1265aa585da5d52ce98ed768454a0d08 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a1265aa585da5d52ce98ed768454a0d08">subs</a> (self, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, **kwargs)</td></tr>
<tr class="separator:a1265aa585da5d52ce98ed768454a0d08 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfda6d07719128e0156017d1f04a5fc inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a2cfda6d07719128e0156017d1f04a5fc">xreplace</a> (self, rule)</td></tr>
<tr class="separator:a2cfda6d07719128e0156017d1f04a5fc inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114391c7f958541242547d2e677255a8 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a114391c7f958541242547d2e677255a8">has</a> (self, *patterns)</td></tr>
<tr class="separator:a114391c7f958541242547d2e677255a8 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5914780dea3f52b21965ea84620b4041 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a5914780dea3f52b21965ea84620b4041">has_xfree</a> (self, set[<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html">Basic</a>] s)</td></tr>
<tr class="separator:a5914780dea3f52b21965ea84620b4041 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6510e3178119a8642cd23af9b85af2 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a2a6510e3178119a8642cd23af9b85af2">has_free</a> (self, *patterns)</td></tr>
<tr class="separator:a2a6510e3178119a8642cd23af9b85af2 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2a73f20ab7179161c9cfebc93a3bec inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a9f2a73f20ab7179161c9cfebc93a3bec">replace</a> (self, query, value, map=False, simultaneous=True, exact=None)</td></tr>
<tr class="separator:a9f2a73f20ab7179161c9cfebc93a3bec inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9dd0426d6830739a9da8635740547d inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0f9dd0426d6830739a9da8635740547d">find</a> (self, query, group=False)</td></tr>
<tr class="separator:a0f9dd0426d6830739a9da8635740547d inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a21686fb3c39e396649006c233e416a inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a7a21686fb3c39e396649006c233e416a">count</a> (self, query)</td></tr>
<tr class="separator:a7a21686fb3c39e396649006c233e416a inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b90862e5fc6fc47878a477de79559c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ad9b90862e5fc6fc47878a477de79559c">matches</a> (self, expr, repl_dict=None, old=False)</td></tr>
<tr class="separator:ad9b90862e5fc6fc47878a477de79559c inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83e0bf056ce2a046f5c593ae654983e inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ab83e0bf056ce2a046f5c593ae654983e">match</a> (self, pattern, old=False)</td></tr>
<tr class="separator:ab83e0bf056ce2a046f5c593ae654983e inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e4437563b08a39848f583863cfdc4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a763e4437563b08a39848f583863cfdc4">count_ops</a> (self, visual=None)</td></tr>
<tr class="separator:a763e4437563b08a39848f583863cfdc4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7df640aa205aeb0eaf60783da39955b inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ad7df640aa205aeb0eaf60783da39955b">doit</a> (self, **hints)</td></tr>
<tr class="separator:ad7df640aa205aeb0eaf60783da39955b inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74e8d4f9b750aa13ce66025a487f9a4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#aa74e8d4f9b750aa13ce66025a487f9a4">simplify</a> (self, **kwargs)</td></tr>
<tr class="separator:aa74e8d4f9b750aa13ce66025a487f9a4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed808a1351ad1913e1a2c86886e8da4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0ed808a1351ad1913e1a2c86886e8da4">refine</a> (self, assumption=True)</td></tr>
<tr class="separator:a0ed808a1351ad1913e1a2c86886e8da4 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf160793376f345c7374e5e08e8352f3 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#abf160793376f345c7374e5e08e8352f3">rewrite</a> (self, *<a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac2f01a9439d24153e2602e3edc4de4d1">args</a>, deep=True, **hints)</td></tr>
<tr class="separator:abf160793376f345c7374e5e08e8352f3 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10baa584425c6feadb4469a5a77a87bb inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a10baa584425c6feadb4469a5a77a87bb">could_extract_minus_sign</a> (self)</td></tr>
<tr class="separator:a10baa584425c6feadb4469a5a77a87bb inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075c3233d3275cdf25c399d64ef9a277 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a075c3233d3275cdf25c399d64ef9a277">is_same</a> (a, b, approx=None)</td></tr>
<tr class="separator:a075c3233d3275cdf25c399d64ef9a277 inherit pub_methods_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsympy_1_1core_1_1__print__helpers_1_1Printable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsympy_1_1core_1_1__print__helpers_1_1Printable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsympy_1_1core_1_1__print__helpers_1_1Printable.html">sympy.core._print_helpers.Printable</a></td></tr>
<tr class="memitem:a7c3f60d7b82d5f7f8341d98683e3d24a inherit pub_methods_classsympy_1_1core_1_1__print__helpers_1_1Printable"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1__print__helpers_1_1Printable.html#a7c3f60d7b82d5f7f8341d98683e3d24a">__str__</a> (self)</td></tr>
<tr class="separator:a7c3f60d7b82d5f7f8341d98683e3d24a inherit pub_methods_classsympy_1_1core_1_1__print__helpers_1_1Printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3f60d7b82d5f7f8341d98683e3d24a inherit pub_methods_classsympy_1_1core_1_1__print__helpers_1_1Printable"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1__print__helpers_1_1Printable.html#a7c3f60d7b82d5f7f8341d98683e3d24a">__str__</a> (self)</td></tr>
<tr class="separator:a7c3f60d7b82d5f7f8341d98683e3d24a inherit pub_methods_classsympy_1_1core_1_1__print__helpers_1_1Printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac73380b6e282e1d1d475ee44972aa451"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#ac73380b6e282e1d1d475ee44972aa451">degree</a></td></tr>
<tr class="separator:ac73380b6e282e1d1d475ee44972aa451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a15fbb08166457ddbc48d5346c267808c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1perm__groups_1_1PermutationGroup.html#a15fbb08166457ddbc48d5346c267808c">is_group</a> = True</td></tr>
<tr class="separator:a15fbb08166457ddbc48d5346c267808c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html">sympy.core.basic.Basic</a></td></tr>
<tr class="memitem:acc59033fab073b7153a5c145fbf05b43 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#acc59033fab073b7153a5c145fbf05b43">is_number</a> = False</td></tr>
<tr class="separator:acc59033fab073b7153a5c145fbf05b43 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128041f2eee5e638020b053e35cd4693 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a128041f2eee5e638020b053e35cd4693">is_Atom</a> = False</td></tr>
<tr class="separator:a128041f2eee5e638020b053e35cd4693 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe77ec1c7c457a0714b83ff2f1ee11 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a6dbe77ec1c7c457a0714b83ff2f1ee11">is_Symbol</a> = False</td></tr>
<tr class="separator:a6dbe77ec1c7c457a0714b83ff2f1ee11 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6650b194e05098ecd76766ba7424af inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a8f6650b194e05098ecd76766ba7424af">is_symbol</a> = False</td></tr>
<tr class="separator:a8f6650b194e05098ecd76766ba7424af inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2989b7825e77f9edfd2926726487850c inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a2989b7825e77f9edfd2926726487850c">is_Indexed</a> = False</td></tr>
<tr class="separator:a2989b7825e77f9edfd2926726487850c inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fe96058ebbe46bd9164060b4708447 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a58fe96058ebbe46bd9164060b4708447">is_Dummy</a> = False</td></tr>
<tr class="separator:a58fe96058ebbe46bd9164060b4708447 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6237005e4ddb56e5baba87e267624c83 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a6237005e4ddb56e5baba87e267624c83">is_Wild</a> = False</td></tr>
<tr class="separator:a6237005e4ddb56e5baba87e267624c83 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a582e94cc018de467668e8ec602ab9a inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a4a582e94cc018de467668e8ec602ab9a">is_Function</a> = False</td></tr>
<tr class="separator:a4a582e94cc018de467668e8ec602ab9a inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d39d98402270caf4646e1347e779ce inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#af1d39d98402270caf4646e1347e779ce">is_Add</a> = False</td></tr>
<tr class="separator:af1d39d98402270caf4646e1347e779ce inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e86a6fc43cb52ec5f3d6eb0dce9d0f inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ac0e86a6fc43cb52ec5f3d6eb0dce9d0f">is_Mul</a> = False</td></tr>
<tr class="separator:ac0e86a6fc43cb52ec5f3d6eb0dce9d0f inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c1826edda89f49b4b9116ed964d664 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a92c1826edda89f49b4b9116ed964d664">is_Pow</a> = False</td></tr>
<tr class="separator:a92c1826edda89f49b4b9116ed964d664 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72085a2cc795160cd80b7aa1524811d8 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a72085a2cc795160cd80b7aa1524811d8">is_Number</a> = False</td></tr>
<tr class="separator:a72085a2cc795160cd80b7aa1524811d8 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e5baceb596edba47aa1c38a2c8828b inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a65e5baceb596edba47aa1c38a2c8828b">is_Float</a> = False</td></tr>
<tr class="separator:a65e5baceb596edba47aa1c38a2c8828b inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2413def29afcfebcc45f3101851ed8a inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ae2413def29afcfebcc45f3101851ed8a">is_Rational</a> = False</td></tr>
<tr class="separator:ae2413def29afcfebcc45f3101851ed8a inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492915002faa5acb2e6acfc2d8cdddea inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a492915002faa5acb2e6acfc2d8cdddea">is_Integer</a> = False</td></tr>
<tr class="separator:a492915002faa5acb2e6acfc2d8cdddea inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26578c6d300a3b97a47f434608c60618 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a26578c6d300a3b97a47f434608c60618">is_NumberSymbol</a> = False</td></tr>
<tr class="separator:a26578c6d300a3b97a47f434608c60618 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c29e976ce9f711339461028fda5032 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ab8c29e976ce9f711339461028fda5032">is_Order</a> = False</td></tr>
<tr class="separator:ab8c29e976ce9f711339461028fda5032 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be52631783fe6ccbe1b62d23cc1fc9b inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a8be52631783fe6ccbe1b62d23cc1fc9b">is_Derivative</a> = False</td></tr>
<tr class="separator:a8be52631783fe6ccbe1b62d23cc1fc9b inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099057e3bb5461447a255b5601cb9316 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a099057e3bb5461447a255b5601cb9316">is_Piecewise</a> = False</td></tr>
<tr class="separator:a099057e3bb5461447a255b5601cb9316 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e2e724b246fb25a685de00e480b7b6 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a42e2e724b246fb25a685de00e480b7b6">is_Poly</a> = False</td></tr>
<tr class="separator:a42e2e724b246fb25a685de00e480b7b6 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663b609de692830d5a666ba17eeac508 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a663b609de692830d5a666ba17eeac508">is_AlgebraicNumber</a> = False</td></tr>
<tr class="separator:a663b609de692830d5a666ba17eeac508 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be7363c2b5ef89bf1f3bbc9d7fc05a5 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0be7363c2b5ef89bf1f3bbc9d7fc05a5">is_Relational</a> = False</td></tr>
<tr class="separator:a0be7363c2b5ef89bf1f3bbc9d7fc05a5 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45289be208943272f626fb88fda471 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a7b45289be208943272f626fb88fda471">is_Equality</a> = False</td></tr>
<tr class="separator:a7b45289be208943272f626fb88fda471 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c1ea8245d1ed90a74c6b5bc80a1ec9 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a01c1ea8245d1ed90a74c6b5bc80a1ec9">is_Boolean</a> = False</td></tr>
<tr class="separator:a01c1ea8245d1ed90a74c6b5bc80a1ec9 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b02578323f20021fc25492fd8b4ca25 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a4b02578323f20021fc25492fd8b4ca25">is_Not</a> = False</td></tr>
<tr class="separator:a4b02578323f20021fc25492fd8b4ca25 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ba638c993541bf7670714666a1681d inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a37ba638c993541bf7670714666a1681d">is_Matrix</a> = False</td></tr>
<tr class="separator:a37ba638c993541bf7670714666a1681d inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3887b269fcbba72f8278b564ff39129 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#ab3887b269fcbba72f8278b564ff39129">is_Vector</a> = False</td></tr>
<tr class="separator:ab3887b269fcbba72f8278b564ff39129 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191412d105a22ab4a6bba4813c76c617 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a191412d105a22ab4a6bba4813c76c617">is_Point</a> = False</td></tr>
<tr class="separator:a191412d105a22ab4a6bba4813c76c617 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfc274dde5ad2741a6814f14d40fd46 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#aebfc274dde5ad2741a6814f14d40fd46">is_MatAdd</a> = False</td></tr>
<tr class="separator:aebfc274dde5ad2741a6814f14d40fd46 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dca5a287ea0c894859726b4954989d5 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a0dca5a287ea0c894859726b4954989d5">is_MatMul</a> = False</td></tr>
<tr class="separator:a0dca5a287ea0c894859726b4954989d5 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c900ecf2838ce3cf8bf4d51eee2342 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1basic_1_1Basic.html#a28c900ecf2838ce3cf8bf4d51eee2342">Kind</a></td></tr>
<tr class="separator:a28c900ecf2838ce3cf8bf4d51eee2342 inherit pub_static_attribs_classsympy_1_1core_1_1basic_1_1Basic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The class defining a Permutation group.

Explanation
===========

``PermutationGroup([p1, p2, ..., pn])`` returns the permutation group
generated by the list of permutations. This group can be supplied
to Polyhedron if one desires to decorate the elements to which the
indices of the permutation refer.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics import Polyhedron

The permutations corresponding to motion of the front, right and
bottom face of a $2 \times 2$ Rubik's cube are defined:

&gt;&gt;&gt; F = Permutation(2, 19, 21, 8)(3, 17, 20, 10)(4, 6, 7, 5)
&gt;&gt;&gt; R = Permutation(1, 5, 21, 14)(3, 7, 23, 12)(8, 10, 11, 9)
&gt;&gt;&gt; D = Permutation(6, 18, 14, 10)(7, 19, 15, 11)(20, 22, 23, 21)

These are passed as permutations to PermutationGroup:

&gt;&gt;&gt; G = PermutationGroup(F, R, D)
&gt;&gt;&gt; G.order()
3674160

The group can be supplied to a Polyhedron in order to track the
objects being moved. An example involving the $2 \times 2$ Rubik's cube is
given there, but here is a simple demonstration:

&gt;&gt;&gt; a = Permutation(2, 1)
&gt;&gt;&gt; b = Permutation(1, 0)
&gt;&gt;&gt; G = PermutationGroup(a, b)
&gt;&gt;&gt; P = Polyhedron(list('ABC'), pgroup=G)
&gt;&gt;&gt; P.corners
(A, B, C)
&gt;&gt;&gt; P.rotate(0) # apply permutation 0
&gt;&gt;&gt; P.corners
(A, C, B)
&gt;&gt;&gt; P.reset()
&gt;&gt;&gt; P.corners
(A, B, C)

Or one can make a permutation as a product of selected permutations
and apply them to an iterable directly:

&gt;&gt;&gt; P10 = G.make_perm([0, 1])
&gt;&gt;&gt; P10('ABC')
['C', 'A', 'B']

See Also
========

sympy.combinatorics.polyhedron.Polyhedron,
sympy.combinatorics.permutations.Permutation

References
==========

.. [1] Holt, D., Eick, B., O'Brien, E.
       "Handbook of Computational Group Theory"

.. [2] Seress, A.
       "Permutation Group Algorithms"

.. [3] https://en.wikipedia.org/wiki/Schreier_vector

.. [4] https://en.wikipedia.org/wiki/Nielsen_transformation#Product_replacement_algorithm

.. [5] Frank Celler, Charles R.Leedham-Green, Scott H.Murray,
       Alice C.Niemeyer, and E.A.O'Brien. "Generating Random
       Elements of a Finite Group"

.. [6] https://en.wikipedia.org/wiki/Block_%28permutation_group_theory%29

.. [7] https://algorithmist.com/wiki/Union_find

.. [8] https://en.wikipedia.org/wiki/Multiply_transitive_group#Multiply_transitive_groups

.. [9] https://en.wikipedia.org/wiki/Center_%28group_theory%29

.. [10] https://en.wikipedia.org/wiki/Centralizer_and_normalizer

.. [11] https://groupprops.subwiki.org/wiki/Derived_subgroup

.. [12] https://en.wikipedia.org/wiki/Nilpotent_group

.. [13] https://www.math.colostate.edu/~hulpke/CGT/cgtnotes.pdf

.. [14] https://docs.gap-system.org/doc/ref/manual.pdf</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0716b231b058e2931ac2fa9042e0a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0716b231b058e2931ac2fa9042e0a2a8">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0716b231b058e2931ac2fa9042e0a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0716b231b058e2931ac2fa9042e0a2a8">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afdccfccd6b33b5af6ea9a9337f8cf4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdccfccd6b33b5af6ea9a9337f8cf4e5">&#9670;&nbsp;</a></span>__contains__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__contains__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if *i* is contained in PermutationGroup.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; p = Permutation(1, 2, 3)
&gt;&gt;&gt; Permutation(3) in PermutationGroup(p)
True</pre> 
</div>
</div>
<a id="afdccfccd6b33b5af6ea9a9337f8cf4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdccfccd6b33b5af6ea9a9337f8cf4e5">&#9670;&nbsp;</a></span>__contains__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__contains__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if *i* is contained in PermutationGroup.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; p = Permutation(1, 2, 3)
&gt;&gt;&gt; Permutation(3) in PermutationGroup(p)
True</pre> 
</div>
</div>
<a id="a04b4a02f47aae013546c54e6e2495526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b4a02f47aae013546c54e6e2495526">&#9670;&nbsp;</a></span>__getitem__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__getitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04b4a02f47aae013546c54e6e2495526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b4a02f47aae013546c54e6e2495526">&#9670;&nbsp;</a></span>__getitem__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__getitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab803e52d9fad6c542fc2fcba7132a5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab803e52d9fad6c542fc2fcba7132a5d8">&#9670;&nbsp;</a></span>__len__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__len__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab803e52d9fad6c542fc2fcba7132a5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab803e52d9fad6c542fc2fcba7132a5d8">&#9670;&nbsp;</a></span>__len__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__len__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e07ca01da5a3cd76bc306cbffed5987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07ca01da5a3cd76bc306cbffed5987">&#9670;&nbsp;</a></span>__mul__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__mul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the direct product of two permutation groups as a permutation
group.

Explanation
===========

This implementation realizes the direct product by shifting the index
set for the generators of the second group: so if we have ``G`` acting
on ``n1`` points and ``H`` acting on ``n2`` points, ``G*H`` acts on
``n1 + n2`` points.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import CyclicGroup
&gt;&gt;&gt; G = CyclicGroup(5)
&gt;&gt;&gt; H = G*G
&gt;&gt;&gt; H
PermutationGroup([
    (9)(0 1 2 3 4),
    (5 6 7 8 9)])
&gt;&gt;&gt; H.order()
25</pre> 
</div>
</div>
<a id="a8e07ca01da5a3cd76bc306cbffed5987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07ca01da5a3cd76bc306cbffed5987">&#9670;&nbsp;</a></span>__mul__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__mul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the direct product of two permutation groups as a permutation
group.

Explanation
===========

This implementation realizes the direct product by shifting the index
set for the generators of the second group: so if we have ``G`` acting
on ``n1`` points and ``H`` acting on ``n2`` points, ``G*H`` acts on
``n1 + n2`` points.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import CyclicGroup
&gt;&gt;&gt; G = CyclicGroup(5)
&gt;&gt;&gt; H = G*G
&gt;&gt;&gt; H
PermutationGroup([
    (9)(0 1 2 3 4),
    (5 6 7 8 9)])
&gt;&gt;&gt; H.order()
25</pre> 
</div>
</div>
<a id="a0de7b92db97d96cc13cd6c290e20e083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de7b92db97d96cc13cd6c290e20e083">&#9670;&nbsp;</a></span>__new__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__new__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dups</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The default constructor. Accepts Cycle and Permutation forms.
Removes duplicates unless ``dups`` keyword is ``False``.
</pre> 
</div>
</div>
<a id="a0de7b92db97d96cc13cd6c290e20e083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de7b92db97d96cc13cd6c290e20e083">&#9670;&nbsp;</a></span>__new__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.__new__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dups</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The default constructor. Accepts Cycle and Permutation forms.
Removes duplicates unless ``dups`` keyword is ``False``.
</pre> 
</div>
</div>
<a id="a6a4a2bd2eb937cbec1f9626e89e102c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4a2bd2eb937cbec1f9626e89e102c4">&#9670;&nbsp;</a></span>abelian_invariants() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.abelian_invariants </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the abelian invariants for the given group.
Let ``G`` be a nontrivial finite abelian group. Then G is isomorphic to
the direct product of finitely many nontrivial cyclic groups of
prime-power order.

Explanation
===========

The prime-powers that occur as the orders of the factors are uniquely
determined by G. More precisely, the primes that occur in the orders of the
factors in any such decomposition of ``G`` are exactly the primes that divide
``|G|`` and for any such prime ``p``, if the orders of the factors that are
p-groups in one such decomposition of ``G`` are ``p^{t_1} &gt;= p^{t_2} &gt;= ... p^{t_r}``,
then the orders of the factors that are p-groups in any such decomposition of ``G``
are ``p^{t_1} &gt;= p^{t_2} &gt;= ... p^{t_r}``.

The uniquely determined integers ``p^{t_1} &gt;= p^{t_2} &gt;= ... p^{t_r}``, taken
for all primes that divide ``|G|`` are called the invariants of the nontrivial
group ``G`` as suggested in ([14], p. 542).

Notes
=====

We adopt the convention that the invariants of a trivial group are [].

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.abelian_invariants()
[2]
&gt;&gt;&gt; from sympy.combinatorics import CyclicGroup
&gt;&gt;&gt; G = CyclicGroup(7)
&gt;&gt;&gt; G.abelian_invariants()
[7]</pre> 
</div>
</div>
<a id="a6a4a2bd2eb937cbec1f9626e89e102c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4a2bd2eb937cbec1f9626e89e102c4">&#9670;&nbsp;</a></span>abelian_invariants() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.abelian_invariants </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the abelian invariants for the given group.
Let ``G`` be a nontrivial finite abelian group. Then G is isomorphic to
the direct product of finitely many nontrivial cyclic groups of
prime-power order.

Explanation
===========

The prime-powers that occur as the orders of the factors are uniquely
determined by G. More precisely, the primes that occur in the orders of the
factors in any such decomposition of ``G`` are exactly the primes that divide
``|G|`` and for any such prime ``p``, if the orders of the factors that are
p-groups in one such decomposition of ``G`` are ``p^{t_1} &gt;= p^{t_2} &gt;= ... p^{t_r}``,
then the orders of the factors that are p-groups in any such decomposition of ``G``
are ``p^{t_1} &gt;= p^{t_2} &gt;= ... p^{t_r}``.

The uniquely determined integers ``p^{t_1} &gt;= p^{t_2} &gt;= ... p^{t_r}``, taken
for all primes that divide ``|G|`` are called the invariants of the nontrivial
group ``G`` as suggested in ([14], p. 542).

Notes
=====

We adopt the convention that the invariants of a trivial group are [].

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.abelian_invariants()
[2]
&gt;&gt;&gt; from sympy.combinatorics import CyclicGroup
&gt;&gt;&gt; G = CyclicGroup(7)
&gt;&gt;&gt; G.abelian_invariants()
[7]</pre> 
</div>
</div>
<a id="a04c7e522087fd136432d29cf2032ac0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c7e522087fd136432d29cf2032ac0e">&#9670;&nbsp;</a></span>base() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.base </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a base from the Schreier-Sims algorithm.

Explanation
===========

For a permutation group `G`, a base is a sequence of points
`B = (b_1, b_2, \dots, b_k)` such that no element of `G` apart
from the identity fixes all the points in `B`. The concepts of
a base and strong generating set and their applications are
discussed in depth in [1], pp. 87-89 and [2], pp. 55-57.

An alternative way to think of `B` is that it gives the
indices of the stabilizer cosets that contain more than the
identity permutation.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; G = PermutationGroup([Permutation(0, 1, 3)(2, 4)])
&gt;&gt;&gt; G.base
[0, 2]

See Also
========

strong_gens, basic_transversals, basic_orbits, basic_stabilizers</pre> 
</div>
</div>
<a id="a04c7e522087fd136432d29cf2032ac0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c7e522087fd136432d29cf2032ac0e">&#9670;&nbsp;</a></span>base() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.base </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a base from the Schreier-Sims algorithm.

Explanation
===========

For a permutation group `G`, a base is a sequence of points
`B = (b_1, b_2, \dots, b_k)` such that no element of `G` apart
from the identity fixes all the points in `B`. The concepts of
a base and strong generating set and their applications are
discussed in depth in [1], pp. 87-89 and [2], pp. 55-57.

An alternative way to think of `B` is that it gives the
indices of the stabilizer cosets that contain more than the
identity permutation.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; G = PermutationGroup([Permutation(0, 1, 3)(2, 4)])
&gt;&gt;&gt; G.base
[0, 2]

See Also
========

strong_gens, basic_transversals, basic_orbits, basic_stabilizers</pre> 
</div>
</div>
<a id="a3d6597e1e817ffc343a95a7b796a696b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6597e1e817ffc343a95a7b796a696b">&#9670;&nbsp;</a></span>baseswap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.baseswap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strong_gens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>randomized</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transversals</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basic_orbits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strong_gens_distr</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Swap two consecutive base points in base and strong generating set.

Explanation
===========

If a base for a group `G` is given by `(b_1, b_2, \dots, b_k)`, this
function returns a base `(b_1, b_2, \dots, b_{i+1}, b_i, \dots, b_k)`,
where `i` is given by ``pos``, and a strong generating set relative
to that base. The original base and strong generating set are not
modified.

The randomized version (default) is of Las Vegas type.

Parameters
==========

base, strong_gens
    The base and strong generating set.
pos
    The position at which swapping is performed.
randomized
    A switch between randomized and deterministic version.
transversals
    The transversals for the basic orbits, if known.
basic_orbits
    The basic orbits, if known.
strong_gens_distr
    The strong generators distributed by basic stabilizers, if known.

Returns
=======

(base, strong_gens)
    ``base`` is the new base, and ``strong_gens`` is a generating set
    relative to it.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs
&gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup
&gt;&gt;&gt; S = SymmetricGroup(4)
&gt;&gt;&gt; S.schreier_sims()
&gt;&gt;&gt; S.base
[0, 1, 2]
&gt;&gt;&gt; base, gens = S.baseswap(S.base, S.strong_gens, 1, randomized=False)
&gt;&gt;&gt; base, gens
([0, 2, 1],
[(0 1 2 3), (3)(0 1), (1 3 2),
 (2 3), (1 3)])

check that base, gens is a BSGS

&gt;&gt;&gt; S1 = PermutationGroup(gens)
&gt;&gt;&gt; _verify_bsgs(S1, base, gens)
True

See Also
========

schreier_sims

Notes
=====

The deterministic version of the algorithm is discussed in
[1], pp. 102-103; the randomized version is discussed in [1], p.103, and
[2], p.98. It is of Las Vegas type.
Notice that [1] contains a mistake in the pseudocode and
discussion of BASESWAP: on line 3 of the pseudocode,
`|\beta_{i+1}^{\left\langle T\right\rangle}|` should be replaced by
`|\beta_{i}^{\left\langle T\right\rangle}|`, and the same for the
discussion of the algorithm.</pre> 
</div>
</div>
<a id="a3d6597e1e817ffc343a95a7b796a696b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6597e1e817ffc343a95a7b796a696b">&#9670;&nbsp;</a></span>baseswap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.baseswap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strong_gens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>randomized</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transversals</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basic_orbits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strong_gens_distr</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Swap two consecutive base points in base and strong generating set.

Explanation
===========

If a base for a group `G` is given by `(b_1, b_2, \dots, b_k)`, this
function returns a base `(b_1, b_2, \dots, b_{i+1}, b_i, \dots, b_k)`,
where `i` is given by ``pos``, and a strong generating set relative
to that base. The original base and strong generating set are not
modified.

The randomized version (default) is of Las Vegas type.

Parameters
==========

base, strong_gens
    The base and strong generating set.
pos
    The position at which swapping is performed.
randomized
    A switch between randomized and deterministic version.
transversals
    The transversals for the basic orbits, if known.
basic_orbits
    The basic orbits, if known.
strong_gens_distr
    The strong generators distributed by basic stabilizers, if known.

Returns
=======

(base, strong_gens)
    ``base`` is the new base, and ``strong_gens`` is a generating set
    relative to it.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs
&gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup
&gt;&gt;&gt; S = SymmetricGroup(4)
&gt;&gt;&gt; S.schreier_sims()
&gt;&gt;&gt; S.base
[0, 1, 2]
&gt;&gt;&gt; base, gens = S.baseswap(S.base, S.strong_gens, 1, randomized=False)
&gt;&gt;&gt; base, gens
([0, 2, 1],
[(0 1 2 3), (3)(0 1), (1 3 2),
 (2 3), (1 3)])

check that base, gens is a BSGS

&gt;&gt;&gt; S1 = PermutationGroup(gens)
&gt;&gt;&gt; _verify_bsgs(S1, base, gens)
True

See Also
========

schreier_sims

Notes
=====

The deterministic version of the algorithm is discussed in
[1], pp. 102-103; the randomized version is discussed in [1], p.103, and
[2], p.98. It is of Las Vegas type.
Notice that [1] contains a mistake in the pseudocode and
discussion of BASESWAP: on line 3 of the pseudocode,
`|\beta_{i+1}^{\left\langle T\right\rangle}|` should be replaced by
`|\beta_{i}^{\left\langle T\right\rangle}|`, and the same for the
discussion of the algorithm.</pre> 
</div>
</div>
<a id="aac38d09a5423c85cd1c37778a4774766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac38d09a5423c85cd1c37778a4774766">&#9670;&nbsp;</a></span>basic_orbits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the basic orbits relative to a base and strong generating set.

Explanation
===========

If `(b_1, b_2, \dots, b_k)` is a base for a group `G`, and
`G^{(i)} = G_{b_1, b_2, \dots, b_{i-1}}` is the ``i``-th basic stabilizer
(so that `G^{(1)} = G`), the ``i``-th basic orbit relative to this base
is the orbit of `b_i` under `G^{(i)}`. See [1], pp. 87-89 for more
information.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; S = SymmetricGroup(4)
&gt;&gt;&gt; S.basic_orbits
[[0, 1, 2, 3], [1, 2, 3], [2, 3]]

See Also
========

base, strong_gens, basic_transversals, basic_stabilizers</pre> 
</div>
</div>
<a id="aac38d09a5423c85cd1c37778a4774766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac38d09a5423c85cd1c37778a4774766">&#9670;&nbsp;</a></span>basic_orbits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the basic orbits relative to a base and strong generating set.

Explanation
===========

If `(b_1, b_2, \dots, b_k)` is a base for a group `G`, and
`G^{(i)} = G_{b_1, b_2, \dots, b_{i-1}}` is the ``i``-th basic stabilizer
(so that `G^{(1)} = G`), the ``i``-th basic orbit relative to this base
is the orbit of `b_i` under `G^{(i)}`. See [1], pp. 87-89 for more
information.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; S = SymmetricGroup(4)
&gt;&gt;&gt; S.basic_orbits
[[0, 1, 2, 3], [1, 2, 3], [2, 3]]

See Also
========

base, strong_gens, basic_transversals, basic_stabilizers</pre> 
</div>
</div>
<a id="a6ff132d2b0e6a4f7b16abf151f4caafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff132d2b0e6a4f7b16abf151f4caafc">&#9670;&nbsp;</a></span>basic_stabilizers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a chain of stabilizers relative to a base and strong generating
set.

Explanation
===========

The ``i``-th basic stabilizer `G^{(i)}` relative to a base
`(b_1, b_2, \dots, b_k)` is `G_{b_1, b_2, \dots, b_{i-1}}`. For more
information, see [1], pp. 87-89.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup
&gt;&gt;&gt; A = AlternatingGroup(4)
&gt;&gt;&gt; A.schreier_sims()
&gt;&gt;&gt; A.base
[0, 1]
&gt;&gt;&gt; for g in A.basic_stabilizers:
...     print(g)
...
PermutationGroup([
    (3)(0 1 2),
    (1 2 3)])
PermutationGroup([
    (1 2 3)])

See Also
========

base, strong_gens, basic_orbits, basic_transversals</pre> 
</div>
</div>
<a id="a6ff132d2b0e6a4f7b16abf151f4caafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff132d2b0e6a4f7b16abf151f4caafc">&#9670;&nbsp;</a></span>basic_stabilizers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a chain of stabilizers relative to a base and strong generating
set.

Explanation
===========

The ``i``-th basic stabilizer `G^{(i)}` relative to a base
`(b_1, b_2, \dots, b_k)` is `G_{b_1, b_2, \dots, b_{i-1}}`. For more
information, see [1], pp. 87-89.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup
&gt;&gt;&gt; A = AlternatingGroup(4)
&gt;&gt;&gt; A.schreier_sims()
&gt;&gt;&gt; A.base
[0, 1]
&gt;&gt;&gt; for g in A.basic_stabilizers:
...     print(g)
...
PermutationGroup([
    (3)(0 1 2),
    (1 2 3)])
PermutationGroup([
    (1 2 3)])

See Also
========

base, strong_gens, basic_orbits, basic_transversals</pre> 
</div>
</div>
<a id="aa6f82634a58a706253c7caea8588d284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f82634a58a706253c7caea8588d284">&#9670;&nbsp;</a></span>basic_transversals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return basic transversals relative to a base and strong generating set.

Explanation
===========

The basic transversals are transversals of the basic orbits. They
are provided as a list of dictionaries, each dictionary having
keys - the elements of one of the basic orbits, and values - the
corresponding transversal elements. See [1], pp. 87-89 for more
information.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup
&gt;&gt;&gt; A = AlternatingGroup(4)
&gt;&gt;&gt; A.basic_transversals
[{0: (3), 1: (3)(0 1 2), 2: (3)(0 2 1), 3: (0 3 1)}, {1: (3), 2: (1 2 3), 3: (1 3 2)}]

See Also
========

strong_gens, base, basic_orbits, basic_stabilizers</pre> 
</div>
</div>
<a id="aa6f82634a58a706253c7caea8588d284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f82634a58a706253c7caea8588d284">&#9670;&nbsp;</a></span>basic_transversals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return basic transversals relative to a base and strong generating set.

Explanation
===========

The basic transversals are transversals of the basic orbits. They
are provided as a list of dictionaries, each dictionary having
keys - the elements of one of the basic orbits, and values - the
corresponding transversal elements. See [1], pp. 87-89 for more
information.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup
&gt;&gt;&gt; A = AlternatingGroup(4)
&gt;&gt;&gt; A.basic_transversals
[{0: (3), 1: (3)(0 1 2), 2: (3)(0 2 1), 3: (0 3 1)}, {1: (3), 2: (1 2 3), 3: (1 3 2)}]

See Also
========

strong_gens, base, basic_orbits, basic_stabilizers</pre> 
</div>
</div>
<a id="a2235023c8ae310df7091c9eea52078e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2235023c8ae310df7091c9eea52078e6">&#9670;&nbsp;</a></span>center() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.center </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the center of a permutation group.

Explanation
===========

The center for a group `G` is defined as
`Z(G) = \{z\in G | \forall g\in G, zg = gz \}`,
the set of elements of `G` that commute with all elements of `G`.
It is equal to the centralizer of `G` inside `G`, and is naturally a
subgroup of `G` ([9]).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(4)
&gt;&gt;&gt; G = D.center()
&gt;&gt;&gt; G.order()
2

See Also
========

centralizer

Notes
=====

This is a naive implementation that is a straightforward application
of ``.centralizer()``</pre> 
</div>
</div>
<a id="a2235023c8ae310df7091c9eea52078e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2235023c8ae310df7091c9eea52078e6">&#9670;&nbsp;</a></span>center() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.center </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the center of a permutation group.

Explanation
===========

The center for a group `G` is defined as
`Z(G) = \{z\in G | \forall g\in G, zg = gz \}`,
the set of elements of `G` that commute with all elements of `G`.
It is equal to the centralizer of `G` inside `G`, and is naturally a
subgroup of `G` ([9]).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(4)
&gt;&gt;&gt; G = D.center()
&gt;&gt;&gt; G.order()
2

See Also
========

centralizer

Notes
=====

This is a naive implementation that is a straightforward application
of ``.centralizer()``</pre> 
</div>
</div>
<a id="a60c9a1124a5d165c3857e42710227cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c9a1124a5d165c3857e42710227cf7">&#9670;&nbsp;</a></span>centralizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.centralizer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the centralizer of a group/set/element.

Explanation
===========

The centralizer of a set of permutations ``S`` inside
a group ``G`` is the set of elements of ``G`` that commute with all
elements of ``S``::

    `C_G(S) = \{ g \in G | gs = sg \forall s \in S\}` ([10])

Usually, ``S`` is a subset of ``G``, but if ``G`` is a proper subgroup of
the full symmetric group, we allow for ``S`` to have elements outside
``G``.

It is naturally a subgroup of ``G``; the centralizer of a permutation
group is equal to the centralizer of any set of generators for that
group, since any element commuting with the generators commutes with
any product of the  generators.

Parameters
==========

other
    a permutation group/list of permutations/single permutation

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... CyclicGroup)
&gt;&gt;&gt; S = SymmetricGroup(6)
&gt;&gt;&gt; C = CyclicGroup(6)
&gt;&gt;&gt; H = S.centralizer(C)
&gt;&gt;&gt; H.is_subgroup(C)
True

See Also
========

subgroup_search

Notes
=====

The implementation is an application of ``.subgroup_search()`` with
tests using a specific base for the group ``G``.</pre> 
</div>
</div>
<a id="a60c9a1124a5d165c3857e42710227cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c9a1124a5d165c3857e42710227cf7">&#9670;&nbsp;</a></span>centralizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.centralizer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the centralizer of a group/set/element.

Explanation
===========

The centralizer of a set of permutations ``S`` inside
a group ``G`` is the set of elements of ``G`` that commute with all
elements of ``S``::

    `C_G(S) = \{ g \in G | gs = sg \forall s \in S\}` ([10])

Usually, ``S`` is a subset of ``G``, but if ``G`` is a proper subgroup of
the full symmetric group, we allow for ``S`` to have elements outside
``G``.

It is naturally a subgroup of ``G``; the centralizer of a permutation
group is equal to the centralizer of any set of generators for that
group, since any element commuting with the generators commutes with
any product of the  generators.

Parameters
==========

other
    a permutation group/list of permutations/single permutation

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... CyclicGroup)
&gt;&gt;&gt; S = SymmetricGroup(6)
&gt;&gt;&gt; C = CyclicGroup(6)
&gt;&gt;&gt; H = S.centralizer(C)
&gt;&gt;&gt; H.is_subgroup(C)
True

See Also
========

subgroup_search

Notes
=====

The implementation is an application of ``.subgroup_search()`` with
tests using a specific base for the group ``G``.</pre> 
</div>
</div>
<a id="afd565b0ad59da694ea28b0bc98cdd09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd565b0ad59da694ea28b0bc98cdd09d">&#9670;&nbsp;</a></span>commutator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.commutator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the commutator of two subgroups.

Explanation
===========

For a permutation group ``K`` and subgroups ``G``, ``H``, the
commutator of ``G`` and ``H`` is defined as the group generated
by all the commutators `[g, h] = hgh^{-1}g^{-1}` for ``g`` in ``G`` and
``h`` in ``H``. It is naturally a subgroup of ``K`` ([1], p.27).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... AlternatingGroup)
&gt;&gt;&gt; S = SymmetricGroup(5)
&gt;&gt;&gt; A = AlternatingGroup(5)
&gt;&gt;&gt; G = S.commutator(S, A)
&gt;&gt;&gt; G.is_subgroup(A)
True

See Also
========

derived_subgroup

Notes
=====

The commutator of two subgroups `H, G` is equal to the normal closure
of the commutators of all the generators, i.e. `hgh^{-1}g^{-1}` for `h`
a generator of `H` and `g` a generator of `G` ([1], p.28)</pre> 
</div>
</div>
<a id="afd565b0ad59da694ea28b0bc98cdd09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd565b0ad59da694ea28b0bc98cdd09d">&#9670;&nbsp;</a></span>commutator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.commutator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the commutator of two subgroups.

Explanation
===========

For a permutation group ``K`` and subgroups ``G``, ``H``, the
commutator of ``G`` and ``H`` is defined as the group generated
by all the commutators `[g, h] = hgh^{-1}g^{-1}` for ``g`` in ``G`` and
``h`` in ``H``. It is naturally a subgroup of ``K`` ([1], p.27).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... AlternatingGroup)
&gt;&gt;&gt; S = SymmetricGroup(5)
&gt;&gt;&gt; A = AlternatingGroup(5)
&gt;&gt;&gt; G = S.commutator(S, A)
&gt;&gt;&gt; G.is_subgroup(A)
True

See Also
========

derived_subgroup

Notes
=====

The commutator of two subgroups `H, G` is equal to the normal closure
of the commutators of all the generators, i.e. `hgh^{-1}g^{-1}` for `h`
a generator of `H` and `g` a generator of `G` ([1], p.28)</pre> 
</div>
</div>
<a id="a7490dd3c6da951d96ab928fe5e893ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7490dd3c6da951d96ab928fe5e893ce3">&#9670;&nbsp;</a></span>composition_series() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.composition_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the composition series for a group as a list
of permutation groups.

Explanation
===========

The composition series for a group `G` is defined as a
subnormal series `G = H_0 &gt; H_1 &gt; H_2 \ldots` A composition
series is a subnormal series such that each factor group
`H(i+1) / H(i)` is simple.
A subnormal series is a composition series only if it is of
maximum length.

The algorithm works as follows:
Starting with the derived series the idea is to fill
the gap between `G = der[i]` and `H = der[i+1]` for each
`i` independently. Since, all subgroups of the abelian group
`G/H` are normal so, first step is to take the generators
`g` of `G` and add them to generators of `H` one by one.

The factor groups formed are not simple in general. Each
group is obtained from the previous one by adding one
generator `g`, if the previous group is denoted by `H`
then the next group `K` is generated by `g` and `H`.
The factor group `K/H` is cyclic and it's order is
`K.order()//G.order()`. The series is then extended between
`K` and `H` by groups generated by powers of `g` and `H`.
The series formed is then prepended to the already existing
series.

Examples
========
&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; from sympy.combinatorics.named_groups import CyclicGroup
&gt;&gt;&gt; S = SymmetricGroup(12)
&gt;&gt;&gt; G = S.sylow_subgroup(2)
&gt;&gt;&gt; C = G.composition_series()
&gt;&gt;&gt; [H.order() for H in C]
[1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
&gt;&gt;&gt; G = S.sylow_subgroup(3)
&gt;&gt;&gt; C = G.composition_series()
&gt;&gt;&gt; [H.order() for H in C]
[243, 81, 27, 9, 3, 1]
&gt;&gt;&gt; G = CyclicGroup(12)
&gt;&gt;&gt; C = G.composition_series()
&gt;&gt;&gt; [H.order() for H in C]
[12, 6, 3, 1]</pre> 
</div>
</div>
<a id="a7490dd3c6da951d96ab928fe5e893ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7490dd3c6da951d96ab928fe5e893ce3">&#9670;&nbsp;</a></span>composition_series() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.composition_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the composition series for a group as a list
of permutation groups.

Explanation
===========

The composition series for a group `G` is defined as a
subnormal series `G = H_0 &gt; H_1 &gt; H_2 \ldots` A composition
series is a subnormal series such that each factor group
`H(i+1) / H(i)` is simple.
A subnormal series is a composition series only if it is of
maximum length.

The algorithm works as follows:
Starting with the derived series the idea is to fill
the gap between `G = der[i]` and `H = der[i+1]` for each
`i` independently. Since, all subgroups of the abelian group
`G/H` are normal so, first step is to take the generators
`g` of `G` and add them to generators of `H` one by one.

The factor groups formed are not simple in general. Each
group is obtained from the previous one by adding one
generator `g`, if the previous group is denoted by `H`
then the next group `K` is generated by `g` and `H`.
The factor group `K/H` is cyclic and it's order is
`K.order()//G.order()`. The series is then extended between
`K` and `H` by groups generated by powers of `g` and `H`.
The series formed is then prepended to the already existing
series.

Examples
========
&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; from sympy.combinatorics.named_groups import CyclicGroup
&gt;&gt;&gt; S = SymmetricGroup(12)
&gt;&gt;&gt; G = S.sylow_subgroup(2)
&gt;&gt;&gt; C = G.composition_series()
&gt;&gt;&gt; [H.order() for H in C]
[1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
&gt;&gt;&gt; G = S.sylow_subgroup(3)
&gt;&gt;&gt; C = G.composition_series()
&gt;&gt;&gt; [H.order() for H in C]
[243, 81, 27, 9, 3, 1]
&gt;&gt;&gt; G = CyclicGroup(12)
&gt;&gt;&gt; C = G.composition_series()
&gt;&gt;&gt; [H.order() for H in C]
[12, 6, 3, 1]</pre> 
</div>
</div>
<a id="aa4f259a5c75b9220d96be8561a5bc978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f259a5c75b9220d96be8561a5bc978">&#9670;&nbsp;</a></span>conjugacy_class() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.conjugacy_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the conjugacy class of an element in the group.

Explanation
===========

The conjugacy class of an element ``g`` in a group ``G`` is the set of
elements ``x`` in ``G`` that are conjugate with ``g``, i.e. for which

    ``g = xax^{-1}``

for some ``a`` in ``G``.

Note that conjugacy is an equivalence relation, and therefore that
conjugacy classes are partitions of ``G``. For a list of all the
conjugacy classes of the group, use the conjugacy_classes() method.

In a permutation group, each conjugacy class corresponds to a particular
`cycle structure': for example, in ``S_3``, the conjugacy classes are:

    * the identity class, ``{()}``
    * all transpositions, ``{(1 2), (1 3), (2 3)}``
    * all 3-cycles, ``{(1 2 3), (1 3 2)}``

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, SymmetricGroup
&gt;&gt;&gt; S3 = SymmetricGroup(3)
&gt;&gt;&gt; S3.conjugacy_class(Permutation(0, 1, 2))
{(0 1 2), (0 2 1)}

Notes
=====

This procedure computes the conjugacy class directly by finding the
orbit of the element under conjugation in G. This algorithm is only
feasible for permutation groups of relatively small order, but is like
the orbit() function itself in that respect.
</pre> 
</div>
</div>
<a id="aa4f259a5c75b9220d96be8561a5bc978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f259a5c75b9220d96be8561a5bc978">&#9670;&nbsp;</a></span>conjugacy_class() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.conjugacy_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the conjugacy class of an element in the group.

Explanation
===========

The conjugacy class of an element ``g`` in a group ``G`` is the set of
elements ``x`` in ``G`` that are conjugate with ``g``, i.e. for which

    ``g = xax^{-1}``

for some ``a`` in ``G``.

Note that conjugacy is an equivalence relation, and therefore that
conjugacy classes are partitions of ``G``. For a list of all the
conjugacy classes of the group, use the conjugacy_classes() method.

In a permutation group, each conjugacy class corresponds to a particular
`cycle structure': for example, in ``S_3``, the conjugacy classes are:

    * the identity class, ``{()}``
    * all transpositions, ``{(1 2), (1 3), (2 3)}``
    * all 3-cycles, ``{(1 2 3), (1 3 2)}``

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, SymmetricGroup
&gt;&gt;&gt; S3 = SymmetricGroup(3)
&gt;&gt;&gt; S3.conjugacy_class(Permutation(0, 1, 2))
{(0 1 2), (0 2 1)}

Notes
=====

This procedure computes the conjugacy class directly by finding the
orbit of the element under conjugation in G. This algorithm is only
feasible for permutation groups of relatively small order, but is like
the orbit() function itself in that respect.
</pre> 
</div>
</div>
<a id="af8d54fefe645f67e30d1cc0d5d8e9578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d54fefe645f67e30d1cc0d5d8e9578">&#9670;&nbsp;</a></span>conjugacy_classes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.conjugacy_classes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the conjugacy classes of the group.

Explanation
===========

As described in the documentation for the .conjugacy_class() function,
conjugacy is an equivalence relation on a group G which partitions the
set of elements. This method returns a list of all these conjugacy
classes of G.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import SymmetricGroup
&gt;&gt;&gt; SymmetricGroup(3).conjugacy_classes()
[{(2)}, {(0 1 2), (0 2 1)}, {(0 2), (1 2), (2)(0 1)}]</pre> 
</div>
</div>
<a id="af8d54fefe645f67e30d1cc0d5d8e9578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d54fefe645f67e30d1cc0d5d8e9578">&#9670;&nbsp;</a></span>conjugacy_classes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.conjugacy_classes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the conjugacy classes of the group.

Explanation
===========

As described in the documentation for the .conjugacy_class() function,
conjugacy is an equivalence relation on a group G which partitions the
set of elements. This method returns a list of all these conjugacy
classes of G.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import SymmetricGroup
&gt;&gt;&gt; SymmetricGroup(3).conjugacy_classes()
[{(2)}, {(0 1 2), (0 2 1)}, {(0 2), (1 2), (2)(0 1)}]</pre> 
</div>
</div>
<a id="ad0e2dce2cdfa37fd05d09a87f5334385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e2dce2cdfa37fd05d09a87f5334385">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.contains </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if permutation ``g`` belong to self, ``G``.

Explanation
===========

If ``g`` is an element of ``G`` it can be written as a product
of factors drawn from the cosets of ``G``'s stabilizers. To see
if ``g`` is one of the actual generators defining the group use
``G.has(g)``.

If ``strict`` is not ``True``, ``g`` will be resized, if necessary,
to match the size of permutations in ``self``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup

&gt;&gt;&gt; a = Permutation(1, 2)
&gt;&gt;&gt; b = Permutation(2, 3, 1)
&gt;&gt;&gt; G = PermutationGroup(a, b, degree=5)
&gt;&gt;&gt; G.contains(G[0]) # trivial check
True
&gt;&gt;&gt; elem = Permutation([[2, 3]], size=5)
&gt;&gt;&gt; G.contains(elem)
True
&gt;&gt;&gt; G.contains(Permutation(4)(0, 1, 2, 3))
False

If strict is False, a permutation will be resized, if
necessary:

&gt;&gt;&gt; H = PermutationGroup(Permutation(5))
&gt;&gt;&gt; H.contains(Permutation(3))
False
&gt;&gt;&gt; H.contains(Permutation(3), strict=False)
True

To test if a given permutation is present in the group:

&gt;&gt;&gt; elem in G.generators
False
&gt;&gt;&gt; G.has(elem)
False

See Also
========

coset_factor, sympy.core.basic.Basic.has, __contains__</pre> 
</div>
</div>
<a id="ad0e2dce2cdfa37fd05d09a87f5334385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e2dce2cdfa37fd05d09a87f5334385">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.contains </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if permutation ``g`` belong to self, ``G``.

Explanation
===========

If ``g`` is an element of ``G`` it can be written as a product
of factors drawn from the cosets of ``G``'s stabilizers. To see
if ``g`` is one of the actual generators defining the group use
``G.has(g)``.

If ``strict`` is not ``True``, ``g`` will be resized, if necessary,
to match the size of permutations in ``self``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup

&gt;&gt;&gt; a = Permutation(1, 2)
&gt;&gt;&gt; b = Permutation(2, 3, 1)
&gt;&gt;&gt; G = PermutationGroup(a, b, degree=5)
&gt;&gt;&gt; G.contains(G[0]) # trivial check
True
&gt;&gt;&gt; elem = Permutation([[2, 3]], size=5)
&gt;&gt;&gt; G.contains(elem)
True
&gt;&gt;&gt; G.contains(Permutation(4)(0, 1, 2, 3))
False

If strict is False, a permutation will be resized, if
necessary:

&gt;&gt;&gt; H = PermutationGroup(Permutation(5))
&gt;&gt;&gt; H.contains(Permutation(3))
False
&gt;&gt;&gt; H.contains(Permutation(3), strict=False)
True

To test if a given permutation is present in the group:

&gt;&gt;&gt; elem in G.generators
False
&gt;&gt;&gt; G.has(elem)
False

See Also
========

coset_factor, sympy.core.basic.Basic.has, __contains__</pre> 
</div>
</div>
<a id="aa1eb8ef9c8b0e992a4b904e55605ff7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1eb8ef9c8b0e992a4b904e55605ff7f">&#9670;&nbsp;</a></span>coset_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_factor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factor_index</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``G``'s (self's) coset factorization of ``g``

Explanation
===========

If ``g`` is an element of ``G`` then it can be written as the product
of permutations drawn from the Schreier-Sims coset decomposition,

The permutations returned in ``f`` are those for which
the product gives ``g``: ``g = f[n]*...f[1]*f[0]`` where ``n = len(B)``
and ``B = G.base``. f[i] is one of the permutations in
``self._basic_orbits[i]``.

If factor_index==True,
returns a tuple ``[b[0],..,b[n]]``, where ``b[i]``
belongs to ``self._basic_orbits[i]``

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)
&gt;&gt;&gt; b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)
&gt;&gt;&gt; G = PermutationGroup([a, b])

Define g:

&gt;&gt;&gt; g = Permutation(7)(1, 2, 4)(3, 6, 5)

Confirm that it is an element of G:

&gt;&gt;&gt; G.contains(g)
True

Thus, it can be written as a product of factors (up to
3) drawn from u. See below that a factor from u1 and u2
and the Identity permutation have been used:

&gt;&gt;&gt; f = G.coset_factor(g)
&gt;&gt;&gt; f[2]*f[1]*f[0] == g
True
&gt;&gt;&gt; f1 = G.coset_factor(g, True); f1
[0, 4, 4]
&gt;&gt;&gt; tr = G.basic_transversals
&gt;&gt;&gt; f[0] == tr[0][f1[0]]
True

If g is not an element of G then [] is returned:

&gt;&gt;&gt; c = Permutation(5, 6, 7)
&gt;&gt;&gt; G.coset_factor(c)
[]

See Also
========

sympy.combinatorics.util._strip</pre> 
</div>
</div>
<a id="aa1eb8ef9c8b0e992a4b904e55605ff7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1eb8ef9c8b0e992a4b904e55605ff7f">&#9670;&nbsp;</a></span>coset_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_factor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factor_index</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``G``'s (self's) coset factorization of ``g``

Explanation
===========

If ``g`` is an element of ``G`` then it can be written as the product
of permutations drawn from the Schreier-Sims coset decomposition,

The permutations returned in ``f`` are those for which
the product gives ``g``: ``g = f[n]*...f[1]*f[0]`` where ``n = len(B)``
and ``B = G.base``. f[i] is one of the permutations in
``self._basic_orbits[i]``.

If factor_index==True,
returns a tuple ``[b[0],..,b[n]]``, where ``b[i]``
belongs to ``self._basic_orbits[i]``

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)
&gt;&gt;&gt; b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)
&gt;&gt;&gt; G = PermutationGroup([a, b])

Define g:

&gt;&gt;&gt; g = Permutation(7)(1, 2, 4)(3, 6, 5)

Confirm that it is an element of G:

&gt;&gt;&gt; G.contains(g)
True

Thus, it can be written as a product of factors (up to
3) drawn from u. See below that a factor from u1 and u2
and the Identity permutation have been used:

&gt;&gt;&gt; f = G.coset_factor(g)
&gt;&gt;&gt; f[2]*f[1]*f[0] == g
True
&gt;&gt;&gt; f1 = G.coset_factor(g, True); f1
[0, 4, 4]
&gt;&gt;&gt; tr = G.basic_transversals
&gt;&gt;&gt; f[0] == tr[0][f1[0]]
True

If g is not an element of G then [] is returned:

&gt;&gt;&gt; c = Permutation(5, 6, 7)
&gt;&gt;&gt; G.coset_factor(c)
[]

See Also
========

sympy.combinatorics.util._strip</pre> 
</div>
</div>
<a id="ac1dafce9e16e750217e5b56ceae873a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dafce9e16e750217e5b56ceae873a5">&#9670;&nbsp;</a></span>coset_rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_rank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">rank using Schreier-Sims representation.

Explanation
===========

The coset rank of ``g`` is the ordering number in which
it appears in the lexicographic listing according to the
coset decomposition

The ordering is the same as in G.generate(method='coset').
If ``g`` does not belong to the group it returns None.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)
&gt;&gt;&gt; b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; c = Permutation(7)(2, 4)(3, 5)
&gt;&gt;&gt; G.coset_rank(c)
16
&gt;&gt;&gt; G.coset_unrank(16)
(7)(2 4)(3 5)

See Also
========

coset_factor</pre> 
</div>
</div>
<a id="ac1dafce9e16e750217e5b56ceae873a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dafce9e16e750217e5b56ceae873a5">&#9670;&nbsp;</a></span>coset_rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_rank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">rank using Schreier-Sims representation.

Explanation
===========

The coset rank of ``g`` is the ordering number in which
it appears in the lexicographic listing according to the
coset decomposition

The ordering is the same as in G.generate(method='coset').
If ``g`` does not belong to the group it returns None.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)
&gt;&gt;&gt; b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; c = Permutation(7)(2, 4)(3, 5)
&gt;&gt;&gt; G.coset_rank(c)
16
&gt;&gt;&gt; G.coset_unrank(16)
(7)(2 4)(3 5)

See Also
========

coset_factor</pre> 
</div>
</div>
<a id="a017b7db6f1fedc8494f42d5e108002a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017b7db6f1fedc8494f42d5e108002a6">&#9670;&nbsp;</a></span>coset_table() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_table </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the standardised (right) coset table of self in H as
a list of lists.
</pre> 
</div>
</div>
<a id="a017b7db6f1fedc8494f42d5e108002a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017b7db6f1fedc8494f42d5e108002a6">&#9670;&nbsp;</a></span>coset_table() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_table </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the standardised (right) coset table of self in H as
a list of lists.
</pre> 
</div>
</div>
<a id="a246f19ba3baa008220b54728b3e2d72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246f19ba3baa008220b54728b3e2d72f">&#9670;&nbsp;</a></span>coset_transversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_transversal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a transversal of the right cosets of self by its subgroup H
using the second method described in [1], Subsection 4.6.7</pre> 
</div>
</div>
<a id="a246f19ba3baa008220b54728b3e2d72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246f19ba3baa008220b54728b3e2d72f">&#9670;&nbsp;</a></span>coset_transversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_transversal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a transversal of the right cosets of self by its subgroup H
using the second method described in [1], Subsection 4.6.7</pre> 
</div>
</div>
<a id="aa19554681aebe72cd83ee8b6b7d73fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19554681aebe72cd83ee8b6b7d73fdc">&#9670;&nbsp;</a></span>coset_unrank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_unrank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">unrank using Schreier-Sims representation

coset_unrank is the inverse operation of coset_rank
if 0 &lt;= rank &lt; order; otherwise it returns None.</pre> 
</div>
</div>
<a id="aa19554681aebe72cd83ee8b6b7d73fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19554681aebe72cd83ee8b6b7d73fdc">&#9670;&nbsp;</a></span>coset_unrank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.coset_unrank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">unrank using Schreier-Sims representation

coset_unrank is the inverse operation of coset_rank
if 0 &lt;= rank &lt; order; otherwise it returns None.</pre> 
</div>
</div>
<a id="a79383116523bc879cf6463def1f4d266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79383116523bc879cf6463def1f4d266">&#9670;&nbsp;</a></span>degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the size of the permutations in the group.

Explanation
===========

The number of permutations comprising the group is given by
``len(group)``; the number of permutations that can be generated
by the group is given by ``group.order()``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.degree
3
&gt;&gt;&gt; len(G)
1
&gt;&gt;&gt; G.order()
2
&gt;&gt;&gt; list(G.generate())
[(2), (2)(0 1)]

See Also
========

order
</pre> 
</div>
</div>
<a id="a79383116523bc879cf6463def1f4d266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79383116523bc879cf6463def1f4d266">&#9670;&nbsp;</a></span>degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the size of the permutations in the group.

Explanation
===========

The number of permutations comprising the group is given by
``len(group)``; the number of permutations that can be generated
by the group is given by ``group.order()``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.degree
3
&gt;&gt;&gt; len(G)
1
&gt;&gt;&gt; G.order()
2
&gt;&gt;&gt; list(G.generate())
[(2), (2)(0 1)]

See Also
========

order
</pre> 
</div>
</div>
<a id="a30446ba845d5b811ff455a5289911c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30446ba845d5b811ff455a5289911c51">&#9670;&nbsp;</a></span>derived_series() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.derived_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the derived series for the group.

Explanation
===========

The derived series for a group `G` is defined as
`G = G_0 &gt; G_1 &gt; G_2 &gt; \ldots` where `G_i = [G_{i-1}, G_{i-1}]`,
i.e. `G_i` is the derived subgroup of `G_{i-1}`, for
`i\in\mathbb{N}`. When we have `G_k = G_{k-1}` for some
`k\in\mathbb{N}`, the series terminates.

Returns
=======

A list of permutation groups containing the members of the derived
series in the order `G = G_0, G_1, G_2, \ldots`.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... AlternatingGroup, DihedralGroup)
&gt;&gt;&gt; A = AlternatingGroup(5)
&gt;&gt;&gt; len(A.derived_series())
1
&gt;&gt;&gt; S = SymmetricGroup(4)
&gt;&gt;&gt; len(S.derived_series())
4
&gt;&gt;&gt; S.derived_series()[1].is_subgroup(AlternatingGroup(4))
True
&gt;&gt;&gt; S.derived_series()[2].is_subgroup(DihedralGroup(2))
True

See Also
========

derived_subgroup</pre> 
</div>
</div>
<a id="a30446ba845d5b811ff455a5289911c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30446ba845d5b811ff455a5289911c51">&#9670;&nbsp;</a></span>derived_series() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.derived_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the derived series for the group.

Explanation
===========

The derived series for a group `G` is defined as
`G = G_0 &gt; G_1 &gt; G_2 &gt; \ldots` where `G_i = [G_{i-1}, G_{i-1}]`,
i.e. `G_i` is the derived subgroup of `G_{i-1}`, for
`i\in\mathbb{N}`. When we have `G_k = G_{k-1}` for some
`k\in\mathbb{N}`, the series terminates.

Returns
=======

A list of permutation groups containing the members of the derived
series in the order `G = G_0, G_1, G_2, \ldots`.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... AlternatingGroup, DihedralGroup)
&gt;&gt;&gt; A = AlternatingGroup(5)
&gt;&gt;&gt; len(A.derived_series())
1
&gt;&gt;&gt; S = SymmetricGroup(4)
&gt;&gt;&gt; len(S.derived_series())
4
&gt;&gt;&gt; S.derived_series()[1].is_subgroup(AlternatingGroup(4))
True
&gt;&gt;&gt; S.derived_series()[2].is_subgroup(DihedralGroup(2))
True

See Also
========

derived_subgroup</pre> 
</div>
</div>
<a id="ad76116697ea2112a4dfdb517871edd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76116697ea2112a4dfdb517871edd16">&#9670;&nbsp;</a></span>derived_subgroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the derived subgroup.

Explanation
===========

The derived subgroup, or commutator subgroup is the subgroup generated
by all commutators `[g, h] = hgh^{-1}g^{-1}` for `g, h\in G` ; it is
equal to the normal closure of the set of commutators of the generators
([1], p.28, [11]).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 0, 2, 4, 3])
&gt;&gt;&gt; b = Permutation([0, 1, 3, 2, 4])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; C = G.derived_subgroup()
&gt;&gt;&gt; list(C.generate(af=True))
[[0, 1, 2, 3, 4], [0, 1, 3, 4, 2], [0, 1, 4, 2, 3]]

See Also
========

derived_series</pre> 
</div>
</div>
<a id="ad76116697ea2112a4dfdb517871edd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76116697ea2112a4dfdb517871edd16">&#9670;&nbsp;</a></span>derived_subgroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the derived subgroup.

Explanation
===========

The derived subgroup, or commutator subgroup is the subgroup generated
by all commutators `[g, h] = hgh^{-1}g^{-1}` for `g, h\in G` ; it is
equal to the normal closure of the set of commutators of the generators
([1], p.28, [11]).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 0, 2, 4, 3])
&gt;&gt;&gt; b = Permutation([0, 1, 3, 2, 4])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; C = G.derived_subgroup()
&gt;&gt;&gt; list(C.generate(af=True))
[[0, 1, 2, 3, 4], [0, 1, 3, 4, 2], [0, 1, 4, 2, 3]]

See Also
========

derived_series</pre> 
</div>
</div>
<a id="a896cb7478e42f44c2c61108cfdbfe717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896cb7478e42f44c2c61108cfdbfe717">&#9670;&nbsp;</a></span>elements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.elements </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns all the elements of the permutation group as a list

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; p = PermutationGroup(Permutation(1, 3), Permutation(1, 2))
&gt;&gt;&gt; p.elements
[(3), (3)(1 2), (1 3), (2 3), (1 2 3), (1 3 2)]</pre> 
</div>
</div>
<a id="a896cb7478e42f44c2c61108cfdbfe717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896cb7478e42f44c2c61108cfdbfe717">&#9670;&nbsp;</a></span>elements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.elements </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns all the elements of the permutation group as a list

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; p = PermutationGroup(Permutation(1, 3), Permutation(1, 2))
&gt;&gt;&gt; p.elements
[(3), (3)(1 2), (1 3), (2 3), (1 2 3), (1 3 2)]</pre> 
</div>
</div>
<a id="a8cf887fdd0e60658e26b388cde24ccab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf887fdd0e60658e26b388cde24ccab">&#9670;&nbsp;</a></span>equals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.equals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if PermutationGroup generated by elements in the
group are same i.e they represent the same PermutationGroup.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; p = Permutation(0, 1, 2, 3, 4, 5)
&gt;&gt;&gt; G = PermutationGroup([p, p**2])
&gt;&gt;&gt; H = PermutationGroup([p**2, p])
&gt;&gt;&gt; G.generators == H.generators
False
&gt;&gt;&gt; G.equals(H)
True</pre> 
</div>
</div>
<a id="a8cf887fdd0e60658e26b388cde24ccab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf887fdd0e60658e26b388cde24ccab">&#9670;&nbsp;</a></span>equals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.equals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if PermutationGroup generated by elements in the
group are same i.e they represent the same PermutationGroup.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; p = Permutation(0, 1, 2, 3, 4, 5)
&gt;&gt;&gt; G = PermutationGroup([p, p**2])
&gt;&gt;&gt; H = PermutationGroup([p**2, p])
&gt;&gt;&gt; G.generators == H.generators
False
&gt;&gt;&gt; G.equals(H)
True</pre> 
</div>
</div>
<a id="a1d9e5d43c0c64b1c275bfa6653e805f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9e5d43c0c64b1c275bfa6653e805f6">&#9670;&nbsp;</a></span>generate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;coset&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return iterator to generate the elements of the group.

Explanation
===========

Iteration is done with one of these methods::

  method='coset'  using the Schreier-Sims coset representation
  method='dimino' using the Dimino method

If ``af = True`` it yields the array form of the permutations

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics.polyhedron import tetrahedron

The permutation group given in the tetrahedron object is also
true groups:

&gt;&gt;&gt; G = tetrahedron.pgroup
&gt;&gt;&gt; G.is_group
True

Also the group generated by the permutations in the tetrahedron
pgroup -- even the first two -- is a proper group:

&gt;&gt;&gt; H = PermutationGroup(G[0], G[1])
&gt;&gt;&gt; J = PermutationGroup(list(H.generate())); J
PermutationGroup([
    (0 1)(2 3),
    (1 2 3),
    (1 3 2),
    (0 3 1),
    (0 2 3),
    (0 3)(1 2),
    (0 1 3),
    (3)(0 2 1),
    (0 3 2),
    (3)(0 1 2),
    (0 2)(1 3)])
&gt;&gt;&gt; _.is_group
True
</pre> 
</div>
</div>
<a id="a1d9e5d43c0c64b1c275bfa6653e805f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9e5d43c0c64b1c275bfa6653e805f6">&#9670;&nbsp;</a></span>generate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;coset&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return iterator to generate the elements of the group.

Explanation
===========

Iteration is done with one of these methods::

  method='coset'  using the Schreier-Sims coset representation
  method='dimino' using the Dimino method

If ``af = True`` it yields the array form of the permutations

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics.polyhedron import tetrahedron

The permutation group given in the tetrahedron object is also
true groups:

&gt;&gt;&gt; G = tetrahedron.pgroup
&gt;&gt;&gt; G.is_group
True

Also the group generated by the permutations in the tetrahedron
pgroup -- even the first two -- is a proper group:

&gt;&gt;&gt; H = PermutationGroup(G[0], G[1])
&gt;&gt;&gt; J = PermutationGroup(list(H.generate())); J
PermutationGroup([
    (0 1)(2 3),
    (1 2 3),
    (1 3 2),
    (0 3 1),
    (0 2 3),
    (0 3)(1 2),
    (0 1 3),
    (3)(0 2 1),
    (0 3 2),
    (3)(0 1 2),
    (0 2)(1 3)])
&gt;&gt;&gt; _.is_group
True
</pre> 
</div>
</div>
<a id="a9072b36546fb25ae06052aec93597ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9072b36546fb25ae06052aec93597ae9">&#9670;&nbsp;</a></span>generate_dimino() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generate_dimino </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield group elements using Dimino's algorithm.

If ``af == True`` it yields the array form of the permutations.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([0, 2, 3, 1])
&gt;&gt;&gt; g = PermutationGroup([a, b])
&gt;&gt;&gt; list(g.generate_dimino(af=True))
[[0, 1, 2, 3], [0, 2, 1, 3], [0, 2, 3, 1],
 [0, 1, 3, 2], [0, 3, 2, 1], [0, 3, 1, 2]]

References
==========

.. [1] The Implementation of Various Algorithms for Permutation Groups in
       the Computer Algebra System: AXIOM, N.J. Doye, M.Sc. Thesis</pre> 
</div>
</div>
<a id="a9072b36546fb25ae06052aec93597ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9072b36546fb25ae06052aec93597ae9">&#9670;&nbsp;</a></span>generate_dimino() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generate_dimino </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield group elements using Dimino's algorithm.

If ``af == True`` it yields the array form of the permutations.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([0, 2, 3, 1])
&gt;&gt;&gt; g = PermutationGroup([a, b])
&gt;&gt;&gt; list(g.generate_dimino(af=True))
[[0, 1, 2, 3], [0, 2, 1, 3], [0, 2, 3, 1],
 [0, 1, 3, 2], [0, 3, 2, 1], [0, 3, 1, 2]]

References
==========

.. [1] The Implementation of Various Algorithms for Permutation Groups in
       the Computer Algebra System: AXIOM, N.J. Doye, M.Sc. Thesis</pre> 
</div>
</div>
<a id="a395ab6a0b05cb6063132f9faa9f50447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395ab6a0b05cb6063132f9faa9f50447">&#9670;&nbsp;</a></span>generate_schreier_sims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generate_schreier_sims </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield group elements using the Schreier-Sims representation
in coset_rank order

If ``af = True`` it yields the array form of the permutations

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([0, 2, 3, 1])
&gt;&gt;&gt; g = PermutationGroup([a, b])
&gt;&gt;&gt; list(g.generate_schreier_sims(af=True))
[[0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 2, 1],
 [0, 1, 3, 2], [0, 2, 3, 1], [0, 3, 1, 2]]
</pre> 
</div>
</div>
<a id="a395ab6a0b05cb6063132f9faa9f50447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395ab6a0b05cb6063132f9faa9f50447">&#9670;&nbsp;</a></span>generate_schreier_sims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generate_schreier_sims </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield group elements using the Schreier-Sims representation
in coset_rank order

If ``af = True`` it yields the array form of the permutations

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([0, 2, 3, 1])
&gt;&gt;&gt; g = PermutationGroup([a, b])
&gt;&gt;&gt; list(g.generate_schreier_sims(af=True))
[[0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 2, 1],
 [0, 1, 3, 2], [0, 2, 3, 1], [0, 3, 1, 2]]
</pre> 
</div>
</div>
<a id="ad5fa299e9d3b67a43b9437c10499113b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fa299e9d3b67a43b9437c10499113b">&#9670;&nbsp;</a></span>generator_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generator_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>original</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of strong generators `[s1, \dots, sn]`
s.t `g = sn \times \dots \times s1`. If ``original=True``, make the
list contain only the original group generators</pre> 
</div>
</div>
<a id="ad5fa299e9d3b67a43b9437c10499113b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fa299e9d3b67a43b9437c10499113b">&#9670;&nbsp;</a></span>generator_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generator_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>original</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of strong generators `[s1, \dots, sn]`
s.t `g = sn \times \dots \times s1`. If ``original=True``, make the
list contain only the original group generators</pre> 
</div>
</div>
<a id="a6acb6230f24e98620528b8104b43e5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acb6230f24e98620528b8104b43e5cb">&#9670;&nbsp;</a></span>generators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generators </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the generators of the group.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.generators
[(1 2), (2)(0 1)]</pre> 
</div>
</div>
<a id="a6acb6230f24e98620528b8104b43e5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acb6230f24e98620528b8104b43e5cb">&#9670;&nbsp;</a></span>generators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.generators </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the generators of the group.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.generators
[(1 2), (2)(0 1)]</pre> 
</div>
</div>
<a id="a96bd0df5d92c30bc675b2a8411393e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bd0df5d92c30bc675b2a8411393e22">&#9670;&nbsp;</a></span>identity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.identity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the identity element of the permutation group.</pre> 
</div>
</div>
<a id="a96bd0df5d92c30bc675b2a8411393e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bd0df5d92c30bc675b2a8411393e22">&#9670;&nbsp;</a></span>identity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.identity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the identity element of the permutation group.</pre> 
</div>
</div>
<a id="ae2778845a2bf4331713ab1921abfb6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2778845a2bf4331713ab1921abfb6d5">&#9670;&nbsp;</a></span>index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the index of a permutation group.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(1,2,3)
&gt;&gt;&gt; b =Permutation(3)
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; H = PermutationGroup([b])
&gt;&gt;&gt; G.index(H)
3</pre> 
</div>
</div>
<a id="ae2778845a2bf4331713ab1921abfb6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2778845a2bf4331713ab1921abfb6d5">&#9670;&nbsp;</a></span>index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the index of a permutation group.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(1,2,3)
&gt;&gt;&gt; b =Permutation(3)
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; H = PermutationGroup([b])
&gt;&gt;&gt; G.index(H)
3</pre> 
</div>
</div>
<a id="ae8a60cbfce2006021ac8e3bd41caec72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a60cbfce2006021ac8e3bd41caec72">&#9670;&nbsp;</a></span>is_abelian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_abelian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is Abelian.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.is_abelian
False
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.is_abelian
True</pre> 
</div>
</div>
<a id="ae8a60cbfce2006021ac8e3bd41caec72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a60cbfce2006021ac8e3bd41caec72">&#9670;&nbsp;</a></span>is_abelian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_abelian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is Abelian.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.is_abelian
False
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.is_abelian
True</pre> 
</div>
</div>
<a id="a689a6832ed209ffdaf2bf528e3407d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689a6832ed209ffdaf2bf528e3407d1c">&#9670;&nbsp;</a></span>is_alt_sym() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_random_prec</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Monte Carlo test for the symmetric/alternating group for degrees
&gt;= 8.

Explanation
===========

More specifically, it is one-sided Monte Carlo with the
answer True (i.e., G is symmetric/alternating) guaranteed to be
correct, and the answer False being incorrect with probability eps.

For degree &lt; 8, the order of the group is checked so the test
is deterministic.

Notes
=====

The algorithm itself uses some nontrivial results from group theory and
number theory:
1) If a transitive group ``G`` of degree ``n`` contains an element
with a cycle of length ``n/2 &lt; p &lt; n-2`` for ``p`` a prime, ``G`` is the
symmetric or alternating group ([1], pp. 81-82)
2) The proportion of elements in the symmetric/alternating group having
the property described in 1) is approximately `\log(2)/\log(n)`
([1], p.82; [2], pp. 226-227).
The helper function ``_check_cycles_alt_sym`` is used to
go over the cycles in a permutation and look for ones satisfying 1).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(10)
&gt;&gt;&gt; D.is_alt_sym()
False

See Also
========

_check_cycles_alt_sym</pre> 
</div>
</div>
<a id="a689a6832ed209ffdaf2bf528e3407d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689a6832ed209ffdaf2bf528e3407d1c">&#9670;&nbsp;</a></span>is_alt_sym() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_random_prec</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Monte Carlo test for the symmetric/alternating group for degrees
&gt;= 8.

Explanation
===========

More specifically, it is one-sided Monte Carlo with the
answer True (i.e., G is symmetric/alternating) guaranteed to be
correct, and the answer False being incorrect with probability eps.

For degree &lt; 8, the order of the group is checked so the test
is deterministic.

Notes
=====

The algorithm itself uses some nontrivial results from group theory and
number theory:
1) If a transitive group ``G`` of degree ``n`` contains an element
with a cycle of length ``n/2 &lt; p &lt; n-2`` for ``p`` a prime, ``G`` is the
symmetric or alternating group ([1], pp. 81-82)
2) The proportion of elements in the symmetric/alternating group having
the property described in 1) is approximately `\log(2)/\log(n)`
([1], p.82; [2], pp. 226-227).
The helper function ``_check_cycles_alt_sym`` is used to
go over the cycles in a permutation and look for ones satisfying 1).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(10)
&gt;&gt;&gt; D.is_alt_sym()
False

See Also
========

_check_cycles_alt_sym</pre> 
</div>
</div>
<a id="a292e6ce31910b86f3f77913ae800dfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292e6ce31910b86f3f77913ae800dfc8">&#9670;&nbsp;</a></span>is_alternating() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_alternating </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is alternating.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import AlternatingGroup
&gt;&gt;&gt; g = AlternatingGroup(5)
&gt;&gt;&gt; g.is_alternating
True

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; g = PermutationGroup(
...     Permutation(0, 1, 2, 3, 4),
...     Permutation(2, 3, 4))
&gt;&gt;&gt; g.is_alternating
True

Notes
=====

This uses a naive test involving the computation of the full
group order.
If you need more quicker taxonomy for large groups, you can use
:meth:`PermutationGroup.is_alt_sym`.
However, :meth:`PermutationGroup.is_alt_sym` may not be accurate
and is not able to distinguish between an alternating group and
a symmetric group.

See Also
========

is_alt_sym
</pre> 
</div>
</div>
<a id="a292e6ce31910b86f3f77913ae800dfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292e6ce31910b86f3f77913ae800dfc8">&#9670;&nbsp;</a></span>is_alternating() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_alternating </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is alternating.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import AlternatingGroup
&gt;&gt;&gt; g = AlternatingGroup(5)
&gt;&gt;&gt; g.is_alternating
True

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; g = PermutationGroup(
...     Permutation(0, 1, 2, 3, 4),
...     Permutation(2, 3, 4))
&gt;&gt;&gt; g.is_alternating
True

Notes
=====

This uses a naive test involving the computation of the full
group order.
If you need more quicker taxonomy for large groups, you can use
:meth:`PermutationGroup.is_alt_sym`.
However, :meth:`PermutationGroup.is_alt_sym` may not be accurate
and is not able to distinguish between an alternating group and
a symmetric group.

See Also
========

is_alt_sym
</pre> 
</div>
</div>
<a id="af5c458a1a52990c3caa1bc221e231543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c458a1a52990c3caa1bc221e231543">&#9670;&nbsp;</a></span>is_cyclic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_cyclic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is Cyclic.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AbelianGroup
&gt;&gt;&gt; G = AbelianGroup(3, 4)
&gt;&gt;&gt; G.is_cyclic
True
&gt;&gt;&gt; G = AbelianGroup(4, 4)
&gt;&gt;&gt; G.is_cyclic
False

Notes
=====

If the order of a group $n$ can be factored into the distinct
primes $p_1, p_2, \dots , p_s$ and if

.. math::
    \forall i, j \in \{1, 2, \dots, s \}:
    p_i \not \equiv 1 \pmod {p_j}

holds true, there is only one group of the order $n$ which
is a cyclic group [1]_. This is a generalization of the lemma
that the group of order $15, 35, \dots$ are cyclic.

And also, these additional lemmas can be used to test if a
group is cyclic if the order of the group is already found.

- If the group is abelian and the order of the group is
  square-free, the group is cyclic.
- If the order of the group is less than $6$ and is not $4$, the
  group is cyclic.
- If the order of the group is prime, the group is cyclic.

References
==========

.. [1] 1978: John S. Rose: A Course on Group Theory,
    Introduction to Finite Group Theory: 1.4
</pre> 
</div>
</div>
<a id="af5c458a1a52990c3caa1bc221e231543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c458a1a52990c3caa1bc221e231543">&#9670;&nbsp;</a></span>is_cyclic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_cyclic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is Cyclic.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AbelianGroup
&gt;&gt;&gt; G = AbelianGroup(3, 4)
&gt;&gt;&gt; G.is_cyclic
True
&gt;&gt;&gt; G = AbelianGroup(4, 4)
&gt;&gt;&gt; G.is_cyclic
False

Notes
=====

If the order of a group $n$ can be factored into the distinct
primes $p_1, p_2, \dots , p_s$ and if

.. math::
    \forall i, j \in \{1, 2, \dots, s \}:
    p_i \not \equiv 1 \pmod {p_j}

holds true, there is only one group of the order $n$ which
is a cyclic group [1]_. This is a generalization of the lemma
that the group of order $15, 35, \dots$ are cyclic.

And also, these additional lemmas can be used to test if a
group is cyclic if the order of the group is already found.

- If the group is abelian and the order of the group is
  square-free, the group is cyclic.
- If the order of the group is less than $6$ and is not $4$, the
  group is cyclic.
- If the order of the group is prime, the group is cyclic.

References
==========

.. [1] 1978: John S. Rose: A Course on Group Theory,
    Introduction to Finite Group Theory: 1.4
</pre> 
</div>
</div>
<a id="a0681d8380ee0c5aec16a08b20269eb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0681d8380ee0c5aec16a08b20269eb7d">&#9670;&nbsp;</a></span>is_dihedral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_dihedral </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is dihedral.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation
&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup, CyclicGroup
&gt;&gt;&gt; G = PermutationGroup(Permutation(1, 6)(2, 5)(3, 4), Permutation(0, 1, 2, 3, 4, 5, 6))
&gt;&gt;&gt; G.is_dihedral
True
&gt;&gt;&gt; G = SymmetricGroup(3)
&gt;&gt;&gt; G.is_dihedral
True
&gt;&gt;&gt; G = CyclicGroup(6)
&gt;&gt;&gt; G.is_dihedral
False

References
==========

.. [Di1] https://math.stackexchange.com/questions/827230/given-a-cayley-table-is-there-an-algorithm-to-determine-if-it-is-a-dihedral-gro/827273#827273
.. [Di2] https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral.pdf
.. [Di3] https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral2.pdf
.. [Di4] https://en.wikipedia.org/wiki/Dihedral_group
</pre> 
</div>
</div>
<a id="a0681d8380ee0c5aec16a08b20269eb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0681d8380ee0c5aec16a08b20269eb7d">&#9670;&nbsp;</a></span>is_dihedral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_dihedral </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is dihedral.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation
&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup, CyclicGroup
&gt;&gt;&gt; G = PermutationGroup(Permutation(1, 6)(2, 5)(3, 4), Permutation(0, 1, 2, 3, 4, 5, 6))
&gt;&gt;&gt; G.is_dihedral
True
&gt;&gt;&gt; G = SymmetricGroup(3)
&gt;&gt;&gt; G.is_dihedral
True
&gt;&gt;&gt; G = CyclicGroup(6)
&gt;&gt;&gt; G.is_dihedral
False

References
==========

.. [Di1] https://math.stackexchange.com/questions/827230/given-a-cayley-table-is-there-an-algorithm-to-determine-if-it-is-a-dihedral-gro/827273#827273
.. [Di2] https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral.pdf
.. [Di3] https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral2.pdf
.. [Di4] https://en.wikipedia.org/wiki/Dihedral_group
</pre> 
</div>
</div>
<a id="a2bf30365aa16d94011e76553f8d2f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf30365aa16d94011e76553f8d2f1bc">&#9670;&nbsp;</a></span>is_elementary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_elementary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is elementary abelian. An elementary
abelian group is a finite abelian group, where every nontrivial
element has order `p`, where `p` is a prime.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.is_elementary(2)
True
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([3, 1, 2, 0])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.is_elementary(2)
True
&gt;&gt;&gt; G.is_elementary(3)
False</pre> 
</div>
</div>
<a id="a2bf30365aa16d94011e76553f8d2f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf30365aa16d94011e76553f8d2f1bc">&#9670;&nbsp;</a></span>is_elementary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_elementary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is elementary abelian. An elementary
abelian group is a finite abelian group, where every nontrivial
element has order `p`, where `p` is a prime.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.is_elementary(2)
True
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([3, 1, 2, 0])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.is_elementary(2)
True
&gt;&gt;&gt; G.is_elementary(3)
False</pre> 
</div>
</div>
<a id="adaacd70fef3e7bd0aa06ecbc68c5f733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaacd70fef3e7bd0aa06ecbc68c5f733">&#9670;&nbsp;</a></span>is_nilpotent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_nilpotent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is nilpotent.

Explanation
===========

A group `G` is nilpotent if it has a central series of finite length.
Alternatively, `G` is nilpotent if its lower central series terminates
with the trivial group. Every nilpotent group is also solvable
([1], p.29, [12]).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... CyclicGroup)
&gt;&gt;&gt; C = CyclicGroup(6)
&gt;&gt;&gt; C.is_nilpotent
True
&gt;&gt;&gt; S = SymmetricGroup(5)
&gt;&gt;&gt; S.is_nilpotent
False

See Also
========

lower_central_series, is_solvable</pre> 
</div>
</div>
<a id="adaacd70fef3e7bd0aa06ecbc68c5f733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaacd70fef3e7bd0aa06ecbc68c5f733">&#9670;&nbsp;</a></span>is_nilpotent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_nilpotent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is nilpotent.

Explanation
===========

A group `G` is nilpotent if it has a central series of finite length.
Alternatively, `G` is nilpotent if its lower central series terminates
with the trivial group. Every nilpotent group is also solvable
([1], p.29, [12]).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... CyclicGroup)
&gt;&gt;&gt; C = CyclicGroup(6)
&gt;&gt;&gt; C.is_nilpotent
True
&gt;&gt;&gt; S = SymmetricGroup(5)
&gt;&gt;&gt; S.is_nilpotent
False

See Also
========

lower_central_series, is_solvable</pre> 
</div>
</div>
<a id="af08a60a2f43c68f1a56e569b65f0fea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08a60a2f43c68f1a56e569b65f0fea6">&#9670;&nbsp;</a></span>is_normal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_normal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if ``G=self`` is a normal subgroup of ``gr``.

Explanation
===========

G is normal in gr if
for each g2 in G, g1 in gr, ``g = g1*g2*g1**-1`` belongs to G
It is sufficient to check this for each g1 in gr.generators and
g2 in G.generators.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 2, 0])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G1 = PermutationGroup([a, Permutation([2, 0, 1])])
&gt;&gt;&gt; G1.is_normal(G)
True</pre> 
</div>
</div>
<a id="af08a60a2f43c68f1a56e569b65f0fea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08a60a2f43c68f1a56e569b65f0fea6">&#9670;&nbsp;</a></span>is_normal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_normal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if ``G=self`` is a normal subgroup of ``gr``.

Explanation
===========

G is normal in gr if
for each g2 in G, g1 in gr, ``g = g1*g2*g1**-1`` belongs to G
It is sufficient to check this for each g1 in gr.generators and
g2 in G.generators.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 2, 0])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G1 = PermutationGroup([a, Permutation([2, 0, 1])])
&gt;&gt;&gt; G1.is_normal(G)
True</pre> 
</div>
</div>
<a id="a150928c8161147932617c38dd1623e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150928c8161147932617c38dd1623e88">&#9670;&nbsp;</a></span>is_perfect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_perfect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is perfect.
A group is perfect if it equals to its derived subgroup.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(1,2,3)(4,5)
&gt;&gt;&gt; b = Permutation(1,2,3,4,5)
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.is_perfect
False</pre> 
</div>
</div>
<a id="a150928c8161147932617c38dd1623e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150928c8161147932617c38dd1623e88">&#9670;&nbsp;</a></span>is_perfect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_perfect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is perfect.
A group is perfect if it equals to its derived subgroup.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(1,2,3)(4,5)
&gt;&gt;&gt; b = Permutation(1,2,3,4,5)
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.is_perfect
False</pre> 
</div>
</div>
<a id="acb595484067ff05b4d9834c61cbe5759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb595484067ff05b4d9834c61cbe5759">&#9670;&nbsp;</a></span>is_polycyclic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_polycyclic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if a group is polycyclic. A group is polycyclic if
it has a subnormal series with cyclic factors. For finite groups,
this is the same as if the group is solvable.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([2, 0, 1, 3])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.is_polycyclic
True</pre> 
</div>
</div>
<a id="acb595484067ff05b4d9834c61cbe5759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb595484067ff05b4d9834c61cbe5759">&#9670;&nbsp;</a></span>is_polycyclic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_polycyclic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if a group is polycyclic. A group is polycyclic if
it has a subnormal series with cyclic factors. For finite groups,
this is the same as if the group is solvable.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([2, 0, 1, 3])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.is_polycyclic
True</pre> 
</div>
</div>
<a id="a2fb4cab8bcce55d13493906e4db9dae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb4cab8bcce55d13493906e4db9dae6">&#9670;&nbsp;</a></span>is_primitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_primitive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>randomized</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if a group is primitive.

Explanation
===========

A permutation group ``G`` acting on a set ``S`` is called primitive if
``S`` contains no nontrivial block under the action of ``G``
(a block is nontrivial if its cardinality is more than ``1``).

Notes
=====

The algorithm is described in [1], p.83, and uses the function
minimal_block to search for blocks of the form `\{0, k\}` for ``k``
ranging over representatives for the orbits of `G_0`, the stabilizer of
``0``. This algorithm has complexity `O(n^2)` where ``n`` is the degree
of the group, and will perform badly if `G_0` is small.

There are two implementations offered: one finds `G_0`
deterministically using the function ``stabilizer``, and the other
(default) produces random elements of `G_0` using ``random_stab``,
hoping that they generate a subgroup of `G_0` with not too many more
orbits than `G_0` (this is suggested in [1], p.83). Behavior is changed
by the ``randomized`` flag.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(10)
&gt;&gt;&gt; D.is_primitive()
False

See Also
========

minimal_block, random_stab</pre> 
</div>
</div>
<a id="a2fb4cab8bcce55d13493906e4db9dae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb4cab8bcce55d13493906e4db9dae6">&#9670;&nbsp;</a></span>is_primitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_primitive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>randomized</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if a group is primitive.

Explanation
===========

A permutation group ``G`` acting on a set ``S`` is called primitive if
``S`` contains no nontrivial block under the action of ``G``
(a block is nontrivial if its cardinality is more than ``1``).

Notes
=====

The algorithm is described in [1], p.83, and uses the function
minimal_block to search for blocks of the form `\{0, k\}` for ``k``
ranging over representatives for the orbits of `G_0`, the stabilizer of
``0``. This algorithm has complexity `O(n^2)` where ``n`` is the degree
of the group, and will perform badly if `G_0` is small.

There are two implementations offered: one finds `G_0`
deterministically using the function ``stabilizer``, and the other
(default) produces random elements of `G_0` using ``random_stab``,
hoping that they generate a subgroup of `G_0` with not too many more
orbits than `G_0` (this is suggested in [1], p.83). Behavior is changed
by the ``randomized`` flag.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(10)
&gt;&gt;&gt; D.is_primitive()
False

See Also
========

minimal_block, random_stab</pre> 
</div>
</div>
<a id="a1cb4cfcd0e2b6a91ffcad895823b0ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb4cfcd0e2b6a91ffcad895823b0ade">&#9670;&nbsp;</a></span>is_solvable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_solvable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is solvable.

``G`` is solvable if its derived series terminates with the trivial
group ([1], p.29).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; S = SymmetricGroup(3)
&gt;&gt;&gt; S.is_solvable
True

See Also
========

is_nilpotent, derived_series</pre> 
</div>
</div>
<a id="a1cb4cfcd0e2b6a91ffcad895823b0ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb4cfcd0e2b6a91ffcad895823b0ade">&#9670;&nbsp;</a></span>is_solvable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_solvable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is solvable.

``G`` is solvable if its derived series terminates with the trivial
group ([1], p.29).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; S = SymmetricGroup(3)
&gt;&gt;&gt; S.is_solvable
True

See Also
========

is_nilpotent, derived_series</pre> 
</div>
</div>
<a id="a0c18fbaf345a33ee70e9c4f67496bb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c18fbaf345a33ee70e9c4f67496bb2e">&#9670;&nbsp;</a></span>is_subgroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_subgroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if all elements of ``self`` belong to ``G``.

If ``strict`` is ``False`` then if ``self``'s degree is smaller
than ``G``'s, the elements will be resized to have the same degree.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics import SymmetricGroup, CyclicGroup

Testing is strict by default: the degree of each group must be the
same:

&gt;&gt;&gt; p = Permutation(0, 1, 2, 3, 4, 5)
&gt;&gt;&gt; G1 = PermutationGroup([Permutation(0, 1, 2), Permutation(0, 1)])
&gt;&gt;&gt; G2 = PermutationGroup([Permutation(0, 2), Permutation(0, 1, 2)])
&gt;&gt;&gt; G3 = PermutationGroup([p, p**2])
&gt;&gt;&gt; assert G1.order() == G2.order() == G3.order() == 6
&gt;&gt;&gt; G1.is_subgroup(G2)
True
&gt;&gt;&gt; G1.is_subgroup(G3)
False
&gt;&gt;&gt; G3.is_subgroup(PermutationGroup(G3[1]))
False
&gt;&gt;&gt; G3.is_subgroup(PermutationGroup(G3[0]))
True

To ignore the size, set ``strict`` to ``False``:

&gt;&gt;&gt; S3 = SymmetricGroup(3)
&gt;&gt;&gt; S5 = SymmetricGroup(5)
&gt;&gt;&gt; S3.is_subgroup(S5, strict=False)
True
&gt;&gt;&gt; C7 = CyclicGroup(7)
&gt;&gt;&gt; G = S5*C7
&gt;&gt;&gt; S5.is_subgroup(G, False)
True
&gt;&gt;&gt; C7.is_subgroup(G, 0)
False</pre> 
</div>
</div>
<a id="a0c18fbaf345a33ee70e9c4f67496bb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c18fbaf345a33ee70e9c4f67496bb2e">&#9670;&nbsp;</a></span>is_subgroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_subgroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if all elements of ``self`` belong to ``G``.

If ``strict`` is ``False`` then if ``self``'s degree is smaller
than ``G``'s, the elements will be resized to have the same degree.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics import SymmetricGroup, CyclicGroup

Testing is strict by default: the degree of each group must be the
same:

&gt;&gt;&gt; p = Permutation(0, 1, 2, 3, 4, 5)
&gt;&gt;&gt; G1 = PermutationGroup([Permutation(0, 1, 2), Permutation(0, 1)])
&gt;&gt;&gt; G2 = PermutationGroup([Permutation(0, 2), Permutation(0, 1, 2)])
&gt;&gt;&gt; G3 = PermutationGroup([p, p**2])
&gt;&gt;&gt; assert G1.order() == G2.order() == G3.order() == 6
&gt;&gt;&gt; G1.is_subgroup(G2)
True
&gt;&gt;&gt; G1.is_subgroup(G3)
False
&gt;&gt;&gt; G3.is_subgroup(PermutationGroup(G3[1]))
False
&gt;&gt;&gt; G3.is_subgroup(PermutationGroup(G3[0]))
True

To ignore the size, set ``strict`` to ``False``:

&gt;&gt;&gt; S3 = SymmetricGroup(3)
&gt;&gt;&gt; S5 = SymmetricGroup(5)
&gt;&gt;&gt; S3.is_subgroup(S5, strict=False)
True
&gt;&gt;&gt; C7 = CyclicGroup(7)
&gt;&gt;&gt; G = S5*C7
&gt;&gt;&gt; S5.is_subgroup(G, False)
True
&gt;&gt;&gt; C7.is_subgroup(G, 0)
False</pre> 
</div>
</div>
<a id="a547e87e4cd7a0da5d6f326b58090141c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547e87e4cd7a0da5d6f326b58090141c">&#9670;&nbsp;</a></span>is_symmetric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_symmetric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is symmetric.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import SymmetricGroup
&gt;&gt;&gt; g = SymmetricGroup(5)
&gt;&gt;&gt; g.is_symmetric
True

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; g = PermutationGroup(
...     Permutation(0, 1, 2, 3, 4),
...     Permutation(2, 3))
&gt;&gt;&gt; g.is_symmetric
True

Notes
=====

This uses a naive test involving the computation of the full
group order.
If you need more quicker taxonomy for large groups, you can use
:meth:`PermutationGroup.is_alt_sym`.
However, :meth:`PermutationGroup.is_alt_sym` may not be accurate
and is not able to distinguish between an alternating group and
a symmetric group.

See Also
========

is_alt_sym
</pre> 
</div>
</div>
<a id="a547e87e4cd7a0da5d6f326b58090141c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547e87e4cd7a0da5d6f326b58090141c">&#9670;&nbsp;</a></span>is_symmetric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_symmetric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the group is symmetric.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import SymmetricGroup
&gt;&gt;&gt; g = SymmetricGroup(5)
&gt;&gt;&gt; g.is_symmetric
True

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; g = PermutationGroup(
...     Permutation(0, 1, 2, 3, 4),
...     Permutation(2, 3))
&gt;&gt;&gt; g.is_symmetric
True

Notes
=====

This uses a naive test involving the computation of the full
group order.
If you need more quicker taxonomy for large groups, you can use
:meth:`PermutationGroup.is_alt_sym`.
However, :meth:`PermutationGroup.is_alt_sym` may not be accurate
and is not able to distinguish between an alternating group and
a symmetric group.

See Also
========

is_alt_sym
</pre> 
</div>
</div>
<a id="a90dcb1e94d17f08834d7b40323f36d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dcb1e94d17f08834d7b40323f36d4b">&#9670;&nbsp;</a></span>is_transitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_transitive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is transitive.

Explanation
===========

A group is transitive if it has a single orbit.

If ``strict`` is ``False`` the group is transitive if it has
a single orbit of length different from 1.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([2, 0, 1, 3])
&gt;&gt;&gt; G1 = PermutationGroup([a, b])
&gt;&gt;&gt; G1.is_transitive()
False
&gt;&gt;&gt; G1.is_transitive(strict=False)
True
&gt;&gt;&gt; c = Permutation([2, 3, 0, 1])
&gt;&gt;&gt; G2 = PermutationGroup([a, c])
&gt;&gt;&gt; G2.is_transitive()
True
&gt;&gt;&gt; d = Permutation([1, 0, 2, 3])
&gt;&gt;&gt; e = Permutation([0, 1, 3, 2])
&gt;&gt;&gt; G3 = PermutationGroup([d, e])
&gt;&gt;&gt; G3.is_transitive() or G3.is_transitive(strict=False)
False</pre> 
</div>
</div>
<a id="a90dcb1e94d17f08834d7b40323f36d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dcb1e94d17f08834d7b40323f36d4b">&#9670;&nbsp;</a></span>is_transitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_transitive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is transitive.

Explanation
===========

A group is transitive if it has a single orbit.

If ``strict`` is ``False`` the group is transitive if it has
a single orbit of length different from 1.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1, 3])
&gt;&gt;&gt; b = Permutation([2, 0, 1, 3])
&gt;&gt;&gt; G1 = PermutationGroup([a, b])
&gt;&gt;&gt; G1.is_transitive()
False
&gt;&gt;&gt; G1.is_transitive(strict=False)
True
&gt;&gt;&gt; c = Permutation([2, 3, 0, 1])
&gt;&gt;&gt; G2 = PermutationGroup([a, c])
&gt;&gt;&gt; G2.is_transitive()
True
&gt;&gt;&gt; d = Permutation([1, 0, 2, 3])
&gt;&gt;&gt; e = Permutation([0, 1, 3, 2])
&gt;&gt;&gt; G3 = PermutationGroup([d, e])
&gt;&gt;&gt; G3.is_transitive() or G3.is_transitive(strict=False)
False</pre> 
</div>
</div>
<a id="a6993aff9524bfdc43a8e4949b5915231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6993aff9524bfdc43a8e4949b5915231">&#9670;&nbsp;</a></span>is_trivial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_trivial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is the trivial group.

This is true if the group contains only the identity permutation.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; G = PermutationGroup([Permutation([0, 1, 2])])
&gt;&gt;&gt; G.is_trivial
True</pre> 
</div>
</div>
<a id="a6993aff9524bfdc43a8e4949b5915231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6993aff9524bfdc43a8e4949b5915231">&#9670;&nbsp;</a></span>is_trivial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.is_trivial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test if the group is the trivial group.

This is true if the group contains only the identity permutation.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; G = PermutationGroup([Permutation([0, 1, 2])])
&gt;&gt;&gt; G.is_trivial
True</pre> 
</div>
</div>
<a id="a2379ca9d76560e0135f601e68af3f88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2379ca9d76560e0135f601e68af3f88e">&#9670;&nbsp;</a></span>lower_central_series() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.lower_central_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the lower central series for the group.

The lower central series for a group `G` is the series
`G = G_0 &gt; G_1 &gt; G_2 &gt; \ldots` where
`G_k = [G, G_{k-1}]`, i.e. every term after the first is equal to the
commutator of `G` and the previous term in `G1` ([1], p.29).

Returns
=======

A list of permutation groups in the order `G = G_0, G_1, G_2, \ldots`

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (AlternatingGroup,
... DihedralGroup)
&gt;&gt;&gt; A = AlternatingGroup(4)
&gt;&gt;&gt; len(A.lower_central_series())
2
&gt;&gt;&gt; A.lower_central_series()[1].is_subgroup(DihedralGroup(2))
True

See Also
========

commutator, derived_series</pre> 
</div>
</div>
<a id="a2379ca9d76560e0135f601e68af3f88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2379ca9d76560e0135f601e68af3f88e">&#9670;&nbsp;</a></span>lower_central_series() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.lower_central_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the lower central series for the group.

The lower central series for a group `G` is the series
`G = G_0 &gt; G_1 &gt; G_2 &gt; \ldots` where
`G_k = [G, G_{k-1}]`, i.e. every term after the first is equal to the
commutator of `G` and the previous term in `G1` ([1], p.29).

Returns
=======

A list of permutation groups in the order `G = G_0, G_1, G_2, \ldots`

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (AlternatingGroup,
... DihedralGroup)
&gt;&gt;&gt; A = AlternatingGroup(4)
&gt;&gt;&gt; len(A.lower_central_series())
2
&gt;&gt;&gt; A.lower_central_series()[1].is_subgroup(DihedralGroup(2))
True

See Also
========

commutator, derived_series</pre> 
</div>
</div>
<a id="a68fbc74df7792666e509a0e352c0d912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fbc74df7792666e509a0e352c0d912">&#9670;&nbsp;</a></span>make_perm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.make_perm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multiply ``n`` randomly selected permutations from
pgroup together, starting with the identity
permutation. If ``n`` is a list of integers, those
integers will be used to select the permutations and they
will be applied in L to R order: make_perm((A, B, C)) will
give CBA(I) where I is the identity permutation.

``seed`` is used to set the seed for the random selection
of permutations from pgroup. If this is a list of integers,
the corresponding permutations from pgroup will be selected
in the order give. This is mainly used for testing purposes.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a, b = [Permutation([1, 0, 3, 2]), Permutation([1, 3, 0, 2])]
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.make_perm(1, [0])
(0 1)(2 3)
&gt;&gt;&gt; G.make_perm(3, [0, 1, 0])
(0 2 3 1)
&gt;&gt;&gt; G.make_perm([0, 1, 0])
(0 2 3 1)

See Also
========

random
</pre> 
</div>
</div>
<a id="a68fbc74df7792666e509a0e352c0d912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fbc74df7792666e509a0e352c0d912">&#9670;&nbsp;</a></span>make_perm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.make_perm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multiply ``n`` randomly selected permutations from
pgroup together, starting with the identity
permutation. If ``n`` is a list of integers, those
integers will be used to select the permutations and they
will be applied in L to R order: make_perm((A, B, C)) will
give CBA(I) where I is the identity permutation.

``seed`` is used to set the seed for the random selection
of permutations from pgroup. If this is a list of integers,
the corresponding permutations from pgroup will be selected
in the order give. This is mainly used for testing purposes.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a, b = [Permutation([1, 0, 3, 2]), Permutation([1, 3, 0, 2])]
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.make_perm(1, [0])
(0 1)(2 3)
&gt;&gt;&gt; G.make_perm(3, [0, 1, 0])
(0 2 3 1)
&gt;&gt;&gt; G.make_perm([0, 1, 0])
(0 2 3 1)

See Also
========

random
</pre> 
</div>
</div>
<a id="ab7f36da80262829f87bad2c3a695e882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f36da80262829f87bad2c3a695e882">&#9670;&nbsp;</a></span>max_div() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.max_div </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Maximum proper divisor of the degree of a permutation group.

Explanation
===========

Obviously, this is the degree divided by its minimal proper divisor
(larger than ``1``, if one exists). As it is guaranteed to be prime,
the ``sieve`` from ``sympy.ntheory`` is used.
This function is also used as an optimization tool for the functions
``minimal_block`` and ``_union_find_merge``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; G = PermutationGroup([Permutation([0, 2, 1, 3])])
&gt;&gt;&gt; G.max_div
2

See Also
========

minimal_block, _union_find_merge</pre> 
</div>
</div>
<a id="ab7f36da80262829f87bad2c3a695e882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f36da80262829f87bad2c3a695e882">&#9670;&nbsp;</a></span>max_div() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.max_div </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Maximum proper divisor of the degree of a permutation group.

Explanation
===========

Obviously, this is the degree divided by its minimal proper divisor
(larger than ``1``, if one exists). As it is guaranteed to be prime,
the ``sieve`` from ``sympy.ntheory`` is used.
This function is also used as an optimization tool for the functions
``minimal_block`` and ``_union_find_merge``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; G = PermutationGroup([Permutation([0, 2, 1, 3])])
&gt;&gt;&gt; G.max_div
2

See Also
========

minimal_block, _union_find_merge</pre> 
</div>
</div>
<a id="a169d33347199ac473b0ac402b3b0ac43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169d33347199ac473b0ac402b3b0ac43">&#9670;&nbsp;</a></span>minimal_block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.minimal_block </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a transitive group, finds the block system generated by
``points``.

Explanation
===========

If a group ``G`` acts on a set ``S``, a nonempty subset ``B`` of ``S``
is called a block under the action of ``G`` if for all ``g`` in ``G``
we have ``gB = B`` (``g`` fixes ``B``) or ``gB`` and ``B`` have no
common points (``g`` moves ``B`` entirely). ([1], p.23; [6]).

The distinct translates ``gB`` of a block ``B`` for ``g`` in ``G``
partition the set ``S`` and this set of translates is known as a block
system. Moreover, we obviously have that all blocks in the partition
have the same size, hence the block size divides ``|S|`` ([1], p.23).
A ``G``-congruence is an equivalence relation ``~`` on the set ``S``
such that ``a ~ b`` implies ``g(a) ~ g(b)`` for all ``g`` in ``G``.
For a transitive group, the equivalence classes of a ``G``-congruence
and the blocks of a block system are the same thing ([1], p.23).

The algorithm below checks the group for transitivity, and then finds
the ``G``-congruence generated by the pairs ``(p_0, p_1), (p_0, p_2),
..., (p_0,p_{k-1})`` which is the same as finding the maximal block
system (i.e., the one with minimum block size) such that
``p_0, ..., p_{k-1}`` are in the same block ([1], p.83).

It is an implementation of Atkinson's algorithm, as suggested in [1],
and manipulates an equivalence relation on the set ``S`` using a
union-find data structure. The running time is just above
`O(|points||S|)`. ([1], pp. 83-87; [7]).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(10)
&gt;&gt;&gt; D.minimal_block([0, 5])
[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
&gt;&gt;&gt; D.minimal_block([0, 1])
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

See Also
========

_union_find_rep, _union_find_merge, is_transitive, is_primitive</pre> 
</div>
</div>
<a id="a169d33347199ac473b0ac402b3b0ac43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169d33347199ac473b0ac402b3b0ac43">&#9670;&nbsp;</a></span>minimal_block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.minimal_block </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a transitive group, finds the block system generated by
``points``.

Explanation
===========

If a group ``G`` acts on a set ``S``, a nonempty subset ``B`` of ``S``
is called a block under the action of ``G`` if for all ``g`` in ``G``
we have ``gB = B`` (``g`` fixes ``B``) or ``gB`` and ``B`` have no
common points (``g`` moves ``B`` entirely). ([1], p.23; [6]).

The distinct translates ``gB`` of a block ``B`` for ``g`` in ``G``
partition the set ``S`` and this set of translates is known as a block
system. Moreover, we obviously have that all blocks in the partition
have the same size, hence the block size divides ``|S|`` ([1], p.23).
A ``G``-congruence is an equivalence relation ``~`` on the set ``S``
such that ``a ~ b`` implies ``g(a) ~ g(b)`` for all ``g`` in ``G``.
For a transitive group, the equivalence classes of a ``G``-congruence
and the blocks of a block system are the same thing ([1], p.23).

The algorithm below checks the group for transitivity, and then finds
the ``G``-congruence generated by the pairs ``(p_0, p_1), (p_0, p_2),
..., (p_0,p_{k-1})`` which is the same as finding the maximal block
system (i.e., the one with minimum block size) such that
``p_0, ..., p_{k-1}`` are in the same block ([1], p.83).

It is an implementation of Atkinson's algorithm, as suggested in [1],
and manipulates an equivalence relation on the set ``S`` using a
union-find data structure. The running time is just above
`O(|points||S|)`. ([1], pp. 83-87; [7]).

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(10)
&gt;&gt;&gt; D.minimal_block([0, 5])
[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
&gt;&gt;&gt; D.minimal_block([0, 1])
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

See Also
========

_union_find_rep, _union_find_merge, is_transitive, is_primitive</pre> 
</div>
</div>
<a id="a2e65d45c135d454fbe32493757d1f3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e65d45c135d454fbe32493757d1f3ee">&#9670;&nbsp;</a></span>minimal_blocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.minimal_blocks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>randomized</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a transitive group, return the list of all minimal
block systems. If a group is intransitive, return `False`.

Examples
========
&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; DihedralGroup(6).minimal_blocks()
[[0, 1, 0, 1, 0, 1], [0, 1, 2, 0, 1, 2]]
&gt;&gt;&gt; G = PermutationGroup(Permutation(1,2,5))
&gt;&gt;&gt; G.minimal_blocks()
False

See Also
========

minimal_block, is_transitive, is_primitive</pre> 
</div>
</div>
<a id="a2e65d45c135d454fbe32493757d1f3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e65d45c135d454fbe32493757d1f3ee">&#9670;&nbsp;</a></span>minimal_blocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.minimal_blocks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>randomized</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a transitive group, return the list of all minimal
block systems. If a group is intransitive, return `False`.

Examples
========
&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; DihedralGroup(6).minimal_blocks()
[[0, 1, 0, 1, 0, 1], [0, 1, 2, 0, 1, 2]]
&gt;&gt;&gt; G = PermutationGroup(Permutation(1,2,5))
&gt;&gt;&gt; G.minimal_blocks()
False

See Also
========

minimal_block, is_transitive, is_primitive</pre> 
</div>
</div>
<a id="afff7c38e8e29c220cd77270339a10381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff7c38e8e29c220cd77270339a10381">&#9670;&nbsp;</a></span>normal_closure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.normal_closure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the normal closure of a subgroup/set of permutations.

Explanation
===========

If ``S`` is a subset of a group ``G``, the normal closure of ``A`` in ``G``
is defined as the intersection of all normal subgroups of ``G`` that
contain ``A`` ([1], p.14). Alternatively, it is the group generated by
the conjugates ``x^{-1}yx`` for ``x`` a generator of ``G`` and ``y`` a
generator of the subgroup ``\left\langle S\right\rangle`` generated by
``S`` (for some chosen generating set for ``\left\langle S\right\rangle``)
([1], p.73).

Parameters
==========

other
    a subgroup/list of permutations/single permutation
k
    an implementation-specific parameter that determines the number
    of conjugates that are adjoined to ``other`` at once

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... CyclicGroup, AlternatingGroup)
&gt;&gt;&gt; S = SymmetricGroup(5)
&gt;&gt;&gt; C = CyclicGroup(5)
&gt;&gt;&gt; G = S.normal_closure(C)
&gt;&gt;&gt; G.order()
60
&gt;&gt;&gt; G.is_subgroup(AlternatingGroup(5))
True

See Also
========

commutator, derived_subgroup, random_pr

Notes
=====

The algorithm is described in [1], pp. 73-74; it makes use of the
generation of random elements for permutation groups by the product
replacement algorithm.</pre> 
</div>
</div>
<a id="afff7c38e8e29c220cd77270339a10381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff7c38e8e29c220cd77270339a10381">&#9670;&nbsp;</a></span>normal_closure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.normal_closure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the normal closure of a subgroup/set of permutations.

Explanation
===========

If ``S`` is a subset of a group ``G``, the normal closure of ``A`` in ``G``
is defined as the intersection of all normal subgroups of ``G`` that
contain ``A`` ([1], p.14). Alternatively, it is the group generated by
the conjugates ``x^{-1}yx`` for ``x`` a generator of ``G`` and ``y`` a
generator of the subgroup ``\left\langle S\right\rangle`` generated by
``S`` (for some chosen generating set for ``\left\langle S\right\rangle``)
([1], p.73).

Parameters
==========

other
    a subgroup/list of permutations/single permutation
k
    an implementation-specific parameter that determines the number
    of conjugates that are adjoined to ``other`` at once

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... CyclicGroup, AlternatingGroup)
&gt;&gt;&gt; S = SymmetricGroup(5)
&gt;&gt;&gt; C = CyclicGroup(5)
&gt;&gt;&gt; G = S.normal_closure(C)
&gt;&gt;&gt; G.order()
60
&gt;&gt;&gt; G.is_subgroup(AlternatingGroup(5))
True

See Also
========

commutator, derived_subgroup, random_pr

Notes
=====

The algorithm is described in [1], pp. 73-74; it makes use of the
generation of random elements for permutation groups by the product
replacement algorithm.</pre> 
</div>
</div>
<a id="a460f8946cdf683163d59c7072ee3d29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460f8946cdf683163d59c7072ee3d29e">&#9670;&nbsp;</a></span>orbit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.orbit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>action</em> = <code>'tuples'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the orbit of alpha `\{g(\alpha) | g \in G\}` as a set.

Explanation
===========

The time complexity of the algorithm used here is `O(|Orb|*r)` where
`|Orb|` is the size of the orbit and ``r`` is the number of generators of
the group. For a more detailed analysis, see [1], p.78, [2], pp. 19-21.
Here alpha can be a single point, or a list of points.

If alpha is a single point, the ordinary orbit is computed.
if alpha is a list of points, there are three available options:

'union' - computes the union of the orbits of the points in the list
'tuples' - computes the orbit of the list interpreted as an ordered
tuple under the group action ( i.e., g((1,2,3)) = (g(1), g(2), g(3)) )
'sets' - computes the orbit of the list interpreted as a sets

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 2, 0, 4, 5, 6, 3])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.orbit(0)
{0, 1, 2}
&gt;&gt;&gt; G.orbit([0, 4], 'union')
{0, 1, 2, 3, 4, 5, 6}

See Also
========

orbit_transversal</pre> 
</div>
</div>
<a id="a460f8946cdf683163d59c7072ee3d29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460f8946cdf683163d59c7072ee3d29e">&#9670;&nbsp;</a></span>orbit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.orbit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>action</em> = <code>'tuples'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the orbit of alpha `\{g(\alpha) | g \in G\}` as a set.

Explanation
===========

The time complexity of the algorithm used here is `O(|Orb|*r)` where
`|Orb|` is the size of the orbit and ``r`` is the number of generators of
the group. For a more detailed analysis, see [1], p.78, [2], pp. 19-21.
Here alpha can be a single point, or a list of points.

If alpha is a single point, the ordinary orbit is computed.
if alpha is a list of points, there are three available options:

'union' - computes the union of the orbits of the points in the list
'tuples' - computes the orbit of the list interpreted as an ordered
tuple under the group action ( i.e., g((1,2,3)) = (g(1), g(2), g(3)) )
'sets' - computes the orbit of the list interpreted as a sets

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 2, 0, 4, 5, 6, 3])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.orbit(0)
{0, 1, 2}
&gt;&gt;&gt; G.orbit([0, 4], 'union')
{0, 1, 2, 3, 4, 5, 6}

See Also
========

orbit_transversal</pre> 
</div>
</div>
<a id="af9bcbd4af19aa06fd3d7b39a8001152e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bcbd4af19aa06fd3d7b39a8001152e">&#9670;&nbsp;</a></span>orbit_rep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.orbit_rep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>schreier_vector</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a group element which sends ``alpha`` to ``beta``.

Explanation
===========

If ``beta`` is not in the orbit of ``alpha``, the function returns
``False``. This implementation makes use of the schreier vector.
For a proof of correctness, see [1], p.80

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup
&gt;&gt;&gt; G = AlternatingGroup(5)
&gt;&gt;&gt; G.orbit_rep(0, 4)
(0 4 1 2 3)

See Also
========

schreier_vector</pre> 
</div>
</div>
<a id="af9bcbd4af19aa06fd3d7b39a8001152e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bcbd4af19aa06fd3d7b39a8001152e">&#9670;&nbsp;</a></span>orbit_rep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.orbit_rep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>schreier_vector</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a group element which sends ``alpha`` to ``beta``.

Explanation
===========

If ``beta`` is not in the orbit of ``alpha``, the function returns
``False``. This implementation makes use of the schreier vector.
For a proof of correctness, see [1], p.80

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup
&gt;&gt;&gt; G = AlternatingGroup(5)
&gt;&gt;&gt; G.orbit_rep(0, 4)
(0 4 1 2 3)

See Also
========

schreier_vector</pre> 
</div>
</div>
<a id="a0b16152823083ed1567e6a429d41b791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b16152823083ed1567e6a429d41b791">&#9670;&nbsp;</a></span>orbit_transversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.orbit_transversal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pairs</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a transversal for the orbit of ``alpha`` as a set.

Explanation
===========

For a permutation group `G`, a transversal for the orbit
`Orb = \{g(\alpha) | g \in G\}` is a set
`\{g_\beta | g_\beta(\alpha) = \beta\}` for `\beta \in Orb`.
Note that there may be more than one possible transversal.
If ``pairs`` is set to ``True``, it returns the list of pairs
`(\beta, g_\beta)`. For a proof of correctness, see [1], p.79

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; G = DihedralGroup(6)
&gt;&gt;&gt; G.orbit_transversal(0)
[(5), (0 1 2 3 4 5), (0 5)(1 4)(2 3), (0 2 4)(1 3 5), (5)(0 4)(1 3), (0 3)(1 4)(2 5)]

See Also
========

orbit</pre> 
</div>
</div>
<a id="a0b16152823083ed1567e6a429d41b791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b16152823083ed1567e6a429d41b791">&#9670;&nbsp;</a></span>orbit_transversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.orbit_transversal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pairs</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a transversal for the orbit of ``alpha`` as a set.

Explanation
===========

For a permutation group `G`, a transversal for the orbit
`Orb = \{g(\alpha) | g \in G\}` is a set
`\{g_\beta | g_\beta(\alpha) = \beta\}` for `\beta \in Orb`.
Note that there may be more than one possible transversal.
If ``pairs`` is set to ``True``, it returns the list of pairs
`(\beta, g_\beta)`. For a proof of correctness, see [1], p.79

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; G = DihedralGroup(6)
&gt;&gt;&gt; G.orbit_transversal(0)
[(5), (0 1 2 3 4 5), (0 5)(1 4)(2 3), (0 2 4)(1 3 5), (5)(0 4)(1 3), (0 3)(1 4)(2 5)]

See Also
========

orbit</pre> 
</div>
</div>
<a id="aadc238571a25fd13082c6d46091020ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc238571a25fd13082c6d46091020ef">&#9670;&nbsp;</a></span>orbits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.orbits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rep</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the orbits of ``self``, ordered according to lowest element
in each orbit.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(1, 5)(2, 3)(4, 0, 6)
&gt;&gt;&gt; b = Permutation(1, 5)(3, 4)(2, 6, 0)
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.orbits()
[{0, 2, 3, 4, 6}, {1, 5}]
</pre> 
</div>
</div>
<a id="aadc238571a25fd13082c6d46091020ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc238571a25fd13082c6d46091020ef">&#9670;&nbsp;</a></span>orbits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.orbits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rep</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the orbits of ``self``, ordered according to lowest element
in each orbit.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation(1, 5)(2, 3)(4, 0, 6)
&gt;&gt;&gt; b = Permutation(1, 5)(3, 4)(2, 6, 0)
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.orbits()
[{0, 2, 3, 4, 6}, {1, 5}]
</pre> 
</div>
</div>
<a id="aa4c13a15c002cd1300b1c80328aa9295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c13a15c002cd1300b1c80328aa9295">&#9670;&nbsp;</a></span>order() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the order of the group: the number of permutations that
can be generated from elements of the group.

The number of permutations comprising the group is given by
``len(group)``; the length of each permutation in the group is
given by ``group.size``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup

&gt;&gt;&gt; a = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.degree
3
&gt;&gt;&gt; len(G)
1
&gt;&gt;&gt; G.order()
2
&gt;&gt;&gt; list(G.generate())
[(2), (2)(0 1)]

&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.order()
6

See Also
========

degree</pre> 
</div>
</div>
<a id="aa4c13a15c002cd1300b1c80328aa9295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c13a15c002cd1300b1c80328aa9295">&#9670;&nbsp;</a></span>order() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the order of the group: the number of permutations that
can be generated from elements of the group.

The number of permutations comprising the group is given by
``len(group)``; the length of each permutation in the group is
given by ``group.size``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup

&gt;&gt;&gt; a = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a])
&gt;&gt;&gt; G.degree
3
&gt;&gt;&gt; len(G)
1
&gt;&gt;&gt; G.order()
2
&gt;&gt;&gt; list(G.generate())
[(2), (2)(0 1)]

&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.order()
6

See Also
========

degree</pre> 
</div>
</div>
<a id="ae72db2b8d8d1a352cc9c1243b0ba4fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72db2b8d8d1a352cc9c1243b0ba4fc0">&#9670;&nbsp;</a></span>pointwise_stabilizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.pointwise_stabilizer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>incremental</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the pointwise stabilizer for a set of points.

Explanation
===========

For a permutation group `G` and a set of points
`\{p_1, p_2,\ldots, p_k\}`, the pointwise stabilizer of
`p_1, p_2, \ldots, p_k` is defined as
`G_{p_1,\ldots, p_k} =
\{g\in G | g(p_i) = p_i \forall i\in\{1, 2,\ldots,k\}\}` ([1],p20).
It is a subgroup of `G`.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; S = SymmetricGroup(7)
&gt;&gt;&gt; Stab = S.pointwise_stabilizer([2, 3, 5])
&gt;&gt;&gt; Stab.is_subgroup(S.stabilizer(2).stabilizer(3).stabilizer(5))
True

See Also
========

stabilizer, schreier_sims_incremental

Notes
=====

When incremental == True,
rather than the obvious implementation using successive calls to
``.stabilizer()``, this uses the incremental Schreier-Sims algorithm
to obtain a base with starting segment - the given points.</pre> 
</div>
</div>
<a id="ae72db2b8d8d1a352cc9c1243b0ba4fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72db2b8d8d1a352cc9c1243b0ba4fc0">&#9670;&nbsp;</a></span>pointwise_stabilizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.pointwise_stabilizer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>incremental</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the pointwise stabilizer for a set of points.

Explanation
===========

For a permutation group `G` and a set of points
`\{p_1, p_2,\ldots, p_k\}`, the pointwise stabilizer of
`p_1, p_2, \ldots, p_k` is defined as
`G_{p_1,\ldots, p_k} =
\{g\in G | g(p_i) = p_i \forall i\in\{1, 2,\ldots,k\}\}` ([1],p20).
It is a subgroup of `G`.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; S = SymmetricGroup(7)
&gt;&gt;&gt; Stab = S.pointwise_stabilizer([2, 3, 5])
&gt;&gt;&gt; Stab.is_subgroup(S.stabilizer(2).stabilizer(3).stabilizer(5))
True

See Also
========

stabilizer, schreier_sims_incremental

Notes
=====

When incremental == True,
rather than the obvious implementation using successive calls to
``.stabilizer()``, this uses the incremental Schreier-Sims algorithm
to obtain a base with starting segment - the given points.</pre> 
</div>
</div>
<a id="a772d2abb845ab6c72606666e67322bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772d2abb845ab6c72606666e67322bf4">&#9670;&nbsp;</a></span>polycyclic_group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.polycyclic_group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the PolycyclicGroup instance with below parameters:

Explanation
===========

* pc_sequence : Polycyclic sequence is formed by collecting all
  the missing generators between the adjacent groups in the
  derived series of given permutation group.

* pc_series : Polycyclic series is formed by adding all the missing
  generators of ``der[i+1]`` in ``der[i]``, where ``der`` represents
  the derived series.

* relative_order : A list, computed by the ratio of adjacent groups in
  pc_series.</pre> 
</div>
</div>
<a id="a772d2abb845ab6c72606666e67322bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772d2abb845ab6c72606666e67322bf4">&#9670;&nbsp;</a></span>polycyclic_group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.polycyclic_group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the PolycyclicGroup instance with below parameters:

Explanation
===========

* pc_sequence : Polycyclic sequence is formed by collecting all
  the missing generators between the adjacent groups in the
  derived series of given permutation group.

* pc_series : Polycyclic series is formed by adding all the missing
  generators of ``der[i+1]`` in ``der[i]``, where ``der`` represents
  the derived series.

* relative_order : A list, computed by the ratio of adjacent groups in
  pc_series.</pre> 
</div>
</div>
<a id="a18b047df87817392d91ac7e0c52fa4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b047df87817392d91ac7e0c52fa4c6">&#9670;&nbsp;</a></span>presentation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.presentation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eliminate_gens</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an `FpGroup` presentation of the group.

The algorithm is described in [1], Chapter 6.1.</pre> 
</div>
</div>
<a id="a18b047df87817392d91ac7e0c52fa4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b047df87817392d91ac7e0c52fa4c6">&#9670;&nbsp;</a></span>presentation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.presentation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eliminate_gens</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an `FpGroup` presentation of the group.

The algorithm is described in [1], Chapter 6.1.</pre> 
</div>
</div>
<a id="ad49a5e8efd11953b733a223ac3390a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49a5e8efd11953b733a223ac3390a00">&#9670;&nbsp;</a></span>random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.random </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a random group element
</pre> 
</div>
</div>
<a id="ad49a5e8efd11953b733a223ac3390a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49a5e8efd11953b733a223ac3390a00">&#9670;&nbsp;</a></span>random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.random </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>af</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a random group element
</pre> 
</div>
</div>
<a id="aec91e456ad70949d6efdc32db13c719b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec91e456ad70949d6efdc32db13c719b">&#9670;&nbsp;</a></span>random_pr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.random_pr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gen_count</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_random_prec</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a random group element using product replacement.

Explanation
===========

For the details of the product replacement algorithm, see
``_random_pr_init`` In ``random_pr`` the actual 'product replacement'
is performed. Notice that if the attribute ``_random_gens``
is empty, it needs to be initialized by ``_random_pr_init``.

See Also
========

_random_pr_init</pre> 
</div>
</div>
<a id="aec91e456ad70949d6efdc32db13c719b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec91e456ad70949d6efdc32db13c719b">&#9670;&nbsp;</a></span>random_pr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.random_pr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gen_count</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_random_prec</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a random group element using product replacement.

Explanation
===========

For the details of the product replacement algorithm, see
``_random_pr_init`` In ``random_pr`` the actual 'product replacement'
is performed. Notice that if the attribute ``_random_gens``
is empty, it needs to be initialized by ``_random_pr_init``.

See Also
========

_random_pr_init</pre> 
</div>
</div>
<a id="a8d35747d13633478618d900a2d03f48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d35747d13633478618d900a2d03f48b">&#9670;&nbsp;</a></span>random_stab() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.random_stab </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>schreier_vector</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_random_prec</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Random element from the stabilizer of ``alpha``.

The schreier vector for ``alpha`` is an optional argument used
for speeding up repeated calls. The algorithm is described in [1], p.81

See Also
========

random_pr, orbit_rep</pre> 
</div>
</div>
<a id="a8d35747d13633478618d900a2d03f48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d35747d13633478618d900a2d03f48b">&#9670;&nbsp;</a></span>random_stab() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.random_stab </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>schreier_vector</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_random_prec</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Random element from the stabilizer of ``alpha``.

The schreier vector for ``alpha`` is an optional argument used
for speeding up repeated calls. The algorithm is described in [1], p.81

See Also
========

random_pr, orbit_rep</pre> 
</div>
</div>
<a id="a0b7f034b7d590a0c2c6189abb28baf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7f034b7d590a0c2c6189abb28baf8c">&#9670;&nbsp;</a></span>schreier_sims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Schreier-Sims algorithm.

Explanation
===========

It computes the generators of the chain of stabilizers
`G &gt; G_{b_1} &gt; .. &gt; G_{b1,..,b_r} &gt; 1`
in which `G_{b_1,..,b_i}` stabilizes `b_1,..,b_i`,
and the corresponding ``s`` cosets.
An element of the group can be written as the product
`h_1*..*h_s`.

We use the incremental Schreier-Sims algorithm.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.schreier_sims()
&gt;&gt;&gt; G.basic_transversals
[{0: (2)(0 1), 1: (2), 2: (1 2)},
 {0: (2), 2: (0 2)}]
</pre> 
</div>
</div>
<a id="a0b7f034b7d590a0c2c6189abb28baf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7f034b7d590a0c2c6189abb28baf8c">&#9670;&nbsp;</a></span>schreier_sims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Schreier-Sims algorithm.

Explanation
===========

It computes the generators of the chain of stabilizers
`G &gt; G_{b_1} &gt; .. &gt; G_{b1,..,b_r} &gt; 1`
in which `G_{b_1,..,b_i}` stabilizes `b_1,..,b_i`,
and the corresponding ``s`` cosets.
An element of the group can be written as the product
`h_1*..*h_s`.

We use the incremental Schreier-Sims algorithm.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([0, 2, 1])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.schreier_sims()
&gt;&gt;&gt; G.basic_transversals
[{0: (2)(0 1), 1: (2), 2: (1 2)},
 {0: (2), 2: (0 2)}]
</pre> 
</div>
</div>
<a id="a0a74d41168516ae30d8cbbb83250a5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a74d41168516ae30d8cbbb83250a5a0">&#9670;&nbsp;</a></span>schreier_sims_incremental() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_incremental </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gens</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slp_dict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extend a sequence of points and generating set to a base and strong
generating set.

Parameters
==========

base
    The sequence of points to be extended to a base. Optional
    parameter with default value ``[]``.
gens
    The generating set to be extended to a strong generating set
    relative to the base obtained. Optional parameter with default
    value ``self.generators``.

slp_dict
    If `True`, return a dictionary `{g: gens}` for each strong
    generator `g` where `gens` is a list of strong generators
    coming before `g` in `strong_gens`, such that the product
    of the elements of `gens` is equal to `g`.

Returns
=======

(base, strong_gens)
    ``base`` is the base obtained, and ``strong_gens`` is the strong
    generating set relative to it. The original parameters ``base``,
    ``gens`` remain unchanged.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup
&gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs
&gt;&gt;&gt; A = AlternatingGroup(7)
&gt;&gt;&gt; base = [2, 3]
&gt;&gt;&gt; seq = [2, 3]
&gt;&gt;&gt; base, strong_gens = A.schreier_sims_incremental(base=seq)
&gt;&gt;&gt; _verify_bsgs(A, base, strong_gens)
True
&gt;&gt;&gt; base[:2]
[2, 3]

Notes
=====

This version of the Schreier-Sims algorithm runs in polynomial time.
There are certain assumptions in the implementation - if the trivial
group is provided, ``base`` and ``gens`` are returned immediately,
as any sequence of points is a base for the trivial group. If the
identity is present in the generators ``gens``, it is removed as
it is a redundant generator.
The implementation is described in [1], pp. 90-93.

See Also
========

schreier_sims, schreier_sims_random</pre> 
</div>
</div>
<a id="a0a74d41168516ae30d8cbbb83250a5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a74d41168516ae30d8cbbb83250a5a0">&#9670;&nbsp;</a></span>schreier_sims_incremental() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_incremental </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gens</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slp_dict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extend a sequence of points and generating set to a base and strong
generating set.

Parameters
==========

base
    The sequence of points to be extended to a base. Optional
    parameter with default value ``[]``.
gens
    The generating set to be extended to a strong generating set
    relative to the base obtained. Optional parameter with default
    value ``self.generators``.

slp_dict
    If `True`, return a dictionary `{g: gens}` for each strong
    generator `g` where `gens` is a list of strong generators
    coming before `g` in `strong_gens`, such that the product
    of the elements of `gens` is equal to `g`.

Returns
=======

(base, strong_gens)
    ``base`` is the base obtained, and ``strong_gens`` is the strong
    generating set relative to it. The original parameters ``base``,
    ``gens`` remain unchanged.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup
&gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs
&gt;&gt;&gt; A = AlternatingGroup(7)
&gt;&gt;&gt; base = [2, 3]
&gt;&gt;&gt; seq = [2, 3]
&gt;&gt;&gt; base, strong_gens = A.schreier_sims_incremental(base=seq)
&gt;&gt;&gt; _verify_bsgs(A, base, strong_gens)
True
&gt;&gt;&gt; base[:2]
[2, 3]

Notes
=====

This version of the Schreier-Sims algorithm runs in polynomial time.
There are certain assumptions in the implementation - if the trivial
group is provided, ``base`` and ``gens`` are returned immediately,
as any sequence of points is a base for the trivial group. If the
identity is present in the generators ``gens``, it is removed as
it is a redundant generator.
The implementation is described in [1], pp. 90-93.

See Also
========

schreier_sims, schreier_sims_random</pre> 
</div>
</div>
<a id="a4300fff1c31c164aebcd65aa7de0ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4300fff1c31c164aebcd65aa7de0ad9e">&#9670;&nbsp;</a></span>schreier_sims_random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_random </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gens</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>consec_succ</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_random_prec</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Randomized Schreier-Sims algorithm.

Explanation
===========

The randomized Schreier-Sims algorithm takes the sequence ``base``
and the generating set ``gens``, and extends ``base`` to a base, and
``gens`` to a strong generating set relative to that base with
probability of a wrong answer at most `2^{-consec\_succ}`,
provided the random generators are sufficiently random.

Parameters
==========

base
    The sequence to be extended to a base.
gens
    The generating set to be extended to a strong generating set.
consec_succ
    The parameter defining the probability of a wrong answer.
_random_prec
    An internal parameter used for testing purposes.

Returns
=======

(base, strong_gens)
    ``base`` is the base and ``strong_gens`` is the strong generating
    set relative to it.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs
&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; S = SymmetricGroup(5)
&gt;&gt;&gt; base, strong_gens = S.schreier_sims_random(consec_succ=5)
&gt;&gt;&gt; _verify_bsgs(S, base, strong_gens) #doctest: +SKIP
True

Notes
=====

The algorithm is described in detail in [1], pp. 97-98. It extends
the orbits ``orbs`` and the permutation groups ``stabs`` to
basic orbits and basic stabilizers for the base and strong generating
set produced in the end.
The idea of the extension process
is to "sift" random group elements through the stabilizer chain
and amend the stabilizers/orbits along the way when a sift
is not successful.
The helper function ``_strip`` is used to attempt
to decompose a random group element according to the current
state of the stabilizer chain and report whether the element was
fully decomposed (successful sift) or not (unsuccessful sift). In
the latter case, the level at which the sift failed is reported and
used to amend ``stabs``, ``base``, ``gens`` and ``orbs`` accordingly.
The halting condition is for ``consec_succ`` consecutive successful
sifts to pass. This makes sure that the current ``base`` and ``gens``
form a BSGS with probability at least `1 - 1/\text{consec\_succ}`.

See Also
========

schreier_sims</pre> 
</div>
</div>
<a id="a4300fff1c31c164aebcd65aa7de0ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4300fff1c31c164aebcd65aa7de0ad9e">&#9670;&nbsp;</a></span>schreier_sims_random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_random </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gens</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>consec_succ</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_random_prec</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Randomized Schreier-Sims algorithm.

Explanation
===========

The randomized Schreier-Sims algorithm takes the sequence ``base``
and the generating set ``gens``, and extends ``base`` to a base, and
``gens`` to a strong generating set relative to that base with
probability of a wrong answer at most `2^{-consec\_succ}`,
provided the random generators are sufficiently random.

Parameters
==========

base
    The sequence to be extended to a base.
gens
    The generating set to be extended to a strong generating set.
consec_succ
    The parameter defining the probability of a wrong answer.
_random_prec
    An internal parameter used for testing purposes.

Returns
=======

(base, strong_gens)
    ``base`` is the base and ``strong_gens`` is the strong generating
    set relative to it.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs
&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; S = SymmetricGroup(5)
&gt;&gt;&gt; base, strong_gens = S.schreier_sims_random(consec_succ=5)
&gt;&gt;&gt; _verify_bsgs(S, base, strong_gens) #doctest: +SKIP
True

Notes
=====

The algorithm is described in detail in [1], pp. 97-98. It extends
the orbits ``orbs`` and the permutation groups ``stabs`` to
basic orbits and basic stabilizers for the base and strong generating
set produced in the end.
The idea of the extension process
is to "sift" random group elements through the stabilizer chain
and amend the stabilizers/orbits along the way when a sift
is not successful.
The helper function ``_strip`` is used to attempt
to decompose a random group element according to the current
state of the stabilizer chain and report whether the element was
fully decomposed (successful sift) or not (unsuccessful sift). In
the latter case, the level at which the sift failed is reported and
used to amend ``stabs``, ``base``, ``gens`` and ``orbs`` accordingly.
The halting condition is for ``consec_succ`` consecutive successful
sifts to pass. This makes sure that the current ``base`` and ``gens``
form a BSGS with probability at least `1 - 1/\text{consec\_succ}`.

See Also
========

schreier_sims</pre> 
</div>
</div>
<a id="a2029b24877b1c045bd2908c4cade1014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2029b24877b1c045bd2908c4cade1014">&#9670;&nbsp;</a></span>schreier_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.schreier_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the schreier vector for ``alpha``.

Explanation
===========

The Schreier vector efficiently stores information
about the orbit of ``alpha``. It can later be used to quickly obtain
elements of the group that send ``alpha`` to a particular element
in the orbit. Notice that the Schreier vector depends on the order
in which the group generators are listed. For a definition, see [3].
Since list indices start from zero, we adopt the convention to use
"None" instead of 0 to signify that an element does not belong
to the orbit.
For the algorithm and its correctness, see [2], pp.78-80.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([2, 4, 6, 3, 1, 5, 0])
&gt;&gt;&gt; b = Permutation([0, 1, 3, 5, 4, 6, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.schreier_vector(0)
[-1, None, 0, 1, None, 1, 0]

See Also
========

orbit</pre> 
</div>
</div>
<a id="a2029b24877b1c045bd2908c4cade1014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2029b24877b1c045bd2908c4cade1014">&#9670;&nbsp;</a></span>schreier_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.schreier_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the schreier vector for ``alpha``.

Explanation
===========

The Schreier vector efficiently stores information
about the orbit of ``alpha``. It can later be used to quickly obtain
elements of the group that send ``alpha`` to a particular element
in the orbit. Notice that the Schreier vector depends on the order
in which the group generators are listed. For a definition, see [3].
Since list indices start from zero, we adopt the convention to use
"None" instead of 0 to signify that an element does not belong
to the orbit.
For the algorithm and its correctness, see [2], pp.78-80.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([2, 4, 6, 3, 1, 5, 0])
&gt;&gt;&gt; b = Permutation([0, 1, 3, 5, 4, 6, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.schreier_vector(0)
[-1, None, 0, 1, None, 1, 0]

See Also
========

orbit</pre> 
</div>
</div>
<a id="aed2c65f749705c1d6225f5cede73607a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2c65f749705c1d6225f5cede73607a">&#9670;&nbsp;</a></span>stabilizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.stabilizer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the stabilizer subgroup of ``alpha``.

Explanation
===========

The stabilizer of `\alpha` is the group `G_\alpha =
\{g \in G | g(\alpha) = \alpha\}`.
For a proof of correctness, see [1], p.79.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; G = DihedralGroup(6)
&gt;&gt;&gt; G.stabilizer(5)
PermutationGroup([
    (5)(0 4)(1 3)])

See Also
========

orbit</pre> 
</div>
</div>
<a id="aed2c65f749705c1d6225f5cede73607a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2c65f749705c1d6225f5cede73607a">&#9670;&nbsp;</a></span>stabilizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.stabilizer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the stabilizer subgroup of ``alpha``.

Explanation
===========

The stabilizer of `\alpha` is the group `G_\alpha =
\{g \in G | g(\alpha) = \alpha\}`.
For a proof of correctness, see [1], p.79.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; G = DihedralGroup(6)
&gt;&gt;&gt; G.stabilizer(5)
PermutationGroup([
    (5)(0 4)(1 3)])

See Also
========

orbit</pre> 
</div>
</div>
<a id="a9f013092f2523ad34848ea3286967c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f013092f2523ad34848ea3286967c2e">&#9670;&nbsp;</a></span>strong_gens() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.strong_gens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a strong generating set from the Schreier-Sims algorithm.

Explanation
===========

A generating set `S = \{g_1, g_2, \dots, g_t\}` for a permutation group
`G` is a strong generating set relative to the sequence of points
(referred to as a "base") `(b_1, b_2, \dots, b_k)` if, for
`1 \leq i \leq k` we have that the intersection of the pointwise
stabilizer `G^{(i+1)} := G_{b_1, b_2, \dots, b_i}` with `S` generates
the pointwise stabilizer `G^{(i+1)}`. The concepts of a base and
strong generating set and their applications are discussed in depth
in [1], pp. 87-89 and [2], pp. 55-57.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(4)
&gt;&gt;&gt; D.strong_gens
[(0 1 2 3), (0 3)(1 2), (1 3)]
&gt;&gt;&gt; D.base
[0, 1]

See Also
========

base, basic_transversals, basic_orbits, basic_stabilizers</pre> 
</div>
</div>
<a id="a9f013092f2523ad34848ea3286967c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f013092f2523ad34848ea3286967c2e">&#9670;&nbsp;</a></span>strong_gens() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.strong_gens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a strong generating set from the Schreier-Sims algorithm.

Explanation
===========

A generating set `S = \{g_1, g_2, \dots, g_t\}` for a permutation group
`G` is a strong generating set relative to the sequence of points
(referred to as a "base") `(b_1, b_2, \dots, b_k)` if, for
`1 \leq i \leq k` we have that the intersection of the pointwise
stabilizer `G^{(i+1)} := G_{b_1, b_2, \dots, b_i}` with `S` generates
the pointwise stabilizer `G^{(i+1)}`. The concepts of a base and
strong generating set and their applications are discussed in depth
in [1], pp. 87-89 and [2], pp. 55-57.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; D = DihedralGroup(4)
&gt;&gt;&gt; D.strong_gens
[(0 1 2 3), (0 3)(1 2), (1 3)]
&gt;&gt;&gt; D.base
[0, 1]

See Also
========

base, basic_transversals, basic_orbits, basic_stabilizers</pre> 
</div>
</div>
<a id="a66c8a9d6afdf7a904fbb740393bcfb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c8a9d6afdf7a904fbb740393bcfb81">&#9670;&nbsp;</a></span>strong_presentation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.strong_presentation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a strong finite presentation of group. The generators
of the returned group are in the same order as the strong
generators of group.

The algorithm is based on Sims' Verify algorithm described
in [1], Chapter 6.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; P = DihedralGroup(4)
&gt;&gt;&gt; G = P.strong_presentation()
&gt;&gt;&gt; P.order() == G.order()
True

See Also
========

presentation, _verify</pre> 
</div>
</div>
<a id="a66c8a9d6afdf7a904fbb740393bcfb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c8a9d6afdf7a904fbb740393bcfb81">&#9670;&nbsp;</a></span>strong_presentation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.strong_presentation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a strong finite presentation of group. The generators
of the returned group are in the same order as the strong
generators of group.

The algorithm is based on Sims' Verify algorithm described
in [1], Chapter 6.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; P = DihedralGroup(4)
&gt;&gt;&gt; G = P.strong_presentation()
&gt;&gt;&gt; P.order() == G.order()
True

See Also
========

presentation, _verify</pre> 
</div>
</div>
<a id="a410e5597d9b807557eb1e2f592ad9f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410e5597d9b807557eb1e2f592ad9f27">&#9670;&nbsp;</a></span>subgroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.subgroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">   Return the subgroup generated by `gens` which is a list of
   elements of the group
</pre> 
</div>
</div>
<a id="a410e5597d9b807557eb1e2f592ad9f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410e5597d9b807557eb1e2f592ad9f27">&#9670;&nbsp;</a></span>subgroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.subgroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">   Return the subgroup generated by `gens` which is a list of
   elements of the group
</pre> 
</div>
</div>
<a id="a01d83084c8aee9c5523cf088fb86a528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d83084c8aee9c5523cf088fb86a528">&#9670;&nbsp;</a></span>subgroup_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.subgroup_search </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strong_gens</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tests</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init_subgroup</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the subgroup of all elements satisfying the property ``prop``.

Explanation
===========

This is done by a depth-first search with respect to base images that
uses several tests to prune the search tree.

Parameters
==========

prop
    The property to be used. Has to be callable on group elements
    and always return ``True`` or ``False``. It is assumed that
    all group elements satisfying ``prop`` indeed form a subgroup.
base
    A base for the supergroup.
strong_gens
    A strong generating set for the supergroup.
tests
    A list of callables of length equal to the length of ``base``.
    These are used to rule out group elements by partial base images,
    so that ``tests[l](g)`` returns False if the element ``g`` is known
    not to satisfy prop base on where g sends the first ``l + 1`` base
    points.
init_subgroup
    if a subgroup of the sought group is
    known in advance, it can be passed to the function as this
    parameter.

Returns
=======

res
    The subgroup of all elements satisfying ``prop``. The generating
    set for this group is guaranteed to be a strong generating set
    relative to the base ``base``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... AlternatingGroup)
&gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs
&gt;&gt;&gt; S = SymmetricGroup(7)
&gt;&gt;&gt; prop_even = lambda x: x.is_even
&gt;&gt;&gt; base, strong_gens = S.schreier_sims_incremental()
&gt;&gt;&gt; G = S.subgroup_search(prop_even, base=base, strong_gens=strong_gens)
&gt;&gt;&gt; G.is_subgroup(AlternatingGroup(7))
True
&gt;&gt;&gt; _verify_bsgs(G, base, G.generators)
True

Notes
=====

This function is extremely lengthy and complicated and will require
some careful attention. The implementation is described in
[1], pp. 114-117, and the comments for the code here follow the lines
of the pseudocode in the book for clarity.

The complexity is exponential in general, since the search process by
itself visits all members of the supergroup. However, there are a lot
of tests which are used to prune the search tree, and users can define
their own tests via the ``tests`` parameter, so in practice, and for
some computations, it's not terrible.

A crucial part in the procedure is the frequent base change performed
(this is line 11 in the pseudocode) in order to obtain a new basic
stabilizer. The book mentiones that this can be done by using
``.baseswap(...)``, however the current implementation uses a more
straightforward way to find the next basic stabilizer - calling the
function ``.stabilizer(...)`` on the previous basic stabilizer.</pre> 
</div>
</div>
<a id="a01d83084c8aee9c5523cf088fb86a528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d83084c8aee9c5523cf088fb86a528">&#9670;&nbsp;</a></span>subgroup_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.subgroup_search </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strong_gens</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tests</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init_subgroup</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the subgroup of all elements satisfying the property ``prop``.

Explanation
===========

This is done by a depth-first search with respect to base images that
uses several tests to prune the search tree.

Parameters
==========

prop
    The property to be used. Has to be callable on group elements
    and always return ``True`` or ``False``. It is assumed that
    all group elements satisfying ``prop`` indeed form a subgroup.
base
    A base for the supergroup.
strong_gens
    A strong generating set for the supergroup.
tests
    A list of callables of length equal to the length of ``base``.
    These are used to rule out group elements by partial base images,
    so that ``tests[l](g)`` returns False if the element ``g`` is known
    not to satisfy prop base on where g sends the first ``l + 1`` base
    points.
init_subgroup
    if a subgroup of the sought group is
    known in advance, it can be passed to the function as this
    parameter.

Returns
=======

res
    The subgroup of all elements satisfying ``prop``. The generating
    set for this group is guaranteed to be a strong generating set
    relative to the base ``base``.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,
... AlternatingGroup)
&gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs
&gt;&gt;&gt; S = SymmetricGroup(7)
&gt;&gt;&gt; prop_even = lambda x: x.is_even
&gt;&gt;&gt; base, strong_gens = S.schreier_sims_incremental()
&gt;&gt;&gt; G = S.subgroup_search(prop_even, base=base, strong_gens=strong_gens)
&gt;&gt;&gt; G.is_subgroup(AlternatingGroup(7))
True
&gt;&gt;&gt; _verify_bsgs(G, base, G.generators)
True

Notes
=====

This function is extremely lengthy and complicated and will require
some careful attention. The implementation is described in
[1], pp. 114-117, and the comments for the code here follow the lines
of the pseudocode in the book for clarity.

The complexity is exponential in general, since the search process by
itself visits all members of the supergroup. However, there are a lot
of tests which are used to prune the search tree, and users can define
their own tests via the ``tests`` parameter, so in practice, and for
some computations, it's not terrible.

A crucial part in the procedure is the frequent base change performed
(this is line 11 in the pseudocode) in order to obtain a new basic
stabilizer. The book mentiones that this can be done by using
``.baseswap(...)``, however the current implementation uses a more
straightforward way to find the next basic stabilizer - calling the
function ``.stabilizer(...)`` on the previous basic stabilizer.</pre> 
</div>
</div>
<a id="a5e1c04cac1689a54103a100bba4e5465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1c04cac1689a54103a100bba4e5465">&#9670;&nbsp;</a></span>sylow_subgroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.sylow_subgroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a p-Sylow subgroup of the group.

The algorithm is described in [1], Chapter 4, Section 7

Examples
========
&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup

&gt;&gt;&gt; D = DihedralGroup(6)
&gt;&gt;&gt; S = D.sylow_subgroup(2)
&gt;&gt;&gt; S.order()
4
&gt;&gt;&gt; G = SymmetricGroup(6)
&gt;&gt;&gt; S = G.sylow_subgroup(5)
&gt;&gt;&gt; S.order()
5

&gt;&gt;&gt; G1 = AlternatingGroup(3)
&gt;&gt;&gt; G2 = AlternatingGroup(5)
&gt;&gt;&gt; G3 = AlternatingGroup(9)

&gt;&gt;&gt; S1 = G1.sylow_subgroup(3)
&gt;&gt;&gt; S2 = G2.sylow_subgroup(3)
&gt;&gt;&gt; S3 = G3.sylow_subgroup(3)

&gt;&gt;&gt; len1 = len(S1.lower_central_series())
&gt;&gt;&gt; len2 = len(S2.lower_central_series())
&gt;&gt;&gt; len3 = len(S3.lower_central_series())

&gt;&gt;&gt; len1 == len2
True
&gt;&gt;&gt; len1 &lt; len3
True</pre> 
</div>
</div>
<a id="a5e1c04cac1689a54103a100bba4e5465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1c04cac1689a54103a100bba4e5465">&#9670;&nbsp;</a></span>sylow_subgroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.sylow_subgroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a p-Sylow subgroup of the group.

The algorithm is described in [1], Chapter 4, Section 7

Examples
========
&gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup
&gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup
&gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup

&gt;&gt;&gt; D = DihedralGroup(6)
&gt;&gt;&gt; S = D.sylow_subgroup(2)
&gt;&gt;&gt; S.order()
4
&gt;&gt;&gt; G = SymmetricGroup(6)
&gt;&gt;&gt; S = G.sylow_subgroup(5)
&gt;&gt;&gt; S.order()
5

&gt;&gt;&gt; G1 = AlternatingGroup(3)
&gt;&gt;&gt; G2 = AlternatingGroup(5)
&gt;&gt;&gt; G3 = AlternatingGroup(9)

&gt;&gt;&gt; S1 = G1.sylow_subgroup(3)
&gt;&gt;&gt; S2 = G2.sylow_subgroup(3)
&gt;&gt;&gt; S3 = G3.sylow_subgroup(3)

&gt;&gt;&gt; len1 = len(S1.lower_central_series())
&gt;&gt;&gt; len2 = len(S2.lower_central_series())
&gt;&gt;&gt; len3 = len(S3.lower_central_series())

&gt;&gt;&gt; len1 == len2
True
&gt;&gt;&gt; len1 &lt; len3
True</pre> 
</div>
</div>
<a id="a4f12bb2b2db5b430bc0c8eb7315d624e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f12bb2b2db5b430bc0c8eb7315d624e">&#9670;&nbsp;</a></span>transitivity_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.transitivity_degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the degree of transitivity of the group.

Explanation
===========

A permutation group `G` acting on `\Omega = \{0, 1, \dots, n-1\}` is
``k``-fold transitive, if, for any `k` points
`(a_1, a_2, \dots, a_k) \in \Omega` and any `k` points
`(b_1, b_2, \dots, b_k) \in \Omega` there exists `g \in  G` such that
`g(a_1) = b_1, g(a_2) = b_2, \dots, g(a_k) = b_k`
The degree of transitivity of `G` is the maximum ``k`` such that
`G` is ``k``-fold transitive. ([8])

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 2, 0])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.transitivity_degree
3

See Also
========

is_transitive, orbit</pre> 
</div>
</div>
<a id="a4f12bb2b2db5b430bc0c8eb7315d624e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f12bb2b2db5b430bc0c8eb7315d624e">&#9670;&nbsp;</a></span>transitivity_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.perm_groups.PermutationGroup.transitivity_degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the degree of transitivity of the group.

Explanation
===========

A permutation group `G` acting on `\Omega = \{0, 1, \dots, n-1\}` is
``k``-fold transitive, if, for any `k` points
`(a_1, a_2, \dots, a_k) \in \Omega` and any `k` points
`(b_1, b_2, \dots, b_k) \in \Omega` there exists `g \in  G` such that
`g(a_1) = b_1, g(a_2) = b_2, \dots, g(a_k) = b_k`
The degree of transitivity of `G` is the maximum ``k`` such that
`G` is ``k``-fold transitive. ([8])

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup
&gt;&gt;&gt; a = Permutation([1, 2, 0])
&gt;&gt;&gt; b = Permutation([1, 0, 2])
&gt;&gt;&gt; G = PermutationGroup([a, b])
&gt;&gt;&gt; G.transitivity_degree
3

See Also
========

is_transitive, orbit</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac73380b6e282e1d1d475ee44972aa451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73380b6e282e1d1d475ee44972aa451">&#9670;&nbsp;</a></span>degree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.perm_groups.PermutationGroup.degree</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15fbb08166457ddbc48d5346c267808c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fbb08166457ddbc48d5346c267808c">&#9670;&nbsp;</a></span>is_group</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sympy.combinatorics.perm_groups.PermutationGroup.is_group = True</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/sympy/combinatorics/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2sympy_2combinatorics_2perm__groups_8py.html">perm_groups.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
