<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.core.symbol Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1core_1_1symbol.html">symbol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.core.symbol Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1symbol_1_1Str.html">Str</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1symbol_1_1Dummy.html">Dummy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1symbol_1_1Wild.html">Wild</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab065718df13c57688c97be4cdafc9594"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1symbol.html#ab065718df13c57688c97be4cdafc9594">uniquely_named_symbol</a> (xname, exprs=(), compare=str, modify=None, **assumptions)</td></tr>
<tr class="separator:ab065718df13c57688c97be4cdafc9594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d997cbae640d3ecb2c0d1b787c13c0b"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1symbol.html#a1d997cbae640d3ecb2c0d1b787c13c0b">symbols</a> (names, *cls=<a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a>, **args)</td></tr>
<tr class="separator:a1d997cbae640d3ecb2c0d1b787c13c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e02aa7c6240683c0bbbeb647597439"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1symbol.html#a92e02aa7c6240683c0bbbeb647597439">var</a> (names, **args)</td></tr>
<tr class="separator:a92e02aa7c6240683c0bbbeb647597439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dafdc41800f15c20e051b98236ee60b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1symbol.html#a4dafdc41800f15c20e051b98236ee60b">disambiguate</a> (*iter)</td></tr>
<tr class="separator:a4dafdc41800f15c20e051b98236ee60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4dafdc41800f15c20e051b98236ee60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dafdc41800f15c20e051b98236ee60b">&#9670;&nbsp;</a></span>disambiguate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.symbol.disambiguate </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a Tuple containing the passed expressions with symbols
that appear the same when printed replaced with numerically
subscripted symbols, and all Dummy symbols replaced with Symbols.

Parameters
==========

iter: list of symbols or expressions.

Examples
========

&gt;&gt;&gt; from sympy.core.symbol import disambiguate
&gt;&gt;&gt; from sympy import Dummy, Symbol, Tuple
&gt;&gt;&gt; from sympy.abc import y

&gt;&gt;&gt; tup = Symbol('_x'), Dummy('x'), Dummy('x')
&gt;&gt;&gt; disambiguate(*tup)
(x_2, x, x_1)

&gt;&gt;&gt; eqs = Tuple(Symbol('x')/y, Dummy('x')/y)
&gt;&gt;&gt; disambiguate(*eqs)
(x_1/y, x/y)

&gt;&gt;&gt; ix = Symbol('x', integer=True)
&gt;&gt;&gt; vx = Symbol('x')
&gt;&gt;&gt; disambiguate(vx + ix)
(x + x_1,)

To make your own mapping of symbols to use, pass only the free symbols
of the expressions and create a dictionary:

&gt;&gt;&gt; free = eqs.free_symbols
&gt;&gt;&gt; mapping = dict(zip(free, disambiguate(*free)))
&gt;&gt;&gt; eqs.xreplace(mapping)
(x_1/y, x/y)</pre> 
</div>
</div>
<a id="a1d997cbae640d3ecb2c0d1b787c13c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d997cbae640d3ecb2c0d1b787c13c0b">&#9670;&nbsp;</a></span>symbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Any sympy.core.symbol.symbols </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>cls</em> = <code><a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform strings into instances of :class:`Symbol` class.

:func:`symbols` function returns a sequence of symbols with names taken
from ``names`` argument, which can be a comma or whitespace delimited
string, or a sequence of strings::

    &gt;&gt;&gt; from sympy import symbols, Function

    &gt;&gt;&gt; x, y, z = symbols('x,y,z')
    &gt;&gt;&gt; a, b, c = symbols('a b c')

The type of output is dependent on the properties of input arguments::

    &gt;&gt;&gt; symbols('x')
    x
    &gt;&gt;&gt; symbols('x,')
    (x,)
    &gt;&gt;&gt; symbols('x,y')
    (x, y)
    &gt;&gt;&gt; symbols(('a', 'b', 'c'))
    (a, b, c)
    &gt;&gt;&gt; symbols(['a', 'b', 'c'])
    [a, b, c]
    &gt;&gt;&gt; symbols({'a', 'b', 'c'})
    {a, b, c}

If an iterable container is needed for a single symbol, set the ``seq``
argument to ``True`` or terminate the symbol name with a comma::

    &gt;&gt;&gt; symbols('x', seq=True)
    (x,)

To reduce typing, range syntax is supported to create indexed symbols.
Ranges are indicated by a colon and the type of range is determined by
the character to the right of the colon. If the character is a digit
then all contiguous digits to the left are taken as the nonnegative
starting value (or 0 if there is no digit left of the colon) and all
contiguous digits to the right are taken as 1 greater than the ending
value::

    &gt;&gt;&gt; symbols('x:10')
    (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)

    &gt;&gt;&gt; symbols('x5:10')
    (x5, x6, x7, x8, x9)
    &gt;&gt;&gt; symbols('x5(:2)')
    (x50, x51)

    &gt;&gt;&gt; symbols('x5:10,y:5')
    (x5, x6, x7, x8, x9, y0, y1, y2, y3, y4)

    &gt;&gt;&gt; symbols(('x5:10', 'y:5'))
    ((x5, x6, x7, x8, x9), (y0, y1, y2, y3, y4))

If the character to the right of the colon is a letter, then the single
letter to the left (or 'a' if there is none) is taken as the start
and all characters in the lexicographic range *through* the letter to
the right are used as the range::

    &gt;&gt;&gt; symbols('x:z')
    (x, y, z)
    &gt;&gt;&gt; symbols('x:c')  # null range
    ()
    &gt;&gt;&gt; symbols('x(:c)')
    (xa, xb, xc)

    &gt;&gt;&gt; symbols(':c')
    (a, b, c)

    &gt;&gt;&gt; symbols('a:d, x:z')
    (a, b, c, d, x, y, z)

    &gt;&gt;&gt; symbols(('a:d', 'x:z'))
    ((a, b, c, d), (x, y, z))

Multiple ranges are supported; contiguous numerical ranges should be
separated by parentheses to disambiguate the ending number of one
range from the starting number of the next::

    &gt;&gt;&gt; symbols('x:2(1:3)')
    (x01, x02, x11, x12)
    &gt;&gt;&gt; symbols(':3:2')  # parsing is from left to right
    (00, 01, 10, 11, 20, 21)

Only one pair of parentheses surrounding ranges are removed, so to
include parentheses around ranges, double them. And to include spaces,
commas, or colons, escape them with a backslash::

    &gt;&gt;&gt; symbols('x((a:b))')
    (x(a), x(b))
    &gt;&gt;&gt; symbols(r'x(:1\,:2)')  # or r'x((:1)\,(:2))'
    (x(0,0), x(0,1))

All newly created symbols have assumptions set according to ``args``::

    &gt;&gt;&gt; a = symbols('a', integer=True)
    &gt;&gt;&gt; a.is_integer
    True

    &gt;&gt;&gt; x, y, z = symbols('x,y,z', real=True)
    &gt;&gt;&gt; x.is_real and y.is_real and z.is_real
    True

Despite its name, :func:`symbols` can create symbol-like objects like
instances of Function or Wild classes. To achieve this, set ``cls``
keyword argument to the desired type::

    &gt;&gt;&gt; symbols('f,g,h', cls=Function)
    (f, g, h)

    &gt;&gt;&gt; type(_[0])
    &lt;class 'sympy.core.function.UndefinedFunction'&gt;</pre> 
</div>
</div>
<a id="ab065718df13c57688c97be4cdafc9594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab065718df13c57688c97be4cdafc9594">&#9670;&nbsp;</a></span>uniquely_named_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.symbol.uniquely_named_symbol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exprs</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compare</em> = <code>str</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modify</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>assumptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a symbol whose name is derivated from *xname* but is unique
from any other symbols in *exprs*.

*xname* and symbol names in *exprs* are passed to *compare* to be
converted to comparable forms. If ``compare(xname)`` is not unique,
it is recursively passed to *modify* until unique name is acquired.

Parameters
==========

xname : str or Symbol
    Base name for the new symbol.

exprs : Expr or iterable of Expr
    Expressions whose symbols are compared to *xname*.

compare : function
    Unary function which transforms *xname* and symbol names from
    *exprs* to comparable form.

modify : function
    Unary function which modifies the string. Default is appending
    the number, or increasing the number if exists.

Examples
========

By default, a number is appended to *xname* to generate unique name.
If the number already exists, it is recursively increased.

&gt;&gt;&gt; from sympy.core.symbol import uniquely_named_symbol, Symbol
&gt;&gt;&gt; uniquely_named_symbol('x', Symbol('x'))
x0
&gt;&gt;&gt; uniquely_named_symbol('x', (Symbol('x'), Symbol('x0')))
x1
&gt;&gt;&gt; uniquely_named_symbol('x0', (Symbol('x1'), Symbol('x0')))
x2

Name generation can be controlled by passing *modify* parameter.

&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; uniquely_named_symbol('x', x, modify=lambda s: 2*s)
xx</pre> 
</div>
</div>
<a id="a92e02aa7c6240683c0bbbeb647597439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e02aa7c6240683c0bbbeb647597439">&#9670;&nbsp;</a></span>var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.symbol.var </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create symbols and inject them into the global namespace.

Explanation
===========

This calls :func:`symbols` with the same arguments and puts the results
into the *global* namespace. It's recommended not to use :func:`var` in
library code, where :func:`symbols` has to be used::

Examples
========

&gt;&gt;&gt; from sympy import var

&gt;&gt;&gt; var('x')
x
&gt;&gt;&gt; x # noqa: F821
x

&gt;&gt;&gt; var('a,ab,abc')
(a, ab, abc)
&gt;&gt;&gt; abc # noqa: F821
abc

&gt;&gt;&gt; var('x,y', real=True)
(x, y)
&gt;&gt;&gt; x.is_real and y.is_real # noqa: F821
True

See :func:`symbols` documentation for more details on what kinds of
arguments can be passed to :func:`var`.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
