<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.core.sorting Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1core_1_1sorting.html">sorting</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.core.sorting Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa599e4fc0b890a388e98a72fa9916a25"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1sorting.html#aa599e4fc0b890a388e98a72fa9916a25">default_sort_key</a> (item, order=None)</td></tr>
<tr class="separator:aa599e4fc0b890a388e98a72fa9916a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8178edbfbe0c1565005e00e59b92cf6e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1sorting.html#a8178edbfbe0c1565005e00e59b92cf6e">ordered</a> (seq, keys=None, default=True, warn=False)</td></tr>
<tr class="separator:a8178edbfbe0c1565005e00e59b92cf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa599e4fc0b890a388e98a72fa9916a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa599e4fc0b890a388e98a72fa9916a25">&#9670;&nbsp;</a></span>default_sort_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.sorting.default_sort_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a key that can be used for sorting.

The key has the structure:

(class_key, (len(args), args), exponent.sort_key(), coefficient)

This key is supplied by the sort_key routine of Basic objects when
``item`` is a Basic object or an object (other than a string) that
sympifies to a Basic object. Otherwise, this function produces the
key.

The ``order`` argument is passed along to the sort_key routine and is
used to determine how the terms *within* an expression are ordered.
(See examples below) ``order`` options are: 'lex', 'grlex', 'grevlex',
and reversed values of the same (e.g. 'rev-lex'). The default order
value is None (which translates to 'lex').

Examples
========

&gt;&gt;&gt; from sympy import S, I, default_sort_key, sin, cos, sqrt
&gt;&gt;&gt; from sympy.core.function import UndefinedFunction
&gt;&gt;&gt; from sympy.abc import x

The following are equivalent ways of getting the key for an object:

&gt;&gt;&gt; x.sort_key() == default_sort_key(x)
True

Here are some examples of the key that is produced:

&gt;&gt;&gt; default_sort_key(UndefinedFunction('f'))
((0, 0, 'UndefinedFunction'), (1, ('f',)), ((1, 0, 'Number'),
    (0, ()), (), 1), 1)
&gt;&gt;&gt; default_sort_key('1')
((0, 0, 'str'), (1, ('1',)), ((1, 0, 'Number'), (0, ()), (), 1), 1)
&gt;&gt;&gt; default_sort_key(S.One)
((1, 0, 'Number'), (0, ()), (), 1)
&gt;&gt;&gt; default_sort_key(2)
((1, 0, 'Number'), (0, ()), (), 2)

While sort_key is a method only defined for SymPy objects,
default_sort_key will accept anything as an argument so it is
more robust as a sorting key. For the following, using key=
lambda i: i.sort_key() would fail because 2 does not have a sort_key
method; that's why default_sort_key is used. Note, that it also
handles sympification of non-string items likes ints:

&gt;&gt;&gt; a = [2, I, -I]
&gt;&gt;&gt; sorted(a, key=default_sort_key)
[2, -I, I]

The returned key can be used anywhere that a key can be specified for
a function, e.g. sort, min, max, etc...:

&gt;&gt;&gt; a.sort(key=default_sort_key); a[0]
2
&gt;&gt;&gt; min(a, key=default_sort_key)
2

Notes
=====

The key returned is useful for getting items into a canonical order
that will be the same across platforms. It is not directly useful for
sorting lists of expressions:

&gt;&gt;&gt; a, b = x, 1/x

Since ``a`` has only 1 term, its value of sort_key is unaffected by
``order``:

&gt;&gt;&gt; a.sort_key() == a.sort_key('rev-lex')
True

If ``a`` and ``b`` are combined then the key will differ because there
are terms that can be ordered:

&gt;&gt;&gt; eq = a + b
&gt;&gt;&gt; eq.sort_key() == eq.sort_key('rev-lex')
False
&gt;&gt;&gt; eq.as_ordered_terms()
[x, 1/x]
&gt;&gt;&gt; eq.as_ordered_terms('rev-lex')
[1/x, x]

But since the keys for each of these terms are independent of ``order``'s
value, they do not sort differently when they appear separately in a list:

&gt;&gt;&gt; sorted(eq.args, key=default_sort_key)
[1/x, x]
&gt;&gt;&gt; sorted(eq.args, key=lambda i: default_sort_key(i, order='rev-lex'))
[1/x, x]

The order of terms obtained when using these keys is the order that would
be obtained if those terms were *factors* in a product.

Although it is useful for quickly putting expressions in canonical order,
it does not sort expressions based on their complexity defined by the
number of operations, power of variables and others:

&gt;&gt;&gt; sorted([sin(x)*cos(x), sin(x)], key=default_sort_key)
[sin(x)*cos(x), sin(x)]
&gt;&gt;&gt; sorted([x, x**2, sqrt(x), x**3], key=default_sort_key)
[sqrt(x), x, x**2, x**3]

See Also
========

ordered, sympy.core.expr.Expr.as_ordered_factors, sympy.core.expr.Expr.as_ordered_terms</pre> 
</div>
</div>
<a id="a8178edbfbe0c1565005e00e59b92cf6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8178edbfbe0c1565005e00e59b92cf6e">&#9670;&nbsp;</a></span>ordered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.sorting.ordered </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>warn</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an iterator of the seq where keys are used to break ties
in a conservative fashion: if, after applying a key, there are no
ties then no other keys will be computed.

Two default keys will be applied if 1) keys are not provided or
2) the given keys do not resolve all ties (but only if ``default``
is True). The two keys are ``_nodes`` (which places smaller
expressions before large) and ``default_sort_key`` which (if the
``sort_key`` for an object is defined properly) should resolve
any ties. This strategy is similar to sorting done by
``Basic.compare``, but differs in that ``ordered`` never makes a
decision based on an objects name.

If ``warn`` is True then an error will be raised if there were no
keys remaining to break ties. This can be used if it was expected that
there should be no ties between items that are not identical.

Examples
========

&gt;&gt;&gt; from sympy import ordered, count_ops
&gt;&gt;&gt; from sympy.abc import x, y

The count_ops is not sufficient to break ties in this list and the first
two items appear in their original order (i.e. the sorting is stable):

&gt;&gt;&gt; list(ordered([y + 2, x + 2, x**2 + y + 3],
...    count_ops, default=False, warn=False))
...
[y + 2, x + 2, x**2 + y + 3]

The default_sort_key allows the tie to be broken:

&gt;&gt;&gt; list(ordered([y + 2, x + 2, x**2 + y + 3]))
...
[x + 2, y + 2, x**2 + y + 3]

Here, sequences are sorted by length, then sum:

&gt;&gt;&gt; seq, keys = [[[1, 2, 1], [0, 3, 1], [1, 1, 3], [2], [1]], [
...    lambda x: len(x),
...    lambda x: sum(x)]]
...
&gt;&gt;&gt; list(ordered(seq, keys, default=False, warn=False))
[[1], [2], [1, 2, 1], [0, 3, 1], [1, 1, 3]]

If ``warn`` is True, an error will be raised if there were not
enough keys to break ties:

&gt;&gt;&gt; list(ordered(seq, keys, default=False, warn=True))
Traceback (most recent call last):
...
ValueError: not enough keys to break ties


Notes
=====

The decorated sort is one of the fastest ways to sort a sequence for
which special item comparison is desired: the sequence is decorated,
sorted on the basis of the decoration (e.g. making all letters lower
case) and then undecorated. If one wants to break ties for items that
have the same decorated value, a second key can be used. But if the
second key is expensive to compute then it is inefficient to decorate
all items with both keys: only those items having identical first key
values need to be decorated. This function applies keys successively
only when needed to break ties. By yielding an iterator, use of the
tie-breaker is delayed as long as possible.

This function is best used in cases when use of the first key is
expected to be a good hashing function; if there are no unique hashes
from application of a key, then that key should not have been used. The
exception, however, is that even if there are many collisions, if the
first group is small and one does not need to process all items in the
list then time will not be wasted sorting what one was not interested
in. For example, if one were looking for the minimum in a list and
there were several criteria used to define the sort order, then this
function would be good at returning that quickly if the first group
of candidates is small relative to the number of items being processed.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
