<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.series.formal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1series.html">series</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1series_1_1formal.html">formal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.series.formal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1series_1_1formal_1_1Coeff.html">Coeff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1series_1_1formal_1_1FormalPowerSeries.html">FormalPowerSeries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1series_1_1formal_1_1FiniteFormalPowerSeries.html">FiniteFormalPowerSeries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1series_1_1formal_1_1FormalPowerSeriesProduct.html">FormalPowerSeriesProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1series_1_1formal_1_1FormalPowerSeriesCompose.html">FormalPowerSeriesCompose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1series_1_1formal_1_1FormalPowerSeriesInverse.html">FormalPowerSeriesInverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a829c0396b86d72baff60109c6a7becdf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#a829c0396b86d72baff60109c6a7becdf">rational_algorithm</a> (f, x, k, order=4, full=False)</td></tr>
<tr class="separator:a829c0396b86d72baff60109c6a7becdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1a8a2ba1d0e3f1997c05ca26af875c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#a2c1a8a2ba1d0e3f1997c05ca26af875c">rational_independent</a> (terms, x)</td></tr>
<tr class="separator:a2c1a8a2ba1d0e3f1997c05ca26af875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb58e212aee1e0a1187065541a1b26a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#acb58e212aee1e0a1187065541a1b26a8">simpleDE</a> (f, x, g, order=4)</td></tr>
<tr class="separator:acb58e212aee1e0a1187065541a1b26a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a184d2fb2c4899569c63774eb17c20"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#a18a184d2fb2c4899569c63774eb17c20">exp_re</a> (DE, r, k)</td></tr>
<tr class="separator:a18a184d2fb2c4899569c63774eb17c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9647a5c6bc0317aa23b335059cf82435"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#a9647a5c6bc0317aa23b335059cf82435">hyper_re</a> (DE, r, k)</td></tr>
<tr class="separator:a9647a5c6bc0317aa23b335059cf82435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14911533a97f16e78edce386a8c77d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#ac14911533a97f16e78edce386a8c77d7">rsolve_hypergeometric</a> (f, x, P, Q, k, m)</td></tr>
<tr class="separator:ac14911533a97f16e78edce386a8c77d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab505438680a90e40d493333d6998a7d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#ab505438680a90e40d493333d6998a7d1">solve_de</a> (f, x, DE, order, g, k)</td></tr>
<tr class="separator:ab505438680a90e40d493333d6998a7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235eb5946d7ebda4a22af5a0f24ba8e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#a235eb5946d7ebda4a22af5a0f24ba8e8">hyper_algorithm</a> (f, x, k, order=4)</td></tr>
<tr class="separator:a235eb5946d7ebda4a22af5a0f24ba8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe4b438623d2a680e2b8950e667f2f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#affe4b438623d2a680e2b8950e667f2f8">compute_fps</a> (f, x, x0=0, dir=1, <a class="el" href="classsympy_1_1functions_1_1special_1_1hyper_1_1hyper.html">hyper</a>=True, order=4, rational=True, full=False)</td></tr>
<tr class="separator:affe4b438623d2a680e2b8950e667f2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e37ab4be7639ca1e47bfbbe220f19f0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1series_1_1formal.html#a2e37ab4be7639ca1e47bfbbe220f19f0">fps</a> (f, x=None, x0=0, dir=1, <a class="el" href="classsympy_1_1functions_1_1special_1_1hyper_1_1hyper.html">hyper</a>=True, order=4, rational=True, full=False)</td></tr>
<tr class="separator:a2e37ab4be7639ca1e47bfbbe220f19f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Formal Power Series</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="affe4b438623d2a680e2b8950e667f2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe4b438623d2a680e2b8950e667f2f8">&#9670;&nbsp;</a></span>compute_fps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.compute_fps </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dir</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hyper</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rational</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the formula for Formal Power Series of a function.

Explanation
===========

Tries to compute the formula by applying the following techniques
(in order):

* rational_algorithm
* Hypergeometric algorithm

Parameters
==========

x : Symbol
x0 : number, optional
    Point to perform series expansion about. Default is 0.
dir : {1, -1, '+', '-'}, optional
    If dir is 1 or '+' the series is calculated from the right and
    for -1 or '-' the series is calculated from the left. For smooth
    functions this flag will not alter the results. Default is 1.
hyper : {True, False}, optional
    Set hyper to False to skip the hypergeometric algorithm.
    By default it is set to False.
order : int, optional
    Order of the derivative of ``f``, Default is 4.
rational : {True, False}, optional
    Set rational to False to skip rational algorithm. By default it is set
    to True.
full : {True, False}, optional
    Set full to True to increase the range of rational algorithm.
    See :func:`rational_algorithm` for details. By default it is set to
    False.

Returns
=======

ak : sequence
    Sequence of coefficients.
xk : sequence
    Sequence of powers of x.
ind : Expr
    Independent terms.
mul : Pow
    Common terms.

See Also
========

sympy.series.formal.rational_algorithm
sympy.series.formal.hyper_algorithm
</pre> 
</div>
</div>
<a id="a18a184d2fb2c4899569c63774eb17c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a184d2fb2c4899569c63774eb17c20">&#9670;&nbsp;</a></span>exp_re()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.exp_re </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts a DE with constant coefficients (explike) into a RE.

Explanation
===========

Performs the substitution:

.. math::
    f^j(x) \\to r(k + j)

Normalises the terms so that lowest order of a term is always r(k).

Examples
========

&gt;&gt;&gt; from sympy import Function, Derivative
&gt;&gt;&gt; from sympy.series.formal import exp_re
&gt;&gt;&gt; from sympy.abc import x, k
&gt;&gt;&gt; f, r = Function('f'), Function('r')

&gt;&gt;&gt; exp_re(-f(x) + Derivative(f(x)), r, k)
-r(k) + r(k + 1)
&gt;&gt;&gt; exp_re(Derivative(f(x), x) + Derivative(f(x), (x, 2)), r, k)
r(k) + r(k + 1)

See Also
========

sympy.series.formal.hyper_re
</pre> 
</div>
</div>
<a id="a2e37ab4be7639ca1e47bfbbe220f19f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e37ab4be7639ca1e47bfbbe220f19f0">&#9670;&nbsp;</a></span>fps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.fps </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dir</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hyper</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rational</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates Formal Power Series of ``f``.

Explanation
===========

Returns the formal series expansion of ``f`` around ``x = x0``
with respect to ``x`` in the form of a ``FormalPowerSeries`` object.

Formal Power Series is represented using an explicit formula
computed using different algorithms.

See :func:`compute_fps` for the more details regarding the computation
of formula.

Parameters
==========

x : Symbol, optional
    If x is None and ``f`` is univariate, the univariate symbols will be
    supplied, otherwise an error will be raised.
x0 : number, optional
    Point to perform series expansion about. Default is 0.
dir : {1, -1, '+', '-'}, optional
    If dir is 1 or '+' the series is calculated from the right and
    for -1 or '-' the series is calculated from the left. For smooth
    functions this flag will not alter the results. Default is 1.
hyper : {True, False}, optional
    Set hyper to False to skip the hypergeometric algorithm.
    By default it is set to False.
order : int, optional
    Order of the derivative of ``f``, Default is 4.
rational : {True, False}, optional
    Set rational to False to skip rational algorithm. By default it is set
    to True.
full : {True, False}, optional
    Set full to True to increase the range of rational algorithm.
    See :func:`rational_algorithm` for details. By default it is set to
    False.

Examples
========

&gt;&gt;&gt; from sympy import fps, ln, atan, sin
&gt;&gt;&gt; from sympy.abc import x, n

Rational Functions

&gt;&gt;&gt; fps(ln(1 + x)).truncate()
x - x**2/2 + x**3/3 - x**4/4 + x**5/5 + O(x**6)

&gt;&gt;&gt; fps(atan(x), full=True).truncate()
x - x**3/3 + x**5/5 + O(x**6)

Symbolic Functions

&gt;&gt;&gt; fps(x**n*sin(x**2), x).truncate(8)
-x**(n + 6)/6 + x**(n + 2) + O(x**(n + 8))

See Also
========

sympy.series.formal.FormalPowerSeries
sympy.series.formal.compute_fps
</pre> 
</div>
</div>
<a id="a235eb5946d7ebda4a22af5a0f24ba8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235eb5946d7ebda4a22af5a0f24ba8e8">&#9670;&nbsp;</a></span>hyper_algorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.hyper_algorithm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Hypergeometric algorithm for computing Formal Power Series.

Explanation
===========

Steps:
    * Generates DE
    * Convert the DE into RE
    * Solves the RE

Examples
========

&gt;&gt;&gt; from sympy import exp, ln
&gt;&gt;&gt; from sympy.series.formal import hyper_algorithm

&gt;&gt;&gt; from sympy.abc import x, k

&gt;&gt;&gt; hyper_algorithm(exp(x), x, k)
(Piecewise((1/factorial(k), Eq(Mod(k, 1), 0)), (0, True)), 1, 1)

&gt;&gt;&gt; hyper_algorithm(ln(1 + x), x, k)
(Piecewise(((-1)**(k - 1)*factorial(k - 1)/RisingFactorial(2, k - 1),
 Eq(Mod(k, 1), 0)), (0, True)), x, 2)

See Also
========

sympy.series.formal.simpleDE
sympy.series.formal.solve_de
</pre> 
</div>
</div>
<a id="a9647a5c6bc0317aa23b335059cf82435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9647a5c6bc0317aa23b335059cf82435">&#9670;&nbsp;</a></span>hyper_re()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.hyper_re </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts a DE into a RE.

Explanation
===========

Performs the substitution:

.. math::
    x^l f^j(x) \\to (k + 1 - l)_j . a_{k + j - l}

Normalises the terms so that lowest order of a term is always r(k).

Examples
========

&gt;&gt;&gt; from sympy import Function, Derivative
&gt;&gt;&gt; from sympy.series.formal import hyper_re
&gt;&gt;&gt; from sympy.abc import x, k
&gt;&gt;&gt; f, r = Function('f'), Function('r')

&gt;&gt;&gt; hyper_re(-f(x) + Derivative(f(x)), r, k)
(k + 1)*r(k + 1) - r(k)
&gt;&gt;&gt; hyper_re(-x*f(x) + Derivative(f(x), (x, 2)), r, k)
(k + 2)*(k + 3)*r(k + 3) - r(k)

See Also
========

sympy.series.formal.exp_re
</pre> 
</div>
</div>
<a id="a829c0396b86d72baff60109c6a7becdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829c0396b86d72baff60109c6a7becdf">&#9670;&nbsp;</a></span>rational_algorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.rational_algorithm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rational algorithm for computing
formula of coefficients of Formal Power Series
of a function.

Explanation
===========

Applicable when f(x) or some derivative of f(x)
is a rational function in x.

:func:`rational_algorithm` uses :func:`~.apart` function for partial fraction
decomposition. :func:`~.apart` by default uses 'undetermined coefficients
method'. By setting ``full=True``, 'Bronstein's algorithm' can be used
instead.

Looks for derivative of a function up to 4'th order (by default).
This can be overridden using order option.

Parameters
==========

x : Symbol
order : int, optional
    Order of the derivative of ``f``, Default is 4.
full : bool

Returns
=======

formula : Expr
ind : Expr
    Independent terms.
order : int
full : bool

Examples
========

&gt;&gt;&gt; from sympy import log, atan
&gt;&gt;&gt; from sympy.series.formal import rational_algorithm as ra
&gt;&gt;&gt; from sympy.abc import x, k

&gt;&gt;&gt; ra(1 / (1 - x), x, k)
(1, 0, 0)
&gt;&gt;&gt; ra(log(1 + x), x, k)
(-1/((-1)**k*k), 0, 1)

&gt;&gt;&gt; ra(atan(x), x, k, full=True)
((-I/(2*(-I)**k) + I/(2*I**k))/k, 0, 1)

Notes
=====

By setting ``full=True``, range of admissible functions to be solved using
``rational_algorithm`` can be increased. This option should be used
carefully as it can significantly slow down the computation as ``doit`` is
performed on the :class:`~.RootSum` object returned by the :func:`~.apart`
function. Use ``full=False`` whenever possible.

See Also
========

sympy.polys.partfrac.apart

References
==========

.. [1] Formal Power Series - Dominik Gruntz, Wolfram Koepf
.. [2] Power Series in Computer Algebra - Wolfram Koepf</pre> 
</div>
</div>
<a id="a2c1a8a2ba1d0e3f1997c05ca26af875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1a8a2ba1d0e3f1997c05ca26af875c">&#9670;&nbsp;</a></span>rational_independent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.rational_independent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>terms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of all the rationally independent terms.

Examples
========

&gt;&gt;&gt; from sympy import sin, cos
&gt;&gt;&gt; from sympy.series.formal import rational_independent
&gt;&gt;&gt; from sympy.abc import x

&gt;&gt;&gt; rational_independent([cos(x), sin(x)], x)
[cos(x), sin(x)]
&gt;&gt;&gt; rational_independent([x**2, sin(x), x*sin(x), x**3], x)
[x**3 + x**2, x*sin(x) + sin(x)]
</pre> 
</div>
</div>
<a id="ac14911533a97f16e78edce386a8c77d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14911533a97f16e78edce386a8c77d7">&#9670;&nbsp;</a></span>rsolve_hypergeometric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.rsolve_hypergeometric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves RE of hypergeometric type.

Explanation
===========

Attempts to solve RE of the form

Q(k)*a(k + m) - P(k)*a(k)

Transformations that preserve Hypergeometric type:

    a. x**n*f(x): b(k + m) = R(k - n)*b(k)
    b. f(A*x): b(k + m) = A**m*R(k)*b(k)
    c. f(x**n): b(k + n*m) = R(k/n)*b(k)
    d. f(x**(1/m)): b(k + 1) = R(k*m)*b(k)
    e. f'(x): b(k + m) = ((k + m + 1)/(k + 1))*R(k + 1)*b(k)

Some of these transformations have been used to solve the RE.

Returns
=======

formula : Expr
ind : Expr
    Independent terms.
order : int

Examples
========

&gt;&gt;&gt; from sympy import exp, ln, S
&gt;&gt;&gt; from sympy.series.formal import rsolve_hypergeometric as rh
&gt;&gt;&gt; from sympy.abc import x, k

&gt;&gt;&gt; rh(exp(x), x, -S.One, (k + 1), k, 1)
(Piecewise((1/factorial(k), Eq(Mod(k, 1), 0)), (0, True)), 1, 1)

&gt;&gt;&gt; rh(ln(1 + x), x, k**2, k*(k + 1), k, 1)
(Piecewise(((-1)**(k - 1)*factorial(k - 1)/RisingFactorial(2, k - 1),
 Eq(Mod(k, 1), 0)), (0, True)), x, 2)

References
==========

.. [1] Formal Power Series - Dominik Gruntz, Wolfram Koepf
.. [2] Power Series in Computer Algebra - Wolfram Koepf
</pre> 
</div>
</div>
<a id="acb58e212aee1e0a1187065541a1b26a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb58e212aee1e0a1187065541a1b26a8">&#9670;&nbsp;</a></span>simpleDE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.simpleDE </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates simple DE.

Explanation
===========

DE is of the form

.. math::
    f^k(x) + \sum\limits_{j=0}^{k-1} A_j f^j(x) = 0

where :math:`A_j` should be rational function in x.

Generates DE's upto order 4 (default). DE's can also have free parameters.

By increasing order, higher order DE's can be found.

Yields a tuple of (DE, order).
</pre> 
</div>
</div>
<a id="ab505438680a90e40d493333d6998a7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab505438680a90e40d493333d6998a7d1">&#9670;&nbsp;</a></span>solve_de()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.series.formal.solve_de </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the DE.

Explanation
===========

Tries to solve DE by either converting into a RE containing two terms or
converting into a DE having constant coefficients.

Returns
=======

formula : Expr
ind : Expr
    Independent terms.
order : int

Examples
========

&gt;&gt;&gt; from sympy import Derivative as D, Function
&gt;&gt;&gt; from sympy import exp, ln
&gt;&gt;&gt; from sympy.series.formal import solve_de
&gt;&gt;&gt; from sympy.abc import x, k
&gt;&gt;&gt; f = Function('f')

&gt;&gt;&gt; solve_de(exp(x), x, D(f(x), x) - f(x), 1, f, k)
(Piecewise((1/factorial(k), Eq(Mod(k, 1), 0)), (0, True)), 1, 1)

&gt;&gt;&gt; solve_de(ln(1 + x), x, (x + 1)*D(f(x), x, 2) + D(f(x)), 2, f, k)
(Piecewise(((-1)**(k - 1)*factorial(k - 1)/RisingFactorial(2, k - 1),
 Eq(Mod(k, 1), 0)), (0, True)), x, 2)
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
