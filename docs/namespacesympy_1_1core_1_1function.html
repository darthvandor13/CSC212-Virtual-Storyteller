<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.core.function Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1core_1_1function.html">function</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.core.function Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1PoleError.html">PoleError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1ArgumentIndexError.html">ArgumentIndexError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1BadSignatureError.html">BadSignatureError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1BadArgumentsError.html">BadArgumentsError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1FunctionClass.html">FunctionClass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1Application.html">Application</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1Function.html">Function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1AppliedUndef.html">AppliedUndef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1UndefSageHelper.html">UndefSageHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1UndefinedFunction.html">UndefinedFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1WildFunction.html">WildFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1Derivative.html">Derivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1Lambda.html">Lambda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1function_1_1Subs.html">Subs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa23224ea8880aa590cc416537d1a81a3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#aa23224ea8880aa590cc416537d1a81a3">arity</a> (cls)</td></tr>
<tr class="separator:aa23224ea8880aa590cc416537d1a81a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c6537da15d866902e5482832fc1d57"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#a41c6537da15d866902e5482832fc1d57">diff</a> (f, *symbols, **kwargs)</td></tr>
<tr class="separator:a41c6537da15d866902e5482832fc1d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41c5ac992f2b87f76c8f124d3101524"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#af41c5ac992f2b87f76c8f124d3101524">expand</a> (e, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, <a class="el" href="classsympy_1_1functions_1_1elementary_1_1exponential_1_1log.html">log</a>=True, multinomial=True, basic=True, **hints)</td></tr>
<tr class="separator:af41c5ac992f2b87f76c8f124d3101524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02660c1c0c028f9b88e58c90b9de2a9c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#a02660c1c0c028f9b88e58c90b9de2a9c">expand_mul</a> (expr, deep=True)</td></tr>
<tr class="separator:a02660c1c0c028f9b88e58c90b9de2a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f428db22b9597884cad099b02202daa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#a7f428db22b9597884cad099b02202daa">expand_multinomial</a> (expr, deep=True)</td></tr>
<tr class="separator:a7f428db22b9597884cad099b02202daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19105345b97112ff477d3c6e32080069"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#a19105345b97112ff477d3c6e32080069">expand_log</a> (expr, deep=True, force=False, factor=False)</td></tr>
<tr class="separator:a19105345b97112ff477d3c6e32080069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6832055e0a949b26d01450057b0a7d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#ac6832055e0a949b26d01450057b0a7d5">expand_func</a> (expr, deep=True)</td></tr>
<tr class="separator:ac6832055e0a949b26d01450057b0a7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaa2e427ea3e1294355feb390a5f689"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#a3eaa2e427ea3e1294355feb390a5f689">expand_trig</a> (expr, deep=True)</td></tr>
<tr class="separator:a3eaa2e427ea3e1294355feb390a5f689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3da07c26b54234a239c6d633359037c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#ab3da07c26b54234a239c6d633359037c">expand_complex</a> (expr, deep=True)</td></tr>
<tr class="separator:ab3da07c26b54234a239c6d633359037c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea9bc5c9ecaae1a8066c648559873b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#a6ea9bc5c9ecaae1a8066c648559873b5">expand_power_base</a> (expr, deep=True, force=False)</td></tr>
<tr class="separator:a6ea9bc5c9ecaae1a8066c648559873b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8aa292e9f01f736f95d0c1d65b0782a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#aa8aa292e9f01f736f95d0c1d65b0782a">expand_power_exp</a> (expr, deep=True)</td></tr>
<tr class="separator:aa8aa292e9f01f736f95d0c1d65b0782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6968fc16f87c9e9edd214716604ab1f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#ac6968fc16f87c9e9edd214716604ab1f">count_ops</a> (expr, visual=False)</td></tr>
<tr class="separator:ac6968fc16f87c9e9edd214716604ab1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcafce41049c3cf6b4de09e2e53f586"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1function.html#affcafce41049c3cf6b4de09e2e53f586">nfloat</a> (expr, n=15, exponent=False, dkeys=False)</td></tr>
<tr class="separator:affcafce41049c3cf6b4de09e2e53f586"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">There are three types of functions implemented in SymPy:

    1) defined functions (in the sense that they can be evaluated) like
       exp or sin; they have a name and a body:
           f = exp
    2) undefined function which have a name but no body. Undefined
       functions can be defined using a Function class as follows:
           f = Function('f')
       (the result will be a Function instance)
    3) anonymous function (or lambda function) which have a body (defined
       with dummy variables) but have no name:
           f = Lambda(x, exp(x)*x)
           f = Lambda((x, y), exp(x)*y)
    The fourth type of functions are composites, like (sin + cos)(x); these work in
    SymPy core, but are not yet part of SymPy.

    Examples
    ========

    &gt;&gt;&gt; import sympy
    &gt;&gt;&gt; f = sympy.Function("f")
    &gt;&gt;&gt; from sympy.abc import x
    &gt;&gt;&gt; f(x)
    f(x)
    &gt;&gt;&gt; print(sympy.srepr(f(x).func))
    Function('f')
    &gt;&gt;&gt; f(x).args
    (x,)</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aa23224ea8880aa590cc416537d1a81a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23224ea8880aa590cc416537d1a81a3">&#9670;&nbsp;</a></span>arity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.arity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the arity of the function if it is known, else None.

Explanation
===========

When default values are specified for some arguments, they are
optional and the arity is reported as a tuple of possible values.

Examples
========

&gt;&gt;&gt; from sympy import arity, log
&gt;&gt;&gt; arity(lambda x: x)
1
&gt;&gt;&gt; arity(log)
(1, 2)
&gt;&gt;&gt; arity(lambda *x: sum(x)) is None
True
</pre> 
</div>
</div>
<a id="ac6968fc16f87c9e9edd214716604ab1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6968fc16f87c9e9edd214716604ab1f">&#9670;&nbsp;</a></span>count_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.count_ops </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>visual</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a representation (integer or expression) of the operations in expr.

Parameters
==========

expr : Expr
    If expr is an iterable, the sum of the op counts of the
    items will be returned.

visual : bool, optional
    If ``False`` (default) then the sum of the coefficients of the
    visual expression will be returned.
    If ``True`` then the number of each type of operation is shown
    with the core class types (or their virtual equivalent) multiplied by the
    number of times they occur.

Examples
========

&gt;&gt;&gt; from sympy.abc import a, b, x, y
&gt;&gt;&gt; from sympy import sin, count_ops

Although there is not a SUB object, minus signs are interpreted as
either negations or subtractions:

&gt;&gt;&gt; (x - y).count_ops(visual=True)
SUB
&gt;&gt;&gt; (-x).count_ops(visual=True)
NEG

Here, there are two Adds and a Pow:

&gt;&gt;&gt; (1 + a + b**2).count_ops(visual=True)
2*ADD + POW

In the following, an Add, Mul, Pow and two functions:

&gt;&gt;&gt; (sin(x)*x + sin(x)**2).count_ops(visual=True)
ADD + MUL + POW + 2*SIN

for a total of 5:

&gt;&gt;&gt; (sin(x)*x + sin(x)**2).count_ops(visual=False)
5

Note that "what you type" is not always what you get. The expression
1/x/y is translated by sympy into 1/(x*y) so it gives a DIV and MUL rather
than two DIVs:

&gt;&gt;&gt; (1/x/y).count_ops(visual=True)
DIV + MUL

The visual option can be used to demonstrate the difference in
operations for expressions in different forms. Here, the Horner
representation is compared with the expanded form of a polynomial:

&gt;&gt;&gt; eq=x*(1 + x*(2 + x*(3 + x)))
&gt;&gt;&gt; count_ops(eq.expand(), visual=True) - count_ops(eq, visual=True)
-MUL + 3*POW

The count_ops function also handles iterables:

&gt;&gt;&gt; count_ops([x, sin(x), None, True, x + 2], visual=False)
2
&gt;&gt;&gt; count_ops([x, sin(x), None, True, x + 2], visual=True)
ADD + SIN
&gt;&gt;&gt; count_ops({x: sin(x), x + 2: y + 1}, visual=True)
2*ADD + SIN</pre> 
</div>
</div>
<a id="a41c6537da15d866902e5482832fc1d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c6537da15d866902e5482832fc1d57">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Differentiate f with respect to symbols.

Explanation
===========

This is just a wrapper to unify .diff() and the Derivative class; its
interface is similar to that of integrate().  You can use the same
shortcuts for multiple variables as with Derivative.  For example,
diff(f(x), x, x, x) and diff(f(x), x, 3) both return the third derivative
of f(x).

You can pass evaluate=False to get an unevaluated Derivative class.  Note
that if there are 0 symbols (such as diff(f(x), x, 0), then the result will
be the function (the zeroth derivative), even if evaluate=False.

Examples
========

&gt;&gt;&gt; from sympy import sin, cos, Function, diff
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; f = Function('f')

&gt;&gt;&gt; diff(sin(x), x)
cos(x)
&gt;&gt;&gt; diff(f(x), x, x, x)
Derivative(f(x), (x, 3))
&gt;&gt;&gt; diff(f(x), x, 3)
Derivative(f(x), (x, 3))
&gt;&gt;&gt; diff(sin(x)*cos(y), x, 2, y, 2)
sin(x)*cos(y)

&gt;&gt;&gt; type(diff(sin(x), x))
cos
&gt;&gt;&gt; type(diff(sin(x), x, evaluate=False))
&lt;class 'sympy.core.function.Derivative'&gt;
&gt;&gt;&gt; type(diff(sin(x), x, 0))
sin
&gt;&gt;&gt; type(diff(sin(x), x, 0, evaluate=False))
sin

&gt;&gt;&gt; diff(sin(x))
cos(x)
&gt;&gt;&gt; diff(sin(x*y))
Traceback (most recent call last):
...
ValueError: specify differentiation variables to differentiate sin(x*y)

Note that ``diff(sin(x))`` syntax is meant only for convenience
in interactive sessions and should be avoided in library code.

References
==========

.. [1] https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html

See Also
========

Derivative
idiff: computes the derivative implicitly</pre> 
</div>
</div>
<a id="af41c5ac992f2b87f76c8f124d3101524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41c5ac992f2b87f76c8f124d3101524">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modulus</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>power_base</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>power_exp</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mul</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>log</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multinomial</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basic</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Expand an expression using methods given as hints.

Explanation
===========

Hints evaluated unless explicitly set to False are:  ``basic``, ``log``,
``multinomial``, ``mul``, ``power_base``, and ``power_exp`` The following
hints are supported but not applied unless set to True:  ``complex``,
``func``, and ``trig``.  In addition, the following meta-hints are
supported by some or all of the other hints:  ``frac``, ``numer``,
``denom``, ``modulus``, and ``force``.  ``deep`` is supported by all
hints.  Additionally, subclasses of Expr may define their own hints or
meta-hints.

The ``basic`` hint is used for any special rewriting of an object that
should be done automatically (along with the other hints like ``mul``)
when expand is called. This is a catch-all hint to handle any sort of
expansion that may not be described by the existing hint names. To use
this hint an object should override the ``_eval_expand_basic`` method.
Objects may also define their own expand methods, which are not run by
default.  See the API section below.

If ``deep`` is set to ``True`` (the default), things like arguments of
functions are recursively expanded.  Use ``deep=False`` to only expand on
the top level.

If the ``force`` hint is used, assumptions about variables will be ignored
in making the expansion.

Hints
=====

These hints are run by default

mul
---

Distributes multiplication over addition:

&gt;&gt;&gt; from sympy import cos, exp, sin
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; (y*(x + z)).expand(mul=True)
x*y + y*z

multinomial
-----------

Expand (x + y + ...)**n where n is a positive integer.

&gt;&gt;&gt; ((x + y + z)**2).expand(multinomial=True)
x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2

power_exp
---------

Expand addition in exponents into multiplied bases.

&gt;&gt;&gt; exp(x + y).expand(power_exp=True)
exp(x)*exp(y)
&gt;&gt;&gt; (2**(x + y)).expand(power_exp=True)
2**x*2**y

power_base
----------

Split powers of multiplied bases.

This only happens by default if assumptions allow, or if the
``force`` meta-hint is used:

&gt;&gt;&gt; ((x*y)**z).expand(power_base=True)
(x*y)**z
&gt;&gt;&gt; ((x*y)**z).expand(power_base=True, force=True)
x**z*y**z
&gt;&gt;&gt; ((2*y)**z).expand(power_base=True)
2**z*y**z

Note that in some cases where this expansion always holds, SymPy performs
it automatically:

&gt;&gt;&gt; (x*y)**2
x**2*y**2

log
---

Pull out power of an argument as a coefficient and split logs products
into sums of logs.

Note that these only work if the arguments of the log function have the
proper assumptions--the arguments must be positive and the exponents must
be real--or else the ``force`` hint must be True:

&gt;&gt;&gt; from sympy import log, symbols
&gt;&gt;&gt; log(x**2*y).expand(log=True)
log(x**2*y)
&gt;&gt;&gt; log(x**2*y).expand(log=True, force=True)
2*log(x) + log(y)
&gt;&gt;&gt; x, y = symbols('x,y', positive=True)
&gt;&gt;&gt; log(x**2*y).expand(log=True)
2*log(x) + log(y)

basic
-----

This hint is intended primarily as a way for custom subclasses to enable
expansion by default.

These hints are not run by default:

complex
-------

Split an expression into real and imaginary parts.

&gt;&gt;&gt; x, y = symbols('x,y')
&gt;&gt;&gt; (x + y).expand(complex=True)
re(x) + re(y) + I*im(x) + I*im(y)
&gt;&gt;&gt; cos(x).expand(complex=True)
-I*sin(re(x))*sinh(im(x)) + cos(re(x))*cosh(im(x))

Note that this is just a wrapper around ``as_real_imag()``.  Most objects
that wish to redefine ``_eval_expand_complex()`` should consider
redefining ``as_real_imag()`` instead.

func
----

Expand other functions.

&gt;&gt;&gt; from sympy import gamma
&gt;&gt;&gt; gamma(x + 1).expand(func=True)
x*gamma(x)

trig
----

Do trigonometric expansions.

&gt;&gt;&gt; cos(x + y).expand(trig=True)
-sin(x)*sin(y) + cos(x)*cos(y)
&gt;&gt;&gt; sin(2*x).expand(trig=True)
2*sin(x)*cos(x)

Note that the forms of ``sin(n*x)`` and ``cos(n*x)`` in terms of ``sin(x)``
and ``cos(x)`` are not unique, due to the identity `\sin^2(x) + \cos^2(x)
= 1`.  The current implementation uses the form obtained from Chebyshev
polynomials, but this may change.  See `this MathWorld article
&lt;https://mathworld.wolfram.com/Multiple-AngleFormulas.html&gt;`_ for more
information.

Notes
=====

- You can shut off unwanted methods::

    &gt;&gt;&gt; (exp(x + y)*(x + y)).expand()
    x*exp(x)*exp(y) + y*exp(x)*exp(y)
    &gt;&gt;&gt; (exp(x + y)*(x + y)).expand(power_exp=False)
    x*exp(x + y) + y*exp(x + y)
    &gt;&gt;&gt; (exp(x + y)*(x + y)).expand(mul=False)
    (x + y)*exp(x)*exp(y)

- Use deep=False to only expand on the top level::

    &gt;&gt;&gt; exp(x + exp(x + y)).expand()
    exp(x)*exp(exp(x)*exp(y))
    &gt;&gt;&gt; exp(x + exp(x + y)).expand(deep=False)
    exp(x)*exp(exp(x + y))

- Hints are applied in an arbitrary, but consistent order (in the current
  implementation, they are applied in alphabetical order, except
  multinomial comes before mul, but this may change).  Because of this,
  some hints may prevent expansion by other hints if they are applied
  first. For example, ``mul`` may distribute multiplications and prevent
  ``log`` and ``power_base`` from expanding them. Also, if ``mul`` is
  applied before ``multinomial`, the expression might not be fully
  distributed. The solution is to use the various ``expand_hint`` helper
  functions or to use ``hint=False`` to this function to finely control
  which hints are applied. Here are some examples::

    &gt;&gt;&gt; from sympy import expand, expand_mul, expand_power_base
    &gt;&gt;&gt; x, y, z = symbols('x,y,z', positive=True)

    &gt;&gt;&gt; expand(log(x*(y + z)))
    log(x) + log(y + z)

  Here, we see that ``log`` was applied before ``mul``.  To get the mul
  expanded form, either of the following will work::

    &gt;&gt;&gt; expand_mul(log(x*(y + z)))
    log(x*y + x*z)
    &gt;&gt;&gt; expand(log(x*(y + z)), log=False)
    log(x*y + x*z)

  A similar thing can happen with the ``power_base`` hint::

    &gt;&gt;&gt; expand((x*(y + z))**x)
    (x*y + x*z)**x

  To get the ``power_base`` expanded form, either of the following will
  work::

    &gt;&gt;&gt; expand((x*(y + z))**x, mul=False)
    x**x*(y + z)**x
    &gt;&gt;&gt; expand_power_base((x*(y + z))**x)
    x**x*(y + z)**x

    &gt;&gt;&gt; expand((x + y)*y/x)
    y + y**2/x

  The parts of a rational expression can be targeted::

    &gt;&gt;&gt; expand((x + y)*y/x/(x + 1), frac=True)
    (x*y + y**2)/(x**2 + x)
    &gt;&gt;&gt; expand((x + y)*y/x/(x + 1), numer=True)
    (x*y + y**2)/(x*(x + 1))
    &gt;&gt;&gt; expand((x + y)*y/x/(x + 1), denom=True)
    y*(x + y)/(x**2 + x)

- The ``modulus`` meta-hint can be used to reduce the coefficients of an
  expression post-expansion::

    &gt;&gt;&gt; expand((3*x + 1)**2)
    9*x**2 + 6*x + 1
    &gt;&gt;&gt; expand((3*x + 1)**2, modulus=5)
    4*x**2 + x + 1

- Either ``expand()`` the function or ``.expand()`` the method can be
  used.  Both are equivalent::

    &gt;&gt;&gt; expand((x + 1)**2)
    x**2 + 2*x + 1
    &gt;&gt;&gt; ((x + 1)**2).expand()
    x**2 + 2*x + 1

API
===

Objects can define their own expand hints by defining
``_eval_expand_hint()``.  The function should take the form::

    def _eval_expand_hint(self, **hints):
        # Only apply the method to the top-level expression
        ...

See also the example below.  Objects should define ``_eval_expand_hint()``
methods only if ``hint`` applies to that specific object.  The generic
``_eval_expand_hint()`` method defined in Expr will handle the no-op case.

Each hint should be responsible for expanding that hint only.
Furthermore, the expansion should be applied to the top-level expression
only.  ``expand()`` takes care of the recursion that happens when
``deep=True``.

You should only call ``_eval_expand_hint()`` methods directly if you are
100% sure that the object has the method, as otherwise you are liable to
get unexpected ``AttributeError``s.  Note, again, that you do not need to
recursively apply the hint to args of your object: this is handled
automatically by ``expand()``.  ``_eval_expand_hint()`` should
generally not be used at all outside of an ``_eval_expand_hint()`` method.
If you want to apply a specific expansion from within another method, use
the public ``expand()`` function, method, or ``expand_hint()`` functions.

In order for expand to work, objects must be rebuildable by their args,
i.e., ``obj.func(*obj.args) == obj`` must hold.

Expand methods are passed ``**hints`` so that expand hints may use
'metahints'--hints that control how different expand methods are applied.
For example, the ``force=True`` hint described above that causes
``expand(log=True)`` to ignore assumptions is such a metahint.  The
``deep`` meta-hint is handled exclusively by ``expand()`` and is not
passed to ``_eval_expand_hint()`` methods.

Note that expansion hints should generally be methods that perform some
kind of 'expansion'.  For hints that simply rewrite an expression, use the
.rewrite() API.

Examples
========

&gt;&gt;&gt; from sympy import Expr, sympify
&gt;&gt;&gt; class MyClass(Expr):
...     def __new__(cls, *args):
...         args = sympify(args)
...         return Expr.__new__(cls, *args)
...
...     def _eval_expand_double(self, *, force=False, **hints):
...         '''
...         Doubles the args of MyClass.
...
...         If there more than four args, doubling is not performed,
...         unless force=True is also used (False by default).
...         '''
...         if not force and len(self.args) &gt; 4:
...             return self
...         return self.func(*(self.args + self.args))
...
&gt;&gt;&gt; a = MyClass(1, 2, MyClass(3, 4))
&gt;&gt;&gt; a
MyClass(1, 2, MyClass(3, 4))
&gt;&gt;&gt; a.expand(double=True)
MyClass(1, 2, MyClass(3, 4, 3, 4), 1, 2, MyClass(3, 4, 3, 4))
&gt;&gt;&gt; a.expand(double=True, deep=False)
MyClass(1, 2, MyClass(3, 4), 1, 2, MyClass(3, 4))

&gt;&gt;&gt; b = MyClass(1, 2, 3, 4, 5)
&gt;&gt;&gt; b.expand(double=True)
MyClass(1, 2, 3, 4, 5)
&gt;&gt;&gt; b.expand(double=True, force=True)
MyClass(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)

See Also
========

expand_log, expand_mul, expand_multinomial, expand_complex, expand_trig,
expand_power_base, expand_power_exp, expand_func, sympy.simplify.hyperexpand.hyperexpand</pre> 
</div>
</div>
<a id="ab3da07c26b54234a239c6d633359037c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3da07c26b54234a239c6d633359037c">&#9670;&nbsp;</a></span>expand_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand_complex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper around expand that only uses the complex hint.  See the expand
docstring for more information.

Examples
========

&gt;&gt;&gt; from sympy import expand_complex, exp, sqrt, I
&gt;&gt;&gt; from sympy.abc import z
&gt;&gt;&gt; expand_complex(exp(z))
I*exp(re(z))*sin(im(z)) + exp(re(z))*cos(im(z))
&gt;&gt;&gt; expand_complex(sqrt(I))
sqrt(2)/2 + sqrt(2)*I/2

See Also
========

sympy.core.expr.Expr.as_real_imag
</pre> 
</div>
</div>
<a id="ac6832055e0a949b26d01450057b0a7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6832055e0a949b26d01450057b0a7d5">&#9670;&nbsp;</a></span>expand_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand_func </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper around expand that only uses the func hint.  See the expand
docstring for more information.

Examples
========

&gt;&gt;&gt; from sympy import expand_func, gamma
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; expand_func(gamma(x + 2))
x*(x + 1)*gamma(x)</pre> 
</div>
</div>
<a id="a19105345b97112ff477d3c6e32080069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19105345b97112ff477d3c6e32080069">&#9670;&nbsp;</a></span>expand_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand_log </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factor</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper around expand that only uses the log hint.  See the expand
docstring for more information.

Examples
========

&gt;&gt;&gt; from sympy import symbols, expand_log, exp, log
&gt;&gt;&gt; x, y = symbols('x,y', positive=True)
&gt;&gt;&gt; expand_log(exp(x+y)*(x+y)*log(x*y**2))
(x + y)*(log(x) + 2*log(y))*exp(x + y)</pre> 
</div>
</div>
<a id="a02660c1c0c028f9b88e58c90b9de2a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02660c1c0c028f9b88e58c90b9de2a9c">&#9670;&nbsp;</a></span>expand_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand_mul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper around expand that only uses the mul hint.  See the expand
docstring for more information.

Examples
========

&gt;&gt;&gt; from sympy import symbols, expand_mul, exp, log
&gt;&gt;&gt; x, y = symbols('x,y', positive=True)
&gt;&gt;&gt; expand_mul(exp(x+y)*(x+y)*log(x*y**2))
x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)</pre> 
</div>
</div>
<a id="a7f428db22b9597884cad099b02202daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f428db22b9597884cad099b02202daa">&#9670;&nbsp;</a></span>expand_multinomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand_multinomial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper around expand that only uses the multinomial hint.  See the expand
docstring for more information.

Examples
========

&gt;&gt;&gt; from sympy import symbols, expand_multinomial, exp
&gt;&gt;&gt; x, y = symbols('x y', positive=True)
&gt;&gt;&gt; expand_multinomial((x + exp(x + 1))**2)
x**2 + 2*x*exp(x + 1) + exp(2*x + 2)</pre> 
</div>
</div>
<a id="a6ea9bc5c9ecaae1a8066c648559873b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea9bc5c9ecaae1a8066c648559873b5">&#9670;&nbsp;</a></span>expand_power_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand_power_base </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper around expand that only uses the power_base hint.

A wrapper to expand(power_base=True) which separates a power with a base
that is a Mul into a product of powers, without performing any other
expansions, provided that assumptions about the power's base and exponent
allow.

deep=False (default is True) will only apply to the top-level expression.

force=True (default is False) will cause the expansion to ignore
assumptions about the base and exponent. When False, the expansion will
only happen if the base is non-negative or the exponent is an integer.

&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; from sympy import expand_power_base, sin, cos, exp, Symbol

&gt;&gt;&gt; (x*y)**2
x**2*y**2

&gt;&gt;&gt; (2*x)**y
(2*x)**y
&gt;&gt;&gt; expand_power_base(_)
2**y*x**y

&gt;&gt;&gt; expand_power_base((x*y)**z)
(x*y)**z
&gt;&gt;&gt; expand_power_base((x*y)**z, force=True)
x**z*y**z
&gt;&gt;&gt; expand_power_base(sin((x*y)**z), deep=False)
sin((x*y)**z)
&gt;&gt;&gt; expand_power_base(sin((x*y)**z), force=True)
sin(x**z*y**z)

&gt;&gt;&gt; expand_power_base((2*sin(x))**y + (2*cos(x))**y)
2**y*sin(x)**y + 2**y*cos(x)**y

&gt;&gt;&gt; expand_power_base((2*exp(y))**x)
2**x*exp(y)**x

&gt;&gt;&gt; expand_power_base((2*cos(x))**y)
2**y*cos(x)**y

Notice that sums are left untouched. If this is not the desired behavior,
apply full ``expand()`` to the expression:

&gt;&gt;&gt; expand_power_base(((x+y)*z)**2)
z**2*(x + y)**2
&gt;&gt;&gt; (((x+y)*z)**2).expand()
x**2*z**2 + 2*x*y*z**2 + y**2*z**2

&gt;&gt;&gt; expand_power_base((2*y)**(1+z))
2**(z + 1)*y**(z + 1)
&gt;&gt;&gt; ((2*y)**(1+z)).expand()
2*2**z*y**(z + 1)

The power that is unexpanded can be expanded safely when
``y != 0``, otherwise different values might be obtained for the expression:

&gt;&gt;&gt; prev = _

If we indicate that ``y`` is positive but then replace it with
a value of 0 after expansion, the expression becomes 0:

&gt;&gt;&gt; p = Symbol('p', positive=True)
&gt;&gt;&gt; prev.subs(y, p).expand().subs(p, 0)
0

But if ``z = -1`` the expression would not be zero:

&gt;&gt;&gt; prev.subs(y, 0).subs(z, -1)
1

See Also
========

expand</pre> 
</div>
</div>
<a id="aa8aa292e9f01f736f95d0c1d65b0782a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8aa292e9f01f736f95d0c1d65b0782a">&#9670;&nbsp;</a></span>expand_power_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand_power_exp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper around expand that only uses the power_exp hint.

See the expand docstring for more information.

Examples
========

&gt;&gt;&gt; from sympy import expand_power_exp, Symbol
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; expand_power_exp(3**(y + 2))
9*3**y
&gt;&gt;&gt; expand_power_exp(x**(y + 2))
x**(y + 2)

If ``x = 0`` the value of the expression depends on the
value of ``y``; if the expression were expanded the result
would be 0. So expansion is only done if ``x != 0``:

&gt;&gt;&gt; expand_power_exp(Symbol('x', zero=False)**(y + 2))
x**2*x**y
</pre> 
</div>
</div>
<a id="a3eaa2e427ea3e1294355feb390a5f689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaa2e427ea3e1294355feb390a5f689">&#9670;&nbsp;</a></span>expand_trig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.expand_trig </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper around expand that only uses the trig hint.  See the expand
docstring for more information.

Examples
========

&gt;&gt;&gt; from sympy import expand_trig, sin
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; expand_trig(sin(x+y)*(x+y))
(x + y)*(sin(x)*cos(y) + sin(y)*cos(x))</pre> 
</div>
</div>
<a id="affcafce41049c3cf6b4de09e2e53f586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcafce41049c3cf6b4de09e2e53f586">&#9670;&nbsp;</a></span>nfloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.function.nfloat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dkeys</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make all Rationals in expr Floats except those in exponents
(unless the exponents flag is set to True) and those in undefined
functions. When processing dictionaries, do not modify the keys
unless ``dkeys=True``.

Examples
========

&gt;&gt;&gt; from sympy import nfloat, cos, pi, sqrt
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; nfloat(x**4 + x/2 + cos(pi/3) + 1 + sqrt(y))
x**4 + 0.5*x + sqrt(y) + 1.5
&gt;&gt;&gt; nfloat(x**4 + sqrt(y), exponent=True)
x**4.0 + y**0.5

Container types are not modified:

&gt;&gt;&gt; type(nfloat((1, 2))) is tuple
True
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
