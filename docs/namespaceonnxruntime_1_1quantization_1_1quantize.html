<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: onnxruntime.quantization.quantize Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceonnxruntime.html">onnxruntime</a></li><li class="navelem"><a class="el" href="namespaceonnxruntime_1_1quantization.html">quantization</a></li><li class="navelem"><a class="el" href="namespaceonnxruntime_1_1quantization_1_1quantize.html">quantize</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">onnxruntime.quantization.quantize Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1quantization_1_1quantize_1_1QuantConfig.html">QuantConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1quantization_1_1quantize_1_1StaticQuantConfig.html">StaticQuantConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1quantization_1_1quantize_1_1DynamicQuantConfig.html">DynamicQuantConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a28e9801c64d2740ab1c6f96f10dca7f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classonnxruntime_1_1quantization_1_1quantize_1_1StaticQuantConfig.html">StaticQuantConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceonnxruntime_1_1quantization_1_1quantize.html#a28e9801c64d2740ab1c6f96f10dca7f6">get_qdq_config</a> (str|Path|onnx.ModelProto model_input, <a class="el" href="classonnxruntime_1_1quantization_1_1calibrate_1_1CalibrationDataReader.html">CalibrationDataReader</a> calibration_data_reader, calibrate_method=<a class="el" href="classonnxruntime_1_1quantization_1_1calibrate_1_1CalibrationMethod.html#a554f8473db14001a78e35366aa7f704e">CalibrationMethod.MinMax</a>, dict[str, Any]|None calibrate_args=None, activation_type=<a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a8fa19b96e148140d1b46328340833fbe">QuantType.QUInt8</a>, weight_type=<a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a28fa5fa06ceb77e808d6771f97e3e85d">QuantType.QInt8</a>, bool activation_symmetric=False, bool|None weight_symmetric=None, bool per_channel=False, bool reduce_range=False, bool keep_removable_activations=False, float|None min_real_range=None, dict[str, list[dict[str, Any]]]|None tensor_quant_overrides=None, list[str]|None calibration_providers=None, list[str]|None op_types_to_quantize=None, list[str]|Callable[[onnx.ModelProto, onnx.NodeProto], bool]|None nodes_to_exclude=None, dict|None extra_options=None)</td></tr>
<tr class="separator:a28e9801c64d2740ab1c6f96f10dca7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea750641a72895049452acf86b611c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceonnxruntime_1_1quantization_1_1quantize.html#abea750641a72895049452acf86b611c7">check_static_quant_arguments</a> (<a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantFormat.html">QuantFormat</a> quant_format, <a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html">QuantType</a> activation_type, <a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html">QuantType</a> weight_type)</td></tr>
<tr class="separator:abea750641a72895049452acf86b611c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7151dde527eba99f8a49415f9997ccf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceonnxruntime_1_1quantization_1_1quantize.html#ad7151dde527eba99f8a49415f9997ccf">quantize_static</a> (str|Path|onnx.ModelProto model_input, str|Path model_output, <a class="el" href="classonnxruntime_1_1quantization_1_1calibrate_1_1CalibrationDataReader.html">CalibrationDataReader</a> calibration_data_reader, quant_format=<a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantFormat.html#a8f56b75bb0d98dc315e8923d4a8610ce">QuantFormat.QDQ</a>, op_types_to_quantize=None, per_channel=False, reduce_range=False, activation_type=<a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a28fa5fa06ceb77e808d6771f97e3e85d">QuantType.QInt8</a>, weight_type=<a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a28fa5fa06ceb77e808d6771f97e3e85d">QuantType.QInt8</a>, nodes_to_quantize=None, nodes_to_exclude=None, use_external_data_format=False, calibrate_method=<a class="el" href="classonnxruntime_1_1quantization_1_1calibrate_1_1CalibrationMethod.html#a554f8473db14001a78e35366aa7f704e">CalibrationMethod.MinMax</a>, calibration_providers=None, extra_options=None)</td></tr>
<tr class="separator:ad7151dde527eba99f8a49415f9997ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae082b3d8be96f93dba9f8a65497bbe54"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceonnxruntime_1_1quantization_1_1quantize.html#ae082b3d8be96f93dba9f8a65497bbe54">quantize_dynamic</a> (str|Path|onnx.ModelProto model_input, str|Path model_output, op_types_to_quantize=None, per_channel=False, reduce_range=False, weight_type=<a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a28fa5fa06ceb77e808d6771f97e3e85d">QuantType.QInt8</a>, nodes_to_quantize=None, nodes_to_exclude=None, use_external_data_format=False, extra_options=None)</td></tr>
<tr class="separator:ae082b3d8be96f93dba9f8a65497bbe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc00dc0ce9098663ccf0b31647ba36ee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceonnxruntime_1_1quantization_1_1quantize.html#adc00dc0ce9098663ccf0b31647ba36ee">quantize</a> (str|Path|onnx.ModelProto model_input, str|Path model_output, <a class="el" href="classonnxruntime_1_1quantization_1_1quantize_1_1QuantConfig.html">QuantConfig</a> quant_config)</td></tr>
<tr class="separator:adc00dc0ce9098663ccf0b31647ba36ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abea750641a72895049452acf86b611c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea750641a72895049452acf86b611c7">&#9670;&nbsp;</a></span>check_static_quant_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def onnxruntime.quantization.quantize.check_static_quant_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantFormat.html">QuantFormat</a>&#160;</td>
          <td class="paramname"><em>quant_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html">QuantType</a>&#160;</td>
          <td class="paramname"><em>activation_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html">QuantType</a>&#160;</td>
          <td class="paramname"><em>weight_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28e9801c64d2740ab1c6f96f10dca7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e9801c64d2740ab1c6f96f10dca7f6">&#9670;&nbsp;</a></span>get_qdq_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classonnxruntime_1_1quantization_1_1quantize_1_1StaticQuantConfig.html">StaticQuantConfig</a> onnxruntime.quantization.quantize.get_qdq_config </td>
          <td>(</td>
          <td class="paramtype">str | Path | onnx.ModelProto&#160;</td>
          <td class="paramname"><em>model_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classonnxruntime_1_1quantization_1_1calibrate_1_1CalibrationDataReader.html">CalibrationDataReader</a>&#160;</td>
          <td class="paramname"><em>calibration_data_reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>calibrate_method</em> = <code><a class="el" href="classonnxruntime_1_1quantization_1_1calibrate_1_1CalibrationMethod.html#a554f8473db14001a78e35366aa7f704e">CalibrationMethod.MinMax</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>calibrate_args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activation_type</em> = <code><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a8fa19b96e148140d1b46328340833fbe">QuantType.QUInt8</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight_type</em> = <code><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a28fa5fa06ceb77e808d6771f97e3e85d">QuantType.QInt8</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>activation_symmetric</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>weight_symmetric</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>per_channel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>reduce_range</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>keep_removable_activations</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>min_real_range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, list[dict[str, Any]]] | None &#160;</td>
          <td class="paramname"><em>tensor_quant_overrides</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>calibration_providers</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>op_types_to_quantize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | Callable[[onnx.ModelProto, onnx.NodeProto], bool] | None &#160;</td>
          <td class="paramname"><em>nodes_to_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict | None &#160;</td>
          <td class="paramname"><em>extra_options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a configuration suitable that quantizes the entire model to integer precision.

Params:
    model_input: Path to the input model file or ModelProto.
    calibration_data_reader: Calibration data reader.
    calibrate_methode: The calibration method. Defaults to MinMax.
    activation_type: The default activation quantization type. Defaults to QUInt8.
    weight_type: The default weight quantization type. Defaults to QInt8.
    activation_symmetric: True if activations should be quantized symmetrically (i.e, rmax == -rmin) by default.
        Defaults to false. For int8 and int16, this results in zero-point values of 0. For uint8 and uint16,
        the zero-point values are 127 and 32,767, respectively.
    weight_symmetric: True if weights should be quantized symmetrically (i.e., rmax == -rmin) by default.
        Defaults to None. If set to None, weight_symmetric is assumed true if a weight's quant type is a signed int.
    per_channel: Global option that determines if a fixed set of operator types should be quantized per-channel.
        Defaults to false. Alternatively, use the tensor-level `tensor_quant_overrides` to select individual operators
        and their quantization axes.
    reduce_range: quantize weights with 1 less bit of precision (e.g., 7 bits for QInt8). Defaults to false.
        May improve the accuracy for some models running on non-VNNI machine, especially for per-channel mode.
    keep_removable_activations: Defaults to false. If true, "removable" activations (e.g., Clip or Relu) will not
                    be removed, and will be explicitly represented in the QDQ model. If false, these activations
                    are automatically removed if activations are asymmetrically quantized. Keeping these activations
                    is necessary if optimizations or EP transformations will later remove
                    QuantizeLinear/DequantizeLinear operators from the model.
    min_real_range: Default is None. If set to a floating-point value, the calculation of the quantization parameters
        (i.e., scale and zero point) will enforce a minimum range between rmin and rmax. If (rmax - rmin)
        is less than the specified minimum range, rmax will be set to rmin + min_real_range.
    tensor_quant_overrides: tensor-level quantization overrides. Defaults to None.
        The key is a tensor name and the value is a list of dictionaries. For per-tensor quantization, the list
        contains a single dictionary. For per-channel quantization, the list contains either a dictionary for
        each channel in the tensor or a single dictionary that is assumed to apply to all channels. An 'axis'
        key must be present in the first dictionary for per-channel quantization.

        Each dictionary contains optional overrides with the following keys and values.
            'quant_type' = QuantType : The tensor's quantization data type.
            'axis' = Int             : The per-channel axis. Must be present for per-channel weights.
            'scale' =  Float         : The scale value to use. Must also specify `zero_point` if set.
            'zero_point' = Int       : The zero-point value to use. Must also specify `scale` is set.
            'symmetric' = Bool       : If the tensor should use symmetric quantization. Invalid if also
                                        set `scale` or `zero_point`.
            'reduce_range' = Bool    : If the quantization range should be reduced. Invalid if also
                                        set `scale` or `zero_point`. Only valid for initializers.
            'rmax' = Float           : Override the maximum real tensor value in calibration data.
                                        Invalid if also set `scale` or `zero_point`.
            'rmin' = Float           : Override the minimum real tensor value in calibration data.
                                        Invalid if also set `scale` or `zero_point`.
            'convert' = Dict         : A nested dictionary with the same keys for an activation
                                       tensor that should be converted to another quantization type.
            'convert["recv_nodes"] = Set : Set of node names that consume the converted activation,
                                           other nodes get the original type. If not specified,
                                           assume all consumer nodes get the converted type.
    calibration_providers: Execution providers to run the session during calibration. Default is None which uses
        [ "CPUExecutionProvider" ].
    op_types_to_quantize: List of operator types to quantize. If None, all operators other than Cast, DequantizeLinear,
        and QuantizeLinear are quantized.
    nodes_to_exclude: List of nodes names to exclude from quantization. Alternatively, can provide a function that
        accepts an onnx.ModelProto and onnx.NodeProto as arguments and returns true if the give onnx.NodeProto
        should be excluded from quantization.
    extra_options: Additional options specified as string key/value pairs. Refer to the documentation for
        `quantize_static` for valid keys and values.

Returns:
    A StaticQuantConfig object
</pre> 
</div>
</div>
<a id="adc00dc0ce9098663ccf0b31647ba36ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc00dc0ce9098663ccf0b31647ba36ee">&#9670;&nbsp;</a></span>quantize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def onnxruntime.quantization.quantize.quantize </td>
          <td>(</td>
          <td class="paramtype">str | Path | onnx.ModelProto&#160;</td>
          <td class="paramname"><em>model_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | Path&#160;</td>
          <td class="paramname"><em>model_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classonnxruntime_1_1quantization_1_1quantize_1_1QuantConfig.html">QuantConfig</a>&#160;</td>
          <td class="paramname"><em>quant_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Quantize a model with QuantConfig.

Args:
    model_input (str | Path | ModelProto): Path to the model or ModelProto to quantize.
    model_output (str | Path): Path to save the quantized model.
    quant_config (QuantConfig | WeightOnlyQuantConfig): Quantization Configuration.
</pre> 
</div>
</div>
<a id="ae082b3d8be96f93dba9f8a65497bbe54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae082b3d8be96f93dba9f8a65497bbe54">&#9670;&nbsp;</a></span>quantize_dynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def onnxruntime.quantization.quantize.quantize_dynamic </td>
          <td>(</td>
          <td class="paramtype">str | Path | onnx.ModelProto&#160;</td>
          <td class="paramname"><em>model_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | Path&#160;</td>
          <td class="paramname"><em>model_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>op_types_to_quantize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>per_channel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reduce_range</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight_type</em> = <code><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a28fa5fa06ceb77e808d6771f97e3e85d">QuantType.QInt8</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes_to_quantize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes_to_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_external_data_format</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra_options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given an onnx model, create a quantized onnx model and save it into a file

Args:
    model_input: file path of model or ModelProto to quantize
    model_output: file path of quantized model
    op_types_to_quantize:
        specify the types of operators to quantize, like ['Conv'] to quantize Conv only.
        It quantizes all supported operators by default.
    per_channel: quantize weights per channel
    reduce_range:
        quantize weights with 7-bits. It may improve the accuracy for some models running on non-VNNI machine,
        especially for per-channel mode
    weight_type:
        quantization data type of weight. Please refer to
        https://onnxruntime.ai/docs/performance/quantization.html for more details on data type selection
    nodes_to_quantize:
        List of nodes names to quantize. When this list is not None only the nodes in this list
        are quantized.
        example:
        [
            'Conv__224',
            'Conv__252'
        ]
    nodes_to_exclude:
        List of nodes names to exclude. The nodes in this list will be excluded from quantization
        when it is not None.
    use_external_data_format: option used for large size (&gt;2GB) model. Set to False by default.
    extra_options:
        key value pair dictionary for various options in different case. Current used:
            extra.Sigmoid.nnapi = True/False  (Default is False)
            ActivationSymmetric = True/False: symmetrize calibration data for activations (default is False).
            WeightSymmetric = True/False: symmetrize calibration data for weights (default is True).
            EnableSubgraph = True/False :
                Default is False. If enabled, subgraph will be quantized. Dynamic mode currently is supported. Will
                support more in the future.
            ForceQuantizeNoInputCheck = True/False :
                By default, some latent operators like maxpool, transpose, do not quantize if their input is not
                quantized already. Setting to True to force such operator always quantize input and so generate
                quantized output. Also the True behavior could be disabled per node using the nodes_to_exclude.
            MatMulConstBOnly = True/False:
                Default is True for dynamic mode. If enabled, only MatMul with const B will be quantized.
</pre> 
</div>
</div>
<a id="ad7151dde527eba99f8a49415f9997ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7151dde527eba99f8a49415f9997ccf">&#9670;&nbsp;</a></span>quantize_static()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def onnxruntime.quantization.quantize.quantize_static </td>
          <td>(</td>
          <td class="paramtype">str | Path | onnx.ModelProto&#160;</td>
          <td class="paramname"><em>model_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | Path&#160;</td>
          <td class="paramname"><em>model_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classonnxruntime_1_1quantization_1_1calibrate_1_1CalibrationDataReader.html">CalibrationDataReader</a>&#160;</td>
          <td class="paramname"><em>calibration_data_reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>quant_format</em> = <code><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantFormat.html#a8f56b75bb0d98dc315e8923d4a8610ce">QuantFormat.QDQ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>op_types_to_quantize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>per_channel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reduce_range</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activation_type</em> = <code><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a28fa5fa06ceb77e808d6771f97e3e85d">QuantType.QInt8</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight_type</em> = <code><a class="el" href="classonnxruntime_1_1quantization_1_1quant__utils_1_1QuantType.html#a28fa5fa06ceb77e808d6771f97e3e85d">QuantType.QInt8</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes_to_quantize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes_to_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_external_data_format</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>calibrate_method</em> = <code><a class="el" href="classonnxruntime_1_1quantization_1_1calibrate_1_1CalibrationMethod.html#a554f8473db14001a78e35366aa7f704e">CalibrationMethod.MinMax</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>calibration_providers</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra_options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given an onnx model and calibration data reader, create a quantized onnx model and save it into a file
It is recommended to use QuantFormat.QDQ format from 1.11 with activation_type = QuantType.QInt8 and weight_type
= QuantType.QInt8. If model is targeted to GPU/TRT, symmetric activation and weight are required. If model is
targeted to CPU, asymmetric activation and symmetric weight are recommended for balance of performance and
accuracy.

Args:

    model_input: file path of model or ModelProto to quantize
    model_output: file path of quantized model
    calibration_data_reader: a calibration data reader. It
        enumerates calibration data and generates inputs for the
        original model.
    quant_format: QuantFormat{QOperator, QDQ}.
        QOperator format quantizes the model with quantized operators directly.
        QDQ format quantize the model by inserting QuantizeLinear/DeQuantizeLinear on the tensor.
    activation_type:
        quantization data type of activation. Please refer to
        https://onnxruntime.ai/docs/performance/quantization.html for more details on data type selection
    calibrate_method:
        Current calibration methods supported are MinMax and Entropy.
            Please use CalibrationMethod.MinMax or CalibrationMethod.Entropy as options.
    op_types_to_quantize:
            specify the types of operators to quantize, like ['Conv'] to quantize Conv only.
            It quantizes all supported operators by default.
    per_channel: quantize weights per channel
    reduce_range:
        quantize weights with 7-bits. It may improve the accuracy for some models running on non-VNNI machine,
        especially for per-channel mode
    weight_type:
        quantization data type of weight. Please refer to
        https://onnxruntime.ai/docs/performance/quantization.html for more details on data type selection
    nodes_to_quantize:
        List of nodes names to quantize. When this list is not None only the nodes in this list
        are quantized.
        example:
        [
            'Conv__224',
            'Conv__252'
        ]
    nodes_to_exclude:
        List of nodes names to exclude. The nodes in this list will be excluded from quantization
        when it is not None.
    use_external_data_format: option used for large size (&gt;2GB) model. Set to False by default.
    calibration_providers: Execution providers to run the session during calibration. Default is None which uses
        [ "CPUExecutionProvider" ]
    extra_options:
        key value pair dictionary for various options in different case. Current used:
            extra.Sigmoid.nnapi = True/False  (Default is False)
            ActivationSymmetric = True/False: symmetrize calibration data for activations (default is False).
            WeightSymmetric = True/False: symmetrize calibration data for weights (default is True).
            EnableSubgraph = True/False : Default is False. If enabled, subgraph will be quantized.
                                          Dyanmic mode currently is supported. Will support more in the future.
            ForceQuantizeNoInputCheck = True/False :
                By default, some latent operators like maxpool, transpose, do not quantize if their input is not
                quantized already. Setting to True to force such operator always quantize input and so generate
                quantized output. Also, the True behavior could be disabled per node using the nodes_to_exclude.
            MatMulConstBOnly = True/False:
                Default is False for static mode. If enabled, only MatMul with const B will be quantized.
            AddQDQPairToWeight = True/False :
                Default is False which quantizes floating-point weight and feeds it to solely inserted
                DeQuantizeLinear node. If True, it remains floating-point weight and inserts both
                QuantizeLinear/DeQuantizeLinear nodes to weight.
            OpTypesToExcludeOutputQuantization = list of op type :
                Default is []. If any op type is specified, it won't quantize the output of ops with this
                specific op types.
            DedicatedQDQPair = True/False :
                Default is False. When inserting QDQ pair, multiple nodes can share a single QDQ pair as their
                inputs. If True, it will create identical and dedicated QDQ pair for each node.
            QDQOpTypePerChannelSupportToAxis = dictionary :
                Default is {}. Set channel axis for specific op type, for example: {'MatMul': 1}, and it's
                effective only when per channel quantization is supported and per_channel is True. If specific
                op type supports per channel quantization but not explicitly specified with channel axis,
                default channel axis will be used.
            CalibTensorRangeSymmetric = True/False :
                Default is False. If enabled, the final range of tensor during calibration will be explicitly
                set to symmetric to central point "0".
            CalibStridedMinMax = Optional[int] :
                Default is None. If set to an integer, during calculation of the min-max, only stride amount of
                data will be used and then all results will be merged in the end.
            CalibMovingAverage = True/False :
                Default is False. If enabled, the moving average of the minimum and maximum values will be
                computed when the calibration method selected is MinMax.
            CalibMovingAverageConstant = float :
                Default is 0.01. Constant smoothing factor to use when computing the moving average of the
                minimum and maximum values. Effective only when the calibration method selected is MinMax and
                when CalibMovingAverage is set to True.
            CalibMaxIntermediateOutputs = Optional[int] :
                Default is None. If set to an integer, during calculation of the min-max range of the tensors
                it will load at max value number of outputs before computing and merging the range. This will
                produce the same result as all computing with None, but is more memory efficient.
            SmoothQuant = True/False :
                Default is False. If enabled, SmoothQuant algorithm will be applied before quantization to do
                fake input channel quantization.
            SmoothQuantAlpha = float :
                Default is 0.5. It only works if SmoothQuant is True. It controls the difficulty of weight
                and activation quantization. A larger alpha value could be used on models with more significant
                activation outliers to migrate more quantization difficulty to weights.
            SmoothQuantFolding = True/False :
                Default is True. It only works if SmoothQuant is True. If enabled, inserted Mul ops during
                SmoothQuant will be folded into the previous op if the previous op is foldable.
            UseQDQContribOps = True/False :
                Default is False. If enabled, the inserted QuantizeLinear and DequantizeLinear ops will have the
                `com.microsoft` domain, which forces use of ONNX Runtime's QuantizeLinear and DequantizeLinear
                contrib op implementations. The contrib op implementations may support features not standardized
                into the ONNX specification (e.g., 16-bit quantization types).
            MinimumRealRange = float|None :
                Default is None. If set to a floating-point value, the calculation of the quantization parameters
                (i.e., scale and zero point) will enforce a minimum range between rmin and rmax. If (rmax - rmin)
                is less than the specified minimum range, rmax will be set to rmin + MinimumRealRange. This is
                necessary for EPs like QNN that require a minimum floating-point range when determining
                quantization parameters.
            TensorQuantOverrides = dictionary :
                Default is {}. Set tensor quantization overrides. The key is a tensor name and the value is a
                list of dictionaries. For per-tensor quantization, the list contains a single dictionary. For
                per-channel quantization, the list contains a dictionary for each channel in the tensor.
                Each dictionary contains optional overrides with the following keys and values.
                    'quant_type' = QuantType : The tensor's quantization data type.
                    'scale' =  Float         : The scale value to use. Must also specify `zero_point` if set.
                    'zero_point' = Int       : The zero-point value to use. Must also specify `scale` is set.
                    'symmetric' = Bool       : If the tensor should use symmetric quantization. Invalid if also
                                               set `scale` or `zero_point`.
                    'reduce_range' = Bool    : If the quantization range should be reduced. Invalid if also
                                               set `scale` or `zero_point`.
                    'rmax' = Float           : Override the maximum real tensor value in calibration data.
                                               Invalid if also set `scale` or `zero_point`.
                    'rmin' = Float           : Override the minimum real tensor value in calibration data.
                                               Invalid if also set `scale` or `zero_point`.
            QDQKeepRemovableActivations = True/False:
                Default is False. If true, "removable" activations (e.g., Clip or Relu) will not be removed, and
                will be explicitly represented in the QDQ model. If false, these activations are automatically
                removed if activations are asymmetrically quantized. Keeping these activations is necessary if
                optimizations or EP transformations will later remove QuantizeLinear/DequantizeLinear
                operators from the model.
            QDQDisableWeightAdjustForInt32Bias = True/False:
                Default is False. If true, QDQ quantizer will not adjust the weight's scale when the bias
                has a scale (input_scale * weight_scale) that is too small.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
