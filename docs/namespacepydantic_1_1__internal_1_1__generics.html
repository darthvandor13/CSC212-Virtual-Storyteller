<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: pydantic._internal._generics Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepydantic.html">pydantic</a></li><li class="navelem"><a class="el" href="namespacepydantic_1_1__internal.html">_internal</a></li><li class="navelem"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html">_generics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pydantic._internal._generics Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1__internal_1_1__generics_1_1LimitedDict.html">LimitedDict</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1__internal_1_1__generics_1_1DeepChainMap.html">DeepChainMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1__internal_1_1__generics_1_1PydanticGenericMetadata.html">PydanticGenericMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afcded858103d896453101e13b29d2a9b"><td class="memItemLeft" align="right" valign="top">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#afcded858103d896453101e13b29d2a9b">create_generic_submodel</a> (str model_name, type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] origin, tuple[Any,...] args, tuple[Any,...] params)</td></tr>
<tr class="separator:afcded858103d896453101e13b29d2a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e72b4bc6889cef434bb6ffd83d61bc"><td class="memItemLeft" align="right" valign="top">Iterator[TypeVar]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a91e72b4bc6889cef434bb6ffd83d61bc">iter_contained_typevars</a> (Any v)</td></tr>
<tr class="separator:a91e72b4bc6889cef434bb6ffd83d61bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0864ca443cab43442ffd3e82f39fb5"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a2c0864ca443cab43442ffd3e82f39fb5">get_args</a> (Any v)</td></tr>
<tr class="separator:a2c0864ca443cab43442ffd3e82f39fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85d9b6eb08e2fbd8bfd78430e92edd7"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#aa85d9b6eb08e2fbd8bfd78430e92edd7">get_origin</a> (Any v)</td></tr>
<tr class="separator:aa85d9b6eb08e2fbd8bfd78430e92edd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f63b9cae8e839cd0f0237583dd02c8"><td class="memItemLeft" align="right" valign="top">dict[TypeVar, Any]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#ae5f63b9cae8e839cd0f0237583dd02c8">get_standard_typevars_map</a> (Any cls)</td></tr>
<tr class="separator:ae5f63b9cae8e839cd0f0237583dd02c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dab9794ade8386bed3975ec7a1c3f8"><td class="memItemLeft" align="right" valign="top">dict[TypeVar, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#af8dab9794ade8386bed3975ec7a1c3f8">get_model_typevars_map</a> (type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] cls)</td></tr>
<tr class="separator:af8dab9794ade8386bed3975ec7a1c3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf393e8a431474b872c9096a8e99fadd"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#abf393e8a431474b872c9096a8e99fadd">replace_types</a> (Any type_, Mapping[TypeVar, Any]|None type_map)</td></tr>
<tr class="separator:abf393e8a431474b872c9096a8e99fadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988383c2fcc5e45381e7a3246650d212"><td class="memItemLeft" align="right" valign="top">dict[TypeVar, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a988383c2fcc5e45381e7a3246650d212">map_generic_model_arguments</a> (type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] cls, tuple[Any,...] args)</td></tr>
<tr class="separator:a988383c2fcc5e45381e7a3246650d212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b120c91cf4df0a83a1cea779288b53"><td class="memItemLeft" align="right" valign="top">Iterator[<a class="el" href="classpydantic_1_1__internal_1_1__forward__ref_1_1PydanticRecursiveRef.html">PydanticRecursiveRef</a>|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a05b120c91cf4df0a83a1cea779288b53">generic_recursion_self_type</a> (type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] origin, tuple[Any,...] args)</td></tr>
<tr class="separator:a05b120c91cf4df0a83a1cea779288b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e6abceadaad8d39b24555f71afe7d9"><td class="memItemLeft" align="right" valign="top">set[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a58e6abceadaad8d39b24555f71afe7d9">recursively_defined_type_refs</a> ()</td></tr>
<tr class="separator:a58e6abceadaad8d39b24555f71afe7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9314192feecb986c1a784369b212fa"><td class="memItemLeft" align="right" valign="top">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a3c9314192feecb986c1a784369b212fa">get_cached_generic_type_early</a> (type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] parent, Any typevar_values)</td></tr>
<tr class="separator:a3c9314192feecb986c1a784369b212fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c055e35886a98db1334e04fc60f8be0"><td class="memItemLeft" align="right" valign="top">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a1c055e35886a98db1334e04fc60f8be0">get_cached_generic_type_late</a> (type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] parent, Any typevar_values, type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] origin, tuple[Any,...] args)</td></tr>
<tr class="separator:a1c055e35886a98db1334e04fc60f8be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9d4dadc5ba7a3027f43620754c00c6"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a3a9d4dadc5ba7a3027f43620754c00c6">set_cached_generic_type</a> (type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] parent, tuple[Any,...] typevar_values, type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] type_, type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]|None origin=None, tuple[Any,...]|None args=None)</td></tr>
<tr class="separator:a3a9d4dadc5ba7a3027f43620754c00c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ae68a8555849ed9a1efc4f64dc5892"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a37ae68a8555849ed9a1efc4f64dc5892">replace_types</a> (Any type_, Mapping[Any, Any]|None type_map)</td></tr>
<tr class="separator:a37ae68a8555849ed9a1efc4f64dc5892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae296bbfcd220e62daa2326f7253e5d6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#ae296bbfcd220e62daa2326f7253e5d6c">has_instance_in_type</a> (Any type_, Any isinstance_target)</td></tr>
<tr class="separator:ae296bbfcd220e62daa2326f7253e5d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5813fe8c98d602ef8bc34473a802affc"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a5813fe8c98d602ef8bc34473a802affc">check_parameters_count</a> (type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] cls, tuple[Any,...] parameters)</td></tr>
<tr class="separator:a5813fe8c98d602ef8bc34473a802affc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af66dce654d9513143523a13ddec1ff64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#af66dce654d9513143523a13ddec1ff64">GenericTypesCacheKey</a> = tuple[Any, Any, tuple[Any, ...]]</td></tr>
<tr class="separator:af66dce654d9513143523a13ddec1ff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9105fc49941fc60b0585824ef933bd48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a9105fc49941fc60b0585824ef933bd48">KT</a> = TypeVar('KT')</td></tr>
<tr class="separator:a9105fc49941fc60b0585824ef933bd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041e256fadbac3133f8d1c4dab1df1f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a041e256fadbac3133f8d1c4dab1df1f2">VT</a> = TypeVar('VT')</td></tr>
<tr class="separator:a041e256fadbac3133f8d1c4dab1df1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a759bcb29ba97f166450d257693259"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#a39a759bcb29ba97f166450d257693259">GenericTypesCache</a> = WeakValueDictionary[<a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#af66dce654d9513143523a13ddec1ff64">GenericTypesCacheKey</a>, 'type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]']</td></tr>
<tr class="separator:a39a759bcb29ba97f166450d257693259"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5813fe8c98d602ef8bc34473a802affc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5813fe8c98d602ef8bc34473a802affc">&#9670;&nbsp;</a></span>check_parameters_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic._internal._generics.check_parameters_count </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...]&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check the generic model parameters count is equal.

Args:
    cls: The generic model.
    parameters: A tuple of passed parameters to the generic model.

Raises:
    TypeError: If the passed parameters count is not equal to generic model parameters count.
</pre> 
</div>
</div>
<a id="afcded858103d896453101e13b29d2a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcded858103d896453101e13b29d2a9b">&#9670;&nbsp;</a></span>create_generic_submodel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] pydantic._internal._generics.create_generic_submodel </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...]&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...]
&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dynamically create a submodel of a provided (generic) BaseModel.

This is used when producing concrete parametrizations of generic models. This function
only *creates* the new subclass; the schema/validators/serialization must be updated to
reflect a concrete parametrization elsewhere.

Args:
    model_name: The name of the newly created model.
    origin: The base class for the new model to inherit from.
    args: A tuple of generic metadata arguments.
    params: A tuple of generic metadata parameters.

Returns:
    The created submodel.
</pre> 
</div>
</div>
<a id="a05b120c91cf4df0a83a1cea779288b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b120c91cf4df0a83a1cea779288b53">&#9670;&nbsp;</a></span>generic_recursion_self_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[<a class="el" href="classpydantic_1_1__internal_1_1__forward__ref_1_1PydanticRecursiveRef.html">PydanticRecursiveRef</a> | None] pydantic._internal._generics.generic_recursion_self_type </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...]
&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This contextmanager should be placed around the recursive calls used to build a generic type,
and accept as arguments the generic origin type and the type arguments being passed to it.

If the same origin and arguments are observed twice, it implies that a self-reference placeholder
can be used while building the core schema, and will produce a schema_ref that will be valid in the
final parent schema.
</pre> 
</div>
</div>
<a id="a2c0864ca443cab43442ffd3e82f39fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0864ca443cab43442ffd3e82f39fb5">&#9670;&nbsp;</a></span>get_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Any pydantic._internal._generics.get_args </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c9314192feecb986c1a784369b212fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9314192feecb986c1a784369b212fa">&#9670;&nbsp;</a></span>get_cached_generic_type_early()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] | None pydantic._internal._generics.get_cached_generic_type_early </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>typevar_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The use of a two-stage cache lookup approach was necessary to have the highest performance possible for
repeated calls to `__class_getitem__` on generic types (which may happen in tighter loops during runtime),
while still ensuring that certain alternative parametrizations ultimately resolve to the same type.

As a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]].
The approach could be modified to not use two different cache keys at different points, but the
_early_cache_key is optimized to be as quick to compute as possible (for repeated-access speed), and the
_late_cache_key is optimized to be as "correct" as possible, so that two types that will ultimately be the
same after resolving the type arguments will always produce cache hits.

If we wanted to move to only using a single cache key per type, we would either need to always use the
slower/more computationally intensive logic associated with _late_cache_key, or would need to accept
that Model[List[T]][int] is a different type than Model[List[T]][int]. Because we rely on subclass relationships
during validation, I think it is worthwhile to ensure that types that are functionally equivalent are actually
equal.
</pre> 
</div>
</div>
<a id="a1c055e35886a98db1334e04fc60f8be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c055e35886a98db1334e04fc60f8be0">&#9670;&nbsp;</a></span>get_cached_generic_type_late()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] | None pydantic._internal._generics.get_cached_generic_type_late </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>typevar_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...]
&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">See the docstring of `get_cached_generic_type_early` for more information about the two-stage cache lookup.</pre> 
</div>
</div>
<a id="af8dab9794ade8386bed3975ec7a1c3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8dab9794ade8386bed3975ec7a1c3f8">&#9670;&nbsp;</a></span>get_model_typevars_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[TypeVar, Any] pydantic._internal._generics.get_model_typevars_map </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Package a generic BaseModel's typevars and concrete parametrization (if present) into a dictionary compatible
with the `replace_types` function.

Since BaseModel.__class_getitem__ does not produce a typing._GenericAlias, and the BaseModel generic info is
stored in the __pydantic_generic_metadata__ attribute, we need special handling here.
</pre> 
</div>
</div>
<a id="aa85d9b6eb08e2fbd8bfd78430e92edd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85d9b6eb08e2fbd8bfd78430e92edd7">&#9670;&nbsp;</a></span>get_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Any pydantic._internal._generics.get_origin </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5f63b9cae8e839cd0f0237583dd02c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f63b9cae8e839cd0f0237583dd02c8">&#9670;&nbsp;</a></span>get_standard_typevars_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[TypeVar, Any] | None pydantic._internal._generics.get_standard_typevars_map </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Package a generic type's typevars and parametrization (if present) into a dictionary compatible with the
`replace_types` function. Specifically, this works with standard typing generics and typing._GenericAlias.
</pre> 
</div>
</div>
<a id="ae296bbfcd220e62daa2326f7253e5d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae296bbfcd220e62daa2326f7253e5d6c">&#9670;&nbsp;</a></span>has_instance_in_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._generics.has_instance_in_type </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>type_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>isinstance_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if the type, or any of its arbitrary nested args, satisfy
`isinstance(&lt;type&gt;, isinstance_target)`.
</pre> 
</div>
</div>
<a id="a91e72b4bc6889cef434bb6ffd83d61bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e72b4bc6889cef434bb6ffd83d61bc">&#9670;&nbsp;</a></span>iter_contained_typevars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[TypeVar] pydantic._internal._generics.iter_contained_typevars </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.

This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,
since __parameters__ of (nested) generic BaseModel subclasses won't show up in that list.
</pre> 
</div>
</div>
<a id="a988383c2fcc5e45381e7a3246650d212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988383c2fcc5e45381e7a3246650d212">&#9670;&nbsp;</a></span>map_generic_model_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[TypeVar, Any] pydantic._internal._generics.map_generic_model_arguments </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...]&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a mapping between the parameters of a generic model and the provided arguments during parameterization.

Raises:
    TypeError: If the number of arguments does not match the parameters (i.e. if providing too few or too many arguments).

Example:
    ```python {test="skip" lint="skip"}
    class Model[T, U, V = int](BaseModel): ...

    map_generic_model_arguments(Model, (str, bytes))
    #&gt; {T: str, U: bytes, V: int}

    map_generic_model_arguments(Model, (str,))
    #&gt; TypeError: Too few arguments for &lt;class '__main__.Model'&gt;; actual 1, expected at least 2

    map_generic_model_arguments(Model, (str, bytes, int, complex))
    #&gt; TypeError: Too many arguments for &lt;class '__main__.Model'&gt;; actual 4, expected 3
    ```

Note:
    This function is analogous to the private `typing._check_generic_specialization` function.
</pre> 
</div>
</div>
<a id="a58e6abceadaad8d39b24555f71afe7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e6abceadaad8d39b24555f71afe7d9">&#9670;&nbsp;</a></span>recursively_defined_type_refs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> set[str] pydantic._internal._generics.recursively_defined_type_refs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37ae68a8555849ed9a1efc4f64dc5892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ae68a8555849ed9a1efc4f64dc5892">&#9670;&nbsp;</a></span>replace_types() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic._internal._generics.replace_types </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>type_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[Any, Any] | None&#160;</td>
          <td class="paramname"><em>type_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return type with all occurrences of `type_map` keys recursively replaced with their values.

Args:
    type_: The class or generic alias.
    type_map: Mapping from `TypeVar` instance to concrete types.

Returns:
    A new type representing the basic structure of `type_` with all
    `typevar_map` keys recursively replaced.

Example:
    ```python
    from typing import List, Tuple, Union

    from pydantic._internal._generics import replace_types

    replace_types(Tuple[str, Union[List[str], float]], {str: int})
    #&gt; Tuple[int, Union[List[int], float]]
    ```
</pre> 
</div>
</div>
<a id="abf393e8a431474b872c9096a8e99fadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf393e8a431474b872c9096a8e99fadd">&#9670;&nbsp;</a></span>replace_types() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic._internal._generics.replace_types </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>type_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[TypeVar, Any] | None&#160;</td>
          <td class="paramname"><em>type_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return type with all occurrences of `type_map` keys recursively replaced with their values.

Args:
    type_: The class or generic alias.
    type_map: Mapping from `TypeVar` instance to concrete types.

Returns:
    A new type representing the basic structure of `type_` with all
    `typevar_map` keys recursively replaced.

Example:
    ```python
    from typing import List, Union

    from pydantic._internal._generics import replace_types

    replace_types(tuple[str, Union[List[str], float]], {str: int})
    #&gt; tuple[int, Union[List[int], float]]
    ```
</pre> 
</div>
</div>
<a id="a3a9d4dadc5ba7a3027f43620754c00c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9d4dadc5ba7a3027f43620754c00c6">&#9670;&nbsp;</a></span>set_cached_generic_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None pydantic._internal._generics.set_cached_generic_type </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...]&#160;</td>
          <td class="paramname"><em>typevar_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>type_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] | None &#160;</td>
          <td class="paramname"><em>origin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...] | None &#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">See the docstring of `get_cached_generic_type_early` for more information about why items are cached with
two different keys.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a39a759bcb29ba97f166450d257693259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a759bcb29ba97f166450d257693259">&#9670;&nbsp;</a></span>GenericTypesCache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._generics.GenericTypesCache = WeakValueDictionary[<a class="el" href="namespacepydantic_1_1__internal_1_1__generics.html#af66dce654d9513143523a13ddec1ff64">GenericTypesCacheKey</a>, 'type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af66dce654d9513143523a13ddec1ff64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66dce654d9513143523a13ddec1ff64">&#9670;&nbsp;</a></span>GenericTypesCacheKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._generics.GenericTypesCacheKey = tuple[Any, Any, tuple[Any, ...]]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9105fc49941fc60b0585824ef933bd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9105fc49941fc60b0585824ef933bd48">&#9670;&nbsp;</a></span>KT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._generics.KT = TypeVar('KT')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a041e256fadbac3133f8d1c4dab1df1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041e256fadbac3133f8d1c4dab1df1f2">&#9670;&nbsp;</a></span>VT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._generics.VT = TypeVar('VT')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
