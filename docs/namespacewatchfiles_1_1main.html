<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: watchfiles.main Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewatchfiles.html">watchfiles</a></li><li class="navelem"><a class="el" href="namespacewatchfiles_1_1main.html">main</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">watchfiles.main Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwatchfiles_1_1main_1_1Change.html">Change</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwatchfiles_1_1main_1_1AbstractEvent.html">AbstractEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab9ffaeaeda84fd36a08cb42db815a850"><td class="memItemLeft" align="right" valign="top">Generator[Set[<a class="el" href="namespacewatchfiles_1_1main.html#ad59f9dd6e602b9e23984646e8c0e152a">FileChange</a>], None, None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewatchfiles_1_1main.html#ab9ffaeaeda84fd36a08cb42db815a850">watch</a> (*Union[Path, str] paths, Optional[Callable[['<a class="el" href="classwatchfiles_1_1main_1_1Change.html">Change</a>', str], bool]] watch_filter=<a class="el" href="classwatchfiles_1_1filters_1_1DefaultFilter.html">DefaultFilter</a>(), int debounce=1_600, int step=50, Optional['<a class="el" href="classwatchfiles_1_1main_1_1AbstractEvent.html">AbstractEvent</a>'] stop_event=None, int rust_timeout=5_000, bool yield_on_timeout=False, Optional[bool] debug=None, bool raise_interrupt=True, Optional[bool] force_polling=None, int poll_delay_ms=300, bool recursive=True, Optional[bool] ignore_permission_denied=None)</td></tr>
<tr class="separator:ab9ffaeaeda84fd36a08cb42db815a850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5d598a83b52f3023c2a78950410410"><td class="memItemLeft" align="right" valign="top">AsyncGenerator[Set[<a class="el" href="namespacewatchfiles_1_1main.html#ad59f9dd6e602b9e23984646e8c0e152a">FileChange</a>], None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewatchfiles_1_1main.html#ade5d598a83b52f3023c2a78950410410">awatch</a> (*Union[Path, str] paths, Optional[Callable[[<a class="el" href="classwatchfiles_1_1main_1_1Change.html">Change</a>, str], bool]] watch_filter=<a class="el" href="classwatchfiles_1_1filters_1_1DefaultFilter.html">DefaultFilter</a>(), int debounce=1_600, int step=50, Optional['<a class="el" href="namespacewatchfiles_1_1main.html#a91df05be85a66e827734437129d2edf5">AnyEvent</a>'] stop_event=None, Optional[int] rust_timeout=None, bool yield_on_timeout=False, Optional[bool] debug=None, Optional[bool] raise_interrupt=None, Optional[bool] force_polling=None, int poll_delay_ms=300, bool recursive=True, Optional[bool] ignore_permission_denied=None)</td></tr>
<tr class="separator:ade5d598a83b52f3023c2a78950410410"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a88297abb09f6ecec1bbcb9bf2d9cbc9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewatchfiles_1_1main.html#a88297abb09f6ecec1bbcb9bf2d9cbc9b">logger</a> = logging.getLogger('watchfiles.main')</td></tr>
<tr class="separator:a88297abb09f6ecec1bbcb9bf2d9cbc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f9dd6e602b9e23984646e8c0e152a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewatchfiles_1_1main.html#ad59f9dd6e602b9e23984646e8c0e152a">FileChange</a> = Tuple[<a class="el" href="classwatchfiles_1_1main_1_1Change.html">Change</a>, str]</td></tr>
<tr class="separator:ad59f9dd6e602b9e23984646e8c0e152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91df05be85a66e827734437129d2edf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewatchfiles_1_1main.html#a91df05be85a66e827734437129d2edf5">AnyEvent</a> = Union[<a class="el" href="classanyio_1_1__core_1_1__synchronization_1_1Event.html">anyio.Event</a>, asyncio.Event, trio.Event]</td></tr>
<tr class="separator:a91df05be85a66e827734437129d2edf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ade5d598a83b52f3023c2a78950410410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5d598a83b52f3023c2a78950410410">&#9670;&nbsp;</a></span>awatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> AsyncGenerator[Set[<a class="el" href="namespacewatchfiles_1_1main.html#ad59f9dd6e602b9e23984646e8c0e152a">FileChange</a>], None] watchfiles.main.awatch </td>
          <td>(</td>
          <td class="paramtype">*Union[Path, str]&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Callable[[<a class="el" href="classwatchfiles_1_1main_1_1Change.html">Change</a>, str], bool]] &#160;</td>
          <td class="paramname"><em>watch_filter</em> = <code><a class="el" href="classwatchfiles_1_1filters_1_1DefaultFilter.html">DefaultFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>debounce</em> = <code>1_600</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>step</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional['<a class="el" href="namespacewatchfiles_1_1main.html#a91df05be85a66e827734437129d2edf5">AnyEvent</a>'] &#160;</td>
          <td class="paramname"><em>stop_event</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int] &#160;</td>
          <td class="paramname"><em>rust_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>yield_on_timeout</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>debug</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>raise_interrupt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>force_polling</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>poll_delay_ms</em> = <code>300</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>recursive</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>ignore_permission_denied</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Asynchronous equivalent of [`watch`][watchfiles.watch] using threads to wait for changes.
Arguments match those of [`watch`][watchfiles.watch] except `stop_event`.

All async methods use [anyio](https://anyio.readthedocs.io/en/latest/) to run the event loop.

Unlike [`watch`][watchfiles.watch] `KeyboardInterrupt` cannot be suppressed by `awatch` so they need to be caught
where `asyncio.run` or equivalent is called.

Args:
    *paths: filesystem paths to watch.
    watch_filter: matches the same argument of [`watch`][watchfiles.watch].
    debounce: matches the same argument of [`watch`][watchfiles.watch].
    step: matches the same argument of [`watch`][watchfiles.watch].
    stop_event: `anyio.Event` which can be used to stop iteration, see example below.
    rust_timeout: matches the same argument of [`watch`][watchfiles.watch], except that `None` means
        use `1_000` on Windows and `5_000` on other platforms thus helping with exiting on `Ctrl+C` on Windows,
        see [#110](https://github.com/samuelcolvin/watchfiles/issues/110).
    yield_on_timeout: matches the same argument of [`watch`][watchfiles.watch].
    debug: matches the same argument of [`watch`][watchfiles.watch].
    raise_interrupt: This is deprecated, `KeyboardInterrupt` will cause this coroutine to be cancelled and then
        be raised by the top level `asyncio.run` call or equivalent, and should be caught there.
        See [#136](https://github.com/samuelcolvin/watchfiles/issues/136)
    force_polling: if true, always use polling instead of file system notifications, default is `None` where
        `force_polling` is set to `True` if the `WATCHFILES_FORCE_POLLING` environment variable exists.
    poll_delay_ms: delay between polling for changes, only used if `force_polling=True`.
        `poll_delay_ms` can be changed via the `WATCHFILES_POLL_DELAY_MS` environment variable.
    recursive: if `True`, watch for changes in sub-directories recursively, otherwise watch only for changes in the
        top-level directory, default is `True`.
    ignore_permission_denied: if `True`, will ignore permission denied errors, otherwise will raise them by default.
        Setting the `WATCHFILES_IGNORE_PERMISSION_DENIED` environment variable will set this value too.

Yields:
    The generator yields sets of [`FileChange`][watchfiles.main.FileChange]s.

```py title="Example of awatch usage"
import asyncio
from watchfiles import awatch

async def main():
    async for changes in awatch('./first/dir', './second/dir'):
        print(changes)

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print('stopped via KeyboardInterrupt')
```

```py title="Example of awatch usage with a stop event"
import asyncio
from watchfiles import awatch

async def main():
    stop_event = asyncio.Event()

    async def stop_soon():
        await asyncio.sleep(3)
        stop_event.set()

    stop_soon_task = asyncio.create_task(stop_soon())

    async for changes in awatch('/path/to/dir', stop_event=stop_event):
        print(changes)

    # cleanup by awaiting the (now complete) stop_soon_task
    await stop_soon_task

asyncio.run(main())
```
</pre> 
</div>
</div>
<a id="ab9ffaeaeda84fd36a08cb42db815a850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ffaeaeda84fd36a08cb42db815a850">&#9670;&nbsp;</a></span>watch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Generator[Set[<a class="el" href="namespacewatchfiles_1_1main.html#ad59f9dd6e602b9e23984646e8c0e152a">FileChange</a>], None, None] watchfiles.main.watch </td>
          <td>(</td>
          <td class="paramtype">*Union[Path, str]&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Callable[['<a class="el" href="classwatchfiles_1_1main_1_1Change.html">Change</a>', str], bool]] &#160;</td>
          <td class="paramname"><em>watch_filter</em> = <code><a class="el" href="classwatchfiles_1_1filters_1_1DefaultFilter.html">DefaultFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>debounce</em> = <code>1_600</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>step</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional['<a class="el" href="classwatchfiles_1_1main_1_1AbstractEvent.html">AbstractEvent</a>'] &#160;</td>
          <td class="paramname"><em>stop_event</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>rust_timeout</em> = <code>5_000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>yield_on_timeout</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>debug</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raise_interrupt</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>force_polling</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>poll_delay_ms</em> = <code>300</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>recursive</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>ignore_permission_denied</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Watch one or more paths and yield a set of changes whenever files change.

The paths watched can be directories or files, directories are watched recursively - changes in subdirectories
are also detected.

#### Force polling

Notify will fall back to file polling if it can't use file system notifications, but we also force Notify
to use polling if the `force_polling` argument is `True`; if `force_polling` is unset (or `None`), we enable
force polling thus:

* if the `WATCHFILES_FORCE_POLLING` environment variable exists and is not empty:
    * if the value is `false`, `disable` or `disabled`, force polling is disabled
    * otherwise, force polling is enabled
* otherwise, we enable force polling only if we detect we're running on WSL (Windows Subsystem for Linux)

It is also possible to change the poll delay between iterations, it can be changed to maintain a good response time
and an appropiate CPU consumption using the `poll_delay_ms` argument, we change poll delay thus:

* if file polling is enabled and the `WATCHFILES_POLL_DELAY_MS` env var exists and it is numeric, we use that
* otherwise, we use the argument value

Args:
    *paths: filesystem paths to watch.
    watch_filter: callable used to filter out changes which are not important, you can either use a raw callable
        or a [`BaseFilter`][watchfiles.BaseFilter] instance,
        defaults to an instance of [`DefaultFilter`][watchfiles.DefaultFilter]. To keep all changes, use `None`.
    debounce: maximum time in milliseconds to group changes over before yielding them.
    step: time to wait for new changes in milliseconds, if no changes are detected in this time, and
        at least one change has been detected, the changes are yielded.
    stop_event: event to stop watching, if this is set, the generator will stop iteration,
        this can be anything with an `is_set()` method which returns a bool, e.g. `threading.Event()`.
    rust_timeout: maximum time in milliseconds to wait in the rust code for changes, `0` means no timeout.
    yield_on_timeout: if `True`, the generator will yield upon timeout in rust even if no changes are detected.
    debug: whether to print information about all filesystem changes in rust to stdout, if `None` will use the
        `WATCHFILES_DEBUG` environment variable.
    raise_interrupt: whether to re-raise `KeyboardInterrupt`s, or suppress the error and just stop iterating.
    force_polling: See [Force polling](#force-polling) above.
    poll_delay_ms: delay between polling for changes, only used if `force_polling=True`.
    recursive: if `True`, watch for changes in sub-directories recursively, otherwise watch only for changes in the
        top-level directory, default is `True`.
    ignore_permission_denied: if `True`, will ignore permission denied errors, otherwise will raise them by default.
        Setting the `WATCHFILES_IGNORE_PERMISSION_DENIED` environment variable will set this value too.

Yields:
    The generator yields sets of [`FileChange`][watchfiles.main.FileChange]s.

```py title="Example of watch usage"
from watchfiles import watch

for changes in watch('./first/dir', './second/dir', raise_interrupt=False):
    print(changes)
```
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a91df05be85a66e827734437129d2edf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91df05be85a66e827734437129d2edf5">&#9670;&nbsp;</a></span>AnyEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">watchfiles.main.AnyEvent = Union[<a class="el" href="classanyio_1_1__core_1_1__synchronization_1_1Event.html">anyio.Event</a>, asyncio.Event, trio.Event]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad59f9dd6e602b9e23984646e8c0e152a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59f9dd6e602b9e23984646e8c0e152a">&#9670;&nbsp;</a></span>FileChange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">watchfiles.main.FileChange = Tuple[<a class="el" href="classwatchfiles_1_1main_1_1Change.html">Change</a>, str]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88297abb09f6ecec1bbcb9bf2d9cbc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88297abb09f6ecec1bbcb9bf2d9cbc9b">&#9670;&nbsp;</a></span>logger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">watchfiles.main.logger = logging.getLogger('watchfiles.main')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
