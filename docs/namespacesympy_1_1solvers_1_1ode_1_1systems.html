<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.solvers.ode.systems Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1ode.html">ode</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html">systems</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.solvers.ode.systems Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1ode_1_1systems_1_1ODEOrderError.html">ODEOrderError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1ode_1_1systems_1_1ODENonlinearError.html">ODENonlinearError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a21f4394aa092195c504cfad78bc73f89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html#a21f4394aa092195c504cfad78bc73f89">simpsol</a> (sol, wrt1, wrt2, doit=True)</td></tr>
<tr class="separator:a21f4394aa092195c504cfad78bc73f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e723e92b07ad4e6e745f413185f5044"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html#a0e723e92b07ad4e6e745f413185f5044">linodesolve_type</a> (A, t, b=None)</td></tr>
<tr class="separator:a0e723e92b07ad4e6e745f413185f5044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a395a8d0b03b66a347312ad774c4f79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html#a4a395a8d0b03b66a347312ad774c4f79">linear_ode_to_matrix</a> (eqs, funcs, t, order)</td></tr>
<tr class="separator:a4a395a8d0b03b66a347312ad774c4f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638589983073dd37e5e5f0df0995bd6a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html#a638589983073dd37e5e5f0df0995bd6a">matrix_exp</a> (A, t)</td></tr>
<tr class="separator:a638589983073dd37e5e5f0df0995bd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cae44bf20e66fe1675e001238d3e03a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html#a5cae44bf20e66fe1675e001238d3e03a">matrix_exp_jordan_form</a> (A, t)</td></tr>
<tr class="separator:a5cae44bf20e66fe1675e001238d3e03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d7219197282d87bc75f25af96dbaa0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html#a39d7219197282d87bc75f25af96dbaa0">linodesolve</a> (A, t, b=None, B=None, type=&quot;auto&quot;, doit=False, tau=None)</td></tr>
<tr class="separator:a39d7219197282d87bc75f25af96dbaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6f3a35800bb931e2b1a60555c66e9a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html#a6d6f3a35800bb931e2b1a60555c66e9a">canonical_odes</a> (eqs, funcs, t)</td></tr>
<tr class="separator:a6d6f3a35800bb931e2b1a60555c66e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429b801c41d44739ea384f761c1b2862"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1systems.html#a429b801c41d44739ea384f761c1b2862">dsolve_system</a> (eqs, funcs=None, t=None, ics=None, doit=False, simplify=True)</td></tr>
<tr class="separator:a429b801c41d44739ea384f761c1b2862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6d6f3a35800bb931e2b1a60555c66e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6f3a35800bb931e2b1a60555c66e9a">&#9670;&nbsp;</a></span>canonical_odes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.systems.canonical_odes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function that solves for highest order derivatives in a system

Explanation
===========

This function inputs a system of ODEs and based on the system,
the dependent variables and their highest order, returns the system
in the following form:

.. math::
    X'(t) = A(t) X(t) + b(t)

Here, $X(t)$ is the vector of dependent variables of lower order, $A(t)$ is
the coefficient matrix, $b(t)$ is the non-homogeneous term and $X'(t)$ is the
vector of dependent variables in their respective highest order. We use the term
canonical form to imply the system of ODEs which is of the above form.

If the system passed has a non-linear term with multiple solutions, then a list of
systems is returned in its canonical form.

Parameters
==========

eqs : List
    List of the ODEs
funcs : List
    List of dependent variables
t : Symbol
    Independent variable

Examples
========

&gt;&gt;&gt; from sympy import symbols, Function, Eq, Derivative
&gt;&gt;&gt; from sympy.solvers.ode.systems import canonical_odes
&gt;&gt;&gt; f, g = symbols("f g", cls=Function)
&gt;&gt;&gt; x, y = symbols("x y")
&gt;&gt;&gt; funcs = [f(x), g(x)]
&gt;&gt;&gt; eqs = [Eq(f(x).diff(x) - 7*f(x), 12*g(x)), Eq(g(x).diff(x) + g(x), 20*f(x))]

&gt;&gt;&gt; canonical_eqs = canonical_odes(eqs, funcs, x)
&gt;&gt;&gt; canonical_eqs
[[Eq(Derivative(f(x), x), 7*f(x) + 12*g(x)), Eq(Derivative(g(x), x), 20*f(x) - g(x))]]

&gt;&gt;&gt; system = [Eq(Derivative(f(x), x)**2 - 2*Derivative(f(x), x) + 1, 4), Eq(-y*f(x) + Derivative(g(x), x), 0)]

&gt;&gt;&gt; canonical_system = canonical_odes(system, funcs, x)
&gt;&gt;&gt; canonical_system
[[Eq(Derivative(f(x), x), -1), Eq(Derivative(g(x), x), y*f(x))], [Eq(Derivative(f(x), x), 3), Eq(Derivative(g(x), x), y*f(x))]]

Returns
=======

List</pre> 
</div>
</div>
<a id="a429b801c41d44739ea384f761c1b2862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429b801c41d44739ea384f761c1b2862">&#9670;&nbsp;</a></span>dsolve_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.systems.dsolve_system </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>funcs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ics</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>doit</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves any(supported) system of Ordinary Differential Equations

Explanation
===========

This function takes a system of ODEs as an input, determines if the
it is solvable by this function, and returns the solution if found any.

This function can handle:
1. Linear, First Order, Constant coefficient homogeneous system of ODEs
2. Linear, First Order, Constant coefficient non-homogeneous system of ODEs
3. Linear, First Order, non-constant coefficient homogeneous system of ODEs
4. Linear, First Order, non-constant coefficient non-homogeneous system of ODEs
5. Any implicit system which can be divided into system of ODEs which is of the above 4 forms
6. Any higher order linear system of ODEs that can be reduced to one of the 5 forms of systems described above.

The types of systems described above are not limited by the number of equations, i.e. this
function can solve the above types irrespective of the number of equations in the system passed.
But, the bigger the system, the more time it will take to solve the system.

This function returns a list of solutions. Each solution is a list of equations where LHS is
the dependent variable and RHS is an expression in terms of the independent variable.

Among the non constant coefficient types, not all the systems are solvable by this function. Only
those which have either a coefficient matrix with a commutative antiderivative or those systems which
may be divided further so that the divided systems may have coefficient matrix with commutative antiderivative.

Parameters
==========

eqs : List
    system of ODEs to be solved
funcs : List or None
    List of dependent variables that make up the system of ODEs
t : Symbol or None
    Independent variable in the system of ODEs
ics : Dict or None
    Set of initial boundary/conditions for the system of ODEs
doit : Boolean
    Evaluate the solutions if True. Default value is True. Can be
    set to false if the integral evaluation takes too much time and/or
    is not required.
simplify: Boolean
    Simplify the solutions for the systems. Default value is True.
    Can be set to false if simplification takes too much time and/or
    is not required.

Examples
========

&gt;&gt;&gt; from sympy import symbols, Eq, Function
&gt;&gt;&gt; from sympy.solvers.ode.systems import dsolve_system
&gt;&gt;&gt; f, g = symbols("f g", cls=Function)
&gt;&gt;&gt; x = symbols("x")

&gt;&gt;&gt; eqs = [Eq(f(x).diff(x), g(x)), Eq(g(x).diff(x), f(x))]
&gt;&gt;&gt; dsolve_system(eqs)
[[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]]

You can also pass the initial conditions for the system of ODEs:

&gt;&gt;&gt; dsolve_system(eqs, ics={f(0): 1, g(0): 0})
[[Eq(f(x), exp(x)/2 + exp(-x)/2), Eq(g(x), exp(x)/2 - exp(-x)/2)]]

Optionally, you can pass the dependent variables and the independent
variable for which the system is to be solved:

&gt;&gt;&gt; funcs = [f(x), g(x)]
&gt;&gt;&gt; dsolve_system(eqs, funcs=funcs, t=x)
[[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]]

Lets look at an implicit system of ODEs:

&gt;&gt;&gt; eqs = [Eq(f(x).diff(x)**2, g(x)**2), Eq(g(x).diff(x), g(x))]
&gt;&gt;&gt; dsolve_system(eqs)
[[Eq(f(x), C1 - C2*exp(x)), Eq(g(x), C2*exp(x))], [Eq(f(x), C1 + C2*exp(x)), Eq(g(x), C2*exp(x))]]

Returns
=======

List of List of Equations

Raises
======

NotImplementedError
    When the system of ODEs is not solvable by this function.
ValueError
    When the parameters passed are not in the required form.</pre> 
</div>
</div>
<a id="a4a395a8d0b03b66a347312ad774c4f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a395a8d0b03b66a347312ad774c4f79">&#9670;&nbsp;</a></span>linear_ode_to_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.systems.linear_ode_to_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a linear system of ODEs to matrix form

Explanation
===========

Express a system of linear ordinary differential equations as a single
matrix differential equation [1]. For example the system $x' = x + y + 1$
and $y' = x - y$ can be represented as

.. math:: A_1 X' = A_0 X + b

where $A_1$ and $A_0$ are $2 \times 2$ matrices and $b$, $X$ and $X'$ are
$2 \times 1$ matrices with $X = [x, y]^T$.

Higher-order systems are represented with additional matrices e.g. a
second-order system would look like

.. math:: A_2 X'' =  A_1 X' + A_0 X  + b

Examples
========

&gt;&gt;&gt; from sympy import Function, Symbol, Matrix, Eq
&gt;&gt;&gt; from sympy.solvers.ode.systems import linear_ode_to_matrix
&gt;&gt;&gt; t = Symbol('t')
&gt;&gt;&gt; x = Function('x')
&gt;&gt;&gt; y = Function('y')

We can create a system of linear ODEs like

&gt;&gt;&gt; eqs = [
...     Eq(x(t).diff(t), x(t) + y(t) + 1),
...     Eq(y(t).diff(t), x(t) - y(t)),
... ]
&gt;&gt;&gt; funcs = [x(t), y(t)]
&gt;&gt;&gt; order = 1 # 1st order system

Now ``linear_ode_to_matrix`` can represent this as a matrix
differential equation.

&gt;&gt;&gt; (A1, A0), b = linear_ode_to_matrix(eqs, funcs, t, order)
&gt;&gt;&gt; A1
Matrix([
[1, 0],
[0, 1]])
&gt;&gt;&gt; A0
Matrix([
[1, 1],
[1,  -1]])
&gt;&gt;&gt; b
Matrix([
[1],
[0]])

The original equations can be recovered from these matrices:

&gt;&gt;&gt; eqs_mat = Matrix([eq.lhs - eq.rhs for eq in eqs])
&gt;&gt;&gt; X = Matrix(funcs)
&gt;&gt;&gt; A1 * X.diff(t) - A0 * X - b == eqs_mat
True

If the system of equations has a maximum order greater than the
order of the system specified, a ODEOrderError exception is raised.

&gt;&gt;&gt; eqs = [Eq(x(t).diff(t, 2), x(t).diff(t) + x(t)), Eq(y(t).diff(t), y(t) + x(t))]
&gt;&gt;&gt; linear_ode_to_matrix(eqs, funcs, t, 1)
Traceback (most recent call last):
...
ODEOrderError: Cannot represent system in 1-order form

If the system of equations is nonlinear, then ODENonlinearError is
raised.

&gt;&gt;&gt; eqs = [Eq(x(t).diff(t), x(t) + y(t)), Eq(y(t).diff(t), y(t)**2 + x(t))]
&gt;&gt;&gt; linear_ode_to_matrix(eqs, funcs, t, 1)
Traceback (most recent call last):
...
ODENonlinearError: The system of ODEs is nonlinear.

Parameters
==========

eqs : list of SymPy expressions or equalities
    The equations as expressions (assumed equal to zero).
funcs : list of applied functions
    The dependent variables of the system of ODEs.
t : symbol
    The independent variable.
order : int
    The order of the system of ODEs.

Returns
=======

The tuple ``(As, b)`` where ``As`` is a tuple of matrices and ``b`` is the
the matrix representing the rhs of the matrix equation.

Raises
======

ODEOrderError
    When the system of ODEs have an order greater than what was specified
ODENonlinearError
    When the system of ODEs is nonlinear

See Also
========

linear_eq_to_matrix: for systems of linear algebraic equations.

References
==========

.. [1] https://en.wikipedia.org/wiki/Matrix_differential_equation</pre> 
</div>
</div>
<a id="a39d7219197282d87bc75f25af96dbaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d7219197282d87bc75f25af96dbaa0">&#9670;&nbsp;</a></span>linodesolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.systems.linodesolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>doit</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tau</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">System of n equations linear first-order differential equations

Explanation
===========

This solver solves the system of ODEs of the following form:

.. math::
    X'(t) = A(t) X(t) +  b(t)

Here, $A(t)$ is the coefficient matrix, $X(t)$ is the vector of n independent variables,
$b(t)$ is the non-homogeneous term and $X'(t)$ is the derivative of $X(t)$

Depending on the properties of $A(t)$ and $b(t)$, this solver evaluates the solution
differently.

When $A(t)$ is constant coefficient matrix and $b(t)$ is zero vector i.e. system is homogeneous,
the system is "type1". The solution is:

.. math::
    X(t) = \exp(A t) C

Here, $C$ is a vector of constants and $A$ is the constant coefficient matrix.

When $A(t)$ is constant coefficient matrix and $b(t)$ is non-zero i.e. system is non-homogeneous,
the system is "type2". The solution is:

.. math::
    X(t) = e^{A t} ( \int e^{- A t} b \,dt + C)

When $A(t)$ is coefficient matrix such that its commutative with its antiderivative $B(t)$ and
$b(t)$ is a zero vector i.e. system is homogeneous, the system is "type3". The solution is:

.. math::
    X(t) = \exp(B(t)) C

When $A(t)$ is commutative with its antiderivative $B(t)$ and $b(t)$ is non-zero i.e. system is
non-homogeneous, the system is "type4". The solution is:

.. math::
    X(t) =  e^{B(t)} ( \int e^{-B(t)} b(t) \,dt + C)

When $A(t)$ is a coefficient matrix such that it can be factorized into a scalar and a constant
coefficient matrix:

.. math::
    A(t) = f(t) * A

Where $f(t)$ is a scalar expression in the independent variable $t$ and $A$ is a constant matrix,
then we can do the following substitutions:

.. math::
    tau = \int f(t) dt, X(t) = Y(tau), b(t) = b(f^{-1}(tau))

Here, the substitution for the non-homogeneous term is done only when its non-zero.
Using these substitutions, our original system becomes:

.. math::
    Y'(tau) = A * Y(tau) + b(tau)/f(tau)

The above system can be easily solved using the solution for "type1" or "type2" depending
on the homogeneity of the system. After we get the solution for $Y(tau)$, we substitute the
solution for $tau$ as $t$ to get back $X(t)$

.. math::
    X(t) = Y(tau)

Systems of "type5" and "type6" have a commutative antiderivative but we use this solution
because its faster to compute.

The final solution is the general solution for all the four equations since a constant coefficient
matrix is always commutative with its antidervative.

An additional feature of this function is, if someone wants to substitute for value of the independent
variable, they can pass the substitution `tau` and the solution will have the independent variable
substituted with the passed expression(`tau`).

Parameters
==========

A : Matrix
    Coefficient matrix of the system of linear first order ODEs.
t : Symbol
    Independent variable in the system of ODEs.
b : Matrix or None
    Non-homogeneous term in the system of ODEs. If None is passed,
    a homogeneous system of ODEs is assumed.
B : Matrix or None
    Antiderivative of the coefficient matrix. If the antiderivative
    is not passed and the solution requires the term, then the solver
    would compute it internally.
type : String
    Type of the system of ODEs passed. Depending on the type, the
    solution is evaluated. The type values allowed and the corresponding
    system it solves are: "type1" for constant coefficient homogeneous
    "type2" for constant coefficient non-homogeneous, "type3" for non-constant
    coefficient homogeneous, "type4" for non-constant coefficient non-homogeneous,
    "type5" and "type6" for non-constant coefficient homogeneous and non-homogeneous
    systems respectively where the coefficient matrix can be factorized to a constant
    coefficient matrix.
    The default value is "auto" which will let the solver decide the correct type of
    the system passed.
doit : Boolean
    Evaluate the solution if True, default value is False
tau: Expression
    Used to substitute for the value of `t` after we get the solution of the system.

Examples
========

To solve the system of ODEs using this function directly, several things must be
done in the right order. Wrong inputs to the function will lead to incorrect results.

&gt;&gt;&gt; from sympy import symbols, Function, Eq
&gt;&gt;&gt; from sympy.solvers.ode.systems import canonical_odes, linear_ode_to_matrix, linodesolve, linodesolve_type
&gt;&gt;&gt; from sympy.solvers.ode.subscheck import checkodesol
&gt;&gt;&gt; f, g = symbols("f, g", cls=Function)
&gt;&gt;&gt; x, a = symbols("x, a")
&gt;&gt;&gt; funcs = [f(x), g(x)]
&gt;&gt;&gt; eqs = [Eq(f(x).diff(x) - f(x), a*g(x) + 1), Eq(g(x).diff(x) + g(x), a*f(x))]

Here, it is important to note that before we derive the coefficient matrix, it is
important to get the system of ODEs into the desired form. For that we will use
:obj:`sympy.solvers.ode.systems.canonical_odes()`.

&gt;&gt;&gt; eqs = canonical_odes(eqs, funcs, x)
&gt;&gt;&gt; eqs
[[Eq(Derivative(f(x), x), a*g(x) + f(x) + 1), Eq(Derivative(g(x), x), a*f(x) - g(x))]]

Now, we will use :obj:`sympy.solvers.ode.systems.linear_ode_to_matrix()` to get the coefficient matrix and the
non-homogeneous term if it is there.

&gt;&gt;&gt; eqs = eqs[0]
&gt;&gt;&gt; (A1, A0), b = linear_ode_to_matrix(eqs, funcs, x, 1)
&gt;&gt;&gt; A = A0

We have the coefficient matrices and the non-homogeneous term ready. Now, we can use
:obj:`sympy.solvers.ode.systems.linodesolve_type()` to get the information for the system of ODEs
to finally pass it to the solver.

&gt;&gt;&gt; system_info = linodesolve_type(A, x, b=b)
&gt;&gt;&gt; sol_vector = linodesolve(A, x, b=b, B=system_info['antiderivative'], type=system_info['type_of_equation'])

Now, we can prove if the solution is correct or not by using :obj:`sympy.solvers.ode.checkodesol()`

&gt;&gt;&gt; sol = [Eq(f, s) for f, s in zip(funcs, sol_vector)]
&gt;&gt;&gt; checkodesol(eqs, sol)
(True, [0, 0])

We can also use the doit method to evaluate the solutions passed by the function.

&gt;&gt;&gt; sol_vector_evaluated = linodesolve(A, x, b=b, type="type2", doit=True)

Now, we will look at a system of ODEs which is non-constant.

&gt;&gt;&gt; eqs = [Eq(f(x).diff(x), f(x) + x*g(x)), Eq(g(x).diff(x), -x*f(x) + g(x))]

The system defined above is already in the desired form, so we do not have to convert it.

&gt;&gt;&gt; (A1, A0), b = linear_ode_to_matrix(eqs, funcs, x, 1)
&gt;&gt;&gt; A = A0

A user can also pass the commutative antiderivative required for type3 and type4 system of ODEs.
Passing an incorrect one will lead to incorrect results. If the coefficient matrix is not commutative
with its antiderivative, then :obj:`sympy.solvers.ode.systems.linodesolve_type()` raises a NotImplementedError.
If it does have a commutative antiderivative, then the function just returns the information about the system.

&gt;&gt;&gt; system_info = linodesolve_type(A, x, b=b)

Now, we can pass the antiderivative as an argument to get the solution. If the system information is not
passed, then the solver will compute the required arguments internally.

&gt;&gt;&gt; sol_vector = linodesolve(A, x, b=b)

Once again, we can verify the solution obtained.

&gt;&gt;&gt; sol = [Eq(f, s) for f, s in zip(funcs, sol_vector)]
&gt;&gt;&gt; checkodesol(eqs, sol)
(True, [0, 0])

Returns
=======

List

Raises
======

ValueError
    This error is raised when the coefficient matrix, non-homogeneous term
    or the antiderivative, if passed, are not a matrix or
    do not have correct dimensions
NonSquareMatrixError
    When the coefficient matrix or its antiderivative, if passed is not a
    square matrix
NotImplementedError
    If the coefficient matrix does not have a commutative antiderivative

See Also
========

linear_ode_to_matrix: Coefficient matrix computation function
canonical_odes: System of ODEs representation change
linodesolve_type: Getting information about systems of ODEs to pass in this solver</pre> 
</div>
</div>
<a id="a0e723e92b07ad4e6e745f413185f5044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e723e92b07ad4e6e745f413185f5044">&#9670;&nbsp;</a></span>linodesolve_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.systems.linodesolve_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function that determines the type of the system of ODEs for solving with :obj:`sympy.solvers.ode.systems.linodesolve()`

Explanation
===========

This function takes in the coefficient matrix and/or the non-homogeneous term
and returns the type of the equation that can be solved by :obj:`sympy.solvers.ode.systems.linodesolve()`.

If the system is constant coefficient homogeneous, then "type1" is returned

If the system is constant coefficient non-homogeneous, then "type2" is returned

If the system is non-constant coefficient homogeneous, then "type3" is returned

If the system is non-constant coefficient non-homogeneous, then "type4" is returned

If the system has a non-constant coefficient matrix which can be factorized into constant
coefficient matrix, then "type5" or "type6" is returned for when the system is homogeneous or
non-homogeneous respectively.

Note that, if the system of ODEs is of "type3" or "type4", then along with the type,
the commutative antiderivative of the coefficient matrix is also returned.

If the system cannot be solved by :obj:`sympy.solvers.ode.systems.linodesolve()`, then
NotImplementedError is raised.

Parameters
==========

A : Matrix
    Coefficient matrix of the system of ODEs
b : Matrix or None
    Non-homogeneous term of the system. The default value is None.
    If this argument is None, then the system is assumed to be homogeneous.

Examples
========

&gt;&gt;&gt; from sympy import symbols, Matrix
&gt;&gt;&gt; from sympy.solvers.ode.systems import linodesolve_type
&gt;&gt;&gt; t = symbols("t")
&gt;&gt;&gt; A = Matrix([[1, 1], [2, 3]])
&gt;&gt;&gt; b = Matrix([t, 1])

&gt;&gt;&gt; linodesolve_type(A, t)
{'antiderivative': None, 'type_of_equation': 'type1'}

&gt;&gt;&gt; linodesolve_type(A, t, b=b)
{'antiderivative': None, 'type_of_equation': 'type2'}

&gt;&gt;&gt; A_t = Matrix([[1, t], [-t, 1]])

&gt;&gt;&gt; linodesolve_type(A_t, t)
{'antiderivative': Matrix([
[      t, t**2/2],
[-t**2/2,      t]]), 'type_of_equation': 'type3'}

&gt;&gt;&gt; linodesolve_type(A_t, t, b=b)
{'antiderivative': Matrix([
[      t, t**2/2],
[-t**2/2,      t]]), 'type_of_equation': 'type4'}

&gt;&gt;&gt; A_non_commutative = Matrix([[1, t], [t, -1]])
&gt;&gt;&gt; linodesolve_type(A_non_commutative, t)
Traceback (most recent call last):
...
NotImplementedError:
The system does not have a commutative antiderivative, it cannot be
solved by linodesolve.

Returns
=======

Dict

Raises
======

NotImplementedError
    When the coefficient matrix does not have a commutative antiderivative

See Also
========

linodesolve: Function for which linodesolve_type gets the information</pre> 
</div>
</div>
<a id="a638589983073dd37e5e5f0df0995bd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638589983073dd37e5e5f0df0995bd6a">&#9670;&nbsp;</a></span>matrix_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.systems.matrix_exp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Matrix exponential $\exp(A*t)$ for the matrix ``A`` and scalar ``t``.

Explanation
===========

This functions returns the $\exp(A*t)$ by doing a simple
matrix multiplication:

.. math:: \exp(A*t) = P * expJ * P^{-1}

where $expJ$ is $\exp(J*t)$. $J$ is the Jordan normal
form of $A$ and $P$ is matrix such that:

.. math:: A = P * J * P^{-1}

The matrix exponential $\exp(A*t)$ appears in the solution of linear
differential equations. For example if $x$ is a vector and $A$ is a matrix
then the initial value problem

.. math:: \frac{dx(t)}{dt} = A \times x(t),   x(0) = x0

has the unique solution

.. math:: x(t) = \exp(A t) x0

Examples
========

&gt;&gt;&gt; from sympy import Symbol, Matrix, pprint
&gt;&gt;&gt; from sympy.solvers.ode.systems import matrix_exp
&gt;&gt;&gt; t = Symbol('t')

We will consider a 2x2 matrix for comupting the exponential

&gt;&gt;&gt; A = Matrix([[2, -5], [2, -4]])
&gt;&gt;&gt; pprint(A)
[2  -5]
[     ]
[2  -4]

Now, exp(A*t) is given as follows:

&gt;&gt;&gt; pprint(matrix_exp(A, t))
[   -t           -t                    -t              ]
[3*e  *sin(t) + e  *cos(t)         -5*e  *sin(t)       ]
[                                                      ]
[         -t                     -t           -t       ]
[      2*e  *sin(t)         - 3*e  *sin(t) + e  *cos(t)]

Parameters
==========

A : Matrix
    The matrix $A$ in the expression $\exp(A*t)$
t : Symbol
    The independent variable

See Also
========

matrix_exp_jordan_form: For exponential of Jordan normal form

References
==========

.. [1] https://en.wikipedia.org/wiki/Jordan_normal_form
.. [2] https://en.wikipedia.org/wiki/Matrix_exponential</pre> 
</div>
</div>
<a id="a5cae44bf20e66fe1675e001238d3e03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cae44bf20e66fe1675e001238d3e03a">&#9670;&nbsp;</a></span>matrix_exp_jordan_form()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.systems.matrix_exp_jordan_form </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Matrix exponential $\exp(A*t)$ for the matrix *A* and scalar *t*.

Explanation
===========

Returns the Jordan form of the $\exp(A*t)$ along with the matrix $P$ such that:

.. math::
    \exp(A*t) = P * expJ * P^{-1}

Examples
========

&gt;&gt;&gt; from sympy import Matrix, Symbol
&gt;&gt;&gt; from sympy.solvers.ode.systems import matrix_exp, matrix_exp_jordan_form
&gt;&gt;&gt; t = Symbol('t')

We will consider a 2x2 defective matrix. This shows that our method
works even for defective matrices.

&gt;&gt;&gt; A = Matrix([[1, 1], [0, 1]])

It can be observed that this function gives us the Jordan normal form
and the required invertible matrix P.

&gt;&gt;&gt; P, expJ = matrix_exp_jordan_form(A, t)

Here, it is shown that P and expJ returned by this function is correct
as they satisfy the formula: P * expJ * P_inverse = exp(A*t).

&gt;&gt;&gt; P * expJ * P.inv() == matrix_exp(A, t)
True

Parameters
==========

A : Matrix
    The matrix $A$ in the expression $\exp(A*t)$
t : Symbol
    The independent variable

References
==========

.. [1] https://en.wikipedia.org/wiki/Defective_matrix
.. [2] https://en.wikipedia.org/wiki/Jordan_matrix
.. [3] https://en.wikipedia.org/wiki/Jordan_normal_form</pre> 
</div>
</div>
<a id="a21f4394aa092195c504cfad78bc73f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f4394aa092195c504cfad78bc73f89">&#9670;&nbsp;</a></span>simpsol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.systems.simpsol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wrt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wrt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>doit</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplify solutions from dsolve_system.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
