<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.concrete.guess Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1concrete.html">concrete</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1concrete_1_1guess.html">guess</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.concrete.guess Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aacb096ecfab1536595f8bf54b31c6797"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1concrete_1_1guess.html#aacb096ecfab1536595f8bf54b31c6797">find_simple_recurrence_vector</a> (l)</td></tr>
<tr class="separator:aacb096ecfab1536595f8bf54b31c6797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054c9e5118524d94a9fba735af9e70b8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1concrete_1_1guess.html#a054c9e5118524d94a9fba735af9e70b8">find_simple_recurrence</a> (v, A=<a class="el" href="classsympy_1_1core_1_1function_1_1Function.html">Function</a>('a'), N=<a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a>('n'))</td></tr>
<tr class="separator:a054c9e5118524d94a9fba735af9e70b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26453c1f4075c8f7ff2a7cfc9529d913"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1concrete_1_1guess.html#a26453c1f4075c8f7ff2a7cfc9529d913">rationalize</a> (x, maxcoeff=10000)</td></tr>
<tr class="separator:a26453c1f4075c8f7ff2a7cfc9529d913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea0761ca6fb1d8efbece29fb1290e3a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1concrete_1_1guess.html#aeea0761ca6fb1d8efbece29fb1290e3a">guess_generating_function_rational</a> (v, X=<a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a>('x'))</td></tr>
<tr class="separator:aeea0761ca6fb1d8efbece29fb1290e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163dfd12f6c7d02d53857dcba9b39d16"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1concrete_1_1guess.html#a163dfd12f6c7d02d53857dcba9b39d16">guess_generating_function</a> (v, X=<a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a>('x'), types=['all'], maxsqrtn=2)</td></tr>
<tr class="separator:a163dfd12f6c7d02d53857dcba9b39d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed326043847bba72dc351f9ab7839cc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1concrete_1_1guess.html#a7ed326043847bba72dc351f9ab7839cc">guess</a> (l, all=False, <a class="el" href="classsympy_1_1core_1_1parameters_1_1evaluate.html">evaluate</a>=True, niter=2, variables=None)</td></tr>
<tr class="separator:a7ed326043847bba72dc351f9ab7839cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Various algorithms for helping identifying numbers and sequences.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a054c9e5118524d94a9fba735af9e70b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054c9e5118524d94a9fba735af9e70b8">&#9670;&nbsp;</a></span>find_simple_recurrence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.concrete.guess.find_simple_recurrence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="classsympy_1_1core_1_1function_1_1Function.html">Function</a>('a')</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code><a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a>('n')</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Detects and returns a recurrence relation from a sequence of several integer
(or rational) terms. The name of the function in the returned expression is
'a' by default; the main variable is 'n' by default. The smallest index in
the returned expression is always n (and never n-1, n-2, etc.).

Examples
========

&gt;&gt;&gt; from sympy.concrete.guess import find_simple_recurrence
&gt;&gt;&gt; from sympy import fibonacci
&gt;&gt;&gt; find_simple_recurrence([fibonacci(k) for k in range(12)])
-a(n) - a(n + 1) + a(n + 2)

&gt;&gt;&gt; from sympy import Function, Symbol
&gt;&gt;&gt; a = [1, 1, 1]
&gt;&gt;&gt; for k in range(15): a.append(5*a[-1]-3*a[-2]+8*a[-3])
&gt;&gt;&gt; find_simple_recurrence(a, A=Function('f'), N=Symbol('i'))
-8*f(i) + 3*f(i + 1) - 5*f(i + 2) + f(i + 3)</pre> 
</div>
</div>
<a id="aacb096ecfab1536595f8bf54b31c6797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb096ecfab1536595f8bf54b31c6797">&#9670;&nbsp;</a></span>find_simple_recurrence_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.concrete.guess.find_simple_recurrence_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function is used internally by other functions from the
sympy.concrete.guess module. While most users may want to rather use the
function find_simple_recurrence when looking for recurrence relations
among rational numbers, the current function may still be useful when
some post-processing has to be done.

Explanation
===========

The function returns a vector of length n when a recurrence relation of
order n is detected in the sequence of rational numbers v.

If the returned vector has a length 1, then the returned value is always
the list [0], which means that no relation has been found.

While the functions is intended to be used with rational numbers, it should
work for other kinds of real numbers except for some cases involving
quadratic numbers; for that reason it should be used with some caution when
the argument is not a list of rational numbers.

Examples
========

&gt;&gt;&gt; from sympy.concrete.guess import find_simple_recurrence_vector
&gt;&gt;&gt; from sympy import fibonacci
&gt;&gt;&gt; find_simple_recurrence_vector([fibonacci(k) for k in range(12)])
[1, -1, -1]

See Also
========

See the function sympy.concrete.guess.find_simple_recurrence which is more
user-friendly.</pre> 
</div>
</div>
<a id="a7ed326043847bba72dc351f9ab7839cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed326043847bba72dc351f9ab7839cc">&#9670;&nbsp;</a></span>guess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.concrete.guess.guess </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>evaluate</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>niter</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variables</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function is adapted from the Rate.m package for Mathematica
written by Christian Krattenthaler.
It tries to guess a formula from a given sequence of rational numbers.

Explanation
===========

In order to speed up the process, the 'all' variable is set to False by
default, stopping the computation as some results are returned during an
iteration; the variable can be set to True if more iterations are needed
(other formulas may be found; however they may be equivalent to the first
ones).

Another option is the 'evaluate' variable (default is True); setting it
to False will leave the involved products unevaluated.

By default, the number of iterations is set to 2 but a greater value (up
to len(l)-1) can be specified with the optional 'niter' variable.
More and more convoluted results are found when the order of the
iteration gets higher:

  * first iteration returns polynomial or rational functions;
  * second iteration returns products of rising factorials and their
    inverses;
  * third iteration returns products of products of rising factorials
    and their inverses;
  * etc.

The returned formulas contain symbols i0, i1, i2, ... where the main
variables is i0 (and auxiliary variables are i1, i2, ...). A list of
other symbols can be provided in the 'variables' option; the length of
the least should be the value of 'niter' (more is acceptable but only
the first symbols will be used); in this case, the main variable will be
the first symbol in the list.

Examples
========

&gt;&gt;&gt; from sympy.concrete.guess import guess
&gt;&gt;&gt; guess([1,2,6,24,120], evaluate=False)
[Product(i1 + 1, (i1, 1, i0 - 1))]

&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; r = guess([1,2,7,42,429,7436,218348,10850216], niter=4)
&gt;&gt;&gt; i0 = symbols("i0")
&gt;&gt;&gt; [r[0].subs(i0,n).doit() for n in range(1,10)]
[1, 2, 7, 42, 429, 7436, 218348, 10850216, 911835460]
</pre> 
</div>
</div>
<a id="a163dfd12f6c7d02d53857dcba9b39d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163dfd12f6c7d02d53857dcba9b39d16">&#9670;&nbsp;</a></span>guess_generating_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.concrete.guess.guess_generating_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em> = <code><a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a>('x')</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>types</em> = <code>['all']</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsqrtn</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tries to "guess" a generating function for a sequence of rational numbers v.
Only a few patterns are implemented yet.

Explanation
===========

The function returns a dictionary where keys are the name of a given type of
generating function. Six types are currently implemented:

     type  |  formal definition
    -------+----------------------------------------------------------------
    ogf    | f(x) = Sum(            a_k * x^k       ,  k: 0..infinity )
    egf    | f(x) = Sum(            a_k * x^k / k!  ,  k: 0..infinity )
    lgf    | f(x) = Sum( (-1)^(k+1) a_k * x^k / k   ,  k: 1..infinity )
           |        (with initial index being hold as 1 rather than 0)
    hlgf   | f(x) = Sum(            a_k * x^k / k   ,  k: 1..infinity )
           |        (with initial index being hold as 1 rather than 0)
    lgdogf | f(x) = derivate( log(Sum( a_k * x^k, k: 0..infinity )), x)
    lgdegf | f(x) = derivate( log(Sum( a_k * x^k / k!, k: 0..infinity )), x)

In order to spare time, the user can select only some types of generating
functions (default being ['all']). While forgetting to use a list in the
case of a single type may seem to work most of the time as in: types='ogf'
this (convenient) syntax may lead to unexpected extra results in some cases.

Discarding a type when calling the function does not mean that the type will
not be present in the returned dictionary; it only means that no extra
computation will be performed for that type, but the function may still add
it in the result when it can be easily converted from another type.

Two generating functions (lgdogf and lgdegf) are not even computed if the
initial term of the sequence is 0; it may be useful in that case to try
again after having removed the leading zeros.

Examples
========

&gt;&gt;&gt; from sympy.concrete.guess import guess_generating_function as ggf
&gt;&gt;&gt; ggf([k+1 for k in range(12)], types=['ogf', 'lgf', 'hlgf'])
{'hlgf': 1/(1 - x), 'lgf': 1/(x + 1), 'ogf': 1/(x**2 - 2*x + 1)}

&gt;&gt;&gt; from sympy import sympify
&gt;&gt;&gt; l = sympify("[3/2, 11/2, 0, -121/2, -363/2, 121]")
&gt;&gt;&gt; ggf(l)
{'ogf': (x + 3/2)/(11*x**2 - 3*x + 1)}

&gt;&gt;&gt; from sympy import fibonacci
&gt;&gt;&gt; ggf([fibonacci(k) for k in range(5, 15)], types=['ogf'])
{'ogf': (3*x + 5)/(-x**2 - x + 1)}

&gt;&gt;&gt; from sympy import factorial
&gt;&gt;&gt; ggf([factorial(k) for k in range(12)], types=['ogf', 'egf', 'lgf'])
{'egf': 1/(1 - x)}

&gt;&gt;&gt; ggf([k+1 for k in range(12)], types=['egf'])
{'egf': (x + 1)*exp(x), 'lgdegf': (x + 2)/(x + 1)}

N-th root of a rational function can also be detected (below is an example
coming from the sequence A108626 from https://oeis.org).
The greatest n-th root to be tested is specified as maxsqrtn (default 2).

&gt;&gt;&gt; ggf([1, 2, 5, 14, 41, 124, 383, 1200, 3799, 12122, 38919])['ogf']
sqrt(1/(x**4 + 2*x**2 - 4*x + 1))

References
==========

.. [1] "Concrete Mathematics", R.L. Graham, D.E. Knuth, O. Patashnik
.. [2] https://oeis.org/wiki/Generating_functions</pre> 
</div>
</div>
<a id="aeea0761ca6fb1d8efbece29fb1290e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea0761ca6fb1d8efbece29fb1290e3a">&#9670;&nbsp;</a></span>guess_generating_function_rational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.concrete.guess.guess_generating_function_rational </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em> = <code><a class="el" href="classsympy_1_1core_1_1symbol_1_1Symbol.html">Symbol</a>('x')</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tries to "guess" a rational generating function for a sequence of rational
numbers v.

Examples
========

&gt;&gt;&gt; from sympy.concrete.guess import guess_generating_function_rational
&gt;&gt;&gt; from sympy import fibonacci
&gt;&gt;&gt; l = [fibonacci(k) for k in range(5,15)]
&gt;&gt;&gt; guess_generating_function_rational(l)
(3*x + 5)/(-x**2 - x + 1)

See Also
========

sympy.series.approximants
mpmath.pade</pre> 
</div>
</div>
<a id="a26453c1f4075c8f7ff2a7cfc9529d913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26453c1f4075c8f7ff2a7cfc9529d913">&#9670;&nbsp;</a></span>rationalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.concrete.guess.rationalize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxcoeff</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helps identifying a rational number from a float (or mpmath.mpf) value by
using a continued fraction. The algorithm stops as soon as a large partial
quotient is detected (greater than 10000 by default).

Examples
========

&gt;&gt;&gt; from sympy.concrete.guess import rationalize
&gt;&gt;&gt; from mpmath import cos, pi
&gt;&gt;&gt; rationalize(cos(pi/3))
1/2

&gt;&gt;&gt; from mpmath import mpf
&gt;&gt;&gt; rationalize(mpf("0.333333333333333"))
1/3

While the function is rather intended to help 'identifying' rational
values, it may be used in some cases for approximating real numbers.
(Though other functions may be more relevant in that case.)

&gt;&gt;&gt; rationalize(pi, maxcoeff = 250)
355/113

See Also
========

Several other methods can approximate a real number as a rational, like:

  * fractions.Fraction.from_decimal
  * fractions.Fraction.from_float
  * mpmath.identify
  * mpmath.pslq by using the following syntax: mpmath.pslq([x, 1])
  * mpmath.findpoly by using the following syntax: mpmath.findpoly(x, 1)
  * sympy.simplify.nsimplify (which is a more general function)

The main difference between the current function and all these variants is
that control focuses on magnitude of partial quotients here rather than on
global precision of the approximation. If the real is "known to be" a
rational number, the current function should be able to detect it correctly
with the default settings even when denominator is great (unless its
expansion contains unusually big partial quotients) which may occur
when studying sequences of increasing numbers. If the user cares more
on getting simple fractions, other methods may be more convenient.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
