<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.tensor.array.arrayop Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1tensor.html">tensor</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1tensor_1_1array.html">array</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1arrayop.html">arrayop</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.tensor.array.arrayop Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1tensor_1_1array_1_1arrayop_1_1Flatten.html">Flatten</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8209609aab76823e18be17041dd76061"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1arrayop.html#a8209609aab76823e18be17041dd76061">tensorproduct</a> (*args)</td></tr>
<tr class="separator:a8209609aab76823e18be17041dd76061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b398c1d65cf8c839f73d4d42177656"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1arrayop.html#a34b398c1d65cf8c839f73d4d42177656">tensorcontraction</a> (array, *contraction_axes)</td></tr>
<tr class="separator:a34b398c1d65cf8c839f73d4d42177656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16eeaa5716815832ee5c07002c721f4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1arrayop.html#a16eeaa5716815832ee5c07002c721f4f">tensordiagonal</a> (array, *diagonal_axes)</td></tr>
<tr class="separator:a16eeaa5716815832ee5c07002c721f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4824fe65b7069744d4c51f8445fb80e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1arrayop.html#ab4824fe65b7069744d4c51f8445fb80e">derive_by_array</a> (expr, dx)</td></tr>
<tr class="separator:ab4824fe65b7069744d4c51f8445fb80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7851d045f21748716164644dfe69d08f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1arrayop.html#a7851d045f21748716164644dfe69d08f">permutedims</a> (expr, perm=None, index_order_old=None, index_order_new=None)</td></tr>
<tr class="separator:a7851d045f21748716164644dfe69d08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab4824fe65b7069744d4c51f8445fb80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4824fe65b7069744d4c51f8445fb80e">&#9670;&nbsp;</a></span>derive_by_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.tensor.array.arrayop.derive_by_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Derivative by arrays. Supports both arrays and scalars.

The equivalent operator for array expressions is ``array_derive``.

Explanation
===========

Given the array `A_{i_1, \ldots, i_N}` and the array `X_{j_1, \ldots, j_M}`
this function will return a new array `B` defined by

`B_{j_1,\ldots,j_M,i_1,\ldots,i_N} := \frac{\partial A_{i_1,\ldots,i_N}}{\partial X_{j_1,\ldots,j_M}}`

Examples
========

&gt;&gt;&gt; from sympy import derive_by_array
&gt;&gt;&gt; from sympy.abc import x, y, z, t
&gt;&gt;&gt; from sympy import cos
&gt;&gt;&gt; derive_by_array(cos(x*t), x)
-t*sin(t*x)
&gt;&gt;&gt; derive_by_array(cos(x*t), [x, y, z, t])
[-t*sin(t*x), 0, 0, -x*sin(t*x)]
&gt;&gt;&gt; derive_by_array([x, y**2*z], [[x, y], [z, t]])
[[[1, 0], [0, 2*y*z]], [[0, y**2], [0, 0]]]</pre> 
</div>
</div>
<a id="a7851d045f21748716164644dfe69d08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7851d045f21748716164644dfe69d08f">&#9670;&nbsp;</a></span>permutedims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.tensor.array.arrayop.permutedims </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>perm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index_order_old</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index_order_new</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Permutes the indices of an array.

Parameter specifies the permutation of the indices.

The equivalent operator for array expressions is ``PermuteDims``, which can
be used to keep the expression unevaluated.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y, z, t
&gt;&gt;&gt; from sympy import sin
&gt;&gt;&gt; from sympy import Array, permutedims
&gt;&gt;&gt; a = Array([[x, y, z], [t, sin(x), 0]])
&gt;&gt;&gt; a
[[x, y, z], [t, sin(x), 0]]
&gt;&gt;&gt; permutedims(a, (1, 0))
[[x, t], [y, sin(x)], [z, 0]]

If the array is of second order, ``transpose`` can be used:

&gt;&gt;&gt; from sympy import transpose
&gt;&gt;&gt; transpose(a)
[[x, t], [y, sin(x)], [z, 0]]

Examples on higher dimensions:

&gt;&gt;&gt; b = Array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
&gt;&gt;&gt; permutedims(b, (2, 1, 0))
[[[1, 5], [3, 7]], [[2, 6], [4, 8]]]
&gt;&gt;&gt; permutedims(b, (1, 2, 0))
[[[1, 5], [2, 6]], [[3, 7], [4, 8]]]

An alternative way to specify the same permutations as in the previous
lines involves passing the *old* and *new* indices, either as a list or as
a string:

&gt;&gt;&gt; permutedims(b, index_order_old="cba", index_order_new="abc")
[[[1, 5], [3, 7]], [[2, 6], [4, 8]]]
&gt;&gt;&gt; permutedims(b, index_order_old="cab", index_order_new="abc")
[[[1, 5], [2, 6]], [[3, 7], [4, 8]]]

``Permutation`` objects are also allowed:

&gt;&gt;&gt; from sympy.combinatorics import Permutation
&gt;&gt;&gt; permutedims(b, Permutation([1, 2, 0]))
[[[1, 5], [2, 6]], [[3, 7], [4, 8]]]

See Also
========

sympy.tensor.array.expressions.array_expressions.PermuteDims</pre> 
</div>
</div>
<a id="a34b398c1d65cf8c839f73d4d42177656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b398c1d65cf8c839f73d4d42177656">&#9670;&nbsp;</a></span>tensorcontraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.tensor.array.arrayop.tensorcontraction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>contraction_axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Contraction of an array-like object on the specified axes.

The equivalent operator for array expressions is ``ArrayContraction``,
which can be used to keep the expression unevaluated.

Examples
========

&gt;&gt;&gt; from sympy import Array, tensorcontraction
&gt;&gt;&gt; from sympy import Matrix, eye
&gt;&gt;&gt; tensorcontraction(eye(3), (0, 1))
3
&gt;&gt;&gt; A = Array(range(18), (3, 2, 3))
&gt;&gt;&gt; A
[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]], [[12, 13, 14], [15, 16, 17]]]
&gt;&gt;&gt; tensorcontraction(A, (0, 2))
[21, 30]

Matrix multiplication may be emulated with a proper combination of
``tensorcontraction`` and ``tensorproduct``

&gt;&gt;&gt; from sympy import tensorproduct
&gt;&gt;&gt; from sympy.abc import a,b,c,d,e,f,g,h
&gt;&gt;&gt; m1 = Matrix([[a, b], [c, d]])
&gt;&gt;&gt; m2 = Matrix([[e, f], [g, h]])
&gt;&gt;&gt; p = tensorproduct(m1, m2)
&gt;&gt;&gt; p
[[[[a*e, a*f], [a*g, a*h]], [[b*e, b*f], [b*g, b*h]]], [[[c*e, c*f], [c*g, c*h]], [[d*e, d*f], [d*g, d*h]]]]
&gt;&gt;&gt; tensorcontraction(p, (1, 2))
[[a*e + b*g, a*f + b*h], [c*e + d*g, c*f + d*h]]
&gt;&gt;&gt; m1*m2
Matrix([
[a*e + b*g, a*f + b*h],
[c*e + d*g, c*f + d*h]])

See Also
========

sympy.tensor.array.expressions.array_expressions.ArrayContraction</pre> 
</div>
</div>
<a id="a16eeaa5716815832ee5c07002c721f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16eeaa5716815832ee5c07002c721f4f">&#9670;&nbsp;</a></span>tensordiagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.tensor.array.arrayop.tensordiagonal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>diagonal_axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Diagonalization of an array-like object on the specified axes.

This is equivalent to multiplying the expression by Kronecker deltas
uniting the axes.

The diagonal indices are put at the end of the axes.

The equivalent operator for array expressions is ``ArrayDiagonal``, which
can be used to keep the expression unevaluated.

Examples
========

``tensordiagonal`` acting on a 2-dimensional array by axes 0 and 1 is
equivalent to the diagonal of the matrix:

&gt;&gt;&gt; from sympy import Array, tensordiagonal
&gt;&gt;&gt; from sympy import Matrix, eye
&gt;&gt;&gt; tensordiagonal(eye(3), (0, 1))
[1, 1, 1]

&gt;&gt;&gt; from sympy.abc import a,b,c,d
&gt;&gt;&gt; m1 = Matrix([[a, b], [c, d]])
&gt;&gt;&gt; tensordiagonal(m1, [0, 1])
[a, d]

In case of higher dimensional arrays, the diagonalized out dimensions
are appended removed and appended as a single dimension at the end:

&gt;&gt;&gt; A = Array(range(18), (3, 2, 3))
&gt;&gt;&gt; A
[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]], [[12, 13, 14], [15, 16, 17]]]
&gt;&gt;&gt; tensordiagonal(A, (0, 2))
[[0, 7, 14], [3, 10, 17]]
&gt;&gt;&gt; from sympy import permutedims
&gt;&gt;&gt; tensordiagonal(A, (0, 2)) == permutedims(Array([A[0, :, 0], A[1, :, 1], A[2, :, 2]]), [1, 0])
True

See Also
========

sympy.tensor.array.expressions.array_expressions.ArrayDiagonal</pre> 
</div>
</div>
<a id="a8209609aab76823e18be17041dd76061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8209609aab76823e18be17041dd76061">&#9670;&nbsp;</a></span>tensorproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.tensor.array.arrayop.tensorproduct </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tensor product among scalars or array-like objects.

The equivalent operator for array expressions is ``ArrayTensorProduct``,
which can be used to keep the expression unevaluated.

Examples
========

&gt;&gt;&gt; from sympy.tensor.array import tensorproduct, Array
&gt;&gt;&gt; from sympy.abc import x, y, z, t
&gt;&gt;&gt; A = Array([[1, 2], [3, 4]])
&gt;&gt;&gt; B = Array([x, y])
&gt;&gt;&gt; tensorproduct(A, B)
[[[x, y], [2*x, 2*y]], [[3*x, 3*y], [4*x, 4*y]]]
&gt;&gt;&gt; tensorproduct(A, x)
[[x, 2*x], [3*x, 4*x]]
&gt;&gt;&gt; tensorproduct(A, B, B)
[[[[x**2, x*y], [x*y, y**2]], [[2*x**2, 2*x*y], [2*x*y, 2*y**2]]], [[[3*x**2, 3*x*y], [3*x*y, 3*y**2]], [[4*x**2, 4*x*y], [4*x*y, 4*y**2]]]]

Applying this function on two matrices will result in a rank 4 array.

&gt;&gt;&gt; from sympy import Matrix, eye
&gt;&gt;&gt; m = Matrix([[x, y], [z, t]])
&gt;&gt;&gt; p = tensorproduct(eye(3), m)
&gt;&gt;&gt; p
[[[[x, y], [z, t]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[x, y], [z, t]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]], [[x, y], [z, t]]]]

See Also
========

sympy.tensor.array.expressions.array_expressions.ArrayTensorProduct</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
