<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.polys.subresultants_qq_zz Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys.html">polys</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html">subresultants_qq_zz</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.polys.subresultants_qq_zz Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6dfa315f1efc80c18c5f65d4a968f37d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a6dfa315f1efc80c18c5f65d4a968f37d">sylvester</a> (f, g, x, method=1)</td></tr>
<tr class="separator:a6dfa315f1efc80c18c5f65d4a968f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2489afeeef2411cba499ac6baa578335"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a2489afeeef2411cba499ac6baa578335">process_matrix_output</a> (poly_seq, x)</td></tr>
<tr class="separator:a2489afeeef2411cba499ac6baa578335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fdae515d542c084ffca0a30f4518ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a21fdae515d542c084ffca0a30f4518ed">subresultants_sylv</a> (f, g, x)</td></tr>
<tr class="separator:a21fdae515d542c084ffca0a30f4518ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4cd61a6c90decaf98ff13d11fb6bd9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a6e4cd61a6c90decaf98ff13d11fb6bd9">modified_subresultants_sylv</a> (f, g, x)</td></tr>
<tr class="separator:a6e4cd61a6c90decaf98ff13d11fb6bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21de6a754e69657963a28a48789d2cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#ac21de6a754e69657963a28a48789d2cb">res</a> (f, g, x)</td></tr>
<tr class="separator:ac21de6a754e69657963a28a48789d2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0171a7a388d126c31609c0b9eb1db41b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a0171a7a388d126c31609c0b9eb1db41b">res_q</a> (f, g, x)</td></tr>
<tr class="separator:a0171a7a388d126c31609c0b9eb1db41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950dbc800d763315f994c73952ded1dc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a950dbc800d763315f994c73952ded1dc">res_z</a> (f, g, x)</td></tr>
<tr class="separator:a950dbc800d763315f994c73952ded1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af293c0caa365ad8bb65501f120a8a18a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#af293c0caa365ad8bb65501f120a8a18a">sign_seq</a> (poly_seq, x)</td></tr>
<tr class="separator:af293c0caa365ad8bb65501f120a8a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189b03336d31660e6d028e995dbf8fed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a189b03336d31660e6d028e995dbf8fed">bezout</a> (p, q, x, method='bz')</td></tr>
<tr class="separator:a189b03336d31660e6d028e995dbf8fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba5565ca53f8abaf672072a6e838ad1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a6ba5565ca53f8abaf672072a6e838ad1">backward_eye</a> (n)</td></tr>
<tr class="separator:a6ba5565ca53f8abaf672072a6e838ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b7abdb96570af27600abeb166ee33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a715b7abdb96570af27600abeb166ee33">subresultants_bezout</a> (p, q, x)</td></tr>
<tr class="separator:a715b7abdb96570af27600abeb166ee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6a2ca5ffae98d7bcb75ac1f2a19036"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a6c6a2ca5ffae98d7bcb75ac1f2a19036">modified_subresultants_bezout</a> (p, q, x)</td></tr>
<tr class="separator:a6c6a2ca5ffae98d7bcb75ac1f2a19036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725695ccb16357154afc98e0101928cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a725695ccb16357154afc98e0101928cb">sturm_pg</a> (p, q, x, method=0)</td></tr>
<tr class="separator:a725695ccb16357154afc98e0101928cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8d153e337dedc36c9aa002589b487c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a3e8d153e337dedc36c9aa002589b487c">sturm_q</a> (p, q, x)</td></tr>
<tr class="separator:a3e8d153e337dedc36c9aa002589b487c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe084bf3d4f925953f8e44473c99ff3d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#abe084bf3d4f925953f8e44473c99ff3d">sturm_amv</a> (p, q, x, method=0)</td></tr>
<tr class="separator:abe084bf3d4f925953f8e44473c99ff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae760ce17ae53eaccfb496933790fdb9d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#ae760ce17ae53eaccfb496933790fdb9d">euclid_pg</a> (p, q, x)</td></tr>
<tr class="separator:ae760ce17ae53eaccfb496933790fdb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808979b0cd00a35bcb97936d2a04d415"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a808979b0cd00a35bcb97936d2a04d415">euclid_q</a> (p, q, x)</td></tr>
<tr class="separator:a808979b0cd00a35bcb97936d2a04d415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db2de04bec995f0aaad8d5f04a5b0b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a6db2de04bec995f0aaad8d5f04a5b0b7">euclid_amv</a> (f, g, x)</td></tr>
<tr class="separator:a6db2de04bec995f0aaad8d5f04a5b0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f647701bfbb3f6588ae5b01a83fe41"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a55f647701bfbb3f6588ae5b01a83fe41">modified_subresultants_pg</a> (p, q, x)</td></tr>
<tr class="separator:a55f647701bfbb3f6588ae5b01a83fe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fda283a3d3d3542d20e807ed4fc766"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a94fda283a3d3d3542d20e807ed4fc766">subresultants_pg</a> (p, q, x)</td></tr>
<tr class="separator:a94fda283a3d3d3542d20e807ed4fc766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5657ed323bf6125a77a4aca6df505fcf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a5657ed323bf6125a77a4aca6df505fcf">subresultants_amv_q</a> (p, q, x)</td></tr>
<tr class="separator:a5657ed323bf6125a77a4aca6df505fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540c37b78974ca9a1ec94448c0fd7bd5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a540c37b78974ca9a1ec94448c0fd7bd5">compute_sign</a> (base, expo)</td></tr>
<tr class="separator:a540c37b78974ca9a1ec94448c0fd7bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87e740b87ca3853feb7b9132070f4eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#ae87e740b87ca3853feb7b9132070f4eb">rem_z</a> (p, q, x)</td></tr>
<tr class="separator:ae87e740b87ca3853feb7b9132070f4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12537284dbef30e8a65ecc6b7f41183e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a12537284dbef30e8a65ecc6b7f41183e">quo_z</a> (p, q, x)</td></tr>
<tr class="separator:a12537284dbef30e8a65ecc6b7f41183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a18f362f64b16b2ac3c12202aa0d91"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a07a18f362f64b16b2ac3c12202aa0d91">subresultants_amv</a> (f, g, x)</td></tr>
<tr class="separator:a07a18f362f64b16b2ac3c12202aa0d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d3edbb1ea8df564519b566d055b88d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a03d3edbb1ea8df564519b566d055b88d">modified_subresultants_amv</a> (p, q, x)</td></tr>
<tr class="separator:a03d3edbb1ea8df564519b566d055b88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f91beb30f832220eee981f7fec4f997"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a2f91beb30f832220eee981f7fec4f997">correct_sign</a> (deg_f, deg_g, s1, rdel, cdel)</td></tr>
<tr class="separator:a2f91beb30f832220eee981f7fec4f997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75d7066651d5c34b01eb84165c0e940"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#ac75d7066651d5c34b01eb84165c0e940">subresultants_rem</a> (p, q, x)</td></tr>
<tr class="separator:ac75d7066651d5c34b01eb84165c0e940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5a50aba713db15d5dd71b647ab4ba8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a4a5a50aba713db15d5dd71b647ab4ba8">pivot</a> (M, i, j)</td></tr>
<tr class="separator:a4a5a50aba713db15d5dd71b647ab4ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890cb55fd742cb2e634c948ccd96c1da"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a890cb55fd742cb2e634c948ccd96c1da">rotate_r</a> (L, k)</td></tr>
<tr class="separator:a890cb55fd742cb2e634c948ccd96c1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3979712fdc98a5cd3cc6db888974c6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a8e3979712fdc98a5cd3cc6db888974c6">rotate_l</a> (L, k)</td></tr>
<tr class="separator:a8e3979712fdc98a5cd3cc6db888974c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af969cf3762a4cb431bd291c469df1232"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#af969cf3762a4cb431bd291c469df1232">row2poly</a> (row, deg, x)</td></tr>
<tr class="separator:af969cf3762a4cb431bd291c469df1232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4559903c68465d3220c7ff7ffbced6c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#af4559903c68465d3220c7ff7ffbced6c">create_ma</a> (deg_f, deg_g, row1, row2, col_num)</td></tr>
<tr class="separator:af4559903c68465d3220c7ff7ffbced6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb0558aa4db07b1d645dd4ddb9aecb1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a3fb0558aa4db07b1d645dd4ddb9aecb1">find_degree</a> (M, deg_f)</td></tr>
<tr class="separator:a3fb0558aa4db07b1d645dd4ddb9aecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b3f6f2bf873555862bc60313717137"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a97b3f6f2bf873555862bc60313717137">final_touches</a> (s2, r, deg_g)</td></tr>
<tr class="separator:a97b3f6f2bf873555862bc60313717137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10f1d072959c1e89e6f0f5fa38e817e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#ae10f1d072959c1e89e6f0f5fa38e817e">subresultants_vv</a> (p, q, x, method=0)</td></tr>
<tr class="separator:ae10f1d072959c1e89e6f0f5fa38e817e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a13babc39555fb4e40147ebd6e416f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1subresultants__qq__zz.html#a8a13babc39555fb4e40147ebd6e416f8">subresultants_vv_2</a> (p, q, x)</td></tr>
<tr class="separator:a8a13babc39555fb4e40147ebd6e416f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module contains functions for the computation
of Euclidean, (generalized) Sturmian, (modified) subresultant
polynomial remainder sequences (prs's) of two polynomials;
included are also three functions for the computation of the
resultant of two polynomials.

Except for the function res_z(), which computes the resultant
of two polynomials, the pseudo-remainder function prem()
of sympy is _not_ used by any of the functions in the module.

Instead of prem() we use the function

rem_z().

Included is also the function quo_z().

An explanation of why we avoid prem() can be found in the
references stated in the docstring of rem_z().

1. Theoretical background:
==========================
Consider the polynomials f, g in Z[x] of degrees deg(f) = n and
deg(g) = m with n &gt;= m.

Definition 1:
=============
The sign sequence of a polynomial remainder sequence (prs) is the
sequence of signs of the leading coefficients of its polynomials.

Sign sequences can be computed with the function:

sign_seq(poly_seq, x)

Definition 2:
=============
A polynomial remainder sequence (prs) is called complete if the
degree difference between any two consecutive polynomials is 1;
otherwise, it called incomplete.

It is understood that f, g belong to the sequences mentioned in
the two definitions above.

1A. Euclidean and subresultant prs's:
=====================================
The subresultant prs of f, g is a sequence of polynomials in Z[x]
analogous to the Euclidean prs, the sequence obtained by applying
on f, g Euclid's algorithm for polynomial greatest common divisors
(gcd) in Q[x].

The subresultant prs differs from the Euclidean prs in that the
coefficients of each polynomial in the former sequence are determinants
--- also referred to as subresultants --- of appropriately selected
sub-matrices of sylvester1(f, g, x), Sylvester's matrix of 1840 of
dimensions (n + m) * (n + m).

Recall that the determinant of sylvester1(f, g, x) itself is
called the resultant of f, g and serves as a criterion of whether
the two polynomials have common roots or not.

In SymPy the resultant is computed with the function
resultant(f, g, x). This function does _not_ evaluate the
determinant of sylvester(f, g, x, 1); instead, it returns
the last member of the subresultant prs of f, g, multiplied
(if needed) by an appropriate power of -1; see the caveat below.

In this module we use three functions to compute the
resultant of f, g:
a) res(f, g, x) computes the resultant by evaluating
the determinant of sylvester(f, g, x, 1);
b) res_q(f, g, x) computes the resultant recursively, by
performing polynomial divisions in Q[x] with the function rem();
c) res_z(f, g, x) computes the resultant recursively, by
performing polynomial divisions in Z[x] with the function prem().

Caveat: If Df = degree(f, x) and Dg = degree(g, x), then:

resultant(f, g, x) = (-1)**(Df*Dg) * resultant(g, f, x).

For complete prs's the sign sequence of the Euclidean prs of f, g
is identical to the sign sequence of the subresultant prs of f, g
and the coefficients of one sequence  are easily computed from the
coefficients of the  other.

For incomplete prs's the polynomials in the subresultant prs, generally
differ in sign from those of the Euclidean prs, and --- unlike the
case of complete prs's --- it is not at all obvious how to compute
the coefficients of one sequence from the coefficients of the  other.

1B. Sturmian and modified subresultant prs's:
=============================================
For the same polynomials f, g in Z[x] mentioned above, their ``modified''
subresultant prs is a sequence of polynomials similar to the Sturmian
prs, the sequence obtained by applying in Q[x] Sturm's algorithm on f, g.

The two sequences differ in that the coefficients of each polynomial
in the modified subresultant prs are the determinants --- also referred
to as modified subresultants --- of appropriately selected  sub-matrices
of sylvester2(f, g, x), Sylvester's matrix of 1853 of dimensions 2n x 2n.

The determinant of sylvester2 itself is called the modified resultant
of f, g and it also can serve as a criterion of whether the two
polynomials have common roots or not.

For complete prs's the  sign sequence of the Sturmian prs of f, g is
identical to the sign sequence of the modified subresultant prs of
f, g and the coefficients of one sequence  are easily computed from
the coefficients of the other.

For incomplete prs's the polynomials in the modified subresultant prs,
generally differ in sign from those of the Sturmian prs, and --- unlike
the case of complete prs's --- it is not at all obvious how to compute
the coefficients of one sequence from the coefficients of the  other.

As Sylvester pointed out, the coefficients of the polynomial remainders
obtained as (modified) subresultants are the smallest possible without
introducing rationals and without computing (integer) greatest common
divisors.

1C. On terminology:
===================
Whence the terminology? Well generalized Sturmian prs's are
``modifications'' of Euclidean prs's; the hint came from the title
of the Pell-Gordon paper of 1917.

In the literature one also encounters the name ``non signed'' and
``signed'' prs for Euclidean and Sturmian prs respectively.

Likewise ``non signed'' and ``signed'' subresultant prs for
subresultant and modified subresultant prs respectively.

2. Functions in the module:
===========================
No function utilizes SymPy's function prem().

2A. Matrices:
=============
The functions sylvester(f, g, x, method=1) and
sylvester(f, g, x, method=2) compute either Sylvester matrix.
They can be used to compute (modified) subresultant prs's by
direct determinant evaluation.

The function bezout(f, g, x, method='prs') provides a matrix of
smaller dimensions than either Sylvester matrix. It is the function
of choice for computing (modified) subresultant prs's by direct
determinant evaluation.

sylvester(f, g, x, method=1)
sylvester(f, g, x, method=2)
bezout(f, g, x, method='prs')

The following identity holds:

bezout(f, g, x, method='prs') =
backward_eye(deg(f))*bezout(f, g, x, method='bz')*backward_eye(deg(f))

2B. Subresultant and modified subresultant prs's by
===================================================
determinant evaluations:
=======================
We use the Sylvester matrices of 1840 and 1853 to
compute, respectively, subresultant and modified
subresultant polynomial remainder sequences. However,
for large matrices this approach takes a lot of time.

Instead of utilizing the Sylvester matrices, we can
employ the Bezout matrix which is of smaller dimensions.

subresultants_sylv(f, g, x)
modified_subresultants_sylv(f, g, x)
subresultants_bezout(f, g, x)
modified_subresultants_bezout(f, g, x)

2C. Subresultant prs's by ONE determinant evaluation:
=====================================================
All three functions in this section evaluate one determinant
per remainder polynomial; this is the determinant of an
appropriately selected sub-matrix of sylvester1(f, g, x),
Sylvester's matrix of 1840.

To compute the remainder polynomials the function
subresultants_rem(f, g, x) employs rem(f, g, x).
By contrast, the other two functions implement Van Vleck's ideas
of 1900 and compute the remainder polynomials by trinagularizing
sylvester2(f, g, x), Sylvester's matrix of 1853.


subresultants_rem(f, g, x)
subresultants_vv(f, g, x)
subresultants_vv_2(f, g, x).

2E. Euclidean, Sturmian prs's in Q[x]:
======================================
euclid_q(f, g, x)
sturm_q(f, g, x)

2F. Euclidean, Sturmian and (modified) subresultant prs's P-G:
==============================================================
All functions in this section are based on the Pell-Gordon (P-G)
theorem of 1917.
Computations are done in Q[x], employing the function rem(f, g, x)
for the computation of the remainder polynomials.

euclid_pg(f, g, x)
sturm pg(f, g, x)
subresultants_pg(f, g, x)
modified_subresultants_pg(f, g, x)

2G. Euclidean, Sturmian and (modified) subresultant prs's A-M-V:
================================================================
All functions in this section are based on the Akritas-Malaschonok-
Vigklas (A-M-V) theorem of 2015.
Computations are done in Z[x], employing the function rem_z(f, g, x)
for the computation of the remainder polynomials.

euclid_amv(f, g, x)
sturm_amv(f, g, x)
subresultants_amv(f, g, x)
modified_subresultants_amv(f, g, x)

2Ga. Exception:
===============
subresultants_amv_q(f, g, x)

This function employs rem(f, g, x) for the computation of
the remainder polynomials, despite the fact that it implements
the A-M-V Theorem.

It is included in our module in order to show that theorems P-G
and A-M-V can be implemented utilizing either the function
rem(f, g, x) or the function rem_z(f, g, x).

For clearly historical reasons --- since the Collins-Brown-Traub
coefficients-reduction factor beta_i was not available in 1917 ---
we have implemented the Pell-Gordon theorem with the function
rem(f, g, x) and the A-M-V Theorem  with the function rem_z(f, g, x).

2H. Resultants:
===============
res(f, g, x)
res_q(f, g, x)
res_z(f, g, x)
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6ba5565ca53f8abaf672072a6e838ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba5565ca53f8abaf672072a6e838ad1">&#9670;&nbsp;</a></span>backward_eye()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.backward_eye </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the backward identity matrix of dimensions n x n.

Needed to "turn" the Bezout matrices
so that the leading coefficients are first.
See docstring of the function bezout(p, q, x, method='bz').
</pre> 
</div>
</div>
<a id="a189b03336d31660e6d028e995dbf8fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189b03336d31660e6d028e995dbf8fed">&#9670;&nbsp;</a></span>bezout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.bezout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'bz'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The input polynomials p, q are in Z[x] or in Q[x]. Let
mx = max(degree(p, x), degree(q, x)).

The default option bezout(p, q, x, method='bz') returns Bezout's
symmetric matrix of p and q, of dimensions (mx) x (mx). The
determinant of this matrix is equal to the determinant of sylvester2,
Sylvester's matrix of 1853, whose dimensions are (2*mx) x (2*mx);
however the subresultants of these two matrices may differ.

The other option, bezout(p, q, x, 'prs'), is of interest to us
in this module because it returns a matrix equivalent to sylvester2.
In this case all subresultants of the two matrices are identical.

Both the subresultant polynomial remainder sequence (prs) and
the modified subresultant prs of p and q can be computed by
evaluating determinants of appropriately selected submatrices of
bezout(p, q, x, 'prs') --- one determinant per coefficient of the
remainder polynomials.

The matrices bezout(p, q, x, 'bz') and bezout(p, q, x, 'prs')
are related by the formula

bezout(p, q, x, 'prs') =
backward_eye(deg(p)) * bezout(p, q, x, 'bz') * backward_eye(deg(p)),

where backward_eye() is the backward identity function.

References
==========
1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants
and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,
Vol. 15, 233-266, 2004.</pre> 
</div>
</div>
<a id="a540c37b78974ca9a1ec94448c0fd7bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540c37b78974ca9a1ec94448c0fd7bd5">&#9670;&nbsp;</a></span>compute_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.compute_sign </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">base != 0 and expo &gt;= 0 are integers;

returns the sign of base**expo without
evaluating the power itself!
</pre> 
</div>
</div>
<a id="a2f91beb30f832220eee981f7fec4f997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f91beb30f832220eee981f7fec4f997">&#9670;&nbsp;</a></span>correct_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.correct_sign </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rdel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cdel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Used in various subresultant prs algorithms.

Evaluates the determinant, (a.k.a. subresultant) of a properly selected
submatrix of s1, Sylvester's matrix of 1840, to get the correct sign
and value of the leading coefficient of a given polynomial remainder.

deg_f, deg_g are the degrees of the original polynomials p, q for which the
matrix s1 = sylvester(p, q, x, 1) was constructed.

rdel denotes the expected degree of the remainder; it is the number of
rows to be deleted from each group of rows in s1 as described in the
reference below.

cdel denotes the expected degree minus the actual degree of the remainder;
it is the number of columns to be deleted --- starting with the last column
forming the square matrix --- from the matrix resulting after the row deletions.

References
==========
Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences
and Modified Subresultant Polynomial Remainder Sequences.''
Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.</pre> 
</div>
</div>
<a id="af4559903c68465d3220c7ff7ffbced6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4559903c68465d3220c7ff7ffbced6c">&#9670;&nbsp;</a></span>create_ma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.create_ma </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>col_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a ``small'' matrix M to be triangularized.

deg_f, deg_g are the degrees of the divident and of the
divisor polynomials respectively, deg_g &gt; deg_f.

The coefficients of the divident poly are the elements
in row2 and those of the divisor poly are the elements
in row1.

col_num defines the number of columns of the matrix M.</pre> 
</div>
</div>
<a id="a6db2de04bec995f0aaad8d5f04a5b0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db2de04bec995f0aaad8d5f04a5b0b7">&#9670;&nbsp;</a></span>euclid_amv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.euclid_amv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">f, g are polynomials in Z[x] or Q[x]. It is assumed
that degree(f, x) &gt;= degree(g, x).

Computes the Euclidean sequence of p and q in Z[x] or Q[x].

If the Euclidean sequence is complete the coefficients of the polynomials
in the sequence are subresultants. That is, they are  determinants of
appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.
In this case the Euclidean sequence coincides with the subresultant prs,
of the polynomials p, q.

If the Euclidean sequence is incomplete the signs of the coefficients of the
polynomials in the sequence may differ from the signs of the coefficients of
the corresponding polynomials in the subresultant prs; however, the absolute
values are the same.

To compute the coefficients, no determinant evaluation takes place.
Instead, polynomial divisions in Z[x] or Q[x] are performed, using
the function rem_z(f, g, x);  the coefficients of the remainders
computed this way become subresultants with the help of the
Collins-Brown-Traub formula for coefficient reduction.

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result
on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial
remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''
Serdica Journal of Computing 10 (2016), No.3-4, 197-217.</pre> 
</div>
</div>
<a id="ae760ce17ae53eaccfb496933790fdb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae760ce17ae53eaccfb496933790fdb9d">&#9670;&nbsp;</a></span>euclid_pg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.euclid_pg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the Euclidean sequence of p and q in Z[x] or Q[x].

If the Euclidean sequence is complete the coefficients of the polynomials
in the sequence are subresultants. That is, they are  determinants of
appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.
In this case the Euclidean sequence coincides with the subresultant prs
of the polynomials p, q.

If the Euclidean sequence is incomplete the signs of the coefficients of the
polynomials in the sequence may differ from the signs of the coefficients of
the corresponding polynomials in the subresultant prs; however, the absolute
values are the same.

To compute the Euclidean sequence, no determinant evaluation takes place.
We first compute the (generalized) Sturm sequence  of p and q using
sturm_pg(p, q, x, 1), in which case the coefficients are (in absolute value)
equal to subresultants. Then we change the signs of the remainders in the
Sturm sequence according to the pattern "-, -, +, +, -, -, +, +,..." ;
see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference as well as
the function sturm_pg(p, q, x).

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result
on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders
Obtained in Finding the Greatest Common Divisor of Two Polynomials.'' Serdica
Journal of Computing 9(2) (2015), 123-138.

3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial
Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''
Serdica Journal of Computing 10 (2016), No.3-4, 197-217.
</pre> 
</div>
</div>
<a id="a808979b0cd00a35bcb97936d2a04d415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808979b0cd00a35bcb97936d2a04d415">&#9670;&nbsp;</a></span>euclid_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.euclid_q </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the Euclidean sequence of p and q in Q[x].
Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).

The coefficients of the polynomials in the Euclidean sequence can be uniquely
determined from the corresponding coefficients of the polynomials found
either in:

    (a) the ``modified'' subresultant polynomial remainder sequence,
(references 1, 2)

or in

    (b) the subresultant polynomial remainder sequence (references 3).

References
==========
1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding
the Highest Common Factor of Two Polynomials. Annals of MatheMatics,
Second Series, 18 (1917), No. 4, 188-193.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences
and Modified Subresultant Polynomial Remainder Sequences.''
Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.

3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result
on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.</pre> 
</div>
</div>
<a id="a97b3f6f2bf873555862bc60313717137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b3f6f2bf873555862bc60313717137">&#9670;&nbsp;</a></span>final_touches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.final_touches </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg_g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">s2 is sylvester2, r is the row pointer in s2,
deg_g is the degree of the poly last inserted in s2.

After a gcd of degree &gt; 0 has been found with Van Vleck's
method, and was inserted into s2, if its last term is not
in the last column of s2, then it is inserted as many
times as needed, rotated right by one each time, until
the condition is met.</pre> 
</div>
</div>
<a id="a3fb0558aa4db07b1d645dd4ddb9aecb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb0558aa4db07b1d645dd4ddb9aecb1">&#9670;&nbsp;</a></span>find_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.find_degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds the degree of the poly corresponding (after triangularization)
to the _last_ row of the ``small'' matrix M, created by create_ma().

deg_f is the degree of the divident poly.
If _last_ row is all 0's returns None.</pre> 
</div>
</div>
<a id="a03d3edbb1ea8df564519b566d055b88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d3edbb1ea8df564519b566d055b88d">&#9670;&nbsp;</a></span>modified_subresultants_amv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.modified_subresultants_amv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the modified subresultant prs of p and q in Z[x] or Q[x],
from the subresultant prs of p and q.
The coefficients of the polynomials in the two sequences differ only
in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in
Theorem 2 of the reference.

The coefficients of the polynomials in the output sequence are
modified subresultants. That is, they are  determinants of appropriately
selected submatrices of sylvester2, Sylvester's matrix of 1853.

If the modified subresultant prs is complete, and LC( p ) &gt; 0, it coincides
with the (generalized) Sturm's sequence of the polynomials p, q.

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: "On the Remainders
Obtained in Finding the Greatest Common Divisor of Two Polynomials."
Serdica Journal of Computing, Serdica Journal of Computing, 9(2) (2015), 123-138.</pre> 
</div>
</div>
<a id="a6c6a2ca5ffae98d7bcb75ac1f2a19036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6a2ca5ffae98d7bcb75ac1f2a19036">&#9670;&nbsp;</a></span>modified_subresultants_bezout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.modified_subresultants_bezout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The input polynomials p, q are in Z[x] or in Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the modified subresultant polynomial remainder sequence
of p, q by evaluating determinants of appropriately selected
submatrices of bezout(p, q, x, 'prs'). The dimensions of the
latter are deg(p) x deg(p).

Each coefficient is computed by evaluating the determinant of the
corresponding submatrix of bezout(p, q, x, 'prs').

bezout(p, q, x, 'prs') is used instead of sylvester(p, q, x, 2),
Sylvester's matrix of 1853, because the dimensions of the latter
are 2*deg(p) x 2*deg(p).

If the modified subresultant prs is complete, and LC( p ) &gt; 0, the output
coincides with the (generalized) Sturm's sequence of the polynomials p, q.

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences
and Modified Subresultant Polynomial Remainder Sequences.''
Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.

2. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants
and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,
Vol. 15, 233-266, 2004.</pre> 
</div>
</div>
<a id="a55f647701bfbb3f6588ae5b01a83fe41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f647701bfbb3f6588ae5b01a83fe41">&#9670;&nbsp;</a></span>modified_subresultants_pg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.modified_subresultants_pg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the ``modified'' subresultant prs of p and q in Z[x] or Q[x];
the coefficients of the polynomials in the sequence are
``modified'' subresultants. That is, they are  determinants of appropriately
selected submatrices of sylvester2, Sylvester's matrix of 1853.

To compute the coefficients, no determinant evaluation takes place. Instead,
polynomial divisions in Q[x] are performed, using the function rem(p, q, x);
the coefficients of the remainders computed this way become ``modified''
subresultants with the help of the Pell-Gordon Theorem of 1917.

If the ``modified'' subresultant prs is complete, and LC( p ) &gt; 0, it coincides
with the (generalized) Sturm sequence of the polynomials p, q.

References
==========
1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding
the Highest Common Factor of Two Polynomials. Annals of MatheMatics,
Second Series, 18 (1917), No. 4, 188-193.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences
and Modified Subresultant Polynomial Remainder Sequences.''
Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.</pre> 
</div>
</div>
<a id="a6e4cd61a6c90decaf98ff13d11fb6bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4cd61a6c90decaf98ff13d11fb6bd9">&#9670;&nbsp;</a></span>modified_subresultants_sylv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.modified_subresultants_sylv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The input polynomials f, g are in Z[x] or in Q[x]. It is assumed
that deg(f) &gt;= deg(g).

Computes the modified subresultant polynomial remainder sequence (prs)
of f, g by evaluating determinants of appropriately selected
submatrices of sylvester(f, g, x, 2). The dimensions of the
latter are (2*deg(f)) x (2*deg(f)).

Each coefficient is computed by evaluating the determinant of the
corresponding submatrix of sylvester(f, g, x, 2).

If the modified subresultant prs is complete, then the output coincides
with the Sturmian sequence of the polynomials f, g.

References:
===========
1. A. G. Akritas,G.I. Malaschonok and P.S. Vigklas:
Sturm Sequences and Modified Subresultant Polynomial Remainder
Sequences. Serdica Journal of Computing, Vol. 8, No 1, 29--46, 2014.</pre> 
</div>
</div>
<a id="a4a5a50aba713db15d5dd71b647ab4ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5a50aba713db15d5dd71b647ab4ba8">&#9670;&nbsp;</a></span>pivot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.pivot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">M is a matrix, and M[i, j] specifies the pivot element.

All elements below M[i, j], in the j-th column, will
be zeroed, if they are not already 0, according to
Dodgson-Bareiss' integer preserving transformations.

References
==========
1. Akritas, A. G.: ``A new method for computing polynomial greatest
common divisors and polynomial remainder sequences.''
Numerische MatheMatik 52, 119-127, 1988.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem
by Van Vleck Regarding Sturm Sequences.''
Serdica Journal of Computing, 7, No 4, 101-134, 2013.</pre> 
</div>
</div>
<a id="a2489afeeef2411cba499ac6baa578335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2489afeeef2411cba499ac6baa578335">&#9670;&nbsp;</a></span>process_matrix_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.process_matrix_output </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poly_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">poly_seq is a polynomial remainder sequence computed either by
(modified_)subresultants_bezout or by (modified_)subresultants_sylv.

This function removes from poly_seq all zero polynomials as well
as all those whose degree is equal to the degree of a preceding
polynomial in poly_seq, as we scan it from left to right.</pre> 
</div>
</div>
<a id="a12537284dbef30e8a65ecc6b7f41183e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12537284dbef30e8a65ecc6b7f41183e">&#9670;&nbsp;</a></span>quo_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.quo_z </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intended mainly for p, q polynomials in Z[x] so that,
on dividing p by q, the quotient will also be in Z[x]. (However,
it also works fine for polynomials in Q[x].) It is assumed
that degree(p, x) &gt;= degree(q, x).

It premultiplies p by the _absolute_ value of the leading coefficient
of q, raised to the power deg(p) - deg(q) + 1 and then performs
polynomial division in Q[x], using the function quo(p, q, x).

By contrast the function pquo(p, q, x) does _not_ use the absolute
value of the leading coefficient of q.

See also function rem_z(p, q, x) for additional comments and references.</pre> 
</div>
</div>
<a id="ae87e740b87ca3853feb7b9132070f4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87e740b87ca3853feb7b9132070f4eb">&#9670;&nbsp;</a></span>rem_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.rem_z </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intended mainly for p, q polynomials in Z[x] so that,
on dividing p by q, the remainder will also be in Z[x]. (However,
it also works fine for polynomials in Q[x].) It is assumed
that degree(p, x) &gt;= degree(q, x).

It premultiplies p by the _absolute_ value of the leading coefficient
of q, raised to the power deg(p) - deg(q) + 1 and then performs
polynomial division in Q[x], using the function rem(p, q, x).

By contrast the function prem(p, q, x) does _not_ use the absolute
value of the leading coefficient of q.
This results not only in ``messing up the signs'' of the Euclidean and
Sturmian prs's as mentioned in the second reference,
but also in violation of the main results of the first and third
references --- Theorem 4 and Theorem 1 respectively. Theorems 4 and 1
establish a one-to-one correspondence between the Euclidean and the
Sturmian prs of p, q, on one hand, and the subresultant prs of p, q,
on the other.

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders
Obtained in Finding the Greatest Common Divisor of Two Polynomials.''
Serdica Journal of Computing, 9(2) (2015), 123-138.

2. https://planetMath.org/sturmstheorem

3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result on
the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.</pre> 
</div>
</div>
<a id="ac21de6a754e69657963a28a48789d2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21de6a754e69657963a28a48789d2cb">&#9670;&nbsp;</a></span>res()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.res </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The input polynomials f, g are in Z[x] or in Q[x].

The output is the resultant of f, g computed by evaluating
the determinant of the matrix sylvester(f, g, x, 1).

References:
===========
1. J. S. Cohen: Computer Algebra and Symbolic Computation
 - Mathematical Methods. A. K. Peters, 2003.</pre> 
</div>
</div>
<a id="a0171a7a388d126c31609c0b9eb1db41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0171a7a388d126c31609c0b9eb1db41b">&#9670;&nbsp;</a></span>res_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.res_q </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The input polynomials f, g are in Z[x] or in Q[x].

The output is the resultant of f, g computed recursively
by polynomial divisions in Q[x], using the function rem.
See Cohen's book p. 281.

References:
===========
1. J. S. Cohen: Computer Algebra and Symbolic Computation
 - Mathematical Methods. A. K. Peters, 2003.
</pre> 
</div>
</div>
<a id="a950dbc800d763315f994c73952ded1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950dbc800d763315f994c73952ded1dc">&#9670;&nbsp;</a></span>res_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.res_z </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The input polynomials f, g are in Z[x] or in Q[x].

The output is the resultant of f, g computed recursively
by polynomial divisions in Z[x], using the function prem().
See Cohen's book p. 283.

References:
===========
1. J. S. Cohen: Computer Algebra and Symbolic Computation
 - Mathematical Methods. A. K. Peters, 2003.
</pre> 
</div>
</div>
<a id="a8e3979712fdc98a5cd3cc6db888974c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3979712fdc98a5cd3cc6db888974c6">&#9670;&nbsp;</a></span>rotate_l()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.rotate_l </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rotates left by k. L is a row of a matrix or a list.</pre> 
</div>
</div>
<a id="a890cb55fd742cb2e634c948ccd96c1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890cb55fd742cb2e634c948ccd96c1da">&#9670;&nbsp;</a></span>rotate_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.rotate_r </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rotates right by k. L is a row of a matrix or a list.</pre> 
</div>
</div>
<a id="af969cf3762a4cb431bd291c469df1232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af969cf3762a4cb431bd291c469df1232">&#9670;&nbsp;</a></span>row2poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.row2poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts the row of a matrix to a poly of degree deg and variable x.
Some entries at the beginning and/or at the end of the row may be zero.</pre> 
</div>
</div>
<a id="af293c0caa365ad8bb65501f120a8a18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af293c0caa365ad8bb65501f120a8a18a">&#9670;&nbsp;</a></span>sign_seq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.sign_seq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poly_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a sequence of polynomials poly_seq, it returns
the sequence of signs of the leading coefficients of
the polynomials in poly_seq.</pre> 
</div>
</div>
<a id="abe084bf3d4f925953f8e44473c99ff3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe084bf3d4f925953f8e44473c99ff3d">&#9670;&nbsp;</a></span>sturm_amv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.sturm_amv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].
If q = diff(p, x, 1) it is the usual Sturm sequence.

A. If method == 0, default, the remainder coefficients of the
   sequence are (in absolute value) ``modified'' subresultants, which
   for non-monic polynomials are greater than the coefficients of the
   corresponding subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).

B. If method == 1, the remainder coefficients of the sequence are (in
   absolute value) subresultants, which for non-monic polynomials are
   smaller than the coefficients of the corresponding ``modified''
   subresultants by the factor Abs( LC(p)**( deg(p)- deg(q)) ).

If the Sturm sequence is complete, method=0 and LC( p ) &gt; 0, then the
coefficients of the polynomials in the sequence are ``modified'' subresultants.
That is, they are  determinants of appropriately selected submatrices of
sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence
coincides with the ``modified'' subresultant prs, of the polynomials
p, q.

If the Sturm sequence is incomplete and method=0 then the signs of the
coefficients of the polynomials in the sequence may differ from the signs
of the coefficients of the corresponding polynomials in the ``modified''
subresultant prs; however, the absolute values are the same.

To compute the coefficients, no determinant evaluation takes place.
Instead, we first compute the euclidean sequence  of p and q using
euclid_amv(p, q, x) and then: (a) change the signs of the remainders in the
Euclidean sequence according to the pattern "-, -, +, +, -, -, +, +,..."
(see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference)
and (b) if method=0, assuming deg(p) &gt; deg(q), we multiply the remainder
coefficients of the Euclidean sequence times the factor
Abs( LC(p)**( deg(p)- deg(q)) ) to make them modified subresultants.
See also the function sturm_pg(p, q, x).

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result
on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders
Obtained in Finding the Greatest Common Divisor of Two Polynomials.'' Serdica
Journal of Computing 9(2) (2015), 123-138.

3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial
Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''
Serdica Journal of Computing 10 (2016), No.3-4, 197-217.</pre> 
</div>
</div>
<a id="a725695ccb16357154afc98e0101928cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725695ccb16357154afc98e0101928cb">&#9670;&nbsp;</a></span>sturm_pg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.sturm_pg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].
If q = diff(p, x, 1) it is the usual Sturm sequence.

A. If method == 0, default, the remainder coefficients of the sequence
   are (in absolute value) ``modified'' subresultants, which for non-monic
   polynomials are greater than the coefficients of the corresponding
   subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).

B. If method == 1, the remainder coefficients of the sequence are (in
   absolute value) subresultants, which for non-monic polynomials are
   smaller than the coefficients of the corresponding ``modified''
   subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).

If the Sturm sequence is complete, method=0 and LC( p ) &gt; 0, the coefficients
of the polynomials in the sequence are ``modified'' subresultants.
That is, they are  determinants of appropriately selected submatrices of
sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence
coincides with the ``modified'' subresultant prs, of the polynomials
p, q.

If the Sturm sequence is incomplete and method=0 then the signs of the
coefficients of the polynomials in the sequence may differ from the signs
of the coefficients of the corresponding polynomials in the ``modified''
subresultant prs; however, the absolute values are the same.

To compute the coefficients, no determinant evaluation takes place. Instead,
polynomial divisions in Q[x] are performed, using the function rem(p, q, x);
the coefficients of the remainders computed this way become (``modified'')
subresultants with the help of the Pell-Gordon Theorem of 1917.
See also the function euclid_pg(p, q, x).

References
==========
1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding
the Highest Common Factor of Two Polynomials. Annals of MatheMatics,
Second Series, 18 (1917), No. 4, 188-193.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences
and Modified Subresultant Polynomial Remainder Sequences.''
Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.</pre> 
</div>
</div>
<a id="a3e8d153e337dedc36c9aa002589b487c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8d153e337dedc36c9aa002589b487c">&#9670;&nbsp;</a></span>sturm_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.sturm_q </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the (generalized) Sturm sequence of p and q in Q[x].
Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).

The coefficients of the polynomials in the Sturm sequence can be uniquely
determined from the corresponding coefficients of the polynomials found
either in:

    (a) the ``modified'' subresultant prs, (references 1, 2)

or in

    (b) the subresultant prs (reference 3).

References
==========
1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding
the Highest Common Factor of Two Polynomials. Annals of MatheMatics,
Second Series, 18 (1917), No. 4, 188-193.

2 Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences
and Modified Subresultant Polynomial Remainder Sequences.''
Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.

3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result
on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.</pre> 
</div>
</div>
<a id="a07a18f362f64b16b2ac3c12202aa0d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a18f362f64b16b2ac3c12202aa0d91">&#9670;&nbsp;</a></span>subresultants_amv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.subresultants_amv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(f, x) &gt;= degree(g, x).

Computes the subresultant prs of p and q in Z[x] or Q[x];
the coefficients of the polynomials in the sequence are
subresultants. That is, they are  determinants of appropriately
selected submatrices of sylvester1, Sylvester's matrix of 1840.

To compute the coefficients, no determinant evaluation takes place.
Instead, polynomial divisions in Z[x] or Q[x] are performed, using
the function rem_z(p, q, x);  the coefficients of the remainders
computed this way become subresultants with the help of the
Akritas-Malaschonok-Vigklas Theorem of 2015 and the Collins-Brown-
Traub formula for coefficient reduction.

If the subresultant prs is complete, then it coincides with the
Euclidean sequence of the polynomials p, q.

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result
on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial
remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''
Serdica Journal of Computing 10 (2016), No.3-4, 197-217.</pre> 
</div>
</div>
<a id="a5657ed323bf6125a77a4aca6df505fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5657ed323bf6125a77a4aca6df505fcf">&#9670;&nbsp;</a></span>subresultants_amv_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.subresultants_amv_q </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the subresultant prs of p and q in Q[x];
the coefficients of the polynomials in the sequence are
subresultants. That is, they are  determinants of appropriately
selected submatrices of sylvester1, Sylvester's matrix of 1840.

To compute the coefficients, no determinant evaluation takes place.
Instead, polynomial divisions in Q[x] are performed, using the
function rem(p, q, x);  the coefficients of the remainders
computed this way become subresultants with the help of the
Akritas-Malaschonok-Vigklas Theorem of 2015.

If the subresultant prs is complete, then it coincides with the
Euclidean sequence of the polynomials p, q.

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result
on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial
remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''
Serdica Journal of Computing 10 (2016), No.3-4, 197-217.</pre> 
</div>
</div>
<a id="a715b7abdb96570af27600abeb166ee33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715b7abdb96570af27600abeb166ee33">&#9670;&nbsp;</a></span>subresultants_bezout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.subresultants_bezout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The input polynomials p, q are in Z[x] or in Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the subresultant polynomial remainder sequence
of p, q by evaluating determinants of appropriately selected
submatrices of bezout(p, q, x, 'prs'). The dimensions of the
latter are deg(p) x deg(p).

Each coefficient is computed by evaluating the determinant of the
corresponding submatrix of bezout(p, q, x, 'prs').

bezout(p, q, x, 'prs) is used instead of sylvester(p, q, x, 1),
Sylvester's matrix of 1840, because the dimensions of the latter
are (deg(p) + deg(q)) x (deg(p) + deg(q)).

If the subresultant prs is complete, then the output coincides
with the Euclidean sequence of the polynomials p, q.

References
==========
1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants
and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,
Vol. 15, 233-266, 2004.</pre> 
</div>
</div>
<a id="a94fda283a3d3d3542d20e807ed4fc766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fda283a3d3d3542d20e807ed4fc766">&#9670;&nbsp;</a></span>subresultants_pg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.subresultants_pg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the subresultant prs of p and q in Z[x] or Q[x], from
the modified subresultant prs of p and q.

The coefficients of the polynomials in these two sequences differ only
in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in
Theorem 2 of the reference.

The coefficients of the polynomials in the output sequence are
subresultants. That is, they are  determinants of appropriately
selected submatrices of sylvester1, Sylvester's matrix of 1840.

If the subresultant prs is complete, then it coincides with the
Euclidean sequence of the polynomials p, q.

References
==========
1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: "On the Remainders
Obtained in Finding the Greatest Common Divisor of Two Polynomials."
Serdica Journal of Computing 9(2) (2015), 123-138.</pre> 
</div>
</div>
<a id="ac75d7066651d5c34b01eb84165c0e940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75d7066651d5c34b01eb84165c0e940">&#9670;&nbsp;</a></span>subresultants_rem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.subresultants_rem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the subresultant prs of p and q in Z[x] or Q[x];
the coefficients of the polynomials in the sequence are
subresultants. That is, they are  determinants of appropriately
selected submatrices of sylvester1, Sylvester's matrix of 1840.

To compute the coefficients polynomial divisions in Q[x] are
performed, using the function rem(p, q, x). The coefficients
of the remainders computed this way become subresultants by evaluating
one subresultant per remainder --- that of the leading coefficient.
This way we obtain the correct sign and value of the leading coefficient
of the remainder and we easily ``force'' the rest of the coefficients
to become subresultants.

If the subresultant prs is complete, then it coincides with the
Euclidean sequence of the polynomials p, q.

References
==========
1. Akritas, A. G.:``Three New Methods for Computing Subresultant
Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.</pre> 
</div>
</div>
<a id="a21fdae515d542c084ffca0a30f4518ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fdae515d542c084ffca0a30f4518ed">&#9670;&nbsp;</a></span>subresultants_sylv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.subresultants_sylv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The input polynomials f, g are in Z[x] or in Q[x]. It is assumed
that deg(f) &gt;= deg(g).

Computes the subresultant polynomial remainder sequence (prs)
of f, g by evaluating determinants of appropriately selected
submatrices of sylvester(f, g, x, 1). The dimensions of the
latter are (deg(f) + deg(g)) x (deg(f) + deg(g)).

Each coefficient is computed by evaluating the determinant of the
corresponding submatrix of sylvester(f, g, x, 1).

If the subresultant prs is complete, then the output coincides
with the Euclidean sequence of the polynomials f, g.

References:
===========
1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants
and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,
Vol. 15, 233-266, 2004.</pre> 
</div>
</div>
<a id="ae10f1d072959c1e89e6f0f5fa38e817e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10f1d072959c1e89e6f0f5fa38e817e">&#9670;&nbsp;</a></span>subresultants_vv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.subresultants_vv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the subresultant prs of p, q by triangularizing,
in Z[x] or in Q[x], all the smaller matrices encountered in the
process of triangularizing sylvester2, Sylvester's matrix of 1853;
see references 1 and 2 for Van Vleck's method. With each remainder,
sylvester2 gets updated and is prepared to be printed if requested.

If sylvester2 has small dimensions and you want to see the final,
triangularized matrix use this version with method=1; otherwise,
use either this version with method=0 (default) or the faster version,
subresultants_vv_2(p, q, x), where sylvester2 is used implicitly.

Sylvester's matrix sylvester1  is also used to compute one
subresultant per remainder; namely, that of the leading
coefficient, in order to obtain the correct sign and to
force the remainder coefficients to become subresultants.

If the subresultant prs is complete, then it coincides with the
Euclidean sequence of the polynomials p, q.

If the final, triangularized matrix s2 is printed, then:
    (a) if deg(p) - deg(q) &gt; 1 or deg( gcd(p, q) ) &gt; 0, several
        of the last rows in s2 will remain unprocessed;
    (b) if deg(p) - deg(q) == 0, p will not appear in the final matrix.

References
==========
1. Akritas, A. G.: ``A new method for computing polynomial greatest
common divisors and polynomial remainder sequences.''
Numerische MatheMatik 52, 119-127, 1988.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem
by Van Vleck Regarding Sturm Sequences.''
Serdica Journal of Computing, 7, No 4, 101-134, 2013.

3. Akritas, A. G.:``Three New Methods for Computing Subresultant
Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.</pre> 
</div>
</div>
<a id="a8a13babc39555fb4e40147ebd6e416f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a13babc39555fb4e40147ebd6e416f8">&#9670;&nbsp;</a></span>subresultants_vv_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.subresultants_vv_2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed
that degree(p, x) &gt;= degree(q, x).

Computes the subresultant prs of p, q by triangularizing,
in Z[x] or in Q[x], all the smaller matrices encountered in the
process of triangularizing sylvester2, Sylvester's matrix of 1853;
see references 1 and 2 for Van Vleck's method.

If the sylvester2 matrix has big dimensions use this version,
where sylvester2 is used implicitly. If you want to see the final,
triangularized matrix sylvester2, then use the first version,
subresultants_vv(p, q, x, 1).

sylvester1, Sylvester's matrix of 1840, is also used to compute
one subresultant per remainder; namely, that of the leading
coefficient, in order to obtain the correct sign and to
``force'' the remainder coefficients to become subresultants.

If the subresultant prs is complete, then it coincides with the
Euclidean sequence of the polynomials p, q.

References
==========
1. Akritas, A. G.: ``A new method for computing polynomial greatest
common divisors and polynomial remainder sequences.''
Numerische MatheMatik 52, 119-127, 1988.

2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem
by Van Vleck Regarding Sturm Sequences.''
Serdica Journal of Computing, 7, No 4, 101-134, 2013.

3. Akritas, A. G.:``Three New Methods for Computing Subresultant
Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.</pre> 
</div>
</div>
<a id="a6dfa315f1efc80c18c5f65d4a968f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfa315f1efc80c18c5f65d4a968f37d">&#9670;&nbsp;</a></span>sylvester()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.subresultants_qq_zz.sylvester </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">  The input polynomials f, g are in Z[x] or in Q[x]. Let m = degree(f, x),
  n = degree(g, x) and mx = max(m, n).

  a. If method = 1 (default), computes sylvester1, Sylvester's matrix of 1840
      of dimension (m + n) x (m + n). The determinants of properly chosen
      submatrices of this matrix (a.k.a. subresultants) can be
      used to compute the coefficients of the Euclidean PRS of f, g.

  b. If method = 2, computes sylvester2, Sylvester's matrix of 1853
      of dimension (2*mx) x (2*mx). The determinants of properly chosen
      submatrices of this matrix (a.k.a. ``modified'' subresultants) can be
      used to compute the coefficients of the Sturmian PRS of f, g.

  Applications of these Matrices can be found in the references below.
  Especially, for applications of sylvester2, see the first reference!!

  References
  ==========
  1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem
  by Van Vleck Regarding Sturm Sequences. Serdica Journal of Computing,
  Vol. 7, No 4, 101-134, 2013.

  2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences
  and Modified Subresultant Polynomial Remainder Sequences.''
  Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
