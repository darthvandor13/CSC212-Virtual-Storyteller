<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.solvers.diophantine.diophantine Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine.html">diophantine</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html">diophantine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.solvers.diophantine.diophantine Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1DiophantineSolutionSet.html">DiophantineSolutionSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1DiophantineEquationType.html">DiophantineEquationType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1Univariate.html">Univariate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1Linear.html">Linear</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1BinaryQuadratic.html">BinaryQuadratic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1InhomogeneousTernaryQuadratic.html">InhomogeneousTernaryQuadratic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1HomogeneousTernaryQuadraticNormal.html">HomogeneousTernaryQuadraticNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1HomogeneousTernaryQuadratic.html">HomogeneousTernaryQuadratic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1InhomogeneousGeneralQuadratic.html">InhomogeneousGeneralQuadratic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1HomogeneousGeneralQuadratic.html">HomogeneousGeneralQuadratic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1GeneralSumOfSquares.html">GeneralSumOfSquares</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1GeneralPythagorean.html">GeneralPythagorean</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1CubicThue.html">CubicThue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1diophantine_1_1diophantine_1_1GeneralSumOfEvenPowers.html">GeneralSumOfEvenPowers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a18f50cad70b0964edbdd92cdc617085d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a18f50cad70b0964edbdd92cdc617085d">diophantine</a> (eq, param=symbols(&quot;t&quot;, integer=True), syms=None, permute=False)</td></tr>
<tr class="separator:a18f50cad70b0964edbdd92cdc617085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c2cafb00a1423c49e75af5842b0881"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ad6c2cafb00a1423c49e75af5842b0881">merge_solution</a> (var, var_t, solution)</td></tr>
<tr class="separator:ad6c2cafb00a1423c49e75af5842b0881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1930d30f4ea9eb0362647b8b54eea18"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#aa1930d30f4ea9eb0362647b8b54eea18">diop_solve</a> (eq, param=symbols(&quot;t&quot;, integer=True))</td></tr>
<tr class="separator:aa1930d30f4ea9eb0362647b8b54eea18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c0e7bbc0da625011a0e6f59e6b69fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a93c0e7bbc0da625011a0e6f59e6b69fc">classify_diop</a> (eq, _dict=True)</td></tr>
<tr class="separator:a93c0e7bbc0da625011a0e6f59e6b69fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9ce8e6fdc35e87e29dcf276bddc737"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a8c9ce8e6fdc35e87e29dcf276bddc737">diop_linear</a> (eq, param=symbols(&quot;t&quot;, integer=True))</td></tr>
<tr class="separator:a8c9ce8e6fdc35e87e29dcf276bddc737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1f134d92edc2d2ac7a83f8959936f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a2f1f134d92edc2d2ac7a83f8959936f7">base_solution_linear</a> (c, a, b, t=None)</td></tr>
<tr class="separator:a2f1f134d92edc2d2ac7a83f8959936f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f81d221dad79ba4366602ca59e5df3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ac5f81d221dad79ba4366602ca59e5df3">diop_univariate</a> (eq)</td></tr>
<tr class="separator:ac5f81d221dad79ba4366602ca59e5df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f512e409e885a76bea40fdc9cddfd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a139f512e409e885a76bea40fdc9cddfd">divisible</a> (a, b)</td></tr>
<tr class="separator:a139f512e409e885a76bea40fdc9cddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ad3e14afb844fb3053750d9221e52a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a69ad3e14afb844fb3053750d9221e52a">diop_quadratic</a> (eq, param=symbols(&quot;t&quot;, integer=True))</td></tr>
<tr class="separator:a69ad3e14afb844fb3053750d9221e52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c93456a47e9d65a96f55d1db83f4a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ad5c93456a47e9d65a96f55d1db83f4a2">is_solution_quad</a> (var, coeff, u, v)</td></tr>
<tr class="separator:ad5c93456a47e9d65a96f55d1db83f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58c174a9fa14c315ea9f9f0d2bf67f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ac58c174a9fa14c315ea9f9f0d2bf67f8">diop_DN</a> (D, N, t=symbols(&quot;t&quot;, integer=True))</td></tr>
<tr class="separator:ac58c174a9fa14c315ea9f9f0d2bf67f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f460c3af9241094cf9645ceafdde96c"><td class="memItemLeft" align="right" valign="top">set[tuple[int, int]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a5f460c3af9241094cf9645ceafdde96c">cornacchia</a> (int a, int b, int m)</td></tr>
<tr class="separator:a5f460c3af9241094cf9645ceafdde96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bfddeaaa45e19947f879390abe6b24"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ab9bfddeaaa45e19947f879390abe6b24">PQa</a> (P_0, Q_0, D)</td></tr>
<tr class="separator:ab9bfddeaaa45e19947f879390abe6b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6af2129edd76b699730cd2c7919dc5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a7d6af2129edd76b699730cd2c7919dc5">diop_bf_DN</a> (D, N, t=symbols(&quot;t&quot;, integer=True))</td></tr>
<tr class="separator:a7d6af2129edd76b699730cd2c7919dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2b703193c6c799e396976879c5a465"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#aeb2b703193c6c799e396976879c5a465">equivalent</a> (u, v, r, s, D, N)</td></tr>
<tr class="separator:aeb2b703193c6c799e396976879c5a465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a7c3d263671363cc234a00b900c694"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a50a7c3d263671363cc234a00b900c694">length</a> (P, Q, D)</td></tr>
<tr class="separator:a50a7c3d263671363cc234a00b900c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915e597549b182a57ab417fae04d7d7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a915e597549b182a57ab417fae04d7d7d">transformation_to_DN</a> (eq)</td></tr>
<tr class="separator:a915e597549b182a57ab417fae04d7d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297cb5fd2f7a3fdbed7ea4642b5f64eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a297cb5fd2f7a3fdbed7ea4642b5f64eb">find_DN</a> (eq)</td></tr>
<tr class="separator:a297cb5fd2f7a3fdbed7ea4642b5f64eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae083af0261680730d7f70c202376e3eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ae083af0261680730d7f70c202376e3eb">check_param</a> (x, y, a, params)</td></tr>
<tr class="separator:ae083af0261680730d7f70c202376e3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c89711d9147ddc1c70652a69dfeacf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a65c89711d9147ddc1c70652a69dfeacf">diop_ternary_quadratic</a> (eq, parameterize=False)</td></tr>
<tr class="separator:a65c89711d9147ddc1c70652a69dfeacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab14f66e3644d82ff52f9dc1efa71e0c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#aab14f66e3644d82ff52f9dc1efa71e0c">transformation_to_normal</a> (eq)</td></tr>
<tr class="separator:aab14f66e3644d82ff52f9dc1efa71e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f13609510016acd63cb91928f90dbe7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a6f13609510016acd63cb91928f90dbe7">parametrize_ternary_quadratic</a> (eq)</td></tr>
<tr class="separator:a6f13609510016acd63cb91928f90dbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07c48e884d9d4c36f7876194797e5b6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ae07c48e884d9d4c36f7876194797e5b6">diop_ternary_quadratic_normal</a> (eq, parameterize=False)</td></tr>
<tr class="separator:ae07c48e884d9d4c36f7876194797e5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890fdd2140ce5e03073a47594767908e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a890fdd2140ce5e03073a47594767908e">sqf_normal</a> (a, b, c, steps=False)</td></tr>
<tr class="separator:a890fdd2140ce5e03073a47594767908e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec193daa09312db0d5f78ca05697d442"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#aec193daa09312db0d5f78ca05697d442">square_factor</a> (a)</td></tr>
<tr class="separator:aec193daa09312db0d5f78ca05697d442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7e295ae191c4469b75ff4e51f21161"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ade7e295ae191c4469b75ff4e51f21161">reconstruct</a> (A, B, z)</td></tr>
<tr class="separator:ade7e295ae191c4469b75ff4e51f21161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ab05b8dacfaf639ec5ff68858a3ed7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a93ab05b8dacfaf639ec5ff68858a3ed7">ldescent</a> (A, B)</td></tr>
<tr class="separator:a93ab05b8dacfaf639ec5ff68858a3ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0621518a7edae8ccb64fd93220f8563"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ad0621518a7edae8ccb64fd93220f8563">descent</a> (A, B)</td></tr>
<tr class="separator:ad0621518a7edae8ccb64fd93220f8563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4cf50211249e5b471a343836d7652d"><td class="memItemLeft" align="right" valign="top">tuple[int, int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a9a4cf50211249e5b471a343836d7652d">gaussian_reduce</a> (int w, int a, int b)</td></tr>
<tr class="separator:a9a4cf50211249e5b471a343836d7652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eac39270b95fedb5dd1e0b661c6e513"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a7eac39270b95fedb5dd1e0b661c6e513">holzer</a> (x, y, z, a, b, c)</td></tr>
<tr class="separator:a7eac39270b95fedb5dd1e0b661c6e513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c9964d80c878542380810509ea06e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#af2c9964d80c878542380810509ea06e3">diop_general_pythagorean</a> (eq, param=symbols(&quot;m&quot;, integer=True))</td></tr>
<tr class="separator:af2c9964d80c878542380810509ea06e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2295a43dea206f7f81d90008f242e9c4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a2295a43dea206f7f81d90008f242e9c4">diop_general_sum_of_squares</a> (eq, limit=1)</td></tr>
<tr class="separator:a2295a43dea206f7f81d90008f242e9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf22992e2fbeee9eaae3d83cb26efef5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#adf22992e2fbeee9eaae3d83cb26efef5">diop_general_sum_of_even_powers</a> (eq, limit=1)</td></tr>
<tr class="separator:adf22992e2fbeee9eaae3d83cb26efef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920d368b1b146860f97b988489856ec8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a920d368b1b146860f97b988489856ec8">partition</a> (n, k=None, zeros=False)</td></tr>
<tr class="memdesc:a920d368b1b146860f97b988489856ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions below this comment can be more suitably grouped under an Additive number theory module rather than the Diophantine equation module.  <a href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a920d368b1b146860f97b988489856ec8">More...</a><br /></td></tr>
<tr class="separator:a920d368b1b146860f97b988489856ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a780ad4b7c4bc397ef0133b805a270"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#aa5a780ad4b7c4bc397ef0133b805a270">prime_as_sum_of_two_squares</a> (p)</td></tr>
<tr class="separator:aa5a780ad4b7c4bc397ef0133b805a270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06f9fdd521a1f192b425cc565267344"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ab06f9fdd521a1f192b425cc565267344">sum_of_three_squares</a> (n)</td></tr>
<tr class="separator:ab06f9fdd521a1f192b425cc565267344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b1c262b35d123374712684417f8469"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a15b1c262b35d123374712684417f8469">sum_of_four_squares</a> (n)</td></tr>
<tr class="separator:a15b1c262b35d123374712684417f8469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12ae37d1081aedb42db6763299431d0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ab12ae37d1081aedb42db6763299431d0">power_representation</a> (n, p, k, zeros=False)</td></tr>
<tr class="separator:ab12ae37d1081aedb42db6763299431d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03581013fe25621e5dd97898899182e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a03581013fe25621e5dd97898899182e5">pow_rep_recursive</a> (n_i, k, n_remaining, terms, p)</td></tr>
<tr class="separator:a03581013fe25621e5dd97898899182e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f32c5a05fe21c163e69a6ef0a59787d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a5f32c5a05fe21c163e69a6ef0a59787d">sum_of_squares</a> (n, k, zeros=False)</td></tr>
<tr class="separator:a5f32c5a05fe21c163e69a6ef0a59787d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abae4c91da48a115feebcc0890c831796"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#abae4c91da48a115feebcc0890c831796">all_diop_classes</a></td></tr>
<tr class="separator:abae4c91da48a115feebcc0890c831796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739b678f0e7b65c4b34a38e114b6558b"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a739b678f0e7b65c4b34a38e114b6558b">diop_known</a> = {diop_class.name for diop_class in <a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#abae4c91da48a115feebcc0890c831796">all_diop_classes</a>}</td></tr>
<tr class="separator:a739b678f0e7b65c4b34a38e114b6558b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f5400b0483b6d3b8df7a882cfb8fd5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#a96f5400b0483b6d3b8df7a882cfb8fd5">sum_of_powers</a> = <a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ab12ae37d1081aedb42db6763299431d0">power_representation</a></td></tr>
<tr class="separator:a96f5400b0483b6d3b8df7a882cfb8fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2f1f134d92edc2d2ac7a83f8959936f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1f134d92edc2d2ac7a83f8959936f7">&#9670;&nbsp;</a></span>base_solution_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.base_solution_linear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the base solution for the linear equation, `ax + by = c`.

Explanation
===========

Used by ``diop_linear()`` to find the base solution of a linear
Diophantine equation. If ``t`` is given then the parametrized solution is
returned.

Usage
=====

``base_solution_linear(c, a, b, t)``: ``a``, ``b``, ``c`` are coefficients
in `ax + by = c` and ``t`` is the parameter to be used in the solution.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import base_solution_linear
&gt;&gt;&gt; from sympy.abc import t
&gt;&gt;&gt; base_solution_linear(5, 2, 3) # equation 2*x + 3*y = 5
(-5, 5)
&gt;&gt;&gt; base_solution_linear(0, 5, 7) # equation 5*x + 7*y = 0
(0, 0)
&gt;&gt;&gt; base_solution_linear(5, 2, 3, t) # equation 2*x + 3*y = 5
(3*t - 5, 5 - 2*t)
&gt;&gt;&gt; base_solution_linear(0, 5, 7, t) # equation 5*x + 7*y = 0
(7*t, -5*t)
</pre> 
</div>
</div>
<a id="ae083af0261680730d7f70c202376e3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae083af0261680730d7f70c202376e3eb">&#9670;&nbsp;</a></span>check_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.check_param </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If there is a number modulo ``a`` such that ``x`` and ``y`` are both
integers, then return a parametric representation for ``x`` and ``y``
else return (None, None).

Here ``x`` and ``y`` are functions of ``t``.
</pre> 
</div>
</div>
<a id="a93c0e7bbc0da625011a0e6f59e6b69fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c0e7bbc0da625011a0e6f59e6b69fc">&#9670;&nbsp;</a></span>classify_diop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.classify_diop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_dict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f460c3af9241094cf9645ceafdde96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f460c3af9241094cf9645ceafdde96c">&#9670;&nbsp;</a></span>cornacchia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> set[tuple[int, int]] sympy.solvers.diophantine.diophantine.cornacchia </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves `ax^2 + by^2 = m` where `\gcd(a, b) = 1 = gcd(a, m)` and `a, b &gt; 0`.

Explanation
===========

Uses the algorithm due to Cornacchia. The method only finds primitive
solutions, i.e. ones with `\gcd(x, y) = 1`. So this method cannot be used to
find the solutions of `x^2 + y^2 = 20` since the only solution to former is
`(x, y) = (4, 2)` and it is not primitive. When `a = b`, only the
solutions with `x \leq y` are found. For more details, see the References.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import cornacchia
&gt;&gt;&gt; cornacchia(2, 3, 35) # equation 2x**2 + 3y**2 = 35
{(2, 3), (4, 1)}
&gt;&gt;&gt; cornacchia(1, 1, 25) # equation x**2 + y**2 = 25
{(4, 3)}

References
===========

.. [1] A. Nitaj, "L'algorithme de Cornacchia"
.. [2] Solving the diophantine equation ax**2 + by**2 = m by Cornacchia's
    method, [online], Available:
    http://www.numbertheory.org/php/cornacchia.html

See Also
========

sympy.utilities.iterables.signed_permutations
</pre> 
</div>
</div>
<a id="ad0621518a7edae8ccb64fd93220f8563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0621518a7edae8ccb64fd93220f8563">&#9670;&nbsp;</a></span>descent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.descent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a non-trivial solution, (x, y, z), to `x^2 = Ay^2 + Bz^2`
using Lagrange's descent method with lattice-reduction. `A` and `B`
are assumed to be valid for such a solution to exist.

This is faster than the normal Lagrange's descent algorithm because
the Gaussian reduction is used.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import descent
&gt;&gt;&gt; descent(3, 1) # x**2 = 3*y**2 + z**2
(1, 0, 1)

`(x, y, z) = (1, 0, 1)` is a solution to the above equation.

&gt;&gt;&gt; descent(41, -113)
(-16, -3, 1)

References
==========

.. [1] Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics.
       Mathematics of Computation, 72(243), 1417-1441.
       https://doi.org/10.1090/S0025-5718-02-01480-1
</pre> 
</div>
</div>
<a id="a7d6af2129edd76b699730cd2c7919dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6af2129edd76b699730cd2c7919dc5">&#9670;&nbsp;</a></span>diop_bf_DN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_bf_DN </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>symbols(&quot;t&quot;,&#160;integer=True)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Uses brute force to solve the equation, `x^2 - Dy^2 = N`.

Explanation
===========

Mainly concerned with the generalized Pell equation which is the case when
`D &gt; 0, D` is not a perfect square. For more information on the case refer
[1]_. Let `(t, u)` be the minimal positive solution of the equation
`x^2 - Dy^2 = 1`. Then this method requires
`\sqrt{\\frac{\mid N \mid (t \pm 1)}{2D}}` to be small.

Usage
=====

``diop_bf_DN(D, N, t)``: ``D`` and ``N`` are coefficients in
`x^2 - Dy^2 = N` and ``t`` is the parameter to be used in the solutions.

Details
=======

``D`` and ``N`` correspond to D and N in the equation.
``t`` is the parameter to be used in the solutions.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_bf_DN
&gt;&gt;&gt; diop_bf_DN(13, -4)
[(3, 1), (-3, 1), (36, 10)]
&gt;&gt;&gt; diop_bf_DN(986, 1)
[(49299, 1570)]

See Also
========

diop_DN()

References
==========

.. [1] Solving the generalized Pell equation x**2 - D*y**2 = N, John P.
    Robertson, July 31, 2004, Page 15. https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf
</pre> 
</div>
</div>
<a id="ac58c174a9fa14c315ea9f9f0d2bf67f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58c174a9fa14c315ea9f9f0d2bf67f8">&#9670;&nbsp;</a></span>diop_DN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_DN </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>symbols(&quot;t&quot;,&#160;integer=True)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the equation `x^2 - Dy^2 = N`.

Explanation
===========

Mainly concerned with the case `D &gt; 0, D` is not a perfect square,
which is the same as the generalized Pell equation. The LMM
algorithm [1]_ is used to solve this equation.

Returns one solution tuple, (`x, y)` for each class of the solutions.
Other solutions of the class can be constructed according to the
values of ``D`` and ``N``.

Usage
=====

``diop_DN(D, N, t)``: D and N are integers as in `x^2 - Dy^2 = N` and
``t`` is the parameter to be used in the solutions.

Details
=======

``D`` and ``N`` correspond to D and N in the equation.
``t`` is the parameter to be used in the solutions.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_DN
&gt;&gt;&gt; diop_DN(13, -4) # Solves equation x**2 - 13*y**2 = -4
[(3, 1), (393, 109), (36, 10)]

The output can be interpreted as follows: There are three fundamental
solutions to the equation `x^2 - 13y^2 = -4` given by (3, 1), (393, 109)
and (36, 10). Each tuple is in the form (x, y), i.e. solution (3, 1) means
that `x = 3` and `y = 1`.

&gt;&gt;&gt; diop_DN(986, 1) # Solves equation x**2 - 986*y**2 = 1
[(49299, 1570)]

See Also
========

find_DN(), diop_bf_DN()

References
==========

.. [1] Solving the generalized Pell equation x**2 - D*y**2 = N, John P.
    Robertson, July 31, 2004, Pages 16 - 17. [online], Available:
    https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf
</pre> 
</div>
</div>
<a id="af2c9964d80c878542380810509ea06e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c9964d80c878542380810509ea06e3">&#9670;&nbsp;</a></span>diop_general_pythagorean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_general_pythagorean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em> = <code>symbols(&quot;m&quot;,&#160;integer=True)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the general pythagorean equation,
`a_{1}^2x_{1}^2 + a_{2}^2x_{2}^2 + . . . + a_{n}^2x_{n}^2 - a_{n + 1}^2x_{n + 1}^2 = 0`.

Returns a tuple which contains a parametrized solution to the equation,
sorted in the same order as the input variables.

Usage
=====

``diop_general_pythagorean(eq, param)``: where ``eq`` is a general
pythagorean equation which is assumed to be zero and ``param`` is the base
parameter used to construct other parameters by subscripting.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_general_pythagorean
&gt;&gt;&gt; from sympy.abc import a, b, c, d, e
&gt;&gt;&gt; diop_general_pythagorean(a**2 + b**2 + c**2 - d**2)
(m1**2 + m2**2 - m3**2, 2*m1*m3, 2*m2*m3, m1**2 + m2**2 + m3**2)
&gt;&gt;&gt; diop_general_pythagorean(9*a**2 - 4*b**2 + 16*c**2 + 25*d**2 + e**2)
(10*m1**2  + 10*m2**2  + 10*m3**2 - 10*m4**2, 15*m1**2  + 15*m2**2  + 15*m3**2  + 15*m4**2, 15*m1*m4, 12*m2*m4, 60*m3*m4)
</pre> 
</div>
</div>
<a id="adf22992e2fbeee9eaae3d83cb26efef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf22992e2fbeee9eaae3d83cb26efef5">&#9670;&nbsp;</a></span>diop_general_sum_of_even_powers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_general_sum_of_even_powers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the equation `x_{1}^e + x_{2}^e + . . . + x_{n}^e - k = 0`
where `e` is an even, integer power.

Returns at most ``limit`` number of solutions.

Usage
=====

``general_sum_of_even_powers(eq, limit)`` : Here ``eq`` is an expression which
is assumed to be zero. Also, ``eq`` should be in the form,
`x_{1}^e + x_{2}^e + . . . + x_{n}^e - k = 0`.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_general_sum_of_even_powers
&gt;&gt;&gt; from sympy.abc import a, b
&gt;&gt;&gt; diop_general_sum_of_even_powers(a**4 + b**4 - (2**4 + 3**4))
{(2, 3)}

See Also
========

power_representation
</pre> 
</div>
</div>
<a id="a2295a43dea206f7f81d90008f242e9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2295a43dea206f7f81d90008f242e9c4">&#9670;&nbsp;</a></span>diop_general_sum_of_squares()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the equation `x_{1}^2 + x_{2}^2 + . . . + x_{n}^2 - k = 0`.

Returns at most ``limit`` number of solutions.

Usage
=====

``general_sum_of_squares(eq, limit)`` : Here ``eq`` is an expression which
is assumed to be zero. Also, ``eq`` should be in the form,
`x_{1}^2 + x_{2}^2 + . . . + x_{n}^2 - k = 0`.

Details
=======

When `n = 3` if `k = 4^a(8m + 7)` for some `a, m \in Z` then there will be
no solutions. Refer to [1]_ for more details.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_general_sum_of_squares
&gt;&gt;&gt; from sympy.abc import a, b, c, d, e
&gt;&gt;&gt; diop_general_sum_of_squares(a**2 + b**2 + c**2 + d**2 + e**2 - 2345)
{(15, 22, 22, 24, 24)}

Reference
=========

.. [1] Representing an integer as a sum of three squares, [online],
    Available:
    https://www.proofwiki.org/wiki/Integer_as_Sum_of_Three_Squares
</pre> 
</div>
</div>
<a id="a8c9ce8e6fdc35e87e29dcf276bddc737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9ce8e6fdc35e87e29dcf276bddc737">&#9670;&nbsp;</a></span>diop_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_linear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em> = <code>symbols(&quot;t&quot;,&#160;integer=True)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves linear diophantine equations.

A linear diophantine equation is an equation of the form `a_{1}x_{1} +
a_{2}x_{2} + .. + a_{n}x_{n} = 0` where `a_{1}, a_{2}, ..a_{n}` are
integer constants and `x_{1}, x_{2}, ..x_{n}` are integer variables.

Usage
=====

``diop_linear(eq)``: Returns a tuple containing solutions to the
diophantine equation ``eq``. Values in the tuple is arranged in the same
order as the sorted variables.

Details
=======

``eq`` is a linear diophantine equation which is assumed to be zero.
``param`` is the parameter to be used in the solution.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_linear
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; diop_linear(2*x - 3*y - 5) # solves equation 2*x - 3*y - 5 == 0
(3*t_0 - 5, 2*t_0 - 5)

Here x = -3*t_0 - 5 and y = -2*t_0 - 5

&gt;&gt;&gt; diop_linear(2*x - 3*y - 4*z -3)
(t_0, 2*t_0 + 4*t_1 + 3, -t_0 - 3*t_1 - 3)

See Also
========

diop_quadratic(), diop_ternary_quadratic(), diop_general_pythagorean(),
diop_general_sum_of_squares()
</pre> 
</div>
</div>
<a id="a69ad3e14afb844fb3053750d9221e52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ad3e14afb844fb3053750d9221e52a">&#9670;&nbsp;</a></span>diop_quadratic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_quadratic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em> = <code>symbols(&quot;t&quot;,&#160;integer=True)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves quadratic diophantine equations.

i.e. equations of the form `Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0`. Returns a
set containing the tuples `(x, y)` which contains the solutions. If there
are no solutions then `(None, None)` is returned.

Usage
=====

``diop_quadratic(eq, param)``: ``eq`` is a quadratic binary diophantine
equation. ``param`` is used to indicate the parameter to be used in the
solution.

Details
=======

``eq`` should be an expression which is assumed to be zero.
``param`` is a parameter to be used in the solution.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y, t
&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_quadratic
&gt;&gt;&gt; diop_quadratic(x**2 + y**2 + 2*x + 2*y + 2, t)
{(-1, -1)}

References
==========

.. [1] Methods to solve Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0, [online],
      Available: https://www.alpertron.com.ar/METHODS.HTM
.. [2] Solving the equation ax^2+ bxy + cy^2 + dx + ey + f= 0, [online],
      Available: https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf

See Also
========

diop_linear(), diop_ternary_quadratic(), diop_general_sum_of_squares(),
diop_general_pythagorean()
</pre> 
</div>
</div>
<a id="aa1930d30f4ea9eb0362647b8b54eea18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1930d30f4ea9eb0362647b8b54eea18">&#9670;&nbsp;</a></span>diop_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em> = <code>symbols(&quot;t&quot;,&#160;integer=True)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the diophantine equation ``eq``.

Explanation
===========

Unlike ``diophantine()``, factoring of ``eq`` is not attempted. Uses
``classify_diop()`` to determine the type of the equation and calls
the appropriate solver function.

Use of ``diophantine()`` is recommended over other helper functions.
``diop_solve()`` can return either a set or a tuple depending on the
nature of the equation.

Usage
=====

``diop_solve(eq, t)``: Solve diophantine equation, ``eq`` using ``t``
as a parameter if needed.

Details
=======

``eq`` should be an expression which is assumed to be zero.
``t`` is a parameter to be used in the solution.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine import diop_solve
&gt;&gt;&gt; from sympy.abc import x, y, z, w
&gt;&gt;&gt; diop_solve(2*x + 3*y - 5)
(3*t_0 - 5, 5 - 2*t_0)
&gt;&gt;&gt; diop_solve(4*x + 3*y - 4*z + 5)
(t_0, 8*t_0 + 4*t_1 + 5, 7*t_0 + 3*t_1 + 5)
&gt;&gt;&gt; diop_solve(x + 3*y - 4*z + w - 6)
(t_0, t_0 + t_1, 6*t_0 + 5*t_1 + 4*t_2 - 6, 5*t_0 + 4*t_1 + 3*t_2 - 6)
&gt;&gt;&gt; diop_solve(x**2 + y**2 - 5)
{(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)}


See Also
========

diophantine()
</pre> 
</div>
</div>
<a id="a65c89711d9147ddc1c70652a69dfeacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c89711d9147ddc1c70652a69dfeacf">&#9670;&nbsp;</a></span>diop_ternary_quadratic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_ternary_quadratic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parameterize</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the general quadratic ternary form,
`ax^2 + by^2 + cz^2 + fxy + gyz + hxz = 0`.

Returns a tuple `(x, y, z)` which is a base solution for the above
equation. If there are no solutions, `(None, None, None)` is returned.

Usage
=====

``diop_ternary_quadratic(eq)``: Return a tuple containing a basic solution
to ``eq``.

Details
=======

``eq`` should be an homogeneous expression of degree two in three variables
and it is assumed to be zero.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_ternary_quadratic
&gt;&gt;&gt; diop_ternary_quadratic(x**2 + 3*y**2 - z**2)
(1, 0, 1)
&gt;&gt;&gt; diop_ternary_quadratic(4*x**2 + 5*y**2 - z**2)
(1, 0, 2)
&gt;&gt;&gt; diop_ternary_quadratic(45*x**2 - 7*y**2 - 8*x*y - z**2)
(28, 45, 105)
&gt;&gt;&gt; diop_ternary_quadratic(x**2 - 49*y**2 - z**2 + 13*z*y -8*x*y)
(9, 1, 5)
</pre> 
</div>
</div>
<a id="ae07c48e884d9d4c36f7876194797e5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07c48e884d9d4c36f7876194797e5b6">&#9670;&nbsp;</a></span>diop_ternary_quadratic_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_ternary_quadratic_normal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parameterize</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the quadratic ternary diophantine equation,
`ax^2 + by^2 + cz^2 = 0`.

Explanation
===========

Here the coefficients `a`, `b`, and `c` should be non zero. Otherwise the
equation will be a quadratic binary or univariate equation. If solvable,
returns a tuple `(x, y, z)` that satisfies the given equation. If the
equation does not have integer solutions, `(None, None, None)` is returned.

Usage
=====

``diop_ternary_quadratic_normal(eq)``: where ``eq`` is an equation of the form
`ax^2 + by^2 + cz^2 = 0`.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_ternary_quadratic_normal
&gt;&gt;&gt; diop_ternary_quadratic_normal(x**2 + 3*y**2 - z**2)
(1, 0, 1)
&gt;&gt;&gt; diop_ternary_quadratic_normal(4*x**2 + 5*y**2 - z**2)
(1, 0, 2)
&gt;&gt;&gt; diop_ternary_quadratic_normal(34*x**2 - 3*y**2 - 301*z**2)
(4, 9, 1)
</pre> 
</div>
</div>
<a id="ac5f81d221dad79ba4366602ca59e5df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f81d221dad79ba4366602ca59e5df3">&#9670;&nbsp;</a></span>diop_univariate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diop_univariate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves a univariate diophantine equations.

Explanation
===========

A univariate diophantine equation is an equation of the form
`a_{0} + a_{1}x + a_{2}x^2 + .. + a_{n}x^n = 0` where `a_{1}, a_{2}, ..a_{n}` are
integer constants and `x` is an integer variable.

Usage
=====

``diop_univariate(eq)``: Returns a set containing solutions to the
diophantine equation ``eq``.

Details
=======

``eq`` is a univariate diophantine equation which is assumed to be zero.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import diop_univariate
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; diop_univariate((x - 2)*(x - 3)**2) # solves equation (x - 2)*(x - 3)**2 == 0
{(2,), (3,)}</pre> 
</div>
</div>
<a id="a18f50cad70b0964edbdd92cdc617085d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f50cad70b0964edbdd92cdc617085d">&#9670;&nbsp;</a></span>diophantine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.diophantine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em> = <code>symbols(&quot;t&quot;,&#160;integer=True)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>syms</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permute</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplify the solution procedure of diophantine equation ``eq`` by
converting it into a product of terms which should equal zero.

Explanation
===========

For example, when solving, `x^2 - y^2 = 0` this is treated as
`(x + y)(x - y) = 0` and `x + y = 0` and `x - y = 0` are solved
independently and combined. Each term is solved by calling
``diop_solve()``. (Although it is possible to call ``diop_solve()``
directly, one must be careful to pass an equation in the correct
form and to interpret the output correctly; ``diophantine()`` is
the public-facing function to use in general.)

Output of ``diophantine()`` is a set of tuples. The elements of the
tuple are the solutions for each variable in the equation and
are arranged according to the alphabetic ordering of the variables.
e.g. For an equation with two variables, `a` and `b`, the first
element of the tuple is the solution for `a` and the second for `b`.

Usage
=====

``diophantine(eq, t, syms)``: Solve the diophantine
equation ``eq``.
``t`` is the optional parameter to be used by ``diop_solve()``.
``syms`` is an optional list of symbols which determines the
order of the elements in the returned tuple.

By default, only the base solution is returned. If ``permute`` is set to
True then permutations of the base solution and/or permutations of the
signs of the values will be returned when applicable.

Details
=======

``eq`` should be an expression which is assumed to be zero.
``t`` is the parameter to be used in the solution.

Examples
========

&gt;&gt;&gt; from sympy import diophantine
&gt;&gt;&gt; from sympy.abc import a, b
&gt;&gt;&gt; eq = a**4 + b**4 - (2**4 + 3**4)
&gt;&gt;&gt; diophantine(eq)
{(2, 3)}
&gt;&gt;&gt; diophantine(eq, permute=True)
{(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}

&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; diophantine(x**2 - y**2)
{(t_0, -t_0), (t_0, t_0)}

&gt;&gt;&gt; diophantine(x*(2*x + 3*y - z))
{(0, n1, n2), (t_0, t_1, 2*t_0 + 3*t_1)}
&gt;&gt;&gt; diophantine(x**2 + 3*x*y + 4*x)
{(0, n1), (-3*t_0 - 4, t_0)}

See Also
========

diop_solve
sympy.utilities.iterables.permute_signs
sympy.utilities.iterables.signed_permutations
</pre> 
</div>
</div>
<a id="a139f512e409e885a76bea40fdc9cddfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139f512e409e885a76bea40fdc9cddfd">&#9670;&nbsp;</a></span>divisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.divisible </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns `True` if ``a`` is divisible by ``b`` and `False` otherwise.
</pre> 
</div>
</div>
<a id="aeb2b703193c6c799e396976879c5a465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2b703193c6c799e396976879c5a465">&#9670;&nbsp;</a></span>equivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.equivalent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if two solutions `(u, v)` and `(r, s)` of `x^2 - Dy^2 = N`
belongs to the same equivalence class and False otherwise.

Explanation
===========

Two solutions `(u, v)` and `(r, s)` to the above equation fall to the same
equivalence class iff both `(ur - Dvs)` and `(us - vr)` are divisible by
`N`. See reference [1]_. No test is performed to test whether `(u, v)` and
`(r, s)` are actually solutions to the equation. User should take care of
this.

Usage
=====

``equivalent(u, v, r, s, D, N)``: `(u, v)` and `(r, s)` are two solutions
of the equation `x^2 - Dy^2 = N` and all parameters involved are integers.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import equivalent
&gt;&gt;&gt; equivalent(18, 5, -18, -5, 13, -1)
True
&gt;&gt;&gt; equivalent(3, 1, -18, 393, 109, -4)
False

References
==========

.. [1] Solving the generalized Pell equation x**2 - D*y**2 = N, John P.
    Robertson, July 31, 2004, Page 12. https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf</pre> 
</div>
</div>
<a id="a297cb5fd2f7a3fdbed7ea4642b5f64eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297cb5fd2f7a3fdbed7ea4642b5f64eb">&#9670;&nbsp;</a></span>find_DN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.find_DN </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function returns a tuple, `(D, N)` of the simplified form,
`x^2 - Dy^2 = N`, corresponding to the general quadratic,
`ax^2 + bxy + cy^2 + dx + ey + f = 0`.

Solving the general quadratic is then equivalent to solving the equation
`X^2 - DY^2 = N` and transforming the solutions by using the transformation
matrices returned by ``transformation_to_DN()``.

Usage
=====

``find_DN(eq)``: where ``eq`` is the quadratic to be transformed.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import find_DN
&gt;&gt;&gt; find_DN(x**2 - 3*x*y - y**2 - 2*y + 1)
(13, -884)

Interpretation of the output is that we get `X^2 -13Y^2 = -884` after
transforming `x^2 - 3xy - y^2 - 2y + 1` using the transformation returned
by ``transformation_to_DN()``.

See Also
========

transformation_to_DN()

References
==========

.. [1] Solving the equation ax^2 + bxy + cy^2 + dx + ey + f = 0,
       John P.Robertson, May 8, 2003, Page 7 - 11.
       https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf
</pre> 
</div>
</div>
<a id="a9a4cf50211249e5b471a343836d7652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4cf50211249e5b471a343836d7652d">&#9670;&nbsp;</a></span>gaussian_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[int, int] sympy.solvers.diophantine.diophantine.gaussian_reduce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a reduced solution `(x, z)` to the congruence
`X^2 - aZ^2 \equiv 0 \pmod{b}` so that `x^2 + |a|z^2` is as small as possible.
Here ``w`` is a solution of the congruence `x^2 \equiv a \pmod{b}`.

This function is intended to be used only for ``descent()``.

Explanation
===========

The Gaussian reduction can find the shortest vector for any norm.
So we define the special norm for the vectors `u = (u_1, u_2)` and `v = (v_1, v_2)` as follows.

.. math ::
    u \cdot v := (wu_1 + bu_2)(wv_1 + bv_2) + |a|u_1v_1

Note that, given the mapping `f: (u_1, u_2) \to (wu_1 + bu_2, u_1)`,
`f((u_1,u_2))` is the solution to `X^2 - aZ^2 \equiv 0 \pmod{b}`.
In other words, finding the shortest vector in this norm will yield a solution with smaller `X^2 + |a|Z^2`.
The algorithm starts from basis vectors `(0, 1)` and `(1, 0)`
(corresponding to solutions `(b, 0)` and `(w, 1)`, respectively) and finds the shortest vector.
The shortest vector does not necessarily correspond to the smallest solution,
but since ``descent()`` only wants the smallest possible solution, it is sufficient.

Parameters
==========

w : int
    ``w`` s.t. `w^2 \equiv a \pmod{b}`
a : int
    square-free nonzero integer
b : int
    square-free nonzero integer

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import gaussian_reduce
&gt;&gt;&gt; from sympy.ntheory.residue_ntheory import sqrt_mod
&gt;&gt;&gt; a, b = 19, 101
&gt;&gt;&gt; gaussian_reduce(sqrt_mod(a, b), a, b) # 1**2 - 19*(-4)**2 = -303
(1, -4)
&gt;&gt;&gt; a, b = 11, 14
&gt;&gt;&gt; x, z = gaussian_reduce(sqrt_mod(a, b), a, b)
&gt;&gt;&gt; (x**2 - a*z**2) % b == 0
True

It does not always return the smallest solution.

&gt;&gt;&gt; a, b = 6, 95
&gt;&gt;&gt; min_x, min_z = 1, 4
&gt;&gt;&gt; x, z = gaussian_reduce(sqrt_mod(a, b), a, b)
&gt;&gt;&gt; (x**2 - a*z**2) % b == 0 and (min_x**2 - a*min_z**2) % b == 0
True
&gt;&gt;&gt; min_x**2 + abs(a)*min_z**2 &lt; x**2 + abs(a)*z**2
True

References
==========

.. [1] Gaussian lattice Reduction [online]. Available:
       https://web.archive.org/web/20201021115213/http://home.ie.cuhk.edu.hk/~wkshum/wordpress/?p=404
.. [2] Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics.
       Mathematics of Computation, 72(243), 1417-1441.
       https://doi.org/10.1090/S0025-5718-02-01480-1
</pre> 
</div>
</div>
<a id="a7eac39270b95fedb5dd1e0b661c6e513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eac39270b95fedb5dd1e0b661c6e513">&#9670;&nbsp;</a></span>holzer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.holzer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplify the solution `(x, y, z)` of the equation
`ax^2 + by^2 = cz^2` with `a, b, c &gt; 0` and `z^2 \geq \mid ab \mid` to
a new reduced solution `(x', y', z')` such that `z'^2 \leq \mid ab \mid`.

The algorithm is an interpretation of Mordell's reduction as described
on page 8 of Cremona and Rusin's paper [1]_ and the work of Mordell in
reference [2]_.

References
==========

.. [1] Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics.
       Mathematics of Computation, 72(243), 1417-1441.
       https://doi.org/10.1090/S0025-5718-02-01480-1
.. [2] Diophantine Equations, L. J. Mordell, page 48.</pre> 
</div>
</div>
<a id="ad5c93456a47e9d65a96f55d1db83f4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c93456a47e9d65a96f55d1db83f4a2">&#9670;&nbsp;</a></span>is_solution_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.is_solution_quad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether `(u, v)` is solution to the quadratic binary diophantine
equation with the variable list ``var`` and coefficient dictionary
``coeff``.

Not intended for use by normal users.
</pre> 
</div>
</div>
<a id="a93ab05b8dacfaf639ec5ff68858a3ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ab05b8dacfaf639ec5ff68858a3ed7">&#9670;&nbsp;</a></span>ldescent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.ldescent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a non-trivial solution to `w^2 = Ax^2 + By^2` using
Lagrange's method; return None if there is no such solution.

Parameters
==========

A : Integer
B : Integer
    non-zero integer

Returns
=======

(int, int, int) | None : a tuple `(w_0, x_0, y_0)` which is a solution to the above equation.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import ldescent
&gt;&gt;&gt; ldescent(1, 1) # w^2 = x^2 + y^2
(1, 1, 0)
&gt;&gt;&gt; ldescent(4, -7) # w^2 = 4x^2 - 7y^2
(2, -1, 0)

This means that `x = -1, y = 0` and `w = 2` is a solution to the equation
`w^2 = 4x^2 - 7y^2`

&gt;&gt;&gt; ldescent(5, -1) # w^2 = 5x^2 - y^2
(2, 1, -1)

References
==========

.. [1] The algorithmic resolution of Diophantine equations, Nigel P. Smart,
       London Mathematical Society Student Texts 41, Cambridge University
       Press, Cambridge, 1998.
.. [2] Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics.
       Mathematics of Computation, 72(243), 1417-1441.
       https://doi.org/10.1090/S0025-5718-02-01480-1
</pre> 
</div>
</div>
<a id="a50a7c3d263671363cc234a00b900c694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a7c3d263671363cc234a00b900c694">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the (length of aperiodic part + length of periodic part) of
continued fraction representation of `\\frac{P + \sqrt{D}}{Q}`.

It is important to remember that this does NOT return the length of the
periodic part but the sum of the lengths of the two parts as mentioned
above.

Usage
=====

``length(P, Q, D)``: ``P``, ``Q`` and ``D`` are integers corresponding to
the continued fraction `\\frac{P + \sqrt{D}}{Q}`.

Details
=======

``P``, ``D`` and ``Q`` corresponds to P, D and Q in the continued fraction,
`\\frac{P + \sqrt{D}}{Q}`.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import length
&gt;&gt;&gt; length(-2, 4, 5) # (-2 + sqrt(5))/4
3
&gt;&gt;&gt; length(-5, 4, 17) # (-5 + sqrt(17))/4
4

See Also
========
sympy.ntheory.continued_fraction.continued_fraction_periodic
</pre> 
</div>
</div>
<a id="ad6c2cafb00a1423c49e75af5842b0881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c2cafb00a1423c49e75af5842b0881">&#9670;&nbsp;</a></span>merge_solution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.merge_solution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>var_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This is used to construct the full solution from the solutions of sub
equations.

Explanation
===========

For example when solving the equation `(x - y)(x^2 + y^2 - z^2) = 0`,
solutions for each of the equations `x - y = 0` and `x^2 + y^2 - z^2` are
found independently. Solutions for `x - y = 0` are `(x, y) = (t, t)`. But
we should introduce a value for z when we output the solution for the
original equation. This function converts `(t, t)` into `(t, t, n_{1})`
where `n_{1}` is an integer parameter.
</pre> 
</div>
</div>
<a id="a6f13609510016acd63cb91928f90dbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f13609510016acd63cb91928f90dbe7">&#9670;&nbsp;</a></span>parametrize_ternary_quadratic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.parametrize_ternary_quadratic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the parametrized general solution for the ternary quadratic
equation ``eq`` which has the form
`ax^2 + by^2 + cz^2 + fxy + gyz + hxz = 0`.

Examples
========

&gt;&gt;&gt; from sympy import Tuple, ordered
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import parametrize_ternary_quadratic

The parametrized solution may be returned with three parameters:

&gt;&gt;&gt; parametrize_ternary_quadratic(2*x**2 + y**2 - 2*z**2)
(p**2 - 2*q**2, -2*p**2 + 4*p*q - 4*p*r - 4*q**2, p**2 - 4*p*q + 2*q**2 - 4*q*r)

There might also be only two parameters:

&gt;&gt;&gt; parametrize_ternary_quadratic(4*x**2 + 2*y**2 - 3*z**2)
(2*p**2 - 3*q**2, -4*p**2 + 12*p*q - 6*q**2, 4*p**2 - 8*p*q + 6*q**2)

Notes
=====

Consider ``p`` and ``q`` in the previous 2-parameter
solution and observe that more than one solution can be represented
by a given pair of parameters. If `p` and ``q`` are not coprime, this is
trivially true since the common factor will also be a common factor of the
solution values. But it may also be true even when ``p`` and
``q`` are coprime:

&gt;&gt;&gt; sol = Tuple(*_)
&gt;&gt;&gt; p, q = ordered(sol.free_symbols)
&gt;&gt;&gt; sol.subs([(p, 3), (q, 2)])
(6, 12, 12)
&gt;&gt;&gt; sol.subs([(q, 1), (p, 1)])
(-1, 2, 2)
&gt;&gt;&gt; sol.subs([(q, 0), (p, 1)])
(2, -4, 4)
&gt;&gt;&gt; sol.subs([(q, 1), (p, 0)])
(-3, -6, 6)

Except for sign and a common factor, these are equivalent to
the solution of (1, 2, 2).

References
==========

.. [1] The algorithmic resolution of Diophantine equations, Nigel P. Smart,
       London Mathematical Society Student Texts 41, Cambridge University
       Press, Cambridge, 1998.</pre> 
</div>
</div>
<a id="a920d368b1b146860f97b988489856ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920d368b1b146860f97b988489856ec8">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.partition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeros</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functions below this comment can be more suitably grouped under an Additive number theory module rather than the Diophantine equation module. </p>
<pre class="fragment">Returns a generator that can be used to generate partitions of an integer
`n`.

Explanation
===========

A partition of `n` is a set of positive integers which add up to `n`. For
example, partitions of 3 are 3, 1 + 2, 1 + 1 + 1. A partition is returned
as a tuple. If ``k`` equals None, then all possible partitions are returned
irrespective of their size, otherwise only the partitions of size ``k`` are
returned. If the ``zero`` parameter is set to True then a suitable
number of zeros are added at the end of every partition of size less than
``k``.

``zero`` parameter is considered only if ``k`` is not None. When the
partitions are over, the last `next()` call throws the ``StopIteration``
exception, so this function should always be used inside a try - except
block.

Details
=======

``partition(n, k)``: Here ``n`` is a positive integer and ``k`` is the size
of the partition which is also positive integer.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import partition
&gt;&gt;&gt; f = partition(5)
&gt;&gt;&gt; next(f)
(1, 1, 1, 1, 1)
&gt;&gt;&gt; next(f)
(1, 1, 1, 2)
&gt;&gt;&gt; g = partition(5, 3)
&gt;&gt;&gt; next(g)
(1, 1, 3)
&gt;&gt;&gt; next(g)
(1, 2, 2)
&gt;&gt;&gt; g = partition(5, 3, zeros=True)
&gt;&gt;&gt; next(g)
(0, 0, 5)</pre> 
</div>
</div>
<a id="a03581013fe25621e5dd97898899182e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03581013fe25621e5dd97898899182e5">&#9670;&nbsp;</a></span>pow_rep_recursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.pow_rep_recursive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>terms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab12ae37d1081aedb42db6763299431d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12ae37d1081aedb42db6763299431d0">&#9670;&nbsp;</a></span>power_representation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.power_representation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeros</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a generator for finding k-tuples of integers,
`(n_{1}, n_{2}, . . . n_{k})`, such that
`n = n_{1}^p + n_{2}^p + . . . n_{k}^p`.

Usage
=====

``power_representation(n, p, k, zeros)``: Represent non-negative number
``n`` as a sum of ``k`` ``p``\ th powers. If ``zeros`` is true, then the
solutions is allowed to contain zeros.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import power_representation

Represent 1729 as a sum of two cubes:

&gt;&gt;&gt; f = power_representation(1729, 3, 2)
&gt;&gt;&gt; next(f)
(9, 10)
&gt;&gt;&gt; next(f)
(1, 12)

If the flag `zeros` is True, the solution may contain tuples with
zeros; any such solutions will be generated after the solutions
without zeros:

&gt;&gt;&gt; list(power_representation(125, 2, 3, zeros=True))
[(5, 6, 8), (3, 4, 10), (0, 5, 10), (0, 2, 11)]

For even `p` the `permute_sign` function can be used to get all
signed values:

&gt;&gt;&gt; from sympy.utilities.iterables import permute_signs
&gt;&gt;&gt; list(permute_signs((1, 12)))
[(1, 12), (-1, 12), (1, -12), (-1, -12)]

All possible signed permutations can also be obtained:

&gt;&gt;&gt; from sympy.utilities.iterables import signed_permutations
&gt;&gt;&gt; list(signed_permutations((1, 12)))
[(1, 12), (-1, 12), (1, -12), (-1, -12), (12, 1), (-12, 1), (12, -1), (-12, -1)]
</pre> 
</div>
</div>
<a id="ab9bfddeaaa45e19947f879390abe6b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bfddeaaa45e19947f879390abe6b24">&#9670;&nbsp;</a></span>PQa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.PQa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>P_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns useful information needed to solve the Pell equation.

Explanation
===========

There are six sequences of integers defined related to the continued
fraction representation of `\\frac{P + \sqrt{D}}{Q}`, namely {`P_{i}`},
{`Q_{i}`}, {`a_{i}`},{`A_{i}`}, {`B_{i}`}, {`G_{i}`}. ``PQa()`` Returns
these values as a 6-tuple in the same order as mentioned above. Refer [1]_
for more detailed information.

Usage
=====

``PQa(P_0, Q_0, D)``: ``P_0``, ``Q_0`` and ``D`` are integers corresponding
to `P_{0}`, `Q_{0}` and `D` in the continued fraction
`\\frac{P_{0} + \sqrt{D}}{Q_{0}}`.
Also it's assumed that `P_{0}^2 == D mod(|Q_{0}|)` and `D` is square free.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import PQa
&gt;&gt;&gt; pqa = PQa(13, 4, 5) # (13 + sqrt(5))/4
&gt;&gt;&gt; next(pqa) # (P_0, Q_0, a_0, A_0, B_0, G_0)
(13, 4, 3, 3, 1, -1)
&gt;&gt;&gt; next(pqa) # (P_1, Q_1, a_1, A_1, B_1, G_1)
(-1, 1, 1, 4, 1, 3)

References
==========

.. [1] Solving the generalized Pell equation x^2 - Dy^2 = N, John P.
    Robertson, July 31, 2004, Pages 4 - 8. https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf
</pre> 
</div>
</div>
<a id="aa5a780ad4b7c4bc397ef0133b805a270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a780ad4b7c4bc397ef0133b805a270">&#9670;&nbsp;</a></span>prime_as_sum_of_two_squares()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.prime_as_sum_of_two_squares </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Represent a prime `p` as a unique sum of two squares; this can
only be done if the prime is congruent to 1 mod 4.

Parameters
==========

p : Integer
    A prime that is congruent to 1 mod 4

Returns
=======

(int, int) | None : Pair of positive integers ``(x, y)`` satisfying ``x**2 + y**2 = p``.
                    None if ``p`` is not congruent to 1 mod 4.

Raises
======

ValueError
    If ``p`` is not prime number

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import prime_as_sum_of_two_squares
&gt;&gt;&gt; prime_as_sum_of_two_squares(7)  # can't be done
&gt;&gt;&gt; prime_as_sum_of_two_squares(5)
(1, 2)

Reference
=========

.. [1] Representing a number as a sum of four squares, [online],
       Available: https://schorn.ch/lagrange.html

See Also
========

sum_of_squares</pre> 
</div>
</div>
<a id="ade7e295ae191c4469b75ff4e51f21161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7e295ae191c4469b75ff4e51f21161">&#9670;&nbsp;</a></span>reconstruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.reconstruct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct the `z` value of an equivalent solution of `ax^2 + by^2 + cz^2`
from the `z` value of a solution of the square-free normal form of the
equation, `a'*x^2 + b'*y^2 + c'*z^2`, where `a'`, `b'` and `c'` are square
free and `gcd(a', b', c') == 1`.
</pre> 
</div>
</div>
<a id="a890fdd2140ce5e03073a47594767908e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890fdd2140ce5e03073a47594767908e">&#9670;&nbsp;</a></span>sqf_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.sqf_normal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return `a', b', c'`, the coefficients of the square-free normal
form of `ax^2 + by^2 + cz^2 = 0`, where `a', b', c'` are pairwise
prime.  If `steps` is True then also return three tuples:
`sq`, `sqf`, and `(a', b', c')` where `sq` contains the square
factors of `a`, `b` and `c` after removing the `gcd(a, b, c)`;
`sqf` contains the values of `a`, `b` and `c` after removing
both the `gcd(a, b, c)` and the square factors.

The solutions for `ax^2 + by^2 + cz^2 = 0` can be
recovered from the solutions of `a'x^2 + b'y^2 + c'z^2 = 0`.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import sqf_normal
&gt;&gt;&gt; sqf_normal(2 * 3**2 * 5, 2 * 5 * 11, 2 * 7**2 * 11)
(11, 1, 5)
&gt;&gt;&gt; sqf_normal(2 * 3**2 * 5, 2 * 5 * 11, 2 * 7**2 * 11, True)
((3, 1, 7), (5, 55, 11), (11, 1, 5))

References
==========

.. [1] Legendre's Theorem, Legrange's Descent,
       https://public.csusm.edu/aitken_html/notes/legendre.pdf


See Also
========

reconstruct()
</pre> 
</div>
</div>
<a id="aec193daa09312db0d5f78ca05697d442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec193daa09312db0d5f78ca05697d442">&#9670;&nbsp;</a></span>square_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.square_factor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an integer `c` s.t. `a = c^2k, \ c,k \in Z`. Here `k` is square
free. `a` can be given as an integer or a dictionary of factors.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import square_factor
&gt;&gt;&gt; square_factor(24)
2
&gt;&gt;&gt; square_factor(-36*3)
6
&gt;&gt;&gt; square_factor(1)
1
&gt;&gt;&gt; square_factor({3: 2, 2: 1, -1: 1})  # -18
3

See Also
========
sympy.ntheory.factor_.core
</pre> 
</div>
</div>
<a id="a15b1c262b35d123374712684417f8469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b1c262b35d123374712684417f8469">&#9670;&nbsp;</a></span>sum_of_four_squares()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.sum_of_four_squares </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a 4-tuple `(a, b, c, d)` such that `a^2 + b^2 + c^2 + d^2 = n`.
Here `a, b, c, d \geq 0`.

Parameters
==========

n : Integer
    non-negative integer

Returns
=======

(int, int, int, int) : 4-tuple non-negative integers ``(a, b, c, d)`` satisfying ``a**2 + b**2 + c**2 + d**2 = n``.
                       a,b,c,d are sorted in ascending order.

Raises
======

ValueError
    If ``n`` is a negative integer

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import sum_of_four_squares
&gt;&gt;&gt; sum_of_four_squares(3456)
(8, 8, 32, 48)
&gt;&gt;&gt; sum_of_four_squares(1294585930293)
(0, 1234, 2161, 1137796)

References
==========

.. [1] Representing a number as a sum of four squares, [online],
    Available: https://schorn.ch/lagrange.html

See Also
========

power_representation :
    ``sum_of_four_squares(n)`` is one of the solutions output by ``power_representation(n, 2, 4, zeros=True)``</pre> 
</div>
</div>
<a id="a5f32c5a05fe21c163e69a6ef0a59787d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f32c5a05fe21c163e69a6ef0a59787d">&#9670;&nbsp;</a></span>sum_of_squares()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.sum_of_squares </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeros</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a generator that yields the k-tuples of nonnegative
values, the squares of which sum to n. If zeros is False (default)
then the solution will not contain zeros. The nonnegative
elements of a tuple are sorted.

* If k == 1 and n is square, (n,) is returned.

* If k == 2 then n can only be written as a sum of squares if
  every prime in the factorization of n that has the form
  4*k + 3 has an even multiplicity. If n is prime then
  it can only be written as a sum of two squares if it is
  in the form 4*k + 1.

* if k == 3 then n can be written as a sum of squares if it does
  not have the form 4**m*(8*k + 7).

* all integers can be written as the sum of 4 squares.

* if k &gt; 4 then n can be partitioned and each partition can
  be written as a sum of 4 squares; if n is not evenly divisible
  by 4 then n can be written as a sum of squares only if the
  an additional partition can be written as sum of squares.
  For example, if k = 6 then n is partitioned into two parts,
  the first being written as a sum of 4 squares and the second
  being written as a sum of 2 squares -- which can only be
  done if the condition above for k = 2 can be met, so this will
  automatically reject certain partitions of n.

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import sum_of_squares
&gt;&gt;&gt; list(sum_of_squares(25, 2))
[(3, 4)]
&gt;&gt;&gt; list(sum_of_squares(25, 2, True))
[(3, 4), (0, 5)]
&gt;&gt;&gt; list(sum_of_squares(25, 4))
[(1, 2, 2, 4)]

See Also
========

sympy.utilities.iterables.signed_permutations
</pre> 
</div>
</div>
<a id="ab06f9fdd521a1f192b425cc565267344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06f9fdd521a1f192b425cc565267344">&#9670;&nbsp;</a></span>sum_of_three_squares()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.sum_of_three_squares </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a 3-tuple $(a, b, c)$ such that $a^2 + b^2 + c^2 = n$ and
$a, b, c \geq 0$.

Returns None if $n = 4^a(8m + 7)$ for some `a, m \in \mathbb{Z}`. See
[1]_ for more details.

Parameters
==========

n : Integer
    non-negative integer

Returns
=======

(int, int, int) | None : 3-tuple non-negative integers ``(a, b, c)`` satisfying ``a**2 + b**2 + c**2 = n``.
                         a,b,c are sorted in ascending order. ``None`` if no such ``(a,b,c)``.

Raises
======

ValueError
    If ``n`` is a negative integer

Examples
========

&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import sum_of_three_squares
&gt;&gt;&gt; sum_of_three_squares(44542)
(18, 37, 207)

References
==========

.. [1] Representing a number as a sum of three squares, [online],
    Available: https://schorn.ch/lagrange.html

See Also
========

power_representation :
    ``sum_of_three_squares(n)`` is one of the solutions output by ``power_representation(n, 2, 3, zeros=True)``</pre> 
</div>
</div>
<a id="a915e597549b182a57ab417fae04d7d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915e597549b182a57ab417fae04d7d7d">&#9670;&nbsp;</a></span>transformation_to_DN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.transformation_to_DN </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function transforms general quadratic,
`ax^2 + bxy + cy^2 + dx + ey + f = 0`
to more easy to deal with `X^2 - DY^2 = N` form.

Explanation
===========

This is used to solve the general quadratic equation by transforming it to
the latter form. Refer to [1]_ for more detailed information on the
transformation. This function returns a tuple (A, B) where A is a 2 X 2
matrix and B is a 2 X 1 matrix such that,

Transpose([x y]) =  A * Transpose([X Y]) + B

Usage
=====

``transformation_to_DN(eq)``: where ``eq`` is the quadratic to be
transformed.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.solvers.diophantine.diophantine import transformation_to_DN
&gt;&gt;&gt; A, B = transformation_to_DN(x**2 - 3*x*y - y**2 - 2*y + 1)
&gt;&gt;&gt; A
Matrix([
[1/26, 3/26],
[   0, 1/13]])
&gt;&gt;&gt; B
Matrix([
[-6/13],
[-4/13]])

A, B  returned are such that Transpose((x y)) =  A * Transpose((X Y)) + B.
Substituting these values for `x` and `y` and a bit of simplifying work
will give an equation of the form `x^2 - Dy^2 = N`.

&gt;&gt;&gt; from sympy.abc import X, Y
&gt;&gt;&gt; from sympy import Matrix, simplify
&gt;&gt;&gt; u = (A*Matrix([X, Y]) + B)[0] # Transformation for x
&gt;&gt;&gt; u
X/26 + 3*Y/26 - 6/13
&gt;&gt;&gt; v = (A*Matrix([X, Y]) + B)[1] # Transformation for y
&gt;&gt;&gt; v
Y/13 - 4/13

Next we will substitute these formulas for `x` and `y` and do
``simplify()``.

&gt;&gt;&gt; eq = simplify((x**2 - 3*x*y - y**2 - 2*y + 1).subs(zip((x, y), (u, v))))
&gt;&gt;&gt; eq
X**2/676 - Y**2/52 + 17/13

By multiplying the denominator appropriately, we can get a Pell equation
in the standard form.

&gt;&gt;&gt; eq * 676
X**2 - 13*Y**2 + 884

If only the final equation is needed, ``find_DN()`` can be used.

See Also
========

find_DN()

References
==========

.. [1] Solving the equation ax^2 + bxy + cy^2 + dx + ey + f = 0,
       John P.Robertson, May 8, 2003, Page 7 - 11.
       https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf
</pre> 
</div>
</div>
<a id="aab14f66e3644d82ff52f9dc1efa71e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab14f66e3644d82ff52f9dc1efa71e0c">&#9670;&nbsp;</a></span>transformation_to_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.transformation_to_normal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the transformation Matrix that converts a general ternary
quadratic equation ``eq`` (`ax^2 + by^2 + cz^2 + dxy + eyz + fxz`)
to a form without cross terms: `ax^2 + by^2 + cz^2 = 0`. This is
not used in solving ternary quadratics; it is only implemented for
the sake of completeness.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abae4c91da48a115feebcc0890c831796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae4c91da48a115feebcc0890c831796">&#9670;&nbsp;</a></span>all_diop_classes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list sympy.solvers.diophantine.diophantine.all_diop_classes</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  [</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    Linear,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    Univariate,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    BinaryQuadratic,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    InhomogeneousTernaryQuadratic,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    HomogeneousTernaryQuadraticNormal,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    HomogeneousTernaryQuadratic,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    InhomogeneousGeneralQuadratic,</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    HomogeneousGeneralQuadratic,</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    GeneralSumOfSquares,</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    GeneralPythagorean,</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    CubicThue,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    GeneralSumOfEvenPowers,</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a739b678f0e7b65c4b34a38e114b6558b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739b678f0e7b65c4b34a38e114b6558b">&#9670;&nbsp;</a></span>diop_known</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary sympy.solvers.diophantine.diophantine.diop_known = {diop_class.name for diop_class in <a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#abae4c91da48a115feebcc0890c831796">all_diop_classes</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96f5400b0483b6d3b8df7a882cfb8fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f5400b0483b6d3b8df7a882cfb8fd5">&#9670;&nbsp;</a></span>sum_of_powers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.diophantine.diophantine.sum_of_powers = <a class="el" href="namespacesympy_1_1solvers_1_1diophantine_1_1diophantine.html#ab12ae37d1081aedb42db6763299431d0">power_representation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
