<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.physics.mechanics.kane.KanesMethod Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics.html">physics</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics_1_1mechanics.html">mechanics</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics_1_1mechanics_1_1kane.html">kane</a></li><li class="navelem"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html">KanesMethod</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sympy.physics.mechanics.kane.KanesMethod Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for sympy.physics.mechanics.kane.KanesMethod:</div>
<div class="dyncontent">
<div class="center"><img src="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod__inherit__graph.png" border="0" usemap="#asympy_8physics_8mechanics_8kane_8KanesMethod_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sympy.physics.mechanics.kane.KanesMethod:</div>
<div class="dyncontent">
<div class="center"><img src="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod__coll__graph.png" border="0" usemap="#asympy_8physics_8mechanics_8kane_8KanesMethod_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a75b6ceac55c7c26f4cc8390a942e5bbd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a75b6ceac55c7c26f4cc8390a942e5bbd">__init__</a> (self, frame, q_ind, u_ind, kd_eqs=None, q_dependent=None, configuration_constraints=None, u_dependent=None, velocity_constraints=None, acceleration_constraints=None, u_auxiliary=None, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a1f226ef7ee02cd5fa325a12ecc46d22c">bodies</a>=None, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ab95bfac79166a4845eca0f79a003f7e6">forcelist</a>=None, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a8032c0c2116355024c4d0c6de0dd03c3">explicit_kinematics</a>=True, kd_eqs_solver='LU', constraint_solver='LU')</td></tr>
<tr class="separator:a75b6ceac55c7c26f4cc8390a942e5bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387aa35766ee8bb60f42d7f5eb89bbc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a387aa35766ee8bb60f42d7f5eb89bbc0">to_linearizer</a> (self, linear_solver='LU')</td></tr>
<tr class="separator:a387aa35766ee8bb60f42d7f5eb89bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3f3a0f3a1b4c13021e6103e65aa826"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#abf3f3a0f3a1b4c13021e6103e65aa826">linearize</a> (self, *new_method=None, linear_solver='LU', **kwargs)</td></tr>
<tr class="separator:abf3f3a0f3a1b4c13021e6103e65aa826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42434e075f09a0c9aa2027881a7165a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a42434e075f09a0c9aa2027881a7165a2">kanes_equations</a> (self, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a1f226ef7ee02cd5fa325a12ecc46d22c">bodies</a>=None, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ad76d5b1617b4c0930640365156f30cf1">loads</a>=None)</td></tr>
<tr class="separator:a42434e075f09a0c9aa2027881a7165a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e80001a8f3f147cd2691e0ba61d495"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a03e80001a8f3f147cd2691e0ba61d495">rhs</a> (self, inv_method=None)</td></tr>
<tr class="separator:a03e80001a8f3f147cd2691e0ba61d495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad111f26204c77770de7b0f8482859c2f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ad111f26204c77770de7b0f8482859c2f">kindiffdict</a> (self)</td></tr>
<tr class="separator:ad111f26204c77770de7b0f8482859c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5527138dacd3b327c1bfeb71be9b1313"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a5527138dacd3b327c1bfeb71be9b1313">auxiliary_eqs</a> (self)</td></tr>
<tr class="separator:a5527138dacd3b327c1bfeb71be9b1313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcbdc6fbad76363efac2f104929e1c4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a8fcbdc6fbad76363efac2f104929e1c4">mass_matrix_kin</a> (self)</td></tr>
<tr class="separator:a8fcbdc6fbad76363efac2f104929e1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a14a645df5869a1cd783e9b429d64c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ab0a14a645df5869a1cd783e9b429d64c">forcing_kin</a> (self)</td></tr>
<tr class="separator:ab0a14a645df5869a1cd783e9b429d64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090cad10c60ea3da8048e5d1be3c39ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a090cad10c60ea3da8048e5d1be3c39ed">mass_matrix</a> (self)</td></tr>
<tr class="separator:a090cad10c60ea3da8048e5d1be3c39ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7693f2b037174c2a03a41ae3688bd755"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a7693f2b037174c2a03a41ae3688bd755">forcing</a> (self)</td></tr>
<tr class="separator:a7693f2b037174c2a03a41ae3688bd755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb23cd92aaeaa8df2e68a703f818fb1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#aaeb23cd92aaeaa8df2e68a703f818fb1">mass_matrix_full</a> (self)</td></tr>
<tr class="separator:aaeb23cd92aaeaa8df2e68a703f818fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6763e157a41b542a45fe47bc4c64d3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a3c6763e157a41b542a45fe47bc4c64d3">forcing_full</a> (self)</td></tr>
<tr class="separator:a3c6763e157a41b542a45fe47bc4c64d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedea5e321c4ac2e225d849d4844678af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#aedea5e321c4ac2e225d849d4844678af">q</a> (self)</td></tr>
<tr class="separator:aedea5e321c4ac2e225d849d4844678af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ed6a07dbc0d1f25bde41ad2e4fa578"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a68ed6a07dbc0d1f25bde41ad2e4fa578">u</a> (self)</td></tr>
<tr class="separator:a68ed6a07dbc0d1f25bde41ad2e4fa578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86389db0e9b612b36848c8070ce80ab1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a86389db0e9b612b36848c8070ce80ab1">bodylist</a> (self)</td></tr>
<tr class="separator:a86389db0e9b612b36848c8070ce80ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95bfac79166a4845eca0f79a003f7e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ab95bfac79166a4845eca0f79a003f7e6">forcelist</a> (self)</td></tr>
<tr class="separator:ab95bfac79166a4845eca0f79a003f7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f226ef7ee02cd5fa325a12ecc46d22c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a1f226ef7ee02cd5fa325a12ecc46d22c">bodies</a> (self)</td></tr>
<tr class="separator:a1f226ef7ee02cd5fa325a12ecc46d22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76d5b1617b4c0930640365156f30cf1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ad76d5b1617b4c0930640365156f30cf1">loads</a> (self)</td></tr>
<tr class="separator:ad76d5b1617b4c0930640365156f30cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b6ceac55c7c26f4cc8390a942e5bbd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a75b6ceac55c7c26f4cc8390a942e5bbd">__init__</a> (self, frame, q_ind, u_ind, kd_eqs=None, q_dependent=None, configuration_constraints=None, u_dependent=None, velocity_constraints=None, acceleration_constraints=None, u_auxiliary=None, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a1f226ef7ee02cd5fa325a12ecc46d22c">bodies</a>=None, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ab95bfac79166a4845eca0f79a003f7e6">forcelist</a>=None, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a8032c0c2116355024c4d0c6de0dd03c3">explicit_kinematics</a>=True, kd_eqs_solver='LU', constraint_solver='LU')</td></tr>
<tr class="separator:a75b6ceac55c7c26f4cc8390a942e5bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387aa35766ee8bb60f42d7f5eb89bbc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a387aa35766ee8bb60f42d7f5eb89bbc0">to_linearizer</a> (self, linear_solver='LU')</td></tr>
<tr class="separator:a387aa35766ee8bb60f42d7f5eb89bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3f3a0f3a1b4c13021e6103e65aa826"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#abf3f3a0f3a1b4c13021e6103e65aa826">linearize</a> (self, *new_method=None, linear_solver='LU', **kwargs)</td></tr>
<tr class="separator:abf3f3a0f3a1b4c13021e6103e65aa826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42434e075f09a0c9aa2027881a7165a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a42434e075f09a0c9aa2027881a7165a2">kanes_equations</a> (self, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a1f226ef7ee02cd5fa325a12ecc46d22c">bodies</a>=None, <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ad76d5b1617b4c0930640365156f30cf1">loads</a>=None)</td></tr>
<tr class="separator:a42434e075f09a0c9aa2027881a7165a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e80001a8f3f147cd2691e0ba61d495"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a03e80001a8f3f147cd2691e0ba61d495">rhs</a> (self, inv_method=None)</td></tr>
<tr class="separator:a03e80001a8f3f147cd2691e0ba61d495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad111f26204c77770de7b0f8482859c2f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ad111f26204c77770de7b0f8482859c2f">kindiffdict</a> (self)</td></tr>
<tr class="separator:ad111f26204c77770de7b0f8482859c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5527138dacd3b327c1bfeb71be9b1313"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a5527138dacd3b327c1bfeb71be9b1313">auxiliary_eqs</a> (self)</td></tr>
<tr class="separator:a5527138dacd3b327c1bfeb71be9b1313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcbdc6fbad76363efac2f104929e1c4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a8fcbdc6fbad76363efac2f104929e1c4">mass_matrix_kin</a> (self)</td></tr>
<tr class="separator:a8fcbdc6fbad76363efac2f104929e1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a14a645df5869a1cd783e9b429d64c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ab0a14a645df5869a1cd783e9b429d64c">forcing_kin</a> (self)</td></tr>
<tr class="separator:ab0a14a645df5869a1cd783e9b429d64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090cad10c60ea3da8048e5d1be3c39ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a090cad10c60ea3da8048e5d1be3c39ed">mass_matrix</a> (self)</td></tr>
<tr class="separator:a090cad10c60ea3da8048e5d1be3c39ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7693f2b037174c2a03a41ae3688bd755"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a7693f2b037174c2a03a41ae3688bd755">forcing</a> (self)</td></tr>
<tr class="separator:a7693f2b037174c2a03a41ae3688bd755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb23cd92aaeaa8df2e68a703f818fb1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#aaeb23cd92aaeaa8df2e68a703f818fb1">mass_matrix_full</a> (self)</td></tr>
<tr class="separator:aaeb23cd92aaeaa8df2e68a703f818fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6763e157a41b542a45fe47bc4c64d3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a3c6763e157a41b542a45fe47bc4c64d3">forcing_full</a> (self)</td></tr>
<tr class="separator:a3c6763e157a41b542a45fe47bc4c64d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedea5e321c4ac2e225d849d4844678af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#aedea5e321c4ac2e225d849d4844678af">q</a> (self)</td></tr>
<tr class="separator:aedea5e321c4ac2e225d849d4844678af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ed6a07dbc0d1f25bde41ad2e4fa578"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a68ed6a07dbc0d1f25bde41ad2e4fa578">u</a> (self)</td></tr>
<tr class="separator:a68ed6a07dbc0d1f25bde41ad2e4fa578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86389db0e9b612b36848c8070ce80ab1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a86389db0e9b612b36848c8070ce80ab1">bodylist</a> (self)</td></tr>
<tr class="separator:a86389db0e9b612b36848c8070ce80ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95bfac79166a4845eca0f79a003f7e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ab95bfac79166a4845eca0f79a003f7e6">forcelist</a> (self)</td></tr>
<tr class="separator:ab95bfac79166a4845eca0f79a003f7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f226ef7ee02cd5fa325a12ecc46d22c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a1f226ef7ee02cd5fa325a12ecc46d22c">bodies</a> (self)</td></tr>
<tr class="separator:a1f226ef7ee02cd5fa325a12ecc46d22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76d5b1617b4c0930640365156f30cf1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#ad76d5b1617b4c0930640365156f30cf1">loads</a> (self)</td></tr>
<tr class="separator:ad76d5b1617b4c0930640365156f30cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8032c0c2116355024c4d0c6de0dd03c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1mechanics_1_1kane_1_1KanesMethod.html#a8032c0c2116355024c4d0c6de0dd03c3">explicit_kinematics</a></td></tr>
<tr class="separator:a8032c0c2116355024c4d0c6de0dd03c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Kane's method object.

Explanation
===========

This object is used to do the "book-keeping" as you go through and form
equations of motion in the way Kane presents in:
Kane, T., Levinson, D. Dynamics Theory and Applications. 1985 McGraw-Hill

The attributes are for equations in the form [M] udot = forcing.

Attributes
==========

q, u : Matrix
    Matrices of the generalized coordinates and speeds
bodies : iterable
    Iterable of Particle and RigidBody objects in the system.
loads : iterable
    Iterable of (Point, vector) or (ReferenceFrame, vector) tuples
    describing the forces on the system.
auxiliary_eqs : Matrix
    If applicable, the set of auxiliary Kane's
    equations used to solve for non-contributing
    forces.
mass_matrix : Matrix
    The system's dynamics mass matrix: [k_d; k_dnh]
forcing : Matrix
    The system's dynamics forcing vector: -[f_d; f_dnh]
mass_matrix_kin : Matrix
    The "mass matrix" for kinematic differential equations: k_kqdot
forcing_kin : Matrix
    The forcing vector for kinematic differential equations: -(k_ku*u + f_k)
mass_matrix_full : Matrix
    The "mass matrix" for the u's and q's with dynamics and kinematics
forcing_full : Matrix
    The "forcing vector" for the u's and q's with dynamics and kinematics

Parameters
==========

frame : ReferenceFrame
    The inertial reference frame for the system.
q_ind : iterable of dynamicsymbols
    Independent generalized coordinates.
u_ind : iterable of dynamicsymbols
    Independent generalized speeds.
kd_eqs : iterable of Expr, optional
    Kinematic differential equations, which linearly relate the generalized
    speeds to the time-derivatives of the generalized coordinates.
q_dependent : iterable of dynamicsymbols, optional
    Dependent generalized coordinates.
configuration_constraints : iterable of Expr, optional
    Constraints on the system's configuration, i.e. holonomic constraints.
u_dependent : iterable of dynamicsymbols, optional
    Dependent generalized speeds.
velocity_constraints : iterable of Expr, optional
    Constraints on the system's velocity, i.e. the combination of the
    nonholonomic constraints and the time-derivative of the holonomic
    constraints.
acceleration_constraints : iterable of Expr, optional
    Constraints on the system's acceleration, by default these are the
    time-derivative of the velocity constraints.
u_auxiliary : iterable of dynamicsymbols, optional
    Auxiliary generalized speeds.
bodies : iterable of Particle and/or RigidBody, optional
    The particles and rigid bodies in the system.
forcelist : iterable of tuple[Point | ReferenceFrame, Vector], optional
    Forces and torques applied on the system.
explicit_kinematics : bool
    Boolean whether the mass matrices and forcing vectors should use the
    explicit form (default) or implicit form for kinematics.
    See the notes for more details.
kd_eqs_solver : str, callable
    Method used to solve the kinematic differential equations. If a string
    is supplied, it should be a valid method that can be used with the
    :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is
    supplied, it should have the format ``f(A, rhs)``, where it solves the
    equations and returns the solution. The default utilizes LU solve. See
    the notes for more information.
constraint_solver : str, callable
    Method used to solve the velocity constraints. If a string is
    supplied, it should be a valid method that can be used with the
    :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is
    supplied, it should have the format ``f(A, rhs)``, where it solves the
    equations and returns the solution. The default utilizes LU solve. See
    the notes for more information.

Notes
=====

The mass matrices and forcing vectors related to kinematic equations
are given in the explicit form by default. In other words, the kinematic
mass matrix is $\mathbf{k_{k\dot{q}}} = \mathbf{I}$.
In order to get the implicit form of those matrices/vectors, you can set the
``explicit_kinematics`` attribute to ``False``. So $\mathbf{k_{k\dot{q}}}$
is not necessarily an identity matrix. This can provide more compact
equations for non-simple kinematics.

Two linear solvers can be supplied to ``KanesMethod``: one for solving the
kinematic differential equations and one to solve the velocity constraints.
Both of these sets of equations can be expressed as a linear system ``Ax = rhs``,
which have to be solved in order to obtain the equations of motion.

The default solver ``'LU'``, which stands for LU solve, results relatively low
number of operations. The weakness of this method is that it can result in zero
division errors.

If zero divisions are encountered, a possible solver which may solve the problem
is ``"CRAMER"``. This method uses Cramer's rule to solve the system. This method
is slower and results in more operations than the default solver. However it only
uses a single division by default per entry of the solution.

While a valid list of solvers can be found at
:meth:`sympy.matrices.matrixbase.MatrixBase.solve`, it is also possible to supply a
`callable`. This way it is possible to use a different solver routine. If the
kinematic differential equations are not too complex it can be worth it to simplify
the solution by using ``lambda A, b: simplify(Matrix.LUsolve(A, b))``. Another
option solver one may use is :func:`sympy.solvers.solveset.linsolve`. This can be
done using `lambda A, b: tuple(linsolve((A, b)))[0]`, where we select the first
solution as our system should have only one unique solution.

Examples
========

This is a simple example for a one degree of freedom translational
spring-mass-damper.

In this example, we first need to do the kinematics.
This involves creating generalized speeds and coordinates and their
derivatives.
Then we create a point and set its velocity in a frame.

    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from sympy.physics.mechanics import dynamicsymbols, ReferenceFrame
    &gt;&gt;&gt; from sympy.physics.mechanics import Point, Particle, KanesMethod
    &gt;&gt;&gt; q, u = dynamicsymbols('q u')
    &gt;&gt;&gt; qd, ud = dynamicsymbols('q u', 1)
    &gt;&gt;&gt; m, c, k = symbols('m c k')
    &gt;&gt;&gt; N = ReferenceFrame('N')
    &gt;&gt;&gt; P = Point('P')
    &gt;&gt;&gt; P.set_vel(N, u * N.x)

Next we need to arrange/store information in the way that KanesMethod
requires. The kinematic differential equations should be an iterable of
expressions. A list of forces/torques must be constructed, where each entry
in the list is a (Point, Vector) or (ReferenceFrame, Vector) tuple, where
the Vectors represent the Force or Torque.
Next a particle needs to be created, and it needs to have a point and mass
assigned to it.
Finally, a list of all bodies and particles needs to be created.

    &gt;&gt;&gt; kd = [qd - u]
    &gt;&gt;&gt; FL = [(P, (-k * q - c * u) * N.x)]
    &gt;&gt;&gt; pa = Particle('pa', P, m)
    &gt;&gt;&gt; BL = [pa]

Finally we can generate the equations of motion.
First we create the KanesMethod object and supply an inertial frame,
coordinates, generalized speeds, and the kinematic differential equations.
Additional quantities such as configuration and motion constraints,
dependent coordinates and speeds, and auxiliary speeds are also supplied
here (see the online documentation).
Next we form FR* and FR to complete: Fr + Fr* = 0.
We have the equations of motion at this point.
It makes sense to rearrange them though, so we calculate the mass matrix and
the forcing terms, for E.o.M. in the form: [MM] udot = forcing, where MM is
the mass matrix, udot is a vector of the time derivatives of the
generalized speeds, and forcing is a vector representing "forcing" terms.

    &gt;&gt;&gt; KM = KanesMethod(N, q_ind=[q], u_ind=[u], kd_eqs=kd)
    &gt;&gt;&gt; (fr, frstar) = KM.kanes_equations(BL, FL)
    &gt;&gt;&gt; MM = KM.mass_matrix
    &gt;&gt;&gt; forcing = KM.forcing
    &gt;&gt;&gt; rhs = MM.inv() * forcing
    &gt;&gt;&gt; rhs
    Matrix([[(-c*u(t) - k*q(t))/m]])
    &gt;&gt;&gt; KM.linearize(A_and_B=True)[0]
    Matrix([
    [   0,    1],
    [-k/m, -c/m]])

Please look at the documentation pages for more information on how to
perform linearization and how to deal with dependent coordinates &amp; speeds,
and how do deal with bringing non-contributing forces into evidence.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a75b6ceac55c7c26f4cc8390a942e5bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b6ceac55c7c26f4cc8390a942e5bbd">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kd_eqs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q_dependent</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>configuration_constraints</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_dependent</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>velocity_constraints</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>acceleration_constraints</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_auxiliary</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bodies</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>forcelist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>explicit_kinematics</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kd_eqs_solver</em> = <code>'LU'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>constraint_solver</em> = <code>'LU'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Please read the online documentation. </pre> 
</div>
</div>
<a id="a75b6ceac55c7c26f4cc8390a942e5bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b6ceac55c7c26f4cc8390a942e5bbd">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kd_eqs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q_dependent</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>configuration_constraints</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_dependent</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>velocity_constraints</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>acceleration_constraints</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_auxiliary</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bodies</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>forcelist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>explicit_kinematics</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kd_eqs_solver</em> = <code>'LU'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>constraint_solver</em> = <code>'LU'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Please read the online documentation. </pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5527138dacd3b327c1bfeb71be9b1313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5527138dacd3b327c1bfeb71be9b1313">&#9670;&nbsp;</a></span>auxiliary_eqs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.auxiliary_eqs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A matrix containing the auxiliary equations.</pre> 
</div>
</div>
<a id="a5527138dacd3b327c1bfeb71be9b1313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5527138dacd3b327c1bfeb71be9b1313">&#9670;&nbsp;</a></span>auxiliary_eqs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.auxiliary_eqs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A matrix containing the auxiliary equations.</pre> 
</div>
</div>
<a id="a1f226ef7ee02cd5fa325a12ecc46d22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f226ef7ee02cd5fa325a12ecc46d22c">&#9670;&nbsp;</a></span>bodies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.bodies </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a4bce038407168592669e295e5047e91a">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a1f226ef7ee02cd5fa325a12ecc46d22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f226ef7ee02cd5fa325a12ecc46d22c">&#9670;&nbsp;</a></span>bodies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.bodies </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a4bce038407168592669e295e5047e91a">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a86389db0e9b612b36848c8070ce80ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86389db0e9b612b36848c8070ce80ab1">&#9670;&nbsp;</a></span>bodylist() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.bodylist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86389db0e9b612b36848c8070ce80ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86389db0e9b612b36848c8070ce80ab1">&#9670;&nbsp;</a></span>bodylist() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.bodylist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab95bfac79166a4845eca0f79a003f7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95bfac79166a4845eca0f79a003f7e6">&#9670;&nbsp;</a></span>forcelist() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.forcelist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab95bfac79166a4845eca0f79a003f7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95bfac79166a4845eca0f79a003f7e6">&#9670;&nbsp;</a></span>forcelist() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.forcelist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7693f2b037174c2a03a41ae3688bd755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7693f2b037174c2a03a41ae3688bd755">&#9670;&nbsp;</a></span>forcing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.forcing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The forcing vector of the system.</pre> 
<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a775d5c7528e884df584c83d5edc499a5">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a7693f2b037174c2a03a41ae3688bd755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7693f2b037174c2a03a41ae3688bd755">&#9670;&nbsp;</a></span>forcing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.forcing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The forcing vector of the system.</pre> 
<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a775d5c7528e884df584c83d5edc499a5">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a3c6763e157a41b542a45fe47bc4c64d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6763e157a41b542a45fe47bc4c64d3">&#9670;&nbsp;</a></span>forcing_full() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.forcing_full </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The forcing vector of the system, augmented by the kinematic
differential equations in explicit or implicit form.</pre> 
<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#ab3f83ab67044aa401e7a851e1a027522">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a3c6763e157a41b542a45fe47bc4c64d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6763e157a41b542a45fe47bc4c64d3">&#9670;&nbsp;</a></span>forcing_full() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.forcing_full </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The forcing vector of the system, augmented by the kinematic
differential equations in explicit or implicit form.</pre> 
<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#ab3f83ab67044aa401e7a851e1a027522">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="ab0a14a645df5869a1cd783e9b429d64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a14a645df5869a1cd783e9b429d64c">&#9670;&nbsp;</a></span>forcing_kin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.forcing_kin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The kinematic "forcing vector" of the system.</pre> 
</div>
</div>
<a id="ab0a14a645df5869a1cd783e9b429d64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a14a645df5869a1cd783e9b429d64c">&#9670;&nbsp;</a></span>forcing_kin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.forcing_kin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The kinematic "forcing vector" of the system.</pre> 
</div>
</div>
<a id="a42434e075f09a0c9aa2027881a7165a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42434e075f09a0c9aa2027881a7165a2">&#9670;&nbsp;</a></span>kanes_equations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.kanes_equations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bodies</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loads</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Method to form Kane's equations, Fr + Fr* = 0.

Explanation
===========

Returns (Fr, Fr*). In the case where auxiliary generalized speeds are
present (say, s auxiliary speeds, o generalized speeds, and m motion
constraints) the length of the returned vectors will be o - m + s in
length. The first o - m equations will be the constrained Kane's
equations, then the s auxiliary Kane's equations. These auxiliary
equations can be accessed with the auxiliary_eqs property.

Parameters
==========

bodies : iterable
    An iterable of all RigidBody's and Particle's in the system.
    A system must have at least one body.
loads : iterable
    Takes in an iterable of (Particle, Vector) or (ReferenceFrame, Vector)
    tuples which represent the force at a point or torque on a frame.
    Must be either a non-empty iterable of tuples or None which corresponds
    to a system with no constraints.
</pre> 
</div>
</div>
<a id="a42434e075f09a0c9aa2027881a7165a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42434e075f09a0c9aa2027881a7165a2">&#9670;&nbsp;</a></span>kanes_equations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.kanes_equations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bodies</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loads</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Method to form Kane's equations, Fr + Fr* = 0.

Explanation
===========

Returns (Fr, Fr*). In the case where auxiliary generalized speeds are
present (say, s auxiliary speeds, o generalized speeds, and m motion
constraints) the length of the returned vectors will be o - m + s in
length. The first o - m equations will be the constrained Kane's
equations, then the s auxiliary Kane's equations. These auxiliary
equations can be accessed with the auxiliary_eqs property.

Parameters
==========

bodies : iterable
    An iterable of all RigidBody's and Particle's in the system.
    A system must have at least one body.
loads : iterable
    Takes in an iterable of (Particle, Vector) or (ReferenceFrame, Vector)
    tuples which represent the force at a point or torque on a frame.
    Must be either a non-empty iterable of tuples or None which corresponds
    to a system with no constraints.
</pre> 
</div>
</div>
<a id="ad111f26204c77770de7b0f8482859c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad111f26204c77770de7b0f8482859c2f">&#9670;&nbsp;</a></span>kindiffdict() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.kindiffdict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a dictionary mapping q' to u.</pre> 
</div>
</div>
<a id="ad111f26204c77770de7b0f8482859c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad111f26204c77770de7b0f8482859c2f">&#9670;&nbsp;</a></span>kindiffdict() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.kindiffdict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a dictionary mapping q' to u.</pre> 
</div>
</div>
<a id="abf3f3a0f3a1b4c13021e6103e65aa826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3f3a0f3a1b4c13021e6103e65aa826">&#9670;&nbsp;</a></span>linearize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.linearize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>new_method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linear_solver</em> = <code>'LU'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Linearize the equations of motion about a symbolic operating point.

Parameters
==========
new_method
    Deprecated, does nothing and will be removed.
linear_solver : str, callable
    Method used to solve the several symbolic linear systems of the
    form ``A*x=b`` in the linearization process. If a string is
    supplied, it should be a valid method that can be used with the
    :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is
    supplied, it should have the format ``x = f(A, b)``, where it
    solves the equations and returns the solution. The default is
    ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.
    ``LUsolve()`` is fast to compute but will often result in
    divide-by-zero and thus ``nan`` results.
**kwargs
    Extra keyword arguments are passed to
    :meth:`sympy.physics.mechanics.linearize.Linearizer.linearize`.

Explanation
===========

If kwarg A_and_B is False (default), returns M, A, B, r for the
linearized form, M*[q', u']^T = A*[q_ind, u_ind]^T + B*r.

If kwarg A_and_B is True, returns A, B, r for the linearized form
dx = A*x + B*r, where x = [q_ind, u_ind]^T. Note that this is
computationally intensive if there are many symbolic parameters. For
this reason, it may be more desirable to use the default A_and_B=False,
returning M, A, and B. Values may then be substituted in to these
matrices, and the state space form found as
A = P.T*M.inv()*A, B = P.T*M.inv()*B, where P = Linearizer.perm_mat.

In both cases, r is found as all dynamicsymbols in the equations of
motion that are not part of q, u, q', or u'. They are sorted in
canonical form.

The operating points may be also entered using the ``op_point`` kwarg.
This takes a dictionary of {symbol: value}, or a an iterable of such
dictionaries. The values may be numeric or symbolic. The more values
you can specify beforehand, the faster this computation will run.

For more documentation, please see the ``Linearizer`` class.</pre> 
</div>
</div>
<a id="abf3f3a0f3a1b4c13021e6103e65aa826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3f3a0f3a1b4c13021e6103e65aa826">&#9670;&nbsp;</a></span>linearize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.linearize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>new_method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linear_solver</em> = <code>'LU'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Linearize the equations of motion about a symbolic operating point.

Parameters
==========
new_method
    Deprecated, does nothing and will be removed.
linear_solver : str, callable
    Method used to solve the several symbolic linear systems of the
    form ``A*x=b`` in the linearization process. If a string is
    supplied, it should be a valid method that can be used with the
    :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is
    supplied, it should have the format ``x = f(A, b)``, where it
    solves the equations and returns the solution. The default is
    ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.
    ``LUsolve()`` is fast to compute but will often result in
    divide-by-zero and thus ``nan`` results.
**kwargs
    Extra keyword arguments are passed to
    :meth:`sympy.physics.mechanics.linearize.Linearizer.linearize`.

Explanation
===========

If kwarg A_and_B is False (default), returns M, A, B, r for the
linearized form, M*[q', u']^T = A*[q_ind, u_ind]^T + B*r.

If kwarg A_and_B is True, returns A, B, r for the linearized form
dx = A*x + B*r, where x = [q_ind, u_ind]^T. Note that this is
computationally intensive if there are many symbolic parameters. For
this reason, it may be more desirable to use the default A_and_B=False,
returning M, A, and B. Values may then be substituted in to these
matrices, and the state space form found as
A = P.T*M.inv()*A, B = P.T*M.inv()*B, where P = Linearizer.perm_mat.

In both cases, r is found as all dynamicsymbols in the equations of
motion that are not part of q, u, q', or u'. They are sorted in
canonical form.

The operating points may be also entered using the ``op_point`` kwarg.
This takes a dictionary of {symbol: value}, or a an iterable of such
dictionaries. The values may be numeric or symbolic. The more values
you can specify beforehand, the faster this computation will run.

For more documentation, please see the ``Linearizer`` class.</pre> 
</div>
</div>
<a id="ad76d5b1617b4c0930640365156f30cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76d5b1617b4c0930640365156f30cf1">&#9670;&nbsp;</a></span>loads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.loads </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a6c3ee43ae367cc30d583a691c1f8a0c1">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="ad76d5b1617b4c0930640365156f30cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76d5b1617b4c0930640365156f30cf1">&#9670;&nbsp;</a></span>loads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.loads </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a6c3ee43ae367cc30d583a691c1f8a0c1">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a090cad10c60ea3da8048e5d1be3c39ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090cad10c60ea3da8048e5d1be3c39ed">&#9670;&nbsp;</a></span>mass_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.mass_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The mass matrix of the system.</pre> 
<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a1f61a6d2e68533cbbe15abf00ed0f70f">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a090cad10c60ea3da8048e5d1be3c39ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090cad10c60ea3da8048e5d1be3c39ed">&#9670;&nbsp;</a></span>mass_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.mass_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The mass matrix of the system.</pre> 
<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a1f61a6d2e68533cbbe15abf00ed0f70f">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="aaeb23cd92aaeaa8df2e68a703f818fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb23cd92aaeaa8df2e68a703f818fb1">&#9670;&nbsp;</a></span>mass_matrix_full() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.mass_matrix_full </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The mass matrix of the system, augmented by the kinematic
differential equations in explicit or implicit form.</pre> 
<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a427cfea93aa2576c24695ccc5cf8cdad">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="aaeb23cd92aaeaa8df2e68a703f818fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb23cd92aaeaa8df2e68a703f818fb1">&#9670;&nbsp;</a></span>mass_matrix_full() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.mass_matrix_full </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The mass matrix of the system, augmented by the kinematic
differential equations in explicit or implicit form.</pre> 
<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a427cfea93aa2576c24695ccc5cf8cdad">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a8fcbdc6fbad76363efac2f104929e1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcbdc6fbad76363efac2f104929e1c4">&#9670;&nbsp;</a></span>mass_matrix_kin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.mass_matrix_kin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The kinematic "mass matrix" $\mathbf{k_{k\dot{q}}}$ of the system.</pre> 
</div>
</div>
<a id="a8fcbdc6fbad76363efac2f104929e1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcbdc6fbad76363efac2f104929e1c4">&#9670;&nbsp;</a></span>mass_matrix_kin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.mass_matrix_kin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The kinematic "mass matrix" $\mathbf{k_{k\dot{q}}}$ of the system.</pre> 
</div>
</div>
<a id="aedea5e321c4ac2e225d849d4844678af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedea5e321c4ac2e225d849d4844678af">&#9670;&nbsp;</a></span>q() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.q </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a4bc26c05cab32a7d7317bee8fff4615b">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="aedea5e321c4ac2e225d849d4844678af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedea5e321c4ac2e225d849d4844678af">&#9670;&nbsp;</a></span>q() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.q </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a4bc26c05cab32a7d7317bee8fff4615b">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a03e80001a8f3f147cd2691e0ba61d495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e80001a8f3f147cd2691e0ba61d495">&#9670;&nbsp;</a></span>rhs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.rhs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inv_method</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the system's equations of motion in first order form. The
output is the right hand side of::

   x' = |q'| =: f(q, u, r, p, t)
        |u'|

The right hand side is what is needed by most numerical ODE
integrators.

Parameters
==========

inv_method : str
    The specific sympy inverse matrix calculation method to use. For a
    list of valid methods, see
    :meth:`~sympy.matrices.matrixbase.MatrixBase.inv`</pre> 
</div>
</div>
<a id="a03e80001a8f3f147cd2691e0ba61d495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e80001a8f3f147cd2691e0ba61d495">&#9670;&nbsp;</a></span>rhs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.rhs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inv_method</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the system's equations of motion in first order form. The
output is the right hand side of::

   x' = |q'| =: f(q, u, r, p, t)
        |u'|

The right hand side is what is needed by most numerical ODE
integrators.

Parameters
==========

inv_method : str
    The specific sympy inverse matrix calculation method to use. For a
    list of valid methods, see
    :meth:`~sympy.matrices.matrixbase.MatrixBase.inv`</pre> 
</div>
</div>
<a id="a387aa35766ee8bb60f42d7f5eb89bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387aa35766ee8bb60f42d7f5eb89bbc0">&#9670;&nbsp;</a></span>to_linearizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.to_linearizer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linear_solver</em> = <code>'LU'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an instance of the Linearizer class, initiated from the
data in the KanesMethod class. This may be more desirable than using
the linearize class method, as the Linearizer object will allow more
efficient recalculation (i.e. about varying operating points).

Parameters
==========
linear_solver : str, callable
    Method used to solve the several symbolic linear systems of the
    form ``A*x=b`` in the linearization process. If a string is
    supplied, it should be a valid method that can be used with the
    :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is
    supplied, it should have the format ``x = f(A, b)``, where it
    solves the equations and returns the solution. The default is
    ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.
    ``LUsolve()`` is fast to compute but will often result in
    divide-by-zero and thus ``nan`` results.

Returns
=======
Linearizer
    An instantiated
    :class:`sympy.physics.mechanics.linearize.Linearizer`.</pre> 
</div>
</div>
<a id="a387aa35766ee8bb60f42d7f5eb89bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387aa35766ee8bb60f42d7f5eb89bbc0">&#9670;&nbsp;</a></span>to_linearizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.to_linearizer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linear_solver</em> = <code>'LU'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an instance of the Linearizer class, initiated from the
data in the KanesMethod class. This may be more desirable than using
the linearize class method, as the Linearizer object will allow more
efficient recalculation (i.e. about varying operating points).

Parameters
==========
linear_solver : str, callable
    Method used to solve the several symbolic linear systems of the
    form ``A*x=b`` in the linearization process. If a string is
    supplied, it should be a valid method that can be used with the
    :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is
    supplied, it should have the format ``x = f(A, b)``, where it
    solves the equations and returns the solution. The default is
    ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.
    ``LUsolve()`` is fast to compute but will often result in
    divide-by-zero and thus ``nan`` results.

Returns
=======
Linearizer
    An instantiated
    :class:`sympy.physics.mechanics.linearize.Linearizer`.</pre> 
</div>
</div>
<a id="a68ed6a07dbc0d1f25bde41ad2e4fa578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ed6a07dbc0d1f25bde41ad2e4fa578">&#9670;&nbsp;</a></span>u() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.u </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a7cbdc078331d1a16b1cd92e4b17fc76f">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<a id="a68ed6a07dbc0d1f25bde41ad2e4fa578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ed6a07dbc0d1f25bde41ad2e4fa578">&#9670;&nbsp;</a></span>u() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.mechanics.kane.KanesMethod.u </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classsympy_1_1physics_1_1mechanics_1_1method_1_1__Methods.html#a7cbdc078331d1a16b1cd92e4b17fc76f">sympy.physics.mechanics.method._Methods</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8032c0c2116355024c4d0c6de0dd03c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8032c0c2116355024c4d0c6de0dd03c3">&#9670;&nbsp;</a></span>explicit_kinematics</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.physics.mechanics.kane.KanesMethod.explicit_kinematics</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/sympy/physics/mechanics/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2sympy_2physics_2mechanics_2kane_8py.html">kane.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
