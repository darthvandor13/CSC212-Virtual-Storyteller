<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.ntheory.modular Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1ntheory.html">ntheory</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1ntheory_1_1modular.html">modular</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.ntheory.modular Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4d3f381a85280668421546e784d69d04"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1modular.html#a4d3f381a85280668421546e784d69d04">symmetric_residue</a> (a, m)</td></tr>
<tr class="separator:a4d3f381a85280668421546e784d69d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6988c79b301ee65f945a2612ed132b44"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1modular.html#a6988c79b301ee65f945a2612ed132b44">crt</a> (m, v, symmetric=False, check=True)</td></tr>
<tr class="separator:a6988c79b301ee65f945a2612ed132b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f092d553096e5b5c179e0e12e8711a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1modular.html#a8f092d553096e5b5c179e0e12e8711a2">crt1</a> (m)</td></tr>
<tr class="separator:a8f092d553096e5b5c179e0e12e8711a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c19e9fbb67100d05c30f05f8296922"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1modular.html#a75c19e9fbb67100d05c30f05f8296922">crt2</a> (m, v, mm, e, s, symmetric=False)</td></tr>
<tr class="separator:a75c19e9fbb67100d05c30f05f8296922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d71b26cc255a1bef3ad95f9a32961b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1modular.html#a58d71b26cc255a1bef3ad95f9a32961b">solve_congruence</a> (*remainder_modulus_pairs, **hint)</td></tr>
<tr class="separator:a58d71b26cc255a1bef3ad95f9a32961b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6988c79b301ee65f945a2612ed132b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6988c79b301ee65f945a2612ed132b44">&#9670;&nbsp;</a></span>crt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.modular.crt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Chinese Remainder Theorem.

The moduli in m are assumed to be pairwise coprime.  The output
is then an integer f, such that f = v_i mod m_i for each pair out
of v and m. If ``symmetric`` is False a positive integer will be
returned, else \|f\| will be less than or equal to the LCM of the
moduli, and thus f may be negative.

If the moduli are not co-prime the correct result will be returned
if/when the test of the result is found to be incorrect. This result
will be None if there is no solution.

The keyword ``check`` can be set to False if it is known that the moduli
are coprime.

Examples
========

As an example consider a set of residues ``U = [49, 76, 65]``
and a set of moduli ``M = [99, 97, 95]``. Then we have::

   &gt;&gt;&gt; from sympy.ntheory.modular import crt

   &gt;&gt;&gt; crt([99, 97, 95], [49, 76, 65])
   (639985, 912285)

This is the correct result because::

   &gt;&gt;&gt; [639985 % m for m in [99, 97, 95]]
   [49, 76, 65]

If the moduli are not co-prime, you may receive an incorrect result
if you use ``check=False``:

   &gt;&gt;&gt; crt([12, 6, 17], [3, 4, 2], check=False)
   (954, 1224)
   &gt;&gt;&gt; [954 % m for m in [12, 6, 17]]
   [6, 0, 2]
   &gt;&gt;&gt; crt([12, 6, 17], [3, 4, 2]) is None
   True
   &gt;&gt;&gt; crt([3, 6], [2, 5])
   (5, 6)

Note: the order of gf_crt's arguments is reversed relative to crt,
and that solve_congruence takes residue, modulus pairs.

Programmer's note: rather than checking that all pairs of moduli share
no GCD (an O(n**2) test) and rather than factoring all moduli and seeing
that there is no factor in common, a check that the result gives the
indicated residuals is performed -- an O(n) operation.

See Also
========

solve_congruence
sympy.polys.galoistools.gf_crt : low level crt routine used by this routine
</pre> 
</div>
</div>
<a id="a8f092d553096e5b5c179e0e12e8711a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f092d553096e5b5c179e0e12e8711a2">&#9670;&nbsp;</a></span>crt1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.modular.crt1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">First part of Chinese Remainder Theorem, for multiple application.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.modular import crt, crt1, crt2
&gt;&gt;&gt; m = [99, 97, 95]
&gt;&gt;&gt; v = [49, 76, 65]

The following two codes have the same result.

&gt;&gt;&gt; crt(m, v)
(639985, 912285)

&gt;&gt;&gt; mm, e, s = crt1(m)
&gt;&gt;&gt; crt2(m, v, mm, e, s)
(639985, 912285)

However, it is faster when we want to fix ``m`` and
compute for multiple ``v``, i.e. the following cases:

&gt;&gt;&gt; mm, e, s = crt1(m)
&gt;&gt;&gt; vs = [[52, 21, 37], [19, 46, 76]]
&gt;&gt;&gt; for v in vs:
...     print(crt2(m, v, mm, e, s))
(397042, 912285)
(803206, 912285)

See Also
========

sympy.polys.galoistools.gf_crt1 : low level crt routine used by this routine
sympy.ntheory.modular.crt
sympy.ntheory.modular.crt2</pre> 
</div>
</div>
<a id="a75c19e9fbb67100d05c30f05f8296922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c19e9fbb67100d05c30f05f8296922">&#9670;&nbsp;</a></span>crt2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.modular.crt2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Second part of Chinese Remainder Theorem, for multiple application.

See ``crt1`` for usage.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.modular import crt1, crt2
&gt;&gt;&gt; mm, e, s = crt1([18, 42, 6])
&gt;&gt;&gt; crt2([18, 42, 6], [0, 0, 0], mm, e, s)
(0, 4536)

See Also
========

sympy.polys.galoistools.gf_crt2 : low level crt routine used by this routine
sympy.ntheory.modular.crt
sympy.ntheory.modular.crt1</pre> 
</div>
</div>
<a id="a58d71b26cc255a1bef3ad95f9a32961b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d71b26cc255a1bef3ad95f9a32961b">&#9670;&nbsp;</a></span>solve_congruence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.modular.solve_congruence </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>remainder_modulus_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the integer ``n`` that has the residual ``ai`` when it is
divided by ``mi`` where the ``ai`` and ``mi`` are given as pairs to
this function: ((a1, m1), (a2, m2), ...). If there is no solution,
return None. Otherwise return ``n`` and its modulus.

The ``mi`` values need not be co-prime. If it is known that the moduli are
not co-prime then the hint ``check`` can be set to False (default=True) and
the check for a quicker solution via crt() (valid when the moduli are
co-prime) will be skipped.

If the hint ``symmetric`` is True (default is False), the value of ``n``
will be within 1/2 of the modulus, possibly negative.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.modular import solve_congruence

What number is 2 mod 3, 3 mod 5 and 2 mod 7?

&gt;&gt;&gt; solve_congruence((2, 3), (3, 5), (2, 7))
(23, 105)
&gt;&gt;&gt; [23 % m for m in [3, 5, 7]]
[2, 3, 2]

If you prefer to work with all remainder in one list and
all moduli in another, send the arguments like this:

&gt;&gt;&gt; solve_congruence(*zip((2, 3, 2), (3, 5, 7)))
(23, 105)

The moduli need not be co-prime; in this case there may or
may not be a solution:

&gt;&gt;&gt; solve_congruence((2, 3), (4, 6)) is None
True

&gt;&gt;&gt; solve_congruence((2, 3), (5, 6))
(5, 6)

The symmetric flag will make the result be within 1/2 of the modulus:

&gt;&gt;&gt; solve_congruence((2, 3), (5, 6), symmetric=True)
(-1, 6)

See Also
========

crt : high level routine implementing the Chinese Remainder Theorem</pre> 
</div>
</div>
<a id="a4d3f381a85280668421546e784d69d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3f381a85280668421546e784d69d04">&#9670;&nbsp;</a></span>symmetric_residue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.modular.symmetric_residue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the residual mod m such that it is within half of the modulus.

&gt;&gt;&gt; from sympy.ntheory.modular import symmetric_residue
&gt;&gt;&gt; symmetric_residue(1, 6)
1
&gt;&gt;&gt; symmetric_residue(4, 6)
-2
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
