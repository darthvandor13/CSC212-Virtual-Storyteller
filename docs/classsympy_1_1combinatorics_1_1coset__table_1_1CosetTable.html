<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.combinatorics.coset_table.CosetTable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1combinatorics.html">combinatorics</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1combinatorics_1_1coset__table.html">coset_table</a></li><li class="navelem"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html">CosetTable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sympy.combinatorics.coset_table.CosetTable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>COSET TABLE #.  
 <a href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for sympy.combinatorics.coset_table.CosetTable:</div>
<div class="dyncontent">
<div class="center"><img src="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable__inherit__graph.png" border="0" usemap="#asympy_8combinatorics_8coset__table_8CosetTable_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sympy.combinatorics.coset_table.CosetTable:</div>
<div class="dyncontent">
<div class="center"><img src="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable__coll__graph.png" border="0" usemap="#asympy_8combinatorics_8coset__table_8CosetTable_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ba4a4a979f779842f47ac9249dcff26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a9ba4a4a979f779842f47ac9249dcff26">__init__</a> (self, fp_grp, <a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a26af794aa198379682864bfbe71ead59">subgroup</a>, max_cosets=None)</td></tr>
<tr class="separator:a9ba4a4a979f779842f47ac9249dcff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdf8bb2dbbb230e35bef5931ed9b460"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a1bdf8bb2dbbb230e35bef5931ed9b460">omega</a> (self)</td></tr>
<tr class="separator:a1bdf8bb2dbbb230e35bef5931ed9b460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bd110078b162e27de91c199158a518"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a14bd110078b162e27de91c199158a518">copy</a> (self)</td></tr>
<tr class="separator:a14bd110078b162e27de91c199158a518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90752b480e04eddd5addce3892faf8db"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a90752b480e04eddd5addce3892faf8db">__str__</a> (self)</td></tr>
<tr class="separator:a90752b480e04eddd5addce3892faf8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1476de0fd577d85896d6674b3cec6bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aa1476de0fd577d85896d6674b3cec6bf">n</a> (self)</td></tr>
<tr class="separator:aa1476de0fd577d85896d6674b3cec6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d931cb9eaedb1b845a69aba105339af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a7d931cb9eaedb1b845a69aba105339af">is_complete</a> (self)</td></tr>
<tr class="separator:a7d931cb9eaedb1b845a69aba105339af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e82fb1c964dd0fbe2cc43be38dec91c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a3e82fb1c964dd0fbe2cc43be38dec91c">define</a> (self, alpha, x, modified=False)</td></tr>
<tr class="separator:a3e82fb1c964dd0fbe2cc43be38dec91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5624354c18add7f69c4d04d2d0a34168"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a5624354c18add7f69c4d04d2d0a34168">define_c</a> (self, alpha, x)</td></tr>
<tr class="separator:a5624354c18add7f69c4d04d2d0a34168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121592abc6954803fd6ca95f4795d880"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a121592abc6954803fd6ca95f4795d880">scan_c</a> (self, alpha, word)</td></tr>
<tr class="separator:a121592abc6954803fd6ca95f4795d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947cc0ddbd550c2446112b96a2825ed3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a947cc0ddbd550c2446112b96a2825ed3">coincidence_c</a> (self, alpha, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>)</td></tr>
<tr class="separator:a947cc0ddbd550c2446112b96a2825ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c737e8e4849e9a6bed42ed22596977"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a11c737e8e4849e9a6bed42ed22596977">scan</a> (self, alpha, word, y=None, fill=False, modified=False)</td></tr>
<tr class="separator:a11c737e8e4849e9a6bed42ed22596977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d2d2e2287ffcc85da74753015a76d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a98d2d2e2287ffcc85da74753015a76d1">scan_check</a> (self, alpha, word)</td></tr>
<tr class="separator:a98d2d2e2287ffcc85da74753015a76d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642c5ff6af78246072d78cf8d43da7a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a642c5ff6af78246072d78cf8d43da7a0">merge</a> (self, k, lamda, q, w=None, modified=False)</td></tr>
<tr class="separator:a642c5ff6af78246072d78cf8d43da7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21d0e7832432de3a993c943abff1e8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#af21d0e7832432de3a993c943abff1e8f">rep</a> (self, k, modified=False)</td></tr>
<tr class="separator:af21d0e7832432de3a993c943abff1e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b0dc386611ce650ce933b356dc5a78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a48b0dc386611ce650ce933b356dc5a78">coincidence</a> (self, alpha, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>, w=None, modified=False)</td></tr>
<tr class="separator:a48b0dc386611ce650ce933b356dc5a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ffdc664bba3443d1949ebb1251a515"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a52ffdc664bba3443d1949ebb1251a515">scan_and_fill</a> (self, alpha, word)</td></tr>
<tr class="separator:a52ffdc664bba3443d1949ebb1251a515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace03f28be75693ac7d5632b8fd2556a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aace03f28be75693ac7d5632b8fd2556a">scan_and_fill_c</a> (self, alpha, word)</td></tr>
<tr class="separator:aace03f28be75693ac7d5632b8fd2556a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7139e30e0dcadb95b26382f0842dbc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a3f7139e30e0dcadb95b26382f0842dbc">look_ahead</a> (self)</td></tr>
<tr class="separator:a3f7139e30e0dcadb95b26382f0842dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882ead4493b196a25b907fdbd2988b76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a882ead4493b196a25b907fdbd2988b76">process_deductions</a> (self, R_c_x, R_c_x_inv)</td></tr>
<tr class="separator:a882ead4493b196a25b907fdbd2988b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c3c45bf4a43313ba43599a950baadf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a45c3c45bf4a43313ba43599a950baadf">process_deductions_check</a> (self, R_c_x, R_c_x_inv)</td></tr>
<tr class="separator:a45c3c45bf4a43313ba43599a950baadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad745e954435c08c59d92bf0d5ab2d518"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#ad745e954435c08c59d92bf0d5ab2d518">switch</a> (self, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>, <a class="el" href="classsympy_1_1functions_1_1special_1_1gamma__functions_1_1gamma.html">gamma</a>)</td></tr>
<tr class="separator:ad745e954435c08c59d92bf0d5ab2d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922450b95e7d965c7aec386a23639e02"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a922450b95e7d965c7aec386a23639e02">standardize</a> (self)</td></tr>
<tr class="separator:a922450b95e7d965c7aec386a23639e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a1ea5cd6c37e79b0d2762de106de65"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aa8a1ea5cd6c37e79b0d2762de106de65">compress</a> (self)</td></tr>
<tr class="separator:aa8a1ea5cd6c37e79b0d2762de106de65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd864f382a14b321b12aaf6ce44e0a63"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#abd864f382a14b321b12aaf6ce44e0a63">conjugates</a> (self, R)</td></tr>
<tr class="separator:abd864f382a14b321b12aaf6ce44e0a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8fa9c01b9a8b2f00e2cf17539b74e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a6c8fa9c01b9a8b2f00e2cf17539b74e2">coset_representative</a> (self, coset)</td></tr>
<tr class="separator:a6c8fa9c01b9a8b2f00e2cf17539b74e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0d0f8f13fc54aab0e91bab70017ab4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a3a0d0f8f13fc54aab0e91bab70017ab4">modified_define</a> (self, alpha, x)</td></tr>
<tr class="memdesc:a3a0d0f8f13fc54aab0e91bab70017ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Methods #.  <a href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a3a0d0f8f13fc54aab0e91bab70017ab4">More...</a><br /></td></tr>
<tr class="separator:a3a0d0f8f13fc54aab0e91bab70017ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee41f81556f836236f7a79a45a31e253"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aee41f81556f836236f7a79a45a31e253">modified_scan</a> (self, alpha, w, y, fill=False)</td></tr>
<tr class="separator:aee41f81556f836236f7a79a45a31e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09317c7efd2c42625e167926bd73f68e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a09317c7efd2c42625e167926bd73f68e">modified_scan_and_fill</a> (self, alpha, w, y)</td></tr>
<tr class="separator:a09317c7efd2c42625e167926bd73f68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d8a3f6072a246a13a157d5dc042850"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aa5d8a3f6072a246a13a157d5dc042850">modified_merge</a> (self, k, lamda, w, q)</td></tr>
<tr class="separator:aa5d8a3f6072a246a13a157d5dc042850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342089e7cb1b94fd3d20e51ea4fa60cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a342089e7cb1b94fd3d20e51ea4fa60cd">modified_rep</a> (self, k)</td></tr>
<tr class="separator:a342089e7cb1b94fd3d20e51ea4fa60cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462f3a532807b2f7364d8a7997dc37f0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a462f3a532807b2f7364d8a7997dc37f0">modified_coincidence</a> (self, alpha, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>, w)</td></tr>
<tr class="separator:a462f3a532807b2f7364d8a7997dc37f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba4a4a979f779842f47ac9249dcff26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a9ba4a4a979f779842f47ac9249dcff26">__init__</a> (self, fp_grp, <a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a26af794aa198379682864bfbe71ead59">subgroup</a>, max_cosets=None)</td></tr>
<tr class="separator:a9ba4a4a979f779842f47ac9249dcff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdf8bb2dbbb230e35bef5931ed9b460"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a1bdf8bb2dbbb230e35bef5931ed9b460">omega</a> (self)</td></tr>
<tr class="separator:a1bdf8bb2dbbb230e35bef5931ed9b460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bd110078b162e27de91c199158a518"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a14bd110078b162e27de91c199158a518">copy</a> (self)</td></tr>
<tr class="separator:a14bd110078b162e27de91c199158a518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90752b480e04eddd5addce3892faf8db"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a90752b480e04eddd5addce3892faf8db">__str__</a> (self)</td></tr>
<tr class="separator:a90752b480e04eddd5addce3892faf8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1476de0fd577d85896d6674b3cec6bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aa1476de0fd577d85896d6674b3cec6bf">n</a> (self)</td></tr>
<tr class="separator:aa1476de0fd577d85896d6674b3cec6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d931cb9eaedb1b845a69aba105339af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a7d931cb9eaedb1b845a69aba105339af">is_complete</a> (self)</td></tr>
<tr class="separator:a7d931cb9eaedb1b845a69aba105339af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e82fb1c964dd0fbe2cc43be38dec91c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a3e82fb1c964dd0fbe2cc43be38dec91c">define</a> (self, alpha, x, modified=False)</td></tr>
<tr class="separator:a3e82fb1c964dd0fbe2cc43be38dec91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5624354c18add7f69c4d04d2d0a34168"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a5624354c18add7f69c4d04d2d0a34168">define_c</a> (self, alpha, x)</td></tr>
<tr class="separator:a5624354c18add7f69c4d04d2d0a34168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121592abc6954803fd6ca95f4795d880"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a121592abc6954803fd6ca95f4795d880">scan_c</a> (self, alpha, word)</td></tr>
<tr class="separator:a121592abc6954803fd6ca95f4795d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947cc0ddbd550c2446112b96a2825ed3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a947cc0ddbd550c2446112b96a2825ed3">coincidence_c</a> (self, alpha, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>)</td></tr>
<tr class="separator:a947cc0ddbd550c2446112b96a2825ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c737e8e4849e9a6bed42ed22596977"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a11c737e8e4849e9a6bed42ed22596977">scan</a> (self, alpha, word, y=None, fill=False, modified=False)</td></tr>
<tr class="separator:a11c737e8e4849e9a6bed42ed22596977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d2d2e2287ffcc85da74753015a76d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a98d2d2e2287ffcc85da74753015a76d1">scan_check</a> (self, alpha, word)</td></tr>
<tr class="separator:a98d2d2e2287ffcc85da74753015a76d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642c5ff6af78246072d78cf8d43da7a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a642c5ff6af78246072d78cf8d43da7a0">merge</a> (self, k, lamda, q, w=None, modified=False)</td></tr>
<tr class="separator:a642c5ff6af78246072d78cf8d43da7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21d0e7832432de3a993c943abff1e8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#af21d0e7832432de3a993c943abff1e8f">rep</a> (self, k, modified=False)</td></tr>
<tr class="separator:af21d0e7832432de3a993c943abff1e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b0dc386611ce650ce933b356dc5a78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a48b0dc386611ce650ce933b356dc5a78">coincidence</a> (self, alpha, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>, w=None, modified=False)</td></tr>
<tr class="separator:a48b0dc386611ce650ce933b356dc5a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ffdc664bba3443d1949ebb1251a515"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a52ffdc664bba3443d1949ebb1251a515">scan_and_fill</a> (self, alpha, word)</td></tr>
<tr class="separator:a52ffdc664bba3443d1949ebb1251a515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace03f28be75693ac7d5632b8fd2556a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aace03f28be75693ac7d5632b8fd2556a">scan_and_fill_c</a> (self, alpha, word)</td></tr>
<tr class="separator:aace03f28be75693ac7d5632b8fd2556a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7139e30e0dcadb95b26382f0842dbc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a3f7139e30e0dcadb95b26382f0842dbc">look_ahead</a> (self)</td></tr>
<tr class="separator:a3f7139e30e0dcadb95b26382f0842dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882ead4493b196a25b907fdbd2988b76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a882ead4493b196a25b907fdbd2988b76">process_deductions</a> (self, R_c_x, R_c_x_inv)</td></tr>
<tr class="separator:a882ead4493b196a25b907fdbd2988b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c3c45bf4a43313ba43599a950baadf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a45c3c45bf4a43313ba43599a950baadf">process_deductions_check</a> (self, R_c_x, R_c_x_inv)</td></tr>
<tr class="separator:a45c3c45bf4a43313ba43599a950baadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad745e954435c08c59d92bf0d5ab2d518"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#ad745e954435c08c59d92bf0d5ab2d518">switch</a> (self, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>, <a class="el" href="classsympy_1_1functions_1_1special_1_1gamma__functions_1_1gamma.html">gamma</a>)</td></tr>
<tr class="separator:ad745e954435c08c59d92bf0d5ab2d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922450b95e7d965c7aec386a23639e02"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a922450b95e7d965c7aec386a23639e02">standardize</a> (self)</td></tr>
<tr class="separator:a922450b95e7d965c7aec386a23639e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a1ea5cd6c37e79b0d2762de106de65"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aa8a1ea5cd6c37e79b0d2762de106de65">compress</a> (self)</td></tr>
<tr class="separator:aa8a1ea5cd6c37e79b0d2762de106de65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd864f382a14b321b12aaf6ce44e0a63"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#abd864f382a14b321b12aaf6ce44e0a63">conjugates</a> (self, R)</td></tr>
<tr class="separator:abd864f382a14b321b12aaf6ce44e0a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8fa9c01b9a8b2f00e2cf17539b74e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a6c8fa9c01b9a8b2f00e2cf17539b74e2">coset_representative</a> (self, coset)</td></tr>
<tr class="separator:a6c8fa9c01b9a8b2f00e2cf17539b74e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0d0f8f13fc54aab0e91bab70017ab4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a3a0d0f8f13fc54aab0e91bab70017ab4">modified_define</a> (self, alpha, x)</td></tr>
<tr class="memdesc:a3a0d0f8f13fc54aab0e91bab70017ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Methods #.  <a href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a3a0d0f8f13fc54aab0e91bab70017ab4">More...</a><br /></td></tr>
<tr class="separator:a3a0d0f8f13fc54aab0e91bab70017ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee41f81556f836236f7a79a45a31e253"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aee41f81556f836236f7a79a45a31e253">modified_scan</a> (self, alpha, w, y, fill=False)</td></tr>
<tr class="separator:aee41f81556f836236f7a79a45a31e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09317c7efd2c42625e167926bd73f68e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a09317c7efd2c42625e167926bd73f68e">modified_scan_and_fill</a> (self, alpha, w, y)</td></tr>
<tr class="separator:a09317c7efd2c42625e167926bd73f68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d8a3f6072a246a13a157d5dc042850"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aa5d8a3f6072a246a13a157d5dc042850">modified_merge</a> (self, k, lamda, w, q)</td></tr>
<tr class="separator:aa5d8a3f6072a246a13a157d5dc042850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342089e7cb1b94fd3d20e51ea4fa60cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a342089e7cb1b94fd3d20e51ea4fa60cd">modified_rep</a> (self, k)</td></tr>
<tr class="separator:a342089e7cb1b94fd3d20e51ea4fa60cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462f3a532807b2f7364d8a7997dc37f0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a462f3a532807b2f7364d8a7997dc37f0">modified_coincidence</a> (self, alpha, <a class="el" href="classsympy_1_1functions_1_1special_1_1beta__functions_1_1beta.html">beta</a>, w)</td></tr>
<tr class="separator:a462f3a532807b2f7364d8a7997dc37f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab655ee6499e52724941e893c22bc1ea7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#ab655ee6499e52724941e893c22bc1ea7">fp_group</a></td></tr>
<tr class="separator:ab655ee6499e52724941e893c22bc1ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26af794aa198379682864bfbe71ead59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a26af794aa198379682864bfbe71ead59">subgroup</a></td></tr>
<tr class="separator:a26af794aa198379682864bfbe71ead59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eec1a5e649e9f7b1ed30bd998004d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a02eec1a5e649e9f7b1ed30bd998004d1">p</a></td></tr>
<tr class="separator:a02eec1a5e649e9f7b1ed30bd998004d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8721f42a5040e0114a52851ed08a557"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aa8721f42a5040e0114a52851ed08a557">A</a></td></tr>
<tr class="separator:aa8721f42a5040e0114a52851ed08a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843265dcdd6e2bab1571aff89a1c087d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a843265dcdd6e2bab1571aff89a1c087d">P</a></td></tr>
<tr class="separator:a843265dcdd6e2bab1571aff89a1c087d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adbe72bdc9b2bc0ba066b10561d25e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a1adbe72bdc9b2bc0ba066b10561d25e3">table</a></td></tr>
<tr class="separator:a1adbe72bdc9b2bc0ba066b10561d25e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f814ed696c618fd99794bd0e03bf772"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a8f814ed696c618fd99794bd0e03bf772">A_dict</a></td></tr>
<tr class="separator:a8f814ed696c618fd99794bd0e03bf772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace21feca4e8511f17385a08d46403486"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#ace21feca4e8511f17385a08d46403486">A_dict_inv</a></td></tr>
<tr class="separator:ace21feca4e8511f17385a08d46403486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8be5c1e2bcfa5067b27244c2ea54c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#ade8be5c1e2bcfa5067b27244c2ea54c7">deduction_stack</a></td></tr>
<tr class="separator:ade8be5c1e2bcfa5067b27244c2ea54c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80acda1bfa3478b772cbc80e4282d531"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a80acda1bfa3478b772cbc80e4282d531">p_p</a></td></tr>
<tr class="separator:a80acda1bfa3478b772cbc80e4282d531"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5def5c396116be4b7d880ca53d0bed1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#a5def5c396116be4b7d880ca53d0bed1d">coset_table_max_limit</a> = 4096000</td></tr>
<tr class="separator:a5def5c396116be4b7d880ca53d0bed1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a5c4d605e5b0855970d92cc67597fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#af3a5c4d605e5b0855970d92cc67597fa">coset_table_limit</a> = None</td></tr>
<tr class="separator:af3a5c4d605e5b0855970d92cc67597fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a546ee24a1a99f1e7a941dbcbf222f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1combinatorics_1_1coset__table_1_1CosetTable.html#aa9a546ee24a1a99f1e7a941dbcbf222f">max_stack_size</a> = 100</td></tr>
<tr class="separator:aa9a546ee24a1a99f1e7a941dbcbf222f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>COSET TABLE #. </p>
<pre class="fragment">Properties
==========

[1] `0 \in \Omega` and `\tau(1) = \epsilon`
[2] `\alpha^x = \beta \Leftrightarrow \beta^{x^{-1}} = \alpha`
[3] If `\alpha^x = \beta`, then `H \tau(\alpha)x = H \tau(\beta)`
[4] `\forall \alpha \in \Omega, 1^{\tau(\alpha)} = \alpha`

References
==========

.. [1] Holt, D., Eick, B., O'Brien, E.
       "Handbook of Computational Group Theory"

.. [2] John J. Cannon; Lucien A. Dimino; George Havas; Jane M. Watson
       Mathematics of Computation, Vol. 27, No. 123. (Jul., 1973), pp. 463-490.
       "Implementation and Analysis of the Todd-Coxeter Algorithm"</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9ba4a4a979f779842f47ac9249dcff26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba4a4a979f779842f47ac9249dcff26">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp_grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_cosets</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ba4a4a979f779842f47ac9249dcff26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba4a4a979f779842f47ac9249dcff26">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp_grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_cosets</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a90752b480e04eddd5addce3892faf8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90752b480e04eddd5addce3892faf8db">&#9670;&nbsp;</a></span>__str__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.__str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90752b480e04eddd5addce3892faf8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90752b480e04eddd5addce3892faf8db">&#9670;&nbsp;</a></span>__str__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.__str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b0dc386611ce650ce933b356dc5a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b0dc386611ce650ce933b356dc5a78">&#9670;&nbsp;</a></span>coincidence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.coincidence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The third situation described in ``scan`` routine is handled by this
routine, described on Pg. 156-161 [1].

The unfortunate situation when the scan completes but not correctly,
then ``coincidence`` routine is run. i.e when for some `i` with
`1 \le i \le r+1`, we have `w=st` with `s = x_1 x_2 \dots x_{i-1}`,
`t = x_i x_{i+1} \dots x_r`, and `\beta = \alpha^s` and
`\gamma = \alpha^{t-1}` are defined but unequal. This means that
`\beta` and `\gamma` represent the same coset of `H` in `G`. Described
on Pg. 156 [1]. ``rep``

See Also
========

scan</pre> 
</div>
</div>
<a id="a48b0dc386611ce650ce933b356dc5a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b0dc386611ce650ce933b356dc5a78">&#9670;&nbsp;</a></span>coincidence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.coincidence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The third situation described in ``scan`` routine is handled by this
routine, described on Pg. 156-161 [1].

The unfortunate situation when the scan completes but not correctly,
then ``coincidence`` routine is run. i.e when for some `i` with
`1 \le i \le r+1`, we have `w=st` with `s = x_1 x_2 \dots x_{i-1}`,
`t = x_i x_{i+1} \dots x_r`, and `\beta = \alpha^s` and
`\gamma = \alpha^{t-1}` are defined but unequal. This means that
`\beta` and `\gamma` represent the same coset of `H` in `G`. Described
on Pg. 156 [1]. ``rep``

See Also
========

scan</pre> 
</div>
</div>
<a id="a947cc0ddbd550c2446112b96a2825ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947cc0ddbd550c2446112b96a2825ed3">&#9670;&nbsp;</a></span>coincidence_c() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.coincidence_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variation of ``coincidence`` routine used in the coset-table based
method of coset enumeration. The only difference being on addition of
a new coset in coset table(i.e new coset introduction), then it is
appended to ``deduction_stack``.

See Also
========

coincidence</pre> 
</div>
</div>
<a id="a947cc0ddbd550c2446112b96a2825ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947cc0ddbd550c2446112b96a2825ed3">&#9670;&nbsp;</a></span>coincidence_c() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.coincidence_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variation of ``coincidence`` routine used in the coset-table based
method of coset enumeration. The only difference being on addition of
a new coset in coset table(i.e new coset introduction), then it is
appended to ``deduction_stack``.

See Also
========

coincidence</pre> 
</div>
</div>
<a id="aa8a1ea5cd6c37e79b0d2762de106de65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a1ea5cd6c37e79b0d2762de106de65">&#9670;&nbsp;</a></span>compress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.compress </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Removes the non-live cosets from the coset table, described on
pg. 167 [1].</pre> 
</div>
</div>
<a id="aa8a1ea5cd6c37e79b0d2762de106de65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a1ea5cd6c37e79b0d2762de106de65">&#9670;&nbsp;</a></span>compress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.compress </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Removes the non-live cosets from the coset table, described on
pg. 167 [1].</pre> 
</div>
</div>
<a id="abd864f382a14b321b12aaf6ce44e0a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd864f382a14b321b12aaf6ce44e0a63">&#9670;&nbsp;</a></span>conjugates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.conjugates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd864f382a14b321b12aaf6ce44e0a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd864f382a14b321b12aaf6ce44e0a63">&#9670;&nbsp;</a></span>conjugates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.conjugates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14bd110078b162e27de91c199158a518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bd110078b162e27de91c199158a518">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a shallow copy of Coset Table instance ``self``.</pre> 
</div>
</div>
<a id="a14bd110078b162e27de91c199158a518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bd110078b162e27de91c199158a518">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a shallow copy of Coset Table instance ``self``.</pre> 
</div>
</div>
<a id="a6c8fa9c01b9a8b2f00e2cf17539b74e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8fa9c01b9a8b2f00e2cf17539b74e2">&#9670;&nbsp;</a></span>coset_representative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.coset_representative </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the coset representative of a given coset.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import free_group
&gt;&gt;&gt; from sympy.combinatorics.fp_groups import FpGroup, coset_enumeration_r
&gt;&gt;&gt; F, x, y = free_group("x, y")
&gt;&gt;&gt; f = FpGroup(F, [x**3, y**3, x**-1*y**-1*x*y])
&gt;&gt;&gt; C = coset_enumeration_r(f, [x])
&gt;&gt;&gt; C.compress()
&gt;&gt;&gt; C.table
[[0, 0, 1, 2], [1, 1, 2, 0], [2, 2, 0, 1]]
&gt;&gt;&gt; C.coset_representative(0)
&lt;identity&gt;
&gt;&gt;&gt; C.coset_representative(1)
y
&gt;&gt;&gt; C.coset_representative(2)
y**-1</pre> 
</div>
</div>
<a id="a6c8fa9c01b9a8b2f00e2cf17539b74e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8fa9c01b9a8b2f00e2cf17539b74e2">&#9670;&nbsp;</a></span>coset_representative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.coset_representative </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the coset representative of a given coset.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import free_group
&gt;&gt;&gt; from sympy.combinatorics.fp_groups import FpGroup, coset_enumeration_r
&gt;&gt;&gt; F, x, y = free_group("x, y")
&gt;&gt;&gt; f = FpGroup(F, [x**3, y**3, x**-1*y**-1*x*y])
&gt;&gt;&gt; C = coset_enumeration_r(f, [x])
&gt;&gt;&gt; C.compress()
&gt;&gt;&gt; C.table
[[0, 0, 1, 2], [1, 1, 2, 0], [2, 2, 0, 1]]
&gt;&gt;&gt; C.coset_representative(0)
&lt;identity&gt;
&gt;&gt;&gt; C.coset_representative(1)
y
&gt;&gt;&gt; C.coset_representative(2)
y**-1</pre> 
</div>
</div>
<a id="a3e82fb1c964dd0fbe2cc43be38dec91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e82fb1c964dd0fbe2cc43be38dec91c">&#9670;&nbsp;</a></span>define() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.define </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine is used in the relator-based strategy of Todd-Coxeter
algorithm if some `\alpha^x` is undefined. We check whether there is
space available for defining a new coset. If there is enough space
then we remedy this by adjoining a new coset `\beta` to `\Omega`
(i.e to set of live cosets) and put that equal to `\alpha^x`, then
make an assignment satisfying Property[1]. If there is not enough space
then we halt the Coset Table creation. The maximum amount of space that
can be used by Coset Table can be manipulated using the class variable
``CosetTable.coset_table_max_limit``.

See Also
========

define_c</pre> 
</div>
</div>
<a id="a3e82fb1c964dd0fbe2cc43be38dec91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e82fb1c964dd0fbe2cc43be38dec91c">&#9670;&nbsp;</a></span>define() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.define </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine is used in the relator-based strategy of Todd-Coxeter
algorithm if some `\alpha^x` is undefined. We check whether there is
space available for defining a new coset. If there is enough space
then we remedy this by adjoining a new coset `\beta` to `\Omega`
(i.e to set of live cosets) and put that equal to `\alpha^x`, then
make an assignment satisfying Property[1]. If there is not enough space
then we halt the Coset Table creation. The maximum amount of space that
can be used by Coset Table can be manipulated using the class variable
``CosetTable.coset_table_max_limit``.

See Also
========

define_c</pre> 
</div>
</div>
<a id="a5624354c18add7f69c4d04d2d0a34168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5624354c18add7f69c4d04d2d0a34168">&#9670;&nbsp;</a></span>define_c() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.define_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variation of ``define`` routine, described on Pg. 165 [1], used in
the coset table-based strategy of Todd-Coxeter algorithm. It differs
from ``define`` routine in that for each definition it also adds the
tuple `(\alpha, x)` to the deduction stack.

See Also
========

define</pre> 
</div>
</div>
<a id="a5624354c18add7f69c4d04d2d0a34168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5624354c18add7f69c4d04d2d0a34168">&#9670;&nbsp;</a></span>define_c() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.define_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variation of ``define`` routine, described on Pg. 165 [1], used in
the coset table-based strategy of Todd-Coxeter algorithm. It differs
from ``define`` routine in that for each definition it also adds the
tuple `(\alpha, x)` to the deduction stack.

See Also
========

define</pre> 
</div>
</div>
<a id="a7d931cb9eaedb1b845a69aba105339af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d931cb9eaedb1b845a69aba105339af">&#9670;&nbsp;</a></span>is_complete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.is_complete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The coset table is called complete if it has no undefined entries
on the live cosets; that is, `\alpha^x` is defined for all
`\alpha \in \Omega` and `x \in A`.</pre> 
</div>
</div>
<a id="a7d931cb9eaedb1b845a69aba105339af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d931cb9eaedb1b845a69aba105339af">&#9670;&nbsp;</a></span>is_complete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.is_complete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The coset table is called complete if it has no undefined entries
on the live cosets; that is, `\alpha^x` is defined for all
`\alpha \in \Omega` and `x \in A`.</pre> 
</div>
</div>
<a id="a3f7139e30e0dcadb95b26382f0842dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7139e30e0dcadb95b26382f0842dbc">&#9670;&nbsp;</a></span>look_ahead() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.look_ahead </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">When combined with the HLT method this is known as HLT+Lookahead
method of coset enumeration, described on pg. 164 [1]. Whenever
``define`` aborts due to lack of space available this procedure is
executed. This routine helps in recovering space resulting from
"coincidence" of cosets.</pre> 
</div>
</div>
<a id="a3f7139e30e0dcadb95b26382f0842dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7139e30e0dcadb95b26382f0842dbc">&#9670;&nbsp;</a></span>look_ahead() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.look_ahead </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">When combined with the HLT method this is known as HLT+Lookahead
method of coset enumeration, described on pg. 164 [1]. Whenever
``define`` aborts due to lack of space available this procedure is
executed. This routine helps in recovering space resulting from
"coincidence" of cosets.</pre> 
</div>
</div>
<a id="a642c5ff6af78246072d78cf8d43da7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642c5ff6af78246072d78cf8d43da7a0">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.merge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Merge two classes with representatives ``k`` and ``lamda``, described
on Pg. 157 [1] (for pseudocode), start by putting ``p[k] = lamda``.
It is more efficient to choose the new representative from the larger
of the two classes being merged, i.e larger among ``k`` and ``lamda``.
procedure ``merge`` performs the merging operation, adds the deleted
class representative to the queue ``q``.

Parameters
==========

'k', 'lamda' being the two class representatives to be merged.

Notes
=====

Pg. 86-87 [1] contains a description of this method.

See Also
========

coincidence, rep</pre> 
</div>
</div>
<a id="a642c5ff6af78246072d78cf8d43da7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642c5ff6af78246072d78cf8d43da7a0">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.merge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Merge two classes with representatives ``k`` and ``lamda``, described
on Pg. 157 [1] (for pseudocode), start by putting ``p[k] = lamda``.
It is more efficient to choose the new representative from the larger
of the two classes being merged, i.e larger among ``k`` and ``lamda``.
procedure ``merge`` performs the merging operation, adds the deleted
class representative to the queue ``q``.

Parameters
==========

'k', 'lamda' being the two class representatives to be merged.

Notes
=====

Pg. 86-87 [1] contains a description of this method.

See Also
========

coincidence, rep</pre> 
</div>
</div>
<a id="a462f3a532807b2f7364d8a7997dc37f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462f3a532807b2f7364d8a7997dc37f0">&#9670;&nbsp;</a></span>modified_coincidence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_coincidence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

A coincident pair `\alpha, \beta \in \Omega, w \in Y \cup Y^{-1}`

See Also
========

coincidence</pre> 
</div>
</div>
<a id="a462f3a532807b2f7364d8a7997dc37f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462f3a532807b2f7364d8a7997dc37f0">&#9670;&nbsp;</a></span>modified_coincidence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_coincidence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

A coincident pair `\alpha, \beta \in \Omega, w \in Y \cup Y^{-1}`

See Also
========

coincidence</pre> 
</div>
</div>
<a id="a3a0d0f8f13fc54aab0e91bab70017ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0d0f8f13fc54aab0e91bab70017ab4">&#9670;&nbsp;</a></span>modified_define() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_define </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified Methods #. </p>
<pre class="fragment">Define a function p_p from from [1..n] to A* as
an additional component of the modified coset table.

Parameters
==========

\alpha \in \Omega
x \in A*

See Also
========

define</pre> 
</div>
</div>
<a id="a3a0d0f8f13fc54aab0e91bab70017ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0d0f8f13fc54aab0e91bab70017ab4">&#9670;&nbsp;</a></span>modified_define() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_define </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified Methods #. </p>
<pre class="fragment">Define a function p_p from from [1..n] to A* as
an additional component of the modified coset table.

Parameters
==========

\alpha \in \Omega
x \in A*

See Also
========

define</pre> 
</div>
</div>
<a id="aa5d8a3f6072a246a13a157d5dc042850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d8a3f6072a246a13a157d5dc042850">&#9670;&nbsp;</a></span>modified_merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_merge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

'k', 'lamda' -- the two class representatives to be merged.
q -- queue of length l of elements to be deleted from `\Omega` *.
w -- Word in (YUY^-1)

See Also
========

merge
</pre> 
</div>
</div>
<a id="aa5d8a3f6072a246a13a157d5dc042850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d8a3f6072a246a13a157d5dc042850">&#9670;&nbsp;</a></span>modified_merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_merge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

'k', 'lamda' -- the two class representatives to be merged.
q -- queue of length l of elements to be deleted from `\Omega` *.
w -- Word in (YUY^-1)

See Also
========

merge
</pre> 
</div>
</div>
<a id="a342089e7cb1b94fd3d20e51ea4fa60cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342089e7cb1b94fd3d20e51ea4fa60cd">&#9670;&nbsp;</a></span>modified_rep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_rep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

`k \in [0 \ldots n-1]`

See Also
========

rep
</pre> 
</div>
</div>
<a id="a342089e7cb1b94fd3d20e51ea4fa60cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342089e7cb1b94fd3d20e51ea4fa60cd">&#9670;&nbsp;</a></span>modified_rep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_rep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

`k \in [0 \ldots n-1]`

See Also
========

rep
</pre> 
</div>
</div>
<a id="aee41f81556f836236f7a79a45a31e253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee41f81556f836236f7a79a45a31e253">&#9670;&nbsp;</a></span>modified_scan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_scan </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========
\alpha \in \Omega
w \in A*
y \in (YUY^-1)
fill -- `modified_scan_and_fill` when set to True.

See Also
========

scan
</pre> 
</div>
</div>
<a id="aee41f81556f836236f7a79a45a31e253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee41f81556f836236f7a79a45a31e253">&#9670;&nbsp;</a></span>modified_scan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_scan </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========
\alpha \in \Omega
w \in A*
y \in (YUY^-1)
fill -- `modified_scan_and_fill` when set to True.

See Also
========

scan
</pre> 
</div>
</div>
<a id="a09317c7efd2c42625e167926bd73f68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09317c7efd2c42625e167926bd73f68e">&#9670;&nbsp;</a></span>modified_scan_and_fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_scan_and_fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09317c7efd2c42625e167926bd73f68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09317c7efd2c42625e167926bd73f68e">&#9670;&nbsp;</a></span>modified_scan_and_fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.modified_scan_and_fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1476de0fd577d85896d6674b3cec6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1476de0fd577d85896d6674b3cec6bf">&#9670;&nbsp;</a></span>n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.n </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The number `n` represents the length of the sublist containing the
live cosets.</pre> 
</div>
</div>
<a id="aa1476de0fd577d85896d6674b3cec6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1476de0fd577d85896d6674b3cec6bf">&#9670;&nbsp;</a></span>n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.n </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The number `n` represents the length of the sublist containing the
live cosets.</pre> 
</div>
</div>
<a id="a1bdf8bb2dbbb230e35bef5931ed9b460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdf8bb2dbbb230e35bef5931ed9b460">&#9670;&nbsp;</a></span>omega() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.omega </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set of live cosets. </pre> 
</div>
</div>
<a id="a1bdf8bb2dbbb230e35bef5931ed9b460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdf8bb2dbbb230e35bef5931ed9b460">&#9670;&nbsp;</a></span>omega() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.omega </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set of live cosets. </pre> 
</div>
</div>
<a id="a882ead4493b196a25b907fdbd2988b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882ead4493b196a25b907fdbd2988b76">&#9670;&nbsp;</a></span>process_deductions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.process_deductions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R_c_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R_c_x_inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Processes the deductions that have been pushed onto ``deduction_stack``,
described on Pg. 166 [1] and is used in coset-table based enumeration.

See Also
========

deduction_stack</pre> 
</div>
</div>
<a id="a882ead4493b196a25b907fdbd2988b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882ead4493b196a25b907fdbd2988b76">&#9670;&nbsp;</a></span>process_deductions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.process_deductions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R_c_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R_c_x_inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Processes the deductions that have been pushed onto ``deduction_stack``,
described on Pg. 166 [1] and is used in coset-table based enumeration.

See Also
========

deduction_stack</pre> 
</div>
</div>
<a id="a45c3c45bf4a43313ba43599a950baadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c3c45bf4a43313ba43599a950baadf">&#9670;&nbsp;</a></span>process_deductions_check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.process_deductions_check </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R_c_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R_c_x_inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variation of ``process_deductions``, this calls ``scan_check``
wherever ``process_deductions`` calls ``scan``, described on Pg. [1].

See Also
========

process_deductions</pre> 
</div>
</div>
<a id="a45c3c45bf4a43313ba43599a950baadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c3c45bf4a43313ba43599a950baadf">&#9670;&nbsp;</a></span>process_deductions_check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.process_deductions_check </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R_c_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R_c_x_inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variation of ``process_deductions``, this calls ``scan_check``
wherever ``process_deductions`` calls ``scan``, described on Pg. [1].

See Also
========

process_deductions</pre> 
</div>
</div>
<a id="af21d0e7832432de3a993c943abff1e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21d0e7832432de3a993c943abff1e8f">&#9670;&nbsp;</a></span>rep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.rep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

`k \in [0 \ldots n-1]`, as for ``self`` only array ``p`` is used

Returns
=======

Representative of the class containing ``k``.

Returns the representative of `\sim` class containing ``k``, it also
makes some modification to array ``p`` of ``self`` to ease further
computations, described on Pg. 157 [1].

The information on classes under `\sim` is stored in array `p` of
``self`` argument, which will always satisfy the property:

`p[\alpha] \sim \alpha` and `p[\alpha]=\alpha \iff \alpha=rep(\alpha)`
`\forall \in [0 \ldots n-1]`.

So, for `\alpha \in [0 \ldots n-1]`, we find `rep(self, \alpha)` by
continually replacing `\alpha` by `p[\alpha]` until it becomes
constant (i.e satisfies `p[\alpha] = \alpha`):w

To increase the efficiency of later ``rep`` calculations, whenever we
find `rep(self, \alpha)=\beta`, we set
`p[\gamma] = \beta \forall \gamma \in p-chain` from `\alpha` to `\beta`

Notes
=====

``rep`` routine is also described on Pg. 85-87 [1] in Atkinson's
algorithm, this results from the fact that ``coincidence`` routine
introduces functionality similar to that introduced by the
``minimal_block`` routine on Pg. 85-87 [1].

See Also
========

coincidence, merge</pre> 
</div>
</div>
<a id="af21d0e7832432de3a993c943abff1e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21d0e7832432de3a993c943abff1e8f">&#9670;&nbsp;</a></span>rep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.rep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

`k \in [0 \ldots n-1]`, as for ``self`` only array ``p`` is used

Returns
=======

Representative of the class containing ``k``.

Returns the representative of `\sim` class containing ``k``, it also
makes some modification to array ``p`` of ``self`` to ease further
computations, described on Pg. 157 [1].

The information on classes under `\sim` is stored in array `p` of
``self`` argument, which will always satisfy the property:

`p[\alpha] \sim \alpha` and `p[\alpha]=\alpha \iff \alpha=rep(\alpha)`
`\forall \in [0 \ldots n-1]`.

So, for `\alpha \in [0 \ldots n-1]`, we find `rep(self, \alpha)` by
continually replacing `\alpha` by `p[\alpha]` until it becomes
constant (i.e satisfies `p[\alpha] = \alpha`):w

To increase the efficiency of later ``rep`` calculations, whenever we
find `rep(self, \alpha)=\beta`, we set
`p[\gamma] = \beta \forall \gamma \in p-chain` from `\alpha` to `\beta`

Notes
=====

``rep`` routine is also described on Pg. 85-87 [1] in Atkinson's
algorithm, this results from the fact that ``coincidence`` routine
introduces functionality similar to that introduced by the
``minimal_block`` routine on Pg. 85-87 [1].

See Also
========

coincidence, merge</pre> 
</div>
</div>
<a id="a11c737e8e4849e9a6bed42ed22596977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c737e8e4849e9a6bed42ed22596977">&#9670;&nbsp;</a></span>scan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">``scan`` performs a scanning process on the input ``word``.
It first locates the largest prefix ``s`` of ``word`` for which
`\alpha^s` is defined (i.e is not ``None``), ``s`` may be empty. Let
``word=sv``, let ``t`` be the longest suffix of ``v`` for which
`\alpha^{t^{-1}}` is defined, and let ``v=ut``. Then three
possibilities are there:

1. If ``t=v``, then we say that the scan completes, and if, in addition
`\alpha^s = \alpha^{t^{-1}}`, then we say that the scan completes
correctly.

2. It can also happen that scan does not complete, but `|u|=1`; that
is, the word ``u`` consists of a single generator `x \in A`. In that
case, if `\alpha^s = \beta` and `\alpha^{t^{-1}} = \gamma`, then we can
set `\beta^x = \gamma` and `\gamma^{x^{-1}} = \beta`. These assignments
are known as deductions and enable the scan to complete correctly.

3. See ``coicidence`` routine for explanation of third condition.

Notes
=====

The code for the procedure of scanning `\alpha \in \Omega`
under `w \in A*` is defined on pg. 155 [1]

See Also
========

scan_c, scan_check, scan_and_fill, scan_and_fill_c

Scan and Fill
=============

Performed when the default argument fill=True.

Modified Scan
=============

Performed when the default argument modified=True</pre> 
</div>
</div>
<a id="a11c737e8e4849e9a6bed42ed22596977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c737e8e4849e9a6bed42ed22596977">&#9670;&nbsp;</a></span>scan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modified</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">``scan`` performs a scanning process on the input ``word``.
It first locates the largest prefix ``s`` of ``word`` for which
`\alpha^s` is defined (i.e is not ``None``), ``s`` may be empty. Let
``word=sv``, let ``t`` be the longest suffix of ``v`` for which
`\alpha^{t^{-1}}` is defined, and let ``v=ut``. Then three
possibilities are there:

1. If ``t=v``, then we say that the scan completes, and if, in addition
`\alpha^s = \alpha^{t^{-1}}`, then we say that the scan completes
correctly.

2. It can also happen that scan does not complete, but `|u|=1`; that
is, the word ``u`` consists of a single generator `x \in A`. In that
case, if `\alpha^s = \beta` and `\alpha^{t^{-1}} = \gamma`, then we can
set `\beta^x = \gamma` and `\gamma^{x^{-1}} = \beta`. These assignments
are known as deductions and enable the scan to complete correctly.

3. See ``coicidence`` routine for explanation of third condition.

Notes
=====

The code for the procedure of scanning `\alpha \in \Omega`
under `w \in A*` is defined on pg. 155 [1]

See Also
========

scan_c, scan_check, scan_and_fill, scan_and_fill_c

Scan and Fill
=============

Performed when the default argument fill=True.

Modified Scan
=============

Performed when the default argument modified=True</pre> 
</div>
</div>
<a id="a52ffdc664bba3443d1949ebb1251a515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ffdc664bba3443d1949ebb1251a515">&#9670;&nbsp;</a></span>scan_and_fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan_and_fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A modified version of ``scan`` routine used in the relator-based
method of coset enumeration, described on pg. 162-163 [1], which
follows the idea that whenever the procedure is called and the scan
is incomplete then it makes new definitions to enable the scan to
complete; i.e it fills in the gaps in the scan of the relator or
subgroup generator.</pre> 
</div>
</div>
<a id="a52ffdc664bba3443d1949ebb1251a515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ffdc664bba3443d1949ebb1251a515">&#9670;&nbsp;</a></span>scan_and_fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan_and_fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A modified version of ``scan`` routine used in the relator-based
method of coset enumeration, described on pg. 162-163 [1], which
follows the idea that whenever the procedure is called and the scan
is incomplete then it makes new definitions to enable the scan to
complete; i.e it fills in the gaps in the scan of the relator or
subgroup generator.</pre> 
</div>
</div>
<a id="aace03f28be75693ac7d5632b8fd2556a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace03f28be75693ac7d5632b8fd2556a">&#9670;&nbsp;</a></span>scan_and_fill_c() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan_and_fill_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A modified version of ``scan`` routine, described on Pg. 165 second
para. [1], with modification similar to that of ``scan_anf_fill`` the
only difference being it calls the coincidence procedure used in the
coset-table based method i.e. the routine ``coincidence_c`` is used.

See Also
========

scan, scan_and_fill</pre> 
</div>
</div>
<a id="aace03f28be75693ac7d5632b8fd2556a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace03f28be75693ac7d5632b8fd2556a">&#9670;&nbsp;</a></span>scan_and_fill_c() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan_and_fill_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A modified version of ``scan`` routine, described on Pg. 165 second
para. [1], with modification similar to that of ``scan_anf_fill`` the
only difference being it calls the coincidence procedure used in the
coset-table based method i.e. the routine ``coincidence_c`` is used.

See Also
========

scan, scan_and_fill</pre> 
</div>
</div>
<a id="a121592abc6954803fd6ca95f4795d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121592abc6954803fd6ca95f4795d880">&#9670;&nbsp;</a></span>scan_c() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variation of ``scan`` routine, described on pg. 165 of [1], which
puts at tuple, whenever a deduction occurs, to deduction stack.

See Also
========

scan, scan_check, scan_and_fill, scan_and_fill_c</pre> 
</div>
</div>
<a id="a121592abc6954803fd6ca95f4795d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121592abc6954803fd6ca95f4795d880">&#9670;&nbsp;</a></span>scan_c() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variation of ``scan`` routine, described on pg. 165 of [1], which
puts at tuple, whenever a deduction occurs, to deduction stack.

See Also
========

scan, scan_check, scan_and_fill, scan_and_fill_c</pre> 
</div>
</div>
<a id="a98d2d2e2287ffcc85da74753015a76d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d2d2e2287ffcc85da74753015a76d1">&#9670;&nbsp;</a></span>scan_check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan_check </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Another version of ``scan`` routine, described on, it checks whether
`\alpha` scans correctly under `word`, it is a straightforward
modification of ``scan``. ``scan_check`` returns ``False`` (rather than
calling ``coincidence``) if the scan completes incorrectly; otherwise
it returns ``True``.

See Also
========

scan, scan_c, scan_and_fill, scan_and_fill_c</pre> 
</div>
</div>
<a id="a98d2d2e2287ffcc85da74753015a76d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d2d2e2287ffcc85da74753015a76d1">&#9670;&nbsp;</a></span>scan_check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.scan_check </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Another version of ``scan`` routine, described on, it checks whether
`\alpha` scans correctly under `word`, it is a straightforward
modification of ``scan``. ``scan_check`` returns ``False`` (rather than
calling ``coincidence``) if the scan completes incorrectly; otherwise
it returns ``True``.

See Also
========

scan, scan_c, scan_and_fill, scan_and_fill_c</pre> 
</div>
</div>
<a id="a922450b95e7d965c7aec386a23639e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922450b95e7d965c7aec386a23639e02">&#9670;&nbsp;</a></span>standardize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.standardize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A coset table is standardized if when running through the cosets and
within each coset through the generator images (ignoring generator
inverses), the cosets appear in order of the integers
`0, 1, \dots, n`. "Standardize" reorders the elements of `\Omega`
such that, if we scan the coset table first by elements of `\Omega`
and then by elements of A, then the cosets occur in ascending order.
``standardize()`` is used at the end of an enumeration to permute the
cosets so that they occur in some sort of standard order.

Notes
=====

procedure is described on pg. 167-168 [1], it also makes use of the
``switch`` routine to replace by smaller integer value.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import free_group
&gt;&gt;&gt; from sympy.combinatorics.fp_groups import FpGroup, coset_enumeration_r
&gt;&gt;&gt; F, x, y = free_group("x, y")

# Example 5.3 from [1]
&gt;&gt;&gt; f = FpGroup(F, [x**2*y**2, x**3*y**5])
&gt;&gt;&gt; C = coset_enumeration_r(f, [])
&gt;&gt;&gt; C.compress()
&gt;&gt;&gt; C.table
[[1, 3, 1, 3], [2, 0, 2, 0], [3, 1, 3, 1], [0, 2, 0, 2]]
&gt;&gt;&gt; C.standardize()
&gt;&gt;&gt; C.table
[[1, 2, 1, 2], [3, 0, 3, 0], [0, 3, 0, 3], [2, 1, 2, 1]]</pre> 
</div>
</div>
<a id="a922450b95e7d965c7aec386a23639e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922450b95e7d965c7aec386a23639e02">&#9670;&nbsp;</a></span>standardize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.standardize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A coset table is standardized if when running through the cosets and
within each coset through the generator images (ignoring generator
inverses), the cosets appear in order of the integers
`0, 1, \dots, n`. "Standardize" reorders the elements of `\Omega`
such that, if we scan the coset table first by elements of `\Omega`
and then by elements of A, then the cosets occur in ascending order.
``standardize()`` is used at the end of an enumeration to permute the
cosets so that they occur in some sort of standard order.

Notes
=====

procedure is described on pg. 167-168 [1], it also makes use of the
``switch`` routine to replace by smaller integer value.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics import free_group
&gt;&gt;&gt; from sympy.combinatorics.fp_groups import FpGroup, coset_enumeration_r
&gt;&gt;&gt; F, x, y = free_group("x, y")

# Example 5.3 from [1]
&gt;&gt;&gt; f = FpGroup(F, [x**2*y**2, x**3*y**5])
&gt;&gt;&gt; C = coset_enumeration_r(f, [])
&gt;&gt;&gt; C.compress()
&gt;&gt;&gt; C.table
[[1, 3, 1, 3], [2, 0, 2, 0], [3, 1, 3, 1], [0, 2, 0, 2]]
&gt;&gt;&gt; C.standardize()
&gt;&gt;&gt; C.table
[[1, 2, 1, 2], [3, 0, 3, 0], [0, 3, 0, 3], [2, 1, 2, 1]]</pre> 
</div>
</div>
<a id="ad745e954435c08c59d92bf0d5ab2d518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad745e954435c08c59d92bf0d5ab2d518">&#9670;&nbsp;</a></span>switch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.switch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Switch the elements `\beta, \gamma \in \Omega` of ``self``, used
by the ``standardize`` procedure, described on Pg. 167 [1].

See Also
========

standardize</pre> 
</div>
</div>
<a id="ad745e954435c08c59d92bf0d5ab2d518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad745e954435c08c59d92bf0d5ab2d518">&#9670;&nbsp;</a></span>switch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.combinatorics.coset_table.CosetTable.switch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Switch the elements `\beta, \gamma \in \Omega` of ``self``, used
by the ``standardize`` procedure, described on Pg. 167 [1].

See Also
========

standardize</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa8721f42a5040e0114a52851ed08a557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8721f42a5040e0114a52851ed08a557">&#9670;&nbsp;</a></span>A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.A</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f814ed696c618fd99794bd0e03bf772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f814ed696c618fd99794bd0e03bf772">&#9670;&nbsp;</a></span>A_dict</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.A_dict</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace21feca4e8511f17385a08d46403486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace21feca4e8511f17385a08d46403486">&#9670;&nbsp;</a></span>A_dict_inv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.A_dict_inv</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3a5c4d605e5b0855970d92cc67597fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a5c4d605e5b0855970d92cc67597fa">&#9670;&nbsp;</a></span>coset_table_limit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.coset_table_limit = None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5def5c396116be4b7d880ca53d0bed1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5def5c396116be4b7d880ca53d0bed1d">&#9670;&nbsp;</a></span>coset_table_max_limit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sympy.combinatorics.coset_table.CosetTable.coset_table_max_limit = 4096000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade8be5c1e2bcfa5067b27244c2ea54c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8be5c1e2bcfa5067b27244c2ea54c7">&#9670;&nbsp;</a></span>deduction_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.deduction_stack</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab655ee6499e52724941e893c22bc1ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab655ee6499e52724941e893c22bc1ea7">&#9670;&nbsp;</a></span>fp_group</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.fp_group</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9a546ee24a1a99f1e7a941dbcbf222f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a546ee24a1a99f1e7a941dbcbf222f">&#9670;&nbsp;</a></span>max_stack_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sympy.combinatorics.coset_table.CosetTable.max_stack_size = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02eec1a5e649e9f7b1ed30bd998004d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02eec1a5e649e9f7b1ed30bd998004d1">&#9670;&nbsp;</a></span>p</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.p</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a843265dcdd6e2bab1571aff89a1c087d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843265dcdd6e2bab1571aff89a1c087d">&#9670;&nbsp;</a></span>P</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.P</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80acda1bfa3478b772cbc80e4282d531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80acda1bfa3478b772cbc80e4282d531">&#9670;&nbsp;</a></span>p_p</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.p_p</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26af794aa198379682864bfbe71ead59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26af794aa198379682864bfbe71ead59">&#9670;&nbsp;</a></span>subgroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.subgroup</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1adbe72bdc9b2bc0ba066b10561d25e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adbe72bdc9b2bc0ba066b10561d25e3">&#9670;&nbsp;</a></span>table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.combinatorics.coset_table.CosetTable.table</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/sympy/combinatorics/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2sympy_2combinatorics_2coset__table_8py.html">coset_table.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
