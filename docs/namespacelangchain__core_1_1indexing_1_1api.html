<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: langchain_core.indexing.api Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelangchain__core.html">langchain_core</a></li><li class="navelem"><a class="el" href="namespacelangchain__core_1_1indexing.html">indexing</a></li><li class="navelem"><a class="el" href="namespacelangchain__core_1_1indexing_1_1api.html">api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">langchain_core.indexing.api Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1indexing_1_1api_1_1__HashedDocument.html">_HashedDocument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1indexing_1_1api_1_1IndexingException.html">IndexingException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1indexing_1_1api_1_1IndexingResult.html">IndexingResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae49d174149d215d1b571d673959fc1e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlangchain__core_1_1indexing_1_1api_1_1IndexingResult.html">IndexingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain__core_1_1indexing_1_1api.html#ae49d174149d215d1b571d673959fc1e5">index</a> (Union[<a class="el" href="classlangchain__core_1_1document__loaders_1_1base_1_1BaseLoader.html">BaseLoader</a>, Iterable[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>]] docs_source, <a class="el" href="classlangchain__core_1_1indexing_1_1base_1_1RecordManager.html">RecordManager</a> record_manager, Union[VectorStore, <a class="el" href="classlangchain__core_1_1indexing_1_1base_1_1DocumentIndex.html">DocumentIndex</a>] vector_store, *int batch_size=100, Literal[&quot;incremental&quot;, &quot;full&quot;, &quot;scoped_full&quot;, None] cleanup=None, Union[str, Callable[[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>], str], None] source_id_key=None, int cleanup_batch_size=1_000, bool force_update=False, Optional[dict[str, Any]] upsert_kwargs=None)</td></tr>
<tr class="separator:ae49d174149d215d1b571d673959fc1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610b3f8ea5a4be4440e73e92c8a52e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlangchain__core_1_1indexing_1_1api_1_1IndexingResult.html">IndexingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain__core_1_1indexing_1_1api.html#a610b3f8ea5a4be4440e73e92c8a52e32">aindex</a> (Union[<a class="el" href="classlangchain__core_1_1document__loaders_1_1base_1_1BaseLoader.html">BaseLoader</a>, Iterable[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>], AsyncIterator[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>]] docs_source, <a class="el" href="classlangchain__core_1_1indexing_1_1base_1_1RecordManager.html">RecordManager</a> record_manager, Union[VectorStore, <a class="el" href="classlangchain__core_1_1indexing_1_1base_1_1DocumentIndex.html">DocumentIndex</a>] vector_store, *int batch_size=100, Literal[&quot;incremental&quot;, &quot;full&quot;, &quot;scoped_full&quot;, None] cleanup=None, Union[str, Callable[[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>], str], None] source_id_key=None, int cleanup_batch_size=1_000, bool force_update=False, Optional[dict[str, Any]] upsert_kwargs=None)</td></tr>
<tr class="separator:a610b3f8ea5a4be4440e73e92c8a52e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a78c8f9978221b9e99ff8a1bd46703421"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain__core_1_1indexing_1_1api.html#a78c8f9978221b9e99ff8a1bd46703421">NAMESPACE_UUID</a> = uuid.UUID(int=1984)</td></tr>
<tr class="separator:a78c8f9978221b9e99ff8a1bd46703421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59207805afc5f3a10ac97bac8f9bc7d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain__core_1_1indexing_1_1api.html#a59207805afc5f3a10ac97bac8f9bc7d0">T</a> = TypeVar(&quot;T&quot;)</td></tr>
<tr class="separator:a59207805afc5f3a10ac97bac8f9bc7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Module contains logic for indexing documents into vector stores.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a610b3f8ea5a4be4440e73e92c8a52e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610b3f8ea5a4be4440e73e92c8a52e32">&#9670;&nbsp;</a></span>aindex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classlangchain__core_1_1indexing_1_1api_1_1IndexingResult.html">IndexingResult</a> langchain_core.indexing.api.aindex </td>
          <td>(</td>
          <td class="paramtype">Union[<a class="el" href="classlangchain__core_1_1document__loaders_1_1base_1_1BaseLoader.html">BaseLoader</a>, Iterable[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>], AsyncIterator[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>]]&#160;</td>
          <td class="paramname"><em>docs_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlangchain__core_1_1indexing_1_1base_1_1RecordManager.html">RecordManager</a>&#160;</td>
          <td class="paramname"><em>record_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[VectorStore, <a class="el" href="classlangchain__core_1_1indexing_1_1base_1_1DocumentIndex.html">DocumentIndex</a>]&#160;</td>
          <td class="paramname"><em>vector_store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int &#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;incremental&quot;, &quot;full&quot;, &quot;scoped_full&quot;, None] &#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, Callable[[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>], str], None] &#160;</td>
          <td class="paramname"><em>source_id_key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>cleanup_batch_size</em> = <code>1_000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>force_update</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[dict[str, Any]] &#160;</td>
          <td class="paramname"><em>upsert_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async index data from the loader into the vector store.

Indexing functionality uses a manager to keep track of which documents
are in the vector store.

This allows us to keep track of which documents were updated, and which
documents were deleted, which documents should be skipped.

For the time being, documents are indexed using their hashes, and users
 are not able to specify the uid of the document.

Important:
   * In full mode, the loader should be returning
     the entire dataset, and not just a subset of the dataset.
     Otherwise, the auto_cleanup will remove documents that it is not
     supposed to.
   * In incremental mode, if documents associated with a particular
     source id appear across different batches, the indexing API
     will do some redundant work. This will still result in the
     correct end state of the index, but will unfortunately not be
     100% efficient. For example, if a given document is split into 15
     chunks, and we index them using a batch size of 5, we'll have 3 batches
     all with the same source id. In general, to avoid doing too much
     redundant work select as big a batch size as possible.
   * The `scoped_full` mode is suitable if determining an appropriate batch size
     is challenging or if your data loader cannot return the entire dataset at
     once. This mode keeps track of source IDs in memory, which should be fine
     for most use cases. If your dataset is large (10M+ docs), you will likely
     need to parallelize the indexing process regardless.

Args:
    docs_source: Data loader or iterable of documents to index.
    record_manager: Timestamped set to keep track of which documents were
                     updated.
    vector_store: VectorStore or DocumentIndex to index the documents into.
    batch_size: Batch size to use when indexing. Default is 100.
    cleanup: How to handle clean up of documents. Default is None.
        - incremental: Cleans up all documents that haven't been updated AND
                       that are associated with source ids that were seen
                       during indexing.
                       Clean up is done continuously during indexing helping
                       to minimize the probability of users seeing duplicated
                       content.
        - full: Delete all documents that haven to been returned by the loader.
                Clean up runs after all documents have been indexed.
                This means that users may see duplicated content during indexing.
        - scoped_full: Similar to Full, but only deletes all documents
                       that haven't been updated AND that are associated with
                       source ids that were seen during indexing.
        - None: Do not delete any documents.
    source_id_key: Optional key that helps identify the original source
        of the document. Default is None.
    cleanup_batch_size: Batch size to use when cleaning up documents.
        Default is 1_000.
    force_update: Force update documents even if they are present in the
        record manager. Useful if you are re-indexing with updated embeddings.
        Default is False.
    upsert_kwargs: Additional keyword arguments to pass to the aadd_documents
                   method of the VectorStore or the aupsert method of the
                   DocumentIndex. For example, you can use this to
                   specify a custom vector_field:
                   upsert_kwargs={"vector_field": "embedding"}
        .. versionadded:: 0.3.10

Returns:
    Indexing result which contains information about how many documents
    were added, updated, deleted, or skipped.

Raises:
    ValueError: If cleanup mode is not one of 'incremental', 'full' or None
    ValueError: If cleanup mode is incremental and source_id_key is None.
    ValueError: If vectorstore does not have
        "adelete" and "aadd_documents" required methods.
    ValueError: If source_id_key is not None, but is not a string or callable.

.. version_modified:: 0.3.25

    * Added `scoped_full` cleanup mode.
</pre> 
</div>
</div>
<a id="ae49d174149d215d1b571d673959fc1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49d174149d215d1b571d673959fc1e5">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classlangchain__core_1_1indexing_1_1api_1_1IndexingResult.html">IndexingResult</a> langchain_core.indexing.api.index </td>
          <td>(</td>
          <td class="paramtype">Union[<a class="el" href="classlangchain__core_1_1document__loaders_1_1base_1_1BaseLoader.html">BaseLoader</a>, Iterable[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>]]&#160;</td>
          <td class="paramname"><em>docs_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlangchain__core_1_1indexing_1_1base_1_1RecordManager.html">RecordManager</a>&#160;</td>
          <td class="paramname"><em>record_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[VectorStore, <a class="el" href="classlangchain__core_1_1indexing_1_1base_1_1DocumentIndex.html">DocumentIndex</a>]&#160;</td>
          <td class="paramname"><em>vector_store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int &#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;incremental&quot;, &quot;full&quot;, &quot;scoped_full&quot;, None] &#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, Callable[[<a class="el" href="classlangchain__core_1_1documents_1_1base_1_1Document.html">Document</a>], str], None] &#160;</td>
          <td class="paramname"><em>source_id_key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>cleanup_batch_size</em> = <code>1_000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>force_update</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[dict[str, Any]] &#160;</td>
          <td class="paramname"><em>upsert_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Index data from the loader into the vector store.

Indexing functionality uses a manager to keep track of which documents
are in the vector store.

This allows us to keep track of which documents were updated, and which
documents were deleted, which documents should be skipped.

For the time being, documents are indexed using their hashes, and users
 are not able to specify the uid of the document.

Important:
   * In full mode, the loader should be returning
     the entire dataset, and not just a subset of the dataset.
     Otherwise, the auto_cleanup will remove documents that it is not
     supposed to.
   * In incremental mode, if documents associated with a particular
     source id appear across different batches, the indexing API
     will do some redundant work. This will still result in the
     correct end state of the index, but will unfortunately not be
     100% efficient. For example, if a given document is split into 15
     chunks, and we index them using a batch size of 5, we'll have 3 batches
     all with the same source id. In general, to avoid doing too much
     redundant work select as big a batch size as possible.
    * The `scoped_full` mode is suitable if determining an appropriate batch size
      is challenging or if your data loader cannot return the entire dataset at
      once. This mode keeps track of source IDs in memory, which should be fine
      for most use cases. If your dataset is large (10M+ docs), you will likely
      need to parallelize the indexing process regardless.

Args:
    docs_source: Data loader or iterable of documents to index.
    record_manager: Timestamped set to keep track of which documents were
                     updated.
    vector_store: VectorStore or DocumentIndex to index the documents into.
    batch_size: Batch size to use when indexing. Default is 100.
    cleanup: How to handle clean up of documents. Default is None.
        - incremental: Cleans up all documents that haven't been updated AND
                       that are associated with source ids that were seen
                       during indexing.
                       Clean up is done continuously during indexing helping
                       to minimize the probability of users seeing duplicated
                       content.
        - full: Delete all documents that have not been returned by the loader
                during this run of indexing.
                Clean up runs after all documents have been indexed.
                This means that users may see duplicated content during indexing.
        - scoped_full: Similar to Full, but only deletes all documents
                       that haven't been updated AND that are associated with
                       source ids that were seen during indexing.
        - None: Do not delete any documents.
    source_id_key: Optional key that helps identify the original source
        of the document. Default is None.
    cleanup_batch_size: Batch size to use when cleaning up documents.
        Default is 1_000.
    force_update: Force update documents even if they are present in the
        record manager. Useful if you are re-indexing with updated embeddings.
        Default is False.
    upsert_kwargs: Additional keyword arguments to pass to the add_documents
                   method of the VectorStore or the upsert method of the
                   DocumentIndex. For example, you can use this to
                   specify a custom vector_field:
                   upsert_kwargs={"vector_field": "embedding"}
        .. versionadded:: 0.3.10

Returns:
    Indexing result which contains information about how many documents
    were added, updated, deleted, or skipped.

Raises:
    ValueError: If cleanup mode is not one of 'incremental', 'full' or None
    ValueError: If cleanup mode is incremental and source_id_key is None.
    ValueError: If vectorstore does not have
        "delete" and "add_documents" required methods.
    ValueError: If source_id_key is not None, but is not a string or callable.

.. version_modified:: 0.3.25

    * Added `scoped_full` cleanup mode.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a78c8f9978221b9e99ff8a1bd46703421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c8f9978221b9e99ff8a1bd46703421">&#9670;&nbsp;</a></span>NAMESPACE_UUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">langchain_core.indexing.api.NAMESPACE_UUID = uuid.UUID(int=1984)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59207805afc5f3a10ac97bac8f9bc7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59207805afc5f3a10ac97bac8f9bc7d0">&#9670;&nbsp;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">langchain_core.indexing.api.T = TypeVar(&quot;T&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
