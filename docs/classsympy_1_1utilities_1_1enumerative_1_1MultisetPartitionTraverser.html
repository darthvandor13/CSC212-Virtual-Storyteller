<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.utilities.enumerative.MultisetPartitionTraverser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1utilities.html">utilities</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1utilities_1_1enumerative.html">enumerative</a></li><li class="navelem"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html">MultisetPartitionTraverser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sympy.utilities.enumerative.MultisetPartitionTraverser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6b3ff9da28f7732dc66d9585df7e473f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a6b3ff9da28f7732dc66d9585df7e473f">__init__</a> (self)</td></tr>
<tr class="separator:a6b3ff9da28f7732dc66d9585df7e473f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a94b28b66462b98056ada0d35bff9fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a2a94b28b66462b98056ada0d35bff9fb">db_trace</a> (self, msg)</td></tr>
<tr class="separator:a2a94b28b66462b98056ada0d35bff9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0f4ccadc418ecd2740edd47a1040bd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#abe0f4ccadc418ecd2740edd47a1040bd">decrement_part</a> (self, part)</td></tr>
<tr class="separator:abe0f4ccadc418ecd2740edd47a1040bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf8c27758c913de97fc2da453d83508"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a9cf8c27758c913de97fc2da453d83508">decrement_part_small</a> (self, part, ub)</td></tr>
<tr class="separator:a9cf8c27758c913de97fc2da453d83508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b53f301a4fd4870074b51514b65479"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a87b53f301a4fd4870074b51514b65479">decrement_part_large</a> (self, part, amt, lb)</td></tr>
<tr class="separator:a87b53f301a4fd4870074b51514b65479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15eed89c675d46c19233fa5b93f8a7e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#ab15eed89c675d46c19233fa5b93f8a7e">decrement_part_range</a> (self, part, lb, ub)</td></tr>
<tr class="separator:ab15eed89c675d46c19233fa5b93f8a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af706d244e9439f2cd889a17ef1ce9c71"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#af706d244e9439f2cd889a17ef1ce9c71">spread_part_multiplicity</a> (self)</td></tr>
<tr class="separator:af706d244e9439f2cd889a17ef1ce9c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a39ca66bddf8e7d2ee150e3df71ad3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a31a39ca66bddf8e7d2ee150e3df71ad3">top_part</a> (self)</td></tr>
<tr class="separator:a31a39ca66bddf8e7d2ee150e3df71ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778570c71afe06fab179767d67ad3909"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a778570c71afe06fab179767d67ad3909">enum_all</a> (self, multiplicities)</td></tr>
<tr class="separator:a778570c71afe06fab179767d67ad3909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc88ce003d89967fd71c46398ab937a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a1dc88ce003d89967fd71c46398ab937a">enum_small</a> (self, multiplicities, ub)</td></tr>
<tr class="separator:a1dc88ce003d89967fd71c46398ab937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9a58033f7ac6651340969ad03003c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a0a9a58033f7ac6651340969ad03003c9">enum_large</a> (self, multiplicities, lb)</td></tr>
<tr class="separator:a0a9a58033f7ac6651340969ad03003c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df1af5a326664280e466bb1b49a30c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a1df1af5a326664280e466bb1b49a30c7">enum_range</a> (self, multiplicities, lb, ub)</td></tr>
<tr class="separator:a1df1af5a326664280e466bb1b49a30c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab639f8ff24c915a36a464d0f2b66ab80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#ab639f8ff24c915a36a464d0f2b66ab80">count_partitions_slow</a> (self, multiplicities)</td></tr>
<tr class="separator:ab639f8ff24c915a36a464d0f2b66ab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5397ac7e89879b07a5aa97089e2d1b11"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a5397ac7e89879b07a5aa97089e2d1b11">count_partitions</a> (self, multiplicities)</td></tr>
<tr class="separator:a5397ac7e89879b07a5aa97089e2d1b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3ff9da28f7732dc66d9585df7e473f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a6b3ff9da28f7732dc66d9585df7e473f">__init__</a> (self)</td></tr>
<tr class="separator:a6b3ff9da28f7732dc66d9585df7e473f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a94b28b66462b98056ada0d35bff9fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a2a94b28b66462b98056ada0d35bff9fb">db_trace</a> (self, msg)</td></tr>
<tr class="separator:a2a94b28b66462b98056ada0d35bff9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0f4ccadc418ecd2740edd47a1040bd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#abe0f4ccadc418ecd2740edd47a1040bd">decrement_part</a> (self, part)</td></tr>
<tr class="separator:abe0f4ccadc418ecd2740edd47a1040bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf8c27758c913de97fc2da453d83508"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a9cf8c27758c913de97fc2da453d83508">decrement_part_small</a> (self, part, ub)</td></tr>
<tr class="separator:a9cf8c27758c913de97fc2da453d83508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b53f301a4fd4870074b51514b65479"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a87b53f301a4fd4870074b51514b65479">decrement_part_large</a> (self, part, amt, lb)</td></tr>
<tr class="separator:a87b53f301a4fd4870074b51514b65479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15eed89c675d46c19233fa5b93f8a7e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#ab15eed89c675d46c19233fa5b93f8a7e">decrement_part_range</a> (self, part, lb, ub)</td></tr>
<tr class="separator:ab15eed89c675d46c19233fa5b93f8a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af706d244e9439f2cd889a17ef1ce9c71"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#af706d244e9439f2cd889a17ef1ce9c71">spread_part_multiplicity</a> (self)</td></tr>
<tr class="separator:af706d244e9439f2cd889a17ef1ce9c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a39ca66bddf8e7d2ee150e3df71ad3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a31a39ca66bddf8e7d2ee150e3df71ad3">top_part</a> (self)</td></tr>
<tr class="separator:a31a39ca66bddf8e7d2ee150e3df71ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778570c71afe06fab179767d67ad3909"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a778570c71afe06fab179767d67ad3909">enum_all</a> (self, multiplicities)</td></tr>
<tr class="separator:a778570c71afe06fab179767d67ad3909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc88ce003d89967fd71c46398ab937a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a1dc88ce003d89967fd71c46398ab937a">enum_small</a> (self, multiplicities, ub)</td></tr>
<tr class="separator:a1dc88ce003d89967fd71c46398ab937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9a58033f7ac6651340969ad03003c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a0a9a58033f7ac6651340969ad03003c9">enum_large</a> (self, multiplicities, lb)</td></tr>
<tr class="separator:a0a9a58033f7ac6651340969ad03003c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df1af5a326664280e466bb1b49a30c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a1df1af5a326664280e466bb1b49a30c7">enum_range</a> (self, multiplicities, lb, ub)</td></tr>
<tr class="separator:a1df1af5a326664280e466bb1b49a30c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab639f8ff24c915a36a464d0f2b66ab80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#ab639f8ff24c915a36a464d0f2b66ab80">count_partitions_slow</a> (self, multiplicities)</td></tr>
<tr class="separator:ab639f8ff24c915a36a464d0f2b66ab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5397ac7e89879b07a5aa97089e2d1b11"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a5397ac7e89879b07a5aa97089e2d1b11">count_partitions</a> (self, multiplicities)</td></tr>
<tr class="separator:a5397ac7e89879b07a5aa97089e2d1b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a706bbc8f028640707083a4dcd653b7bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a706bbc8f028640707083a4dcd653b7bd">debug</a></td></tr>
<tr class="separator:a706bbc8f028640707083a4dcd653b7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3ad7c5567df7a91996175088ad0534"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#aef3ad7c5567df7a91996175088ad0534">k1</a></td></tr>
<tr class="separator:aef3ad7c5567df7a91996175088ad0534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295f5766517f967d348db94f7b0f578a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a295f5766517f967d348db94f7b0f578a">k2</a></td></tr>
<tr class="separator:a295f5766517f967d348db94f7b0f578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace175d6f3dad6ee6071492f992c1236e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#ace175d6f3dad6ee6071492f992c1236e">p1</a></td></tr>
<tr class="separator:ace175d6f3dad6ee6071492f992c1236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749d21988c1b9941f4f63d8013a3490e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a749d21988c1b9941f4f63d8013a3490e">pstack</a></td></tr>
<tr class="separator:a749d21988c1b9941f4f63d8013a3490e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e1f7239badae76e124e747dc51c7ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a35e1f7239badae76e124e747dc51c7ef">f</a></td></tr>
<tr class="separator:a35e1f7239badae76e124e747dc51c7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55e4027c9e95f02175b888e614b5916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#ad55e4027c9e95f02175b888e614b5916">lpart</a></td></tr>
<tr class="separator:ad55e4027c9e95f02175b888e614b5916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8606ce3eb483bf24fa5541257a0f5dfc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a8606ce3eb483bf24fa5541257a0f5dfc">discarded</a></td></tr>
<tr class="separator:a8606ce3eb483bf24fa5541257a0f5dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85b5ccf5da93576868fbe164ffcd8d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#ad85b5ccf5da93576868fbe164ffcd8d5">dp_stack</a></td></tr>
<tr class="separator:ad85b5ccf5da93576868fbe164ffcd8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae210d4303c6bbc24c2922634a7778171"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#ae210d4303c6bbc24c2922634a7778171">dp_map</a></td></tr>
<tr class="separator:ae210d4303c6bbc24c2922634a7778171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8d9cf0e3266126f35004fd58c01a07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html#a3d8d9cf0e3266126f35004fd58c01a07">pcount</a></td></tr>
<tr class="separator:a3d8d9cf0e3266126f35004fd58c01a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Has methods to ``enumerate`` and ``count`` the partitions of a multiset.

This implements a refactored and extended version of Knuth's algorithm
7.1.2.5M [AOCP]_."

The enumeration methods of this class are generators and return
data structures which can be interpreted by the same visitor
functions used for the output of ``multiset_partitions_taocp``.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; m.count_partitions([4,4,4,2])
127750
&gt;&gt;&gt; m.count_partitions([3,3,3])
686

See Also
========

multiset_partitions_taocp
sympy.utilities.iterables.multiset_partitions

References
==========

.. [AOCP] Algorithm 7.1.2.5M in Volume 4A, Combinatoral Algorithms,
       Part 1, of The Art of Computer Programming, by Donald Knuth.

.. [Factorisatio] On a Problem of Oppenheim concerning
       "Factorisatio Numerorum" E. R. Canfield, Paul Erdos, Carl
       Pomerance, JOURNAL OF NUMBER THEORY, Vol. 17, No. 1. August
       1983.  See section 7 for a description of an algorithm
       similar to Knuth's.

.. [Yorgey] Generating Multiset Partitions, Brent Yorgey, The
       Monad.Reader, Issue 8, September 2007.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6b3ff9da28f7732dc66d9585df7e473f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3ff9da28f7732dc66d9585df7e473f">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b3ff9da28f7732dc66d9585df7e473f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3ff9da28f7732dc66d9585df7e473f">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5397ac7e89879b07a5aa97089e2d1b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5397ac7e89879b07a5aa97089e2d1b11">&#9670;&nbsp;</a></span>count_partitions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.count_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of partitions of a multiset whose components
have the multiplicities given in ``multiplicities``.

For larger counts, this method is much faster than calling one
of the enumerators and counting the result.  Uses dynamic
programming to cut down on the number of nodes actually
explored.  The dictionary used in order to accelerate the
counting process is stored in the ``MultisetPartitionTraverser``
object and persists across calls.  If the user does not
expect to call ``count_partitions`` for any additional
multisets, the object should be cleared to save memory.  On
the other hand, the cache built up from one count run can
significantly speed up subsequent calls to ``count_partitions``,
so it may be advantageous not to clear the object.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; m.count_partitions([9,8,2])
288716
&gt;&gt;&gt; m.count_partitions([2,2])
9
&gt;&gt;&gt; del m

Notes
=====

If one looks at the workings of Knuth's algorithm M [AOCP]_, it
can be viewed as a traversal of a binary tree of parts.  A
part has (up to) two children, the left child resulting from
the spread operation, and the right child from the decrement
operation.  The ordinary enumeration of multiset partitions is
an in-order traversal of this tree, and with the partitions
corresponding to paths from the root to the leaves. The
mapping from paths to partitions is a little complicated,
since the partition would contain only those parts which are
leaves or the parents of a spread link, not those which are
parents of a decrement link.

For counting purposes, it is sufficient to count leaves, and
this can be done with a recursive in-order traversal.  The
number of leaves of a subtree rooted at a particular part is a
function only of that part itself, so memoizing has the
potential to speed up the counting dramatically.

This method follows a computational approach which is similar
to the hypothetical memoized recursive function, but with two
differences:

1) This method is iterative, borrowing its structure from the
   other enumerations and maintaining an explicit stack of
   parts which are in the process of being counted.  (There
   may be multisets which can be counted reasonably quickly by
   this implementation, but which would overflow the default
   Python recursion limit with a recursive implementation.)

2) Instead of using the part data structure directly, a more
   compact key is constructed.  This saves space, but more
   importantly coalesces some parts which would remain
   separate with physical keys.

Unlike the enumeration functions, there is currently no _range
version of count_partitions.  If someone wants to stretch
their brain, it should be possible to construct one by
memoizing with a histogram of counts rather than a single
count, and combining the histograms.
</pre> 
</div>
</div>
<a id="a5397ac7e89879b07a5aa97089e2d1b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5397ac7e89879b07a5aa97089e2d1b11">&#9670;&nbsp;</a></span>count_partitions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.count_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of partitions of a multiset whose components
have the multiplicities given in ``multiplicities``.

For larger counts, this method is much faster than calling one
of the enumerators and counting the result.  Uses dynamic
programming to cut down on the number of nodes actually
explored.  The dictionary used in order to accelerate the
counting process is stored in the ``MultisetPartitionTraverser``
object and persists across calls.  If the user does not
expect to call ``count_partitions`` for any additional
multisets, the object should be cleared to save memory.  On
the other hand, the cache built up from one count run can
significantly speed up subsequent calls to ``count_partitions``,
so it may be advantageous not to clear the object.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; m.count_partitions([9,8,2])
288716
&gt;&gt;&gt; m.count_partitions([2,2])
9
&gt;&gt;&gt; del m

Notes
=====

If one looks at the workings of Knuth's algorithm M [AOCP]_, it
can be viewed as a traversal of a binary tree of parts.  A
part has (up to) two children, the left child resulting from
the spread operation, and the right child from the decrement
operation.  The ordinary enumeration of multiset partitions is
an in-order traversal of this tree, and with the partitions
corresponding to paths from the root to the leaves. The
mapping from paths to partitions is a little complicated,
since the partition would contain only those parts which are
leaves or the parents of a spread link, not those which are
parents of a decrement link.

For counting purposes, it is sufficient to count leaves, and
this can be done with a recursive in-order traversal.  The
number of leaves of a subtree rooted at a particular part is a
function only of that part itself, so memoizing has the
potential to speed up the counting dramatically.

This method follows a computational approach which is similar
to the hypothetical memoized recursive function, but with two
differences:

1) This method is iterative, borrowing its structure from the
   other enumerations and maintaining an explicit stack of
   parts which are in the process of being counted.  (There
   may be multisets which can be counted reasonably quickly by
   this implementation, but which would overflow the default
   Python recursion limit with a recursive implementation.)

2) Instead of using the part data structure directly, a more
   compact key is constructed.  This saves space, but more
   importantly coalesces some parts which would remain
   separate with physical keys.

Unlike the enumeration functions, there is currently no _range
version of count_partitions.  If someone wants to stretch
their brain, it should be possible to construct one by
memoizing with a histogram of counts rather than a single
count, and combining the histograms.
</pre> 
</div>
</div>
<a id="ab639f8ff24c915a36a464d0f2b66ab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab639f8ff24c915a36a464d0f2b66ab80">&#9670;&nbsp;</a></span>count_partitions_slow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.count_partitions_slow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of partitions of a multiset whose elements
have the multiplicities given in ``multiplicities``.

Primarily for comparison purposes.  It follows the same path as
enumerate, and counts, rather than generates, the partitions.

See Also
========

count_partitions
    Has the same calling interface, but is much faster.</pre> 
</div>
</div>
<a id="ab639f8ff24c915a36a464d0f2b66ab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab639f8ff24c915a36a464d0f2b66ab80">&#9670;&nbsp;</a></span>count_partitions_slow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.count_partitions_slow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of partitions of a multiset whose elements
have the multiplicities given in ``multiplicities``.

Primarily for comparison purposes.  It follows the same path as
enumerate, and counts, rather than generates, the partitions.

See Also
========

count_partitions
    Has the same calling interface, but is much faster.</pre> 
</div>
</div>
<a id="a2a94b28b66462b98056ada0d35bff9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a94b28b66462b98056ada0d35bff9fb">&#9670;&nbsp;</a></span>db_trace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.db_trace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Useful for understanding/debugging the algorithms.  Not
generally activated in end-user code.</pre> 
</div>
</div>
<a id="a2a94b28b66462b98056ada0d35bff9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a94b28b66462b98056ada0d35bff9fb">&#9670;&nbsp;</a></span>db_trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.db_trace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Useful for understanding/debugging the algorithms.  Not
generally activated in end-user code.</pre> 
</div>
</div>
<a id="abe0f4ccadc418ecd2740edd47a1040bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0f4ccadc418ecd2740edd47a1040bd">&#9670;&nbsp;</a></span>decrement_part() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.decrement_part </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrements part (a subrange of pstack), if possible, returning
True iff the part was successfully decremented.

If you think of the v values in the part as a multi-digit
integer (least significant digit on the right) this is
basically decrementing that integer, but with the extra
constraint that the leftmost digit cannot be decremented to 0.

Parameters
==========

part
   The part, represented as a list of PartComponent objects,
   which is to be decremented.</pre> 
</div>
</div>
<a id="abe0f4ccadc418ecd2740edd47a1040bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0f4ccadc418ecd2740edd47a1040bd">&#9670;&nbsp;</a></span>decrement_part() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.decrement_part </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrements part (a subrange of pstack), if possible, returning
True iff the part was successfully decremented.

If you think of the v values in the part as a multi-digit
integer (least significant digit on the right) this is
basically decrementing that integer, but with the extra
constraint that the leftmost digit cannot be decremented to 0.

Parameters
==========

part
   The part, represented as a list of PartComponent objects,
   which is to be decremented.</pre> 
</div>
</div>
<a id="a87b53f301a4fd4870074b51514b65479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b53f301a4fd4870074b51514b65479">&#9670;&nbsp;</a></span>decrement_part_large() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.decrement_part_large </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrements part, while respecting size constraint.

A part can have no children which are of sufficient size (as
indicated by ``lb``) unless that part has sufficient
unallocated multiplicity.  When enforcing the size constraint,
this method will decrement the part (if necessary) by an
amount needed to ensure sufficient unallocated multiplicity.

Returns True iff the part was successfully decremented.

Parameters
==========

part
    part to be decremented (topmost part on the stack)

amt
    Can only take values 0 or 1.  A value of 1 means that the
    part must be decremented, and then the size constraint is
    enforced.  A value of 0 means just to enforce the ``lb``
    size constraint.

lb
    The partitions produced by the calling enumeration must
    have more parts than this value.</pre> 
</div>
</div>
<a id="a87b53f301a4fd4870074b51514b65479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b53f301a4fd4870074b51514b65479">&#9670;&nbsp;</a></span>decrement_part_large() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.decrement_part_large </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrements part, while respecting size constraint.

A part can have no children which are of sufficient size (as
indicated by ``lb``) unless that part has sufficient
unallocated multiplicity.  When enforcing the size constraint,
this method will decrement the part (if necessary) by an
amount needed to ensure sufficient unallocated multiplicity.

Returns True iff the part was successfully decremented.

Parameters
==========

part
    part to be decremented (topmost part on the stack)

amt
    Can only take values 0 or 1.  A value of 1 means that the
    part must be decremented, and then the size constraint is
    enforced.  A value of 0 means just to enforce the ``lb``
    size constraint.

lb
    The partitions produced by the calling enumeration must
    have more parts than this value.</pre> 
</div>
</div>
<a id="ab15eed89c675d46c19233fa5b93f8a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15eed89c675d46c19233fa5b93f8a7e">&#9670;&nbsp;</a></span>decrement_part_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.decrement_part_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrements part (a subrange of pstack), if possible, returning
True iff the part was successfully decremented.

Parameters
==========

part
    part to be decremented (topmost part on the stack)

ub
    the maximum number of parts allowed in a partition
    returned by the calling traversal.

lb
    The partitions produced by the calling enumeration must
    have more parts than this value.

Notes
=====

Combines the constraints of _small and _large decrement
methods.  If returns success, part has been decremented at
least once, but perhaps by quite a bit more if needed to meet
the lb constraint.
</pre> 
</div>
</div>
<a id="ab15eed89c675d46c19233fa5b93f8a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15eed89c675d46c19233fa5b93f8a7e">&#9670;&nbsp;</a></span>decrement_part_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.decrement_part_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrements part (a subrange of pstack), if possible, returning
True iff the part was successfully decremented.

Parameters
==========

part
    part to be decremented (topmost part on the stack)

ub
    the maximum number of parts allowed in a partition
    returned by the calling traversal.

lb
    The partitions produced by the calling enumeration must
    have more parts than this value.

Notes
=====

Combines the constraints of _small and _large decrement
methods.  If returns success, part has been decremented at
least once, but perhaps by quite a bit more if needed to meet
the lb constraint.
</pre> 
</div>
</div>
<a id="a9cf8c27758c913de97fc2da453d83508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf8c27758c913de97fc2da453d83508">&#9670;&nbsp;</a></span>decrement_part_small() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.decrement_part_small </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrements part (a subrange of pstack), if possible, returning
True iff the part was successfully decremented.

Parameters
==========

part
    part to be decremented (topmost part on the stack)

ub
    the maximum number of parts allowed in a partition
    returned by the calling traversal.

Notes
=====

The goal of this modification of the ordinary decrement method
is to fail (meaning that the subtree rooted at this part is to
be skipped) when it can be proved that this part can only have
child partitions which are larger than allowed by ``ub``. If a
decision is made to fail, it must be accurate, otherwise the
enumeration will miss some partitions.  But, it is OK not to
capture all the possible failures -- if a part is passed that
should not be, the resulting too-large partitions are filtered
by the enumeration one level up.  However, as is usual in
constrained enumerations, failing early is advantageous.

The tests used by this method catch the most common cases,
although this implementation is by no means the last word on
this problem.  The tests include:

1) ``lpart`` must be less than ``ub`` by at least 2.  This is because
   once a part has been decremented, the partition
   will gain at least one child in the spread step.

2) If the leading component of the part is about to be
   decremented, check for how many parts will be added in
   order to use up the unallocated multiplicity in that
   leading component, and fail if this number is greater than
   allowed by ``ub``.  (See code for the exact expression.)  This
   test is given in the answer to Knuth's problem 7.2.1.5.69.

3) If there is *exactly* enough room to expand the leading
   component by the above test, check the next component (if
   it exists) once decrementing has finished.  If this has
   ``v == 0``, this next component will push the expansion over the
   limit by 1, so fail.
</pre> 
</div>
</div>
<a id="a9cf8c27758c913de97fc2da453d83508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf8c27758c913de97fc2da453d83508">&#9670;&nbsp;</a></span>decrement_part_small() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.decrement_part_small </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrements part (a subrange of pstack), if possible, returning
True iff the part was successfully decremented.

Parameters
==========

part
    part to be decremented (topmost part on the stack)

ub
    the maximum number of parts allowed in a partition
    returned by the calling traversal.

Notes
=====

The goal of this modification of the ordinary decrement method
is to fail (meaning that the subtree rooted at this part is to
be skipped) when it can be proved that this part can only have
child partitions which are larger than allowed by ``ub``. If a
decision is made to fail, it must be accurate, otherwise the
enumeration will miss some partitions.  But, it is OK not to
capture all the possible failures -- if a part is passed that
should not be, the resulting too-large partitions are filtered
by the enumeration one level up.  However, as is usual in
constrained enumerations, failing early is advantageous.

The tests used by this method catch the most common cases,
although this implementation is by no means the last word on
this problem.  The tests include:

1) ``lpart`` must be less than ``ub`` by at least 2.  This is because
   once a part has been decremented, the partition
   will gain at least one child in the spread step.

2) If the leading component of the part is about to be
   decremented, check for how many parts will be added in
   order to use up the unallocated multiplicity in that
   leading component, and fail if this number is greater than
   allowed by ``ub``.  (See code for the exact expression.)  This
   test is given in the answer to Knuth's problem 7.2.1.5.69.

3) If there is *exactly* enough room to expand the leading
   component by the above test, check the next component (if
   it exists) once decrementing has finished.  If this has
   ``v == 0``, this next component will push the expansion over the
   limit by 1, so fail.
</pre> 
</div>
</div>
<a id="a778570c71afe06fab179767d67ad3909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778570c71afe06fab179767d67ad3909">&#9670;&nbsp;</a></span>enum_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.enum_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerate the partitions of a multiset.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; states = m.enum_all([2,2])
&gt;&gt;&gt; list(list_visitor(state, 'ab') for state in states)
[[['a', 'a', 'b', 'b']],
[['a', 'a', 'b'], ['b']],
[['a', 'a'], ['b', 'b']],
[['a', 'a'], ['b'], ['b']],
[['a', 'b', 'b'], ['a']],
[['a', 'b'], ['a', 'b']],
[['a', 'b'], ['a'], ['b']],
[['a'], ['a'], ['b', 'b']],
[['a'], ['a'], ['b'], ['b']]]

See Also
========

multiset_partitions_taocp:
    which provides the same result as this method, but is
    about twice as fast.  Hence, enum_all is primarily useful
    for testing.  Also see the function for a discussion of
    states and visitors.</pre> 
</div>
</div>
<a id="a778570c71afe06fab179767d67ad3909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778570c71afe06fab179767d67ad3909">&#9670;&nbsp;</a></span>enum_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.enum_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerate the partitions of a multiset.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; states = m.enum_all([2,2])
&gt;&gt;&gt; list(list_visitor(state, 'ab') for state in states)
[[['a', 'a', 'b', 'b']],
[['a', 'a', 'b'], ['b']],
[['a', 'a'], ['b', 'b']],
[['a', 'a'], ['b'], ['b']],
[['a', 'b', 'b'], ['a']],
[['a', 'b'], ['a', 'b']],
[['a', 'b'], ['a'], ['b']],
[['a'], ['a'], ['b', 'b']],
[['a'], ['a'], ['b'], ['b']]]

See Also
========

multiset_partitions_taocp:
    which provides the same result as this method, but is
    about twice as fast.  Hence, enum_all is primarily useful
    for testing.  Also see the function for a discussion of
    states and visitors.</pre> 
</div>
</div>
<a id="a0a9a58033f7ac6651340969ad03003c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9a58033f7ac6651340969ad03003c9">&#9670;&nbsp;</a></span>enum_large() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.enum_large </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerate the partitions of a multiset with lb &lt; num(parts)

Equivalent to enum_range(multiplicities, lb, sum(multiplicities))

Parameters
==========

multiplicities
    list of multiplicities of the components of the multiset.

lb
    Number of parts in the partition must be greater than
    this lower bound.


Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; states = m.enum_large([2,2], 2)
&gt;&gt;&gt; list(list_visitor(state, 'ab') for state in states)
[[['a', 'a'], ['b'], ['b']],
[['a', 'b'], ['a'], ['b']],
[['a'], ['a'], ['b', 'b']],
[['a'], ['a'], ['b'], ['b']]]

See Also
========

enum_all, enum_small, enum_range</pre> 
</div>
</div>
<a id="a0a9a58033f7ac6651340969ad03003c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9a58033f7ac6651340969ad03003c9">&#9670;&nbsp;</a></span>enum_large() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.enum_large </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerate the partitions of a multiset with lb &lt; num(parts)

Equivalent to enum_range(multiplicities, lb, sum(multiplicities))

Parameters
==========

multiplicities
    list of multiplicities of the components of the multiset.

lb
    Number of parts in the partition must be greater than
    this lower bound.


Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; states = m.enum_large([2,2], 2)
&gt;&gt;&gt; list(list_visitor(state, 'ab') for state in states)
[[['a', 'a'], ['b'], ['b']],
[['a', 'b'], ['a'], ['b']],
[['a'], ['a'], ['b', 'b']],
[['a'], ['a'], ['b'], ['b']]]

See Also
========

enum_all, enum_small, enum_range</pre> 
</div>
</div>
<a id="a1df1af5a326664280e466bb1b49a30c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df1af5a326664280e466bb1b49a30c7">&#9670;&nbsp;</a></span>enum_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.enum_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerate the partitions of a multiset with
``lb &lt; num(parts) &lt;= ub``.

In particular, if partitions with exactly ``k`` parts are
desired, call with ``(multiplicities, k - 1, k)``.  This
method generalizes enum_all, enum_small, and enum_large.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; states = m.enum_range([2,2], 1, 2)
&gt;&gt;&gt; list(list_visitor(state, 'ab') for state in states)
[[['a', 'a', 'b'], ['b']],
[['a', 'a'], ['b', 'b']],
[['a', 'b', 'b'], ['a']],
[['a', 'b'], ['a', 'b']]]</pre> 
</div>
</div>
<a id="a1df1af5a326664280e466bb1b49a30c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df1af5a326664280e466bb1b49a30c7">&#9670;&nbsp;</a></span>enum_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.enum_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerate the partitions of a multiset with
``lb &lt; num(parts) &lt;= ub``.

In particular, if partitions with exactly ``k`` parts are
desired, call with ``(multiplicities, k - 1, k)``.  This
method generalizes enum_all, enum_small, and enum_large.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; states = m.enum_range([2,2], 1, 2)
&gt;&gt;&gt; list(list_visitor(state, 'ab') for state in states)
[[['a', 'a', 'b'], ['b']],
[['a', 'a'], ['b', 'b']],
[['a', 'b', 'b'], ['a']],
[['a', 'b'], ['a', 'b']]]</pre> 
</div>
</div>
<a id="a1dc88ce003d89967fd71c46398ab937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc88ce003d89967fd71c46398ab937a">&#9670;&nbsp;</a></span>enum_small() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.enum_small </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerate multiset partitions with no more than ``ub`` parts.

Equivalent to enum_range(multiplicities, 0, ub)

Parameters
==========

multiplicities
     list of multiplicities of the components of the multiset.

ub
    Maximum number of parts

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; states = m.enum_small([2,2], 2)
&gt;&gt;&gt; list(list_visitor(state, 'ab') for state in states)
[[['a', 'a', 'b', 'b']],
[['a', 'a', 'b'], ['b']],
[['a', 'a'], ['b', 'b']],
[['a', 'b', 'b'], ['a']],
[['a', 'b'], ['a', 'b']]]

The implementation is based, in part, on the answer given to
exercise 69, in Knuth [AOCP]_.

See Also
========

enum_all, enum_large, enum_range</pre> 
</div>
</div>
<a id="a1dc88ce003d89967fd71c46398ab937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc88ce003d89967fd71c46398ab937a">&#9670;&nbsp;</a></span>enum_small() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.enum_small </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerate multiset partitions with no more than ``ub`` parts.

Equivalent to enum_range(multiplicities, 0, ub)

Parameters
==========

multiplicities
     list of multiplicities of the components of the multiset.

ub
    Maximum number of parts

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser
&gt;&gt;&gt; m = MultisetPartitionTraverser()
&gt;&gt;&gt; states = m.enum_small([2,2], 2)
&gt;&gt;&gt; list(list_visitor(state, 'ab') for state in states)
[[['a', 'a', 'b', 'b']],
[['a', 'a', 'b'], ['b']],
[['a', 'a'], ['b', 'b']],
[['a', 'b', 'b'], ['a']],
[['a', 'b'], ['a', 'b']]]

The implementation is based, in part, on the answer given to
exercise 69, in Knuth [AOCP]_.

See Also
========

enum_all, enum_large, enum_range</pre> 
</div>
</div>
<a id="af706d244e9439f2cd889a17ef1ce9c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af706d244e9439f2cd889a17ef1ce9c71">&#9670;&nbsp;</a></span>spread_part_multiplicity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.spread_part_multiplicity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if a new part has been created, and
adjusts pstack, f and lpart as needed.

Notes
=====

Spreads unallocated multiplicity from the current top part
into a new part created above the current on the stack.  This
new part is constrained to be less than or equal to the old in
terms of the part ordering.

This call does nothing (and returns False) if the current top
part has no unallocated multiplicity.</pre> 
</div>
</div>
<a id="af706d244e9439f2cd889a17ef1ce9c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af706d244e9439f2cd889a17ef1ce9c71">&#9670;&nbsp;</a></span>spread_part_multiplicity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.spread_part_multiplicity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if a new part has been created, and
adjusts pstack, f and lpart as needed.

Notes
=====

Spreads unallocated multiplicity from the current top part
into a new part created above the current on the stack.  This
new part is constrained to be less than or equal to the old in
terms of the part ordering.

This call does nothing (and returns False) if the current top
part has no unallocated multiplicity.</pre> 
</div>
</div>
<a id="a31a39ca66bddf8e7d2ee150e3df71ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a39ca66bddf8e7d2ee150e3df71ad3">&#9670;&nbsp;</a></span>top_part() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.top_part </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return current top part on the stack, as a slice of pstack.</pre> 
</div>
</div>
<a id="a31a39ca66bddf8e7d2ee150e3df71ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a39ca66bddf8e7d2ee150e3df71ad3">&#9670;&nbsp;</a></span>top_part() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.MultisetPartitionTraverser.top_part </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return current top part on the stack, as a slice of pstack.</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a706bbc8f028640707083a4dcd653b7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706bbc8f028640707083a4dcd653b7bd">&#9670;&nbsp;</a></span>debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.debug</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8606ce3eb483bf24fa5541257a0f5dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8606ce3eb483bf24fa5541257a0f5dfc">&#9670;&nbsp;</a></span>discarded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.discarded</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae210d4303c6bbc24c2922634a7778171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae210d4303c6bbc24c2922634a7778171">&#9670;&nbsp;</a></span>dp_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.dp_map</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad85b5ccf5da93576868fbe164ffcd8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85b5ccf5da93576868fbe164ffcd8d5">&#9670;&nbsp;</a></span>dp_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.dp_stack</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35e1f7239badae76e124e747dc51c7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e1f7239badae76e124e747dc51c7ef">&#9670;&nbsp;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.f</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef3ad7c5567df7a91996175088ad0534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3ad7c5567df7a91996175088ad0534">&#9670;&nbsp;</a></span>k1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.k1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a295f5766517f967d348db94f7b0f578a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295f5766517f967d348db94f7b0f578a">&#9670;&nbsp;</a></span>k2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.k2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad55e4027c9e95f02175b888e614b5916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55e4027c9e95f02175b888e614b5916">&#9670;&nbsp;</a></span>lpart</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.lpart</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace175d6f3dad6ee6071492f992c1236e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace175d6f3dad6ee6071492f992c1236e">&#9670;&nbsp;</a></span>p1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.p1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d8d9cf0e3266126f35004fd58c01a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8d9cf0e3266126f35004fd58c01a07">&#9670;&nbsp;</a></span>pcount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.pcount</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a749d21988c1b9941f4f63d8013a3490e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749d21988c1b9941f4f63d8013a3490e">&#9670;&nbsp;</a></span>pstack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.utilities.enumerative.MultisetPartitionTraverser.pstack</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/sympy/utilities/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2sympy_2utilities_2enumerative_8py.html">enumerative.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
