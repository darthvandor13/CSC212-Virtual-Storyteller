<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.polys.matrices.dense Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys.html">polys</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys_1_1matrices.html">matrices</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html">dense</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.polys.matrices.dense Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a730904826a0f7ece02d50b2bb47a5f2a"><td class="memItemLeft" align="right" valign="top">list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a835f8c0c54789f9e64fdc753ed098b65">T</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a730904826a0f7ece02d50b2bb47a5f2a">ddm_transpose</a> (Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a835f8c0c54789f9e64fdc753ed098b65">T</a>]] matrix)</td></tr>
<tr class="separator:a730904826a0f7ece02d50b2bb47a5f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b119d9df67febde33b2b6102ec3cf9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a42b119d9df67febde33b2b6102ec3cf9">ddm_iadd</a> (list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] a, Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] b)</td></tr>
<tr class="separator:a42b119d9df67febde33b2b6102ec3cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb0180ccc70a2260944401447658d0f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a4bb0180ccc70a2260944401447658d0f">ddm_isub</a> (list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] a, Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] b)</td></tr>
<tr class="separator:a4bb0180ccc70a2260944401447658d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff348cda8a6561a249dba311a9f9839"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a7ff348cda8a6561a249dba311a9f9839">ddm_ineg</a> (list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] a)</td></tr>
<tr class="separator:a7ff348cda8a6561a249dba311a9f9839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77549905540b0cf98ec1a87b109cf002"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a77549905540b0cf98ec1a87b109cf002">ddm_imul</a> (list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] a, <a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a> b)</td></tr>
<tr class="separator:a77549905540b0cf98ec1a87b109cf002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c1e08ae51563dce0332ea9f5b19f07"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ad5c1e08ae51563dce0332ea9f5b19f07">ddm_irmul</a> (list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] a, <a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a> b)</td></tr>
<tr class="separator:ad5c1e08ae51563dce0332ea9f5b19f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8e0e51d6df5141f5a42d68319460db"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#afe8e0e51d6df5141f5a42d68319460db">ddm_imatmul</a> (list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] a, Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] b, Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]] c)</td></tr>
<tr class="separator:afe8e0e51d6df5141f5a42d68319460db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5ad4ac798da8b50597b74e54a33cc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a1b5ad4ac798da8b50597b74e54a33cc0">ddm_irref</a> (a, _partial_pivot=False)</td></tr>
<tr class="separator:a1b5ad4ac798da8b50597b74e54a33cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaa6b53e0a2258837f3def77219534e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#abfaa6b53e0a2258837f3def77219534e">ddm_irref_den</a> (a, K)</td></tr>
<tr class="separator:abfaa6b53e0a2258837f3def77219534e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638c4483e7e4dd575df46991f9d76139"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a638c4483e7e4dd575df46991f9d76139">ddm_idet</a> (a, K)</td></tr>
<tr class="separator:a638c4483e7e4dd575df46991f9d76139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49af44106cf7273f73c68b5a7d487e9f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a49af44106cf7273f73c68b5a7d487e9f">ddm_iinv</a> (ainv, a, K)</td></tr>
<tr class="separator:a49af44106cf7273f73c68b5a7d487e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a86e545dc019441d17f9739121abbe9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a2a86e545dc019441d17f9739121abbe9">ddm_ilu_split</a> (L, U, K)</td></tr>
<tr class="separator:a2a86e545dc019441d17f9739121abbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2014370c07c1597a511164fc1ef47b80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a2014370c07c1597a511164fc1ef47b80">ddm_ilu</a> (a)</td></tr>
<tr class="separator:a2014370c07c1597a511164fc1ef47b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328078a0ee73fcbcb101c1d73b371ee5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a328078a0ee73fcbcb101c1d73b371ee5">ddm_ilu_solve</a> (x, L, U, swaps, b)</td></tr>
<tr class="separator:a328078a0ee73fcbcb101c1d73b371ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff4d527ba5643aad21c68812d454c2c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#acff4d527ba5643aad21c68812d454c2c">ddm_berk</a> (M, K)</td></tr>
<tr class="separator:acff4d527ba5643aad21c68812d454c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a835f8c0c54789f9e64fdc753ed098b65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a835f8c0c54789f9e64fdc753ed098b65">T</a> = TypeVar('T')</td></tr>
<tr class="separator:a835f8c0c54789f9e64fdc753ed098b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dac05bd1f856b036ba11b3525ecb82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a> = TypeVar('R', bound=<a class="el" href="classsympy_1_1polys_1_1matrices_1_1__typing_1_1RingElement.html">RingElement</a>)</td></tr>
<tr class="separator:ab9dac05bd1f856b036ba11b3525ecb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Module for the ddm_* routines for operating on a matrix in list of lists
matrix representation.

These routines are used internally by the DDM class which also provides a
friendlier interface for them. The idea here is to implement core matrix
routines in a way that can be applied to any simple list representation
without the need to use any particular matrix class. For example we can
compute the RREF of a matrix like:

    &gt;&gt;&gt; from sympy.polys.matrices.dense import ddm_irref
    &gt;&gt;&gt; M = [[1, 2, 3], [4, 5, 6]]
    &gt;&gt;&gt; pivots = ddm_irref(M)
    &gt;&gt;&gt; M
    [[1.0, 0.0, -1.0], [0, 1.0, 2.0]]

These are lower-level routines that work mostly in place.The routines at this
level should not need to know what the domain of the elements is but should
ideally document what operations they will use and what functions they need to
be provided with.

The next-level up is the DDM class which uses these routines but wraps them up
with an interface that handles copying etc and keeps track of the Domain of
the elements of the matrix:

    &gt;&gt;&gt; from sympy.polys.domains import QQ
    &gt;&gt;&gt; from sympy.polys.matrices.ddm import DDM
    &gt;&gt;&gt; M = DDM([[QQ(1), QQ(2), QQ(3)], [QQ(4), QQ(5), QQ(6)]], (2, 3), QQ)
    &gt;&gt;&gt; M
    [[1, 2, 3], [4, 5, 6]]
    &gt;&gt;&gt; Mrref, pivots = M.rref()
    &gt;&gt;&gt; Mrref
    [[1, 0, -1], [0, 1, 2]]</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="acff4d527ba5643aad21c68812d454c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff4d527ba5643aad21c68812d454c2c">&#9670;&nbsp;</a></span>ddm_berk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.dense.ddm_berk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Berkowitz algorithm for computing the characteristic polynomial.

Explanation
===========

The Berkowitz algorithm is a division-free algorithm for computing the
characteristic polynomial of a matrix over any commutative ring using only
arithmetic in the coefficient ring.

Examples
========

&gt;&gt;&gt; from sympy import Matrix
&gt;&gt;&gt; from sympy.polys.matrices.dense import ddm_berk
&gt;&gt;&gt; from sympy.polys.domains import ZZ
&gt;&gt;&gt; M = [[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]]
&gt;&gt;&gt; ddm_berk(M, ZZ)
[[1], [-5], [-2]]
&gt;&gt;&gt; Matrix(M).charpoly()
PurePoly(lambda**2 - 5*lambda - 2, lambda, domain='ZZ')

See Also
========

sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly
    The high-level interface to this function.

References
==========

.. [1] https://en.wikipedia.org/wiki/Samuelson%E2%80%93Berkowitz_algorithm
</pre> 
</div>
</div>
<a id="a42b119d9df67febde33b2b6102ec3cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b119d9df67febde33b2b6102ec3cf9">&#9670;&nbsp;</a></span>ddm_iadd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None sympy.polys.matrices.dense.ddm_iadd </td>
          <td>(</td>
          <td class="paramtype">list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a += b</pre> 
</div>
</div>
<a id="a638c4483e7e4dd575df46991f9d76139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638c4483e7e4dd575df46991f9d76139">&#9670;&nbsp;</a></span>ddm_idet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.dense.ddm_idet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a  &lt;--  echelon(a); return det

Explanation
===========

Compute the determinant of $a$ using the Bareiss fraction-free algorithm.
The matrix $a$ is modified in place. Its diagonal elements are the
determinants of the leading principal minors. The determinant of $a$ is
returned.

The domain $K$ must support exact division (``K.exquo``). This method is
suitable for most exact rings and fields like :ref:`ZZ`, :ref:`QQ` and
:ref:`QQ(a)` but not for inexact domains like :ref:`RR` and :ref:`CC`.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices.ddm import ddm_idet
&gt;&gt;&gt; a = [[ZZ(1), ZZ(2), ZZ(3)], [ZZ(4), ZZ(5), ZZ(6)], [ZZ(7), ZZ(8), ZZ(9)]]
&gt;&gt;&gt; a
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; ddm_idet(a, ZZ)
0
&gt;&gt;&gt; a
[[1, 2, 3], [4, -3, -6], [7, -6, 0]]
&gt;&gt;&gt; [a[i][i] for i in range(len(a))]
[1, -3, 0]

See Also
========

sympy.polys.matrices.domainmatrix.DomainMatrix.det

References
==========

.. [1] https://en.wikipedia.org/wiki/Bareiss_algorithm
.. [2] https://www.math.usm.edu/perry/Research/Thesis_DRL.pdf
</pre> 
</div>
</div>
<a id="a49af44106cf7273f73c68b5a7d487e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49af44106cf7273f73c68b5a7d487e9f">&#9670;&nbsp;</a></span>ddm_iinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.dense.ddm_iinv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ainv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">ainv  &lt;--  inv(a)

Compute the inverse of a matrix $a$ over a field $K$ using Gauss-Jordan
elimination. The result is stored in $ainv$.

Uses division in the ground domain which should be an exact field.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices.ddm import ddm_iinv, ddm_imatmul
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; a = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]
&gt;&gt;&gt; ainv = [[None, None], [None, None]]
&gt;&gt;&gt; ddm_iinv(ainv, a, QQ)
&gt;&gt;&gt; ainv
[[-2, 1], [3/2, -1/2]]
&gt;&gt;&gt; result = [[QQ(0), QQ(0)], [QQ(0), QQ(0)]]
&gt;&gt;&gt; ddm_imatmul(result, a, ainv)
&gt;&gt;&gt; result
[[1, 0], [0, 1]]

See Also
========

ddm_irref: the underlying routine.
</pre> 
</div>
</div>
<a id="a2014370c07c1597a511164fc1ef47b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2014370c07c1597a511164fc1ef47b80">&#9670;&nbsp;</a></span>ddm_ilu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.dense.ddm_ilu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a  &lt;--  LU(a)

Computes the LU decomposition of a matrix in place. Returns a list of
row swaps that were performed.

Uses division in the ground domain which should be an exact field.

This is only suitable for domains like :ref:`GF(p)`, :ref:`QQ`, :ref:`QQ_I`
and :ref:`QQ(a)`. With a rational function field like :ref:`K(x)` it is
better to clear denominators and use division-free algorithms. Pivoting is
used to avoid exact zeros but not for floating point accuracy so :ref:`RR`
and :ref:`CC` are not suitable (use :func:`ddm_irref` instead).

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices.dense import ddm_ilu
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; a = [[QQ(1, 2), QQ(1, 3)], [QQ(1, 4), QQ(1, 5)]]
&gt;&gt;&gt; swaps = ddm_ilu(a)
&gt;&gt;&gt; swaps
[]
&gt;&gt;&gt; a
[[1/2, 1/3], [1/2, 1/30]]

The same example using ``Matrix``:

&gt;&gt;&gt; from sympy import Matrix, S
&gt;&gt;&gt; M = Matrix([[S(1)/2, S(1)/3], [S(1)/4, S(1)/5]])
&gt;&gt;&gt; L, U, swaps = M.LUdecomposition()
&gt;&gt;&gt; L
Matrix([
[  1, 0],
[1/2, 1]])
&gt;&gt;&gt; U
Matrix([
[1/2,  1/3],
[  0, 1/30]])
&gt;&gt;&gt; swaps
[]

See Also
========

ddm_irref
ddm_ilu_solve
sympy.matrices.matrixbase.MatrixBase.LUdecomposition
</pre> 
</div>
</div>
<a id="a328078a0ee73fcbcb101c1d73b371ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328078a0ee73fcbcb101c1d73b371ee5">&#9670;&nbsp;</a></span>ddm_ilu_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.dense.ddm_ilu_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>swaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">x  &lt;--  solve(L*U*x = swaps(b))

Solve a linear system, $A*x = b$, given an LU factorization of $A$.

Uses division in the ground domain which must be a field.

Modifies $x$ in place.

Examples
========

Compute the LU decomposition of $A$ (in place):

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices.dense import ddm_ilu, ddm_ilu_solve
&gt;&gt;&gt; A = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]
&gt;&gt;&gt; swaps = ddm_ilu(A)
&gt;&gt;&gt; A
[[1, 2], [3, -2]]
&gt;&gt;&gt; L = U = A

Solve the linear system:

&gt;&gt;&gt; b = [[QQ(5)], [QQ(6)]]
&gt;&gt;&gt; x = [[None], [None]]
&gt;&gt;&gt; ddm_ilu_solve(x, L, U, swaps, b)
&gt;&gt;&gt; x
[[-4], [9/2]]

See Also
========

ddm_ilu
    Compute the LU decomposition of a matrix in place.
ddm_ilu_split
    Compute the LU decomposition of a matrix and separate $L$ and $U$.
sympy.polys.matrices.domainmatrix.DomainMatrix.lu_solve
    Higher level interface to this function.
</pre> 
</div>
</div>
<a id="a2a86e545dc019441d17f9739121abbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a86e545dc019441d17f9739121abbe9">&#9670;&nbsp;</a></span>ddm_ilu_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.dense.ddm_ilu_split </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">L, U  &lt;--  LU(U)

Compute the LU decomposition of a matrix $L$ in place and store the lower
and upper triangular matrices in $L$ and $U$, respectively. Returns a list
of row swaps that were performed.

Uses division in the ground domain which should be an exact field.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices.ddm import ddm_ilu_split
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; L = [[QQ(0), QQ(0)], [QQ(0), QQ(0)]]
&gt;&gt;&gt; U = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]
&gt;&gt;&gt; swaps = ddm_ilu_split(L, U, QQ)
&gt;&gt;&gt; swaps
[]
&gt;&gt;&gt; L
[[0, 0], [3, 0]]
&gt;&gt;&gt; U
[[1, 2], [0, -2]]

See Also
========

ddm_ilu
ddm_ilu_solve
</pre> 
</div>
</div>
<a id="afe8e0e51d6df5141f5a42d68319460db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8e0e51d6df5141f5a42d68319460db">&#9670;&nbsp;</a></span>ddm_imatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None sympy.polys.matrices.dense.ddm_imatmul </td>
          <td>(</td>
          <td class="paramtype">list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]
&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a += b @ c</pre> 
</div>
</div>
<a id="a77549905540b0cf98ec1a87b109cf002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77549905540b0cf98ec1a87b109cf002">&#9670;&nbsp;</a></span>ddm_imul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None sympy.polys.matrices.dense.ddm_imul </td>
          <td>(</td>
          <td class="paramtype">list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a &lt;-- a*b</pre> 
</div>
</div>
<a id="a7ff348cda8a6561a249dba311a9f9839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff348cda8a6561a249dba311a9f9839">&#9670;&nbsp;</a></span>ddm_ineg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None sympy.polys.matrices.dense.ddm_ineg </td>
          <td>(</td>
          <td class="paramtype">list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a &lt;-- -a</pre> 
</div>
</div>
<a id="ad5c1e08ae51563dce0332ea9f5b19f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c1e08ae51563dce0332ea9f5b19f07">&#9670;&nbsp;</a></span>ddm_irmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None sympy.polys.matrices.dense.ddm_irmul </td>
          <td>(</td>
          <td class="paramtype">list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a &lt;-- b*a</pre> 
</div>
</div>
<a id="a1b5ad4ac798da8b50597b74e54a33cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5ad4ac798da8b50597b74e54a33cc0">&#9670;&nbsp;</a></span>ddm_irref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.dense.ddm_irref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_partial_pivot</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">In-place reduced row echelon form of a matrix.

Compute the reduced row echelon form of $a$. Modifies $a$ in place and
returns a list of the pivot columns.

Uses naive Gauss-Jordan elimination in the ground domain which must be a
field.

This routine is only really suitable for use with simple field domains like
:ref:`GF(p)`, :ref:`QQ` and :ref:`QQ(a)` although even for :ref:`QQ` with
larger matrices it is possibly more efficient to use fraction free
approaches.

This method is not suitable for use with rational function fields
(:ref:`K(x)`) because the elements will blowup leading to costly gcd
operations. In this case clearing denominators and using fraction free
approaches is likely to be more efficient.

For inexact numeric domains like :ref:`RR` and :ref:`CC` pass
``_partial_pivot=True`` to use partial pivoting to control rounding errors.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices.dense import ddm_irref
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; M = [[QQ(1), QQ(2), QQ(3)], [QQ(4), QQ(5), QQ(6)]]
&gt;&gt;&gt; pivots = ddm_irref(M)
&gt;&gt;&gt; M
[[1, 0, -1], [0, 1, 2]]
&gt;&gt;&gt; pivots
[0, 1]

See Also
========

sympy.polys.matrices.domainmatrix.DomainMatrix.rref
    Higher level interface to this routine.
ddm_irref_den
    The fraction free version of this routine.
sdm_irref
    A sparse version of this routine.

References
==========

.. [1] https://en.wikipedia.org/wiki/Row_echelon_form#Reduced_row_echelon_form
</pre> 
</div>
</div>
<a id="abfaa6b53e0a2258837f3def77219534e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfaa6b53e0a2258837f3def77219534e">&#9670;&nbsp;</a></span>ddm_irref_den()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.dense.ddm_irref_den </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a  &lt;--  rref(a); return (den, pivots)

Compute the fraction-free reduced row echelon form (RREF) of $a$. Modifies
$a$ in place and returns a tuple containing the denominator of the RREF and
a list of the pivot columns.

Explanation
===========

The algorithm used is the fraction-free version of Gauss-Jordan elimination
described as FFGJ in [1]_. Here it is modified to handle zero or missing
pivots and to avoid redundant arithmetic.

The domain $K$ must support exact division (``K.exquo``) but does not need
to be a field. This method is suitable for most exact rings and fields like
:ref:`ZZ`, :ref:`QQ` and :ref:`QQ(a)`. In the case of :ref:`QQ` or
:ref:`K(x)` it might be more efficient to clear denominators and use
:ref:`ZZ` or :ref:`K[x]` instead.

For inexact domains like :ref:`RR` and :ref:`CC` use ``ddm_irref`` instead.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices.dense import ddm_irref_den
&gt;&gt;&gt; from sympy import ZZ, Matrix
&gt;&gt;&gt; M = [[ZZ(1), ZZ(2), ZZ(3)], [ZZ(4), ZZ(5), ZZ(6)]]
&gt;&gt;&gt; den, pivots = ddm_irref_den(M, ZZ)
&gt;&gt;&gt; M
[[-3, 0, 3], [0, -3, -6]]
&gt;&gt;&gt; den
-3
&gt;&gt;&gt; pivots
[0, 1]
&gt;&gt;&gt; Matrix(M).rref()[0]
Matrix([
[1, 0, -1],
[0, 1,  2]])

See Also
========

ddm_irref
    A version of this routine that uses field division.
sdm_irref
    A sparse version of :func:`ddm_irref`.
sdm_rref_den
    A sparse version of :func:`ddm_irref_den`.
sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den
    Higher level interface.

References
==========

.. [1] Fraction-free algorithms for linear and polynomial equations.
    George C. Nakos , Peter R. Turner , Robert M. Williams.
    https://dl.acm.org/doi/10.1145/271130.271133
</pre> 
</div>
</div>
<a id="a4bb0180ccc70a2260944401447658d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb0180ccc70a2260944401447658d0f">&#9670;&nbsp;</a></span>ddm_isub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None sympy.polys.matrices.dense.ddm_isub </td>
          <td>(</td>
          <td class="paramtype">list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#ab9dac05bd1f856b036ba11b3525ecb82">R</a>]]&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a -= b</pre> 
</div>
</div>
<a id="a730904826a0f7ece02d50b2bb47a5f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730904826a0f7ece02d50b2bb47a5f2a">&#9670;&nbsp;</a></span>ddm_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[list[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a835f8c0c54789f9e64fdc753ed098b65">T</a>]] sympy.polys.matrices.dense.ddm_transpose </td>
          <td>(</td>
          <td class="paramtype">Sequence[Sequence[<a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1dense.html#a835f8c0c54789f9e64fdc753ed098b65">T</a>]]&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">matrix transpose</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab9dac05bd1f856b036ba11b3525ecb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dac05bd1f856b036ba11b3525ecb82">&#9670;&nbsp;</a></span>R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.matrices.dense.R = TypeVar('R', bound=<a class="el" href="classsympy_1_1polys_1_1matrices_1_1__typing_1_1RingElement.html">RingElement</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a835f8c0c54789f9e64fdc753ed098b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835f8c0c54789f9e64fdc753ed098b65">&#9670;&nbsp;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.matrices.dense.T = TypeVar('T')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
