<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.calculus.differentiation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html">differentiation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.calculus.differentiation Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a70616b17becd4288517f77436d3061ec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a70616b17becd4288517f77436d3061ec">difference</a> (ctx, s, n)</td></tr>
<tr class="separator:a70616b17becd4288517f77436d3061ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370b2433c31335029f11500bf45c4ce9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a370b2433c31335029f11500bf45c4ce9">hsteps</a> (ctx, f, x, n, prec, **options)</td></tr>
<tr class="separator:a370b2433c31335029f11500bf45c4ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd468897a05c39ae816285a1a4f10c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#afbd468897a05c39ae816285a1a4f10c7">diff</a> (ctx, f, x, n=1, **options)</td></tr>
<tr class="separator:afbd468897a05c39ae816285a1a4f10c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3fbe65496d243cb645972e91ab47f1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a6d3fbe65496d243cb645972e91ab47f1">diffs</a> (ctx, f, x, n=None, **options)</td></tr>
<tr class="separator:a6d3fbe65496d243cb645972e91ab47f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470495d6bc8c2cce0e3ff38353a41ffa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a470495d6bc8c2cce0e3ff38353a41ffa">iterable_to_function</a> (gen)</td></tr>
<tr class="separator:a470495d6bc8c2cce0e3ff38353a41ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1a54b556a8cf7293e711ffe75210d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a3af1a54b556a8cf7293e711ffe75210d">diffs_prod</a> (ctx, factors)</td></tr>
<tr class="separator:a3af1a54b556a8cf7293e711ffe75210d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6876cf8deec273d409740cf41005cc7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#af6876cf8deec273d409740cf41005cc7">dpoly</a> (n, _cache={})</td></tr>
<tr class="separator:af6876cf8deec273d409740cf41005cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9f78d3695b7233c876e79ba7674b62"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a1d9f78d3695b7233c876e79ba7674b62">diffs_exp</a> (ctx, fdiffs)</td></tr>
<tr class="separator:a1d9f78d3695b7233c876e79ba7674b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b44ca0e4d029da3fe131317c94127db"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a6b44ca0e4d029da3fe131317c94127db">differint</a> (ctx, f, x, n=1, x0=0)</td></tr>
<tr class="separator:a6b44ca0e4d029da3fe131317c94127db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf80a59e9b20420fd5d82899f2d7d2c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#aaaf80a59e9b20420fd5d82899f2d7d2c">diffun</a> (ctx, f, n=1, **options)</td></tr>
<tr class="separator:aaaf80a59e9b20420fd5d82899f2d7d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdfd0639fd4cc7610ee14e3df03a482"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a6cdfd0639fd4cc7610ee14e3df03a482">taylor</a> (ctx, f, x, n, **options)</td></tr>
<tr class="separator:a6cdfd0639fd4cc7610ee14e3df03a482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53634822f19c7c058d72616241d393f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#ad53634822f19c7c058d72616241d393f">pade</a> (ctx, a, L, M)</td></tr>
<tr class="separator:ad53634822f19c7c058d72616241d393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0abc5f62e64b4452591640aba290e213"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1differentiation.html#a0abc5f62e64b4452591640aba290e213">iteritems</a> = dict.iteritems</td></tr>
<tr class="separator:a0abc5f62e64b4452591640aba290e213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afbd468897a05c39ae816285a1a4f10c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd468897a05c39ae816285a1a4f10c7">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Numerically computes the derivative of `f`, `f'(x)`, or generally for
an integer `n \ge 0`, the `n`-th derivative `f^{(n)}(x)`.
A few basic examples are::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; diff(lambda x: x**2 + x, 1.0)
    3.0
    &gt;&gt;&gt; diff(lambda x: x**2 + x, 1.0, 2)
    2.0
    &gt;&gt;&gt; diff(lambda x: x**2 + x, 1.0, 3)
    0.0
    &gt;&gt;&gt; nprint([diff(exp, 3, n) for n in range(5)])   # exp'(x) = exp(x)
    [20.0855, 20.0855, 20.0855, 20.0855, 20.0855]

Even more generally, given a tuple of arguments `(x_1, \ldots, x_k)`
and order `(n_1, \ldots, n_k)`, the partial derivative
`f^{(n_1,\ldots,n_k)}(x_1,\ldots,x_k)` is evaluated. For example::

    &gt;&gt;&gt; diff(lambda x,y: 3*x*y + 2*y - x, (0.25, 0.5), (0,1))
    2.75
    &gt;&gt;&gt; diff(lambda x,y: 3*x*y + 2*y - x, (0.25, 0.5), (1,1))
    3.0

**Options**

The following optional keyword arguments are recognized:

``method``
    Supported methods are ``'step'`` or ``'quad'``: derivatives may be
    computed using either a finite difference with a small step
    size `h` (default), or numerical quadrature.
``direction``
    Direction of finite difference: can be -1 for a left
    difference, 0 for a central difference (default), or +1
    for a right difference; more generally can be any complex number.
``addprec``
    Extra precision for `h` used to account for the function's
    sensitivity to perturbations (default = 10).
``relative``
    Choose `h` relative to the magnitude of `x`, rather than an
    absolute value; useful for large or tiny `x` (default = False).
``h``
    As an alternative to ``addprec`` and ``relative``, manually
    select the step size `h`.
``singular``
    If True, evaluation exactly at the point `x` is avoided; this is
    useful for differentiating functions with removable singularities.
    Default = False.
``radius``
    Radius of integration contour (with ``method = 'quad'``).
    Default = 0.25. A larger radius typically is faster and more
    accurate, but it must be chosen so that `f` has no
    singularities within the radius from the evaluation point.

A finite difference requires `n+1` function evaluations and must be
performed at `(n+1)` times the target precision. Accordingly, `f` must
support fast evaluation at high precision.

With integration, a larger number of function evaluations is
required, but not much extra precision is required. For high order
derivatives, this method may thus be faster if f is very expensive to
evaluate at high precision.

**Further examples**

The direction option is useful for computing left- or right-sided
derivatives of nonsmooth functions::

    &gt;&gt;&gt; diff(abs, 0, direction=0)
    0.0
    &gt;&gt;&gt; diff(abs, 0, direction=1)
    1.0
    &gt;&gt;&gt; diff(abs, 0, direction=-1)
    -1.0

More generally, if the direction is nonzero, a right difference
is computed where the step size is multiplied by sign(direction).
For example, with direction=+j, the derivative from the positive
imaginary direction will be computed::

    &gt;&gt;&gt; diff(abs, 0, direction=j)
    (0.0 - 1.0j)

With integration, the result may have a small imaginary part
even even if the result is purely real::

    &gt;&gt;&gt; diff(sqrt, 1, method='quad')    # doctest:+ELLIPSIS
    (0.5 - 4.59...e-26j)
    &gt;&gt;&gt; chop(_)
    0.5

Adding precision to obtain an accurate value::

    &gt;&gt;&gt; diff(cos, 1e-30)
    0.0
    &gt;&gt;&gt; diff(cos, 1e-30, h=0.0001)
    -9.99999998328279e-31
    &gt;&gt;&gt; diff(cos, 1e-30, addprec=100)
    -1.0e-30</pre> 
</div>
</div>
<a id="a70616b17becd4288517f77436d3061ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70616b17becd4288517f77436d3061ec">&#9670;&nbsp;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a sequence `(s_k)` containing at least `n+1` items, returns the
`n`-th forward difference,

.. math ::

    \Delta^n = \sum_{k=0}^{\infty} (-1)^{k+n} {n \choose k} s_k.
</pre> 
</div>
</div>
<a id="a6b44ca0e4d029da3fe131317c94127db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b44ca0e4d029da3fe131317c94127db">&#9670;&nbsp;</a></span>differint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.differint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the Riemann-Liouville differintegral, or fractional
derivative, defined by

.. math ::

    \,_{x_0}{\mathbb{D}}^n_xf(x) = \frac{1}{\Gamma(m-n)} \frac{d^m}{dx^m}
    \int_{x_0}^{x}(x-t)^{m-n-1}f(t)dt

where `f` is a given (presumably well-behaved) function,
`x` is the evaluation point, `n` is the order, and `x_0` is
the reference point of integration (`m` is an arbitrary
parameter selected automatically).

With `n = 1`, this is just the standard derivative `f'(x)`; with `n = 2`,
the second derivative `f''(x)`, etc. With `n = -1`, it gives
`\int_{x_0}^x f(t) dt`, with `n = -2`
it gives `\int_{x_0}^x \left( \int_{x_0}^t f(u) du \right) dt`, etc.

As `n` is permitted to be any number, this operator generalizes
iterated differentiation and iterated integration to a single
operator with a continuous order parameter.

**Examples**

There is an exact formula for the fractional derivative of a
monomial `x^p`, which may be used as a reference. For example,
the following gives a half-derivative (order 0.5)::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; x = mpf(3); p = 2; n = 0.5
    &gt;&gt;&gt; differint(lambda t: t**p, x, n)
    7.81764019044672
    &gt;&gt;&gt; gamma(p+1)/gamma(p-n+1) * x**(p-n)
    7.81764019044672

Another useful test function is the exponential function, whose
integration / differentiation formula easy generalizes
to arbitrary order. Here we first compute a third derivative,
and then a triply nested integral. (The reference point `x_0`
is set to `-\infty` to avoid nonzero endpoint terms.)::

    &gt;&gt;&gt; differint(lambda x: exp(pi*x), -1.5, 3)
    0.278538406900792
    &gt;&gt;&gt; exp(pi*-1.5) * pi**3
    0.278538406900792
    &gt;&gt;&gt; differint(lambda x: exp(pi*x), 3.5, -3, -inf)
    1922.50563031149
    &gt;&gt;&gt; exp(pi*3.5) / pi**3
    1922.50563031149

However, for noninteger `n`, the differentiation formula for the
exponential function must be modified to give the same result as the
Riemann-Liouville differintegral::

    &gt;&gt;&gt; x = mpf(3.5)
    &gt;&gt;&gt; c = pi
    &gt;&gt;&gt; n = 1+2*j
    &gt;&gt;&gt; differint(lambda x: exp(c*x), x, n)
    (-123295.005390743 + 140955.117867654j)
    &gt;&gt;&gt; x**(-n) * exp(c)**x * (x*c)**n * gammainc(-n, 0, x*c) / gamma(-n)
    (-123295.005390743 + 140955.117867654j)</pre> 
</div>
</div>
<a id="a6d3fbe65496d243cb645972e91ab47f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3fbe65496d243cb645972e91ab47f1">&#9670;&nbsp;</a></span>diffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.diffs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a generator that yields the sequence of derivatives

.. math ::

    f(x), f'(x), f''(x), \ldots, f^{(k)}(x), \ldots

With ``method='step'``, :func:`~mpmath.diffs` uses only `O(k)`
function evaluations to generate the first `k` derivatives,
rather than the roughly `O(k^2)` evaluations
required if one calls :func:`~mpmath.diff` `k` separate times.

With `n &lt; \infty`, the generator stops as soon as the
`n`-th derivative has been generated. If the exact number of
needed derivatives is known in advance, this is further
slightly more efficient.

Options are the same as for :func:`~mpmath.diff`.

**Examples**

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; nprint(list(diffs(cos, 1, 5)))
    [0.540302, -0.841471, -0.540302, 0.841471, 0.540302, -0.841471]
    &gt;&gt;&gt; for i, d in zip(range(6), diffs(cos, 1)):
    ...     print("%s %s" % (i, d))
    ...
    0 0.54030230586814
    1 -0.841470984807897
    2 -0.54030230586814
    3 0.841470984807897
    4 0.54030230586814
    5 -0.841470984807897</pre> 
</div>
</div>
<a id="a1d9f78d3695b7233c876e79ba7674b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9f78d3695b7233c876e79ba7674b62">&#9670;&nbsp;</a></span>diffs_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.diffs_exp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fdiffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given an iterable or generator yielding `f(x), f'(x), f''(x), \ldots`
generate `g(x), g'(x), g''(x), \ldots` where `g(x) = \exp(f(x))`.

At high precision and for large orders, this is typically more efficient
than numerical differentiation if the derivatives of `f(x)`
admit direct computation.

Note: This function does not increase the working precision internally,
so guard digits may have to be added externally for full accuracy.

**Examples**

The derivatives of the gamma function can be computed using
logarithmic differentiation::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt;
    &gt;&gt;&gt; def diffs_loggamma(x):
    ...     yield loggamma(x)
    ...     i = 0
    ...     while 1:
    ...         yield psi(i,x)
    ...         i += 1
    ...
    &gt;&gt;&gt; u = diffs_exp(diffs_loggamma(3))
    &gt;&gt;&gt; v = diffs(gamma, 3)
    &gt;&gt;&gt; next(u); next(v)
    2.0
    2.0
    &gt;&gt;&gt; next(u); next(v)
    1.84556867019693
    1.84556867019693
    &gt;&gt;&gt; next(u); next(v)
    2.49292999190269
    2.49292999190269
    &gt;&gt;&gt; next(u); next(v)
    3.44996501352367
    3.44996501352367</pre> 
</div>
</div>
<a id="a3af1a54b556a8cf7293e711ffe75210d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af1a54b556a8cf7293e711ffe75210d">&#9670;&nbsp;</a></span>diffs_prod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.diffs_prod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a list of `N` iterables or generators yielding
`f_k(x), f'_k(x), f''_k(x), \ldots` for `k = 1, \ldots, N`,
generate `g(x), g'(x), g''(x), \ldots` where
`g(x) = f_1(x) f_2(x) \cdots f_N(x)`.

At high precision and for large orders, this is typically more efficient
than numerical differentiation if the derivatives of each `f_k(x)`
admit direct computation.

Note: This function does not increase the working precision internally,
so guard digits may have to be added externally for full accuracy.

**Examples**

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; f = lambda x: exp(x)*cos(x)*sin(x)
    &gt;&gt;&gt; u = diffs(f, 1)
    &gt;&gt;&gt; v = mp.diffs_prod([diffs(exp,1), diffs(cos,1), diffs(sin,1)])
    &gt;&gt;&gt; next(u); next(v)
    1.23586333600241
    1.23586333600241
    &gt;&gt;&gt; next(u); next(v)
    0.104658952245596
    0.104658952245596
    &gt;&gt;&gt; next(u); next(v)
    -5.96999877552086
    -5.96999877552086
    &gt;&gt;&gt; next(u); next(v)
    -12.4632923122697
    -12.4632923122697</pre> 
</div>
</div>
<a id="aaaf80a59e9b20420fd5d82899f2d7d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf80a59e9b20420fd5d82899f2d7d2c">&#9670;&nbsp;</a></span>diffun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.diffun </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a function `f`, returns a function `g(x)` that evaluates the nth
derivative `f^{(n)}(x)`::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; cos2 = diffun(sin)
    &gt;&gt;&gt; sin2 = diffun(sin, 4)
    &gt;&gt;&gt; cos(1.3), cos2(1.3)
    (0.267498828624587, 0.267498828624587)
    &gt;&gt;&gt; sin(1.3), sin2(1.3)
    (0.963558185417193, 0.963558185417193)

The function `f` must support arbitrary precision evaluation.
See :func:`~mpmath.diff` for additional details and supported
keyword options.
</pre> 
</div>
</div>
<a id="af6876cf8deec273d409740cf41005cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6876cf8deec273d409740cf41005cc7">&#9670;&nbsp;</a></span>dpoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.dpoly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_cache</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">nth differentiation polynomial for exp (Faa di Bruno's formula).

TODO: most exponents are zero, so maybe a sparse representation
would be better.
</pre> 
</div>
</div>
<a id="a370b2433c31335029f11500bf45c4ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370b2433c31335029f11500bf45c4ce9">&#9670;&nbsp;</a></span>hsteps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.hsteps </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a470495d6bc8c2cce0e3ff38353a41ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470495d6bc8c2cce0e3ff38353a41ffa">&#9670;&nbsp;</a></span>iterable_to_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.iterable_to_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad53634822f19c7c058d72616241d393f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53634822f19c7c058d72616241d393f">&#9670;&nbsp;</a></span>pade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.pade </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a Pade approximation of degree `(L, M)` to a function.
Given at least `L+M+1` Taylor coefficients `a` approximating
a function `A(x)`, :func:`~mpmath.pade` returns coefficients of
polynomials `P, Q` satisfying

.. math ::

    P = \sum_{k=0}^L p_k x^k

    Q = \sum_{k=0}^M q_k x^k

    Q_0 = 1

    A(x) Q(x) = P(x) + O(x^{L+M+1})

`P(x)/Q(x)` can provide a good approximation to an analytic function
beyond the radius of convergence of its Taylor series (example
from G.A. Baker 'Essentials of Pade Approximants' Academic Press,
Ch.1A)::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; one = mpf(1)
    &gt;&gt;&gt; def f(x):
    ...     return sqrt((one + 2*x)/(one + x))
    ...
    &gt;&gt;&gt; a = taylor(f, 0, 6)
    &gt;&gt;&gt; p, q = pade(a, 3, 3)
    &gt;&gt;&gt; x = 10
    &gt;&gt;&gt; polyval(p[::-1], x)/polyval(q[::-1], x)
    1.38169105566806
    &gt;&gt;&gt; f(x)
    1.38169855941551</pre> 
</div>
</div>
<a id="a6cdfd0639fd4cc7610ee14e3df03a482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdfd0639fd4cc7610ee14e3df03a482">&#9670;&nbsp;</a></span>taylor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.differentiation.taylor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produces a degree-`n` Taylor polynomial around the point `x` of the
given function `f`. The coefficients are returned as a list.

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; nprint(chop(taylor(sin, 0, 5)))
    [0.0, 1.0, 0.0, -0.166667, 0.0, 0.00833333]

The coefficients are computed using high-order numerical
differentiation. The function must be possible to evaluate
to arbitrary precision. See :func:`~mpmath.diff` for additional details
and supported keyword options.

Note that to evaluate the Taylor polynomial as an approximation
of `f`, e.g. with :func:`~mpmath.polyval`, the coefficients must be reversed,
and the point of the Taylor expansion must be subtracted from
the argument:

    &gt;&gt;&gt; p = taylor(exp, 2.0, 10)
    &gt;&gt;&gt; polyval(p[::-1], 2.5 - 2.0)
    12.1824939606092
    &gt;&gt;&gt; exp(2.5)
    12.1824939607035</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0abc5f62e64b4452591640aba290e213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abc5f62e64b4452591640aba290e213">&#9670;&nbsp;</a></span>iteritems</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpmath.calculus.differentiation.iteritems = dict.iteritems</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
