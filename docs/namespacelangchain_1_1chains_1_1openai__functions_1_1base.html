<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: langchain.chains.openai_functions.base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelangchain.html">langchain</a></li><li class="navelem"><a class="el" href="namespacelangchain_1_1chains.html">chains</a></li><li class="navelem"><a class="el" href="namespacelangchain_1_1chains_1_1openai__functions.html">openai_functions</a></li><li class="navelem"><a class="el" href="namespacelangchain_1_1chains_1_1openai__functions_1_1base.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">langchain.chains.openai_functions.base Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0bb3f5a34d87bb3991ee08c9d136630b"><td class="memItemLeft" align="right" valign="top">LLMChain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain_1_1chains_1_1openai__functions_1_1base.html#a0bb3f5a34d87bb3991ee08c9d136630b">create_openai_fn_chain</a> (Sequence[Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>], Callable]] functions, BaseLanguageModel llm, BasePromptTemplate prompt, *bool enforce_single_function_usage=True, str output_key=&quot;function&quot;, Optional[BaseLLMOutputParser] output_parser=None, **Any kwargs)</td></tr>
<tr class="separator:a0bb3f5a34d87bb3991ee08c9d136630b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa2b24ab32d7268895fbbb999ede6cf"><td class="memItemLeft" align="right" valign="top">LLMChain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain_1_1chains_1_1openai__functions_1_1base.html#aefa2b24ab32d7268895fbbb999ede6cf">create_structured_output_chain</a> (Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]] output_schema, BaseLanguageModel llm, BasePromptTemplate prompt, *str output_key=&quot;function&quot;, Optional[BaseLLMOutputParser] output_parser=None, **Any kwargs)</td></tr>
<tr class="separator:aefa2b24ab32d7268895fbbb999ede6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Methods for creating chains that use OpenAI function-calling APIs.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a0bb3f5a34d87bb3991ee08c9d136630b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb3f5a34d87bb3991ee08c9d136630b">&#9670;&nbsp;</a></span>create_openai_fn_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> LLMChain langchain.chains.openai_functions.base.create_openai_fn_chain </td>
          <td>(</td>
          <td class="paramtype">Sequence[Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>], Callable]]&#160;</td>
          <td class="paramname"><em>functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseLanguageModel&#160;</td>
          <td class="paramname"><em>llm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasePromptTemplate&#160;</td>
          <td class="paramname"><em>prompt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>enforce_single_function_usage</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>output_key</em> = <code>&quot;function&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[BaseLLMOutputParser] &#160;</td>
          <td class="paramname"><em>output_parser</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">[Legacy] Create an LLM chain that uses OpenAI functions.

Args:
    functions: A sequence of either dictionaries, pydantic.BaseModels classes, or
        Python functions. If dictionaries are passed in, they are assumed to
        already be a valid OpenAI functions. If only a single
        function is passed in, then it will be enforced that the model use that
        function. pydantic.BaseModels and Python functions should have docstrings
        describing what the function does. For best results, pydantic.BaseModels
        should have descriptions of the parameters and Python functions should have
        Google Python style args descriptions in the docstring. Additionally,
        Python functions should only use primitive types (str, int, float, bool) or
        pydantic.BaseModels for arguments.
    llm: Language model to use, assumed to support the OpenAI function-calling API.
    prompt: BasePromptTemplate to pass to the model.
    enforce_single_function_usage: only used if a single function is passed in. If
        True, then the model will be forced to use the given function. If False,
        then the model will be given the option to use the given function or not.
    output_key: The key to use when returning the output in LLMChain.__call__.
    output_parser: BaseLLMOutputParser to use for parsing model outputs. By default
        will be inferred from the function types. If pydantic.BaseModels are passed
        in, then the OutputParser will try to parse outputs using those. Otherwise
        model outputs will simply be parsed as JSON. If multiple functions are
        passed in and they are not pydantic.BaseModels, the chain output will
        include both the name of the function that was returned and the arguments
        to pass to the function.

Returns:
    An LLMChain that will pass in the given functions to the model when run.

Example:
    .. code-block:: python

            from typing import Optional

            from langchain.chains.openai_functions import create_openai_fn_chain
            from langchain_community.chat_models import ChatOpenAI
            from langchain_core.prompts import ChatPromptTemplate

            from pydantic import BaseModel, Field


            class RecordPerson(BaseModel):
                \"\"\"Record some identifying information about a person.\"\"\"

                name: str = Field(..., description="The person's name")
                age: int = Field(..., description="The person's age")
                fav_food: Optional[str] = Field(None, description="The person's favorite food")


            class RecordDog(BaseModel):
                \"\"\"Record some identifying information about a dog.\"\"\"

                name: str = Field(..., description="The dog's name")
                color: str = Field(..., description="The dog's color")
                fav_food: Optional[str] = Field(None, description="The dog's favorite food")


            llm = ChatOpenAI(model="gpt-4", temperature=0)
            prompt = ChatPromptTemplate.from_messages(
                [
                    ("system", "You are a world class algorithm for recording entities."),
                    ("human", "Make calls to the relevant function to record the entities in the following input: {input}"),
                    ("human", "Tip: Make sure to answer in the correct format"),
                ]
            )
            chain = create_openai_fn_chain([RecordPerson, RecordDog], llm, prompt)
            chain.run("Harry was a chubby brown beagle who loved chicken")
            # -&gt; RecordDog(name="Harry", color="brown", fav_food="chicken")
</pre> 
</div>
</div>
<a id="aefa2b24ab32d7268895fbbb999ede6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa2b24ab32d7268895fbbb999ede6cf">&#9670;&nbsp;</a></span>create_structured_output_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> LLMChain langchain.chains.openai_functions.base.create_structured_output_chain </td>
          <td>(</td>
          <td class="paramtype">Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]]&#160;</td>
          <td class="paramname"><em>output_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseLanguageModel&#160;</td>
          <td class="paramname"><em>llm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasePromptTemplate&#160;</td>
          <td class="paramname"><em>prompt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str &#160;</td>
          <td class="paramname"><em>output_key</em> = <code>&quot;function&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[BaseLLMOutputParser] &#160;</td>
          <td class="paramname"><em>output_parser</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">[Legacy] Create an LLMChain that uses an OpenAI function to get a structured output.

Args:
    output_schema: Either a dictionary or pydantic.BaseModel class. If a dictionary
        is passed in, it's assumed to already be a valid JsonSchema.
        For best results, pydantic.BaseModels should have docstrings describing what
        the schema represents and descriptions for the parameters.
    llm: Language model to use, assumed to support the OpenAI function-calling API.
    prompt: BasePromptTemplate to pass to the model.
    output_key: The key to use when returning the output in LLMChain.__call__.
    output_parser: BaseLLMOutputParser to use for parsing model outputs. By default
        will be inferred from the function types. If pydantic.BaseModels are passed
        in, then the OutputParser will try to parse outputs using those. Otherwise
        model outputs will simply be parsed as JSON.

Returns:
    An LLMChain that will pass the given function to the model.

Example:
    .. code-block:: python

            from typing import Optional

            from langchain.chains.openai_functions import create_structured_output_chain
            from langchain_community.chat_models import ChatOpenAI
            from langchain_core.prompts import ChatPromptTemplate

            from pydantic import BaseModel, Field

            class Dog(BaseModel):
                \"\"\"Identifying information about a dog.\"\"\"

                name: str = Field(..., description="The dog's name")
                color: str = Field(..., description="The dog's color")
                fav_food: Optional[str] = Field(None, description="The dog's favorite food")

            llm = ChatOpenAI(model="gpt-3.5-turbo-0613", temperature=0)
            prompt = ChatPromptTemplate.from_messages(
                [
                    ("system", "You are a world class algorithm for extracting information in structured formats."),
                    ("human", "Use the given format to extract information from the following input: {input}"),
                    ("human", "Tip: Make sure to answer in the correct format"),
                ]
            )
            chain = create_structured_output_chain(Dog, llm, prompt)
            chain.run("Harry was a chubby brown beagle who loved chicken")
            # -&gt; Dog(name="Harry", color="brown", fav_food="chicken")
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
