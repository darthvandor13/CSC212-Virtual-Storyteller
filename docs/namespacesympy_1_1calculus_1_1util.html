<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.calculus.util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1calculus_1_1util.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.calculus.util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af18dc08b9209b01b67c0c8ec5aa63cf1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#af18dc08b9209b01b67c0c8ec5aa63cf1">continuous_domain</a> (f, symbol, domain)</td></tr>
<tr class="separator:af18dc08b9209b01b67c0c8ec5aa63cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366d51485ea6e606585e6f329b952586"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#a366d51485ea6e606585e6f329b952586">function_range</a> (f, symbol, domain)</td></tr>
<tr class="separator:a366d51485ea6e606585e6f329b952586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad581b38187ea088a967d1db8aa3692b9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#ad581b38187ea088a967d1db8aa3692b9">not_empty_in</a> (finset_intersection, *syms)</td></tr>
<tr class="separator:ad581b38187ea088a967d1db8aa3692b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a16d5f7e5df344cb8521e52969cb74f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#a8a16d5f7e5df344cb8521e52969cb74f">periodicity</a> (f, symbol, check=False)</td></tr>
<tr class="separator:a8a16d5f7e5df344cb8521e52969cb74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bbbd61002f8ec3390a0297e2ed64cc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#a42bbbd61002f8ec3390a0297e2ed64cc">lcim</a> (numbers)</td></tr>
<tr class="separator:a42bbbd61002f8ec3390a0297e2ed64cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081538fb7e991d6aabb72c1cff83170a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#a081538fb7e991d6aabb72c1cff83170a">is_convex</a> (f, *syms, domain=S.Reals)</td></tr>
<tr class="separator:a081538fb7e991d6aabb72c1cff83170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee45620ba180f0f2f488c7a836b2e823"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#aee45620ba180f0f2f488c7a836b2e823">stationary_points</a> (f, symbol, domain=S.Reals)</td></tr>
<tr class="separator:aee45620ba180f0f2f488c7a836b2e823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaa5ae3699f7afce6bb3e266164f742"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#abcaa5ae3699f7afce6bb3e266164f742">maximum</a> (f, symbol, domain=S.Reals)</td></tr>
<tr class="separator:abcaa5ae3699f7afce6bb3e266164f742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dac9f7b68b2bf8ce2347fb81c66bbbc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1util.html#a1dac9f7b68b2bf8ce2347fb81c66bbbc">minimum</a> (f, symbol, domain=S.Reals)</td></tr>
<tr class="separator:a1dac9f7b68b2bf8ce2347fb81c66bbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af18dc08b9209b01b67c0c8ec5aa63cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18dc08b9209b01b67c0c8ec5aa63cf1">&#9670;&nbsp;</a></span>continuous_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.continuous_domain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the domain on which the function expression f is continuous.

This function is limited by the ability to determine the various
singularities and discontinuities of the given function.
The result is either given as a union of intervals or constructed using
other set operations.

Parameters
==========

f : :py:class:`~.Expr`
    The concerned function.
symbol : :py:class:`~.Symbol`
    The variable for which the intervals are to be determined.
domain : :py:class:`~.Interval`
    The domain over which the continuity of the symbol has to be checked.

Examples
========

&gt;&gt;&gt; from sympy import Interval, Symbol, S, tan, log, pi, sqrt
&gt;&gt;&gt; from sympy.calculus.util import continuous_domain
&gt;&gt;&gt; x = Symbol('x')
&gt;&gt;&gt; continuous_domain(1/x, x, S.Reals)
Union(Interval.open(-oo, 0), Interval.open(0, oo))
&gt;&gt;&gt; continuous_domain(tan(x), x, Interval(0, pi))
Union(Interval.Ropen(0, pi/2), Interval.Lopen(pi/2, pi))
&gt;&gt;&gt; continuous_domain(sqrt(x - 2), x, Interval(-5, 5))
Interval(2, 5)
&gt;&gt;&gt; continuous_domain(log(2*x - 1), x, S.Reals)
Interval.open(1/2, oo)

Returns
=======

:py:class:`~.Interval`
    Union of all intervals where the function is continuous.

Raises
======

NotImplementedError
    If the method to determine continuity of such a function
    has not yet been developed.</pre> 
</div>
</div>
<a id="a366d51485ea6e606585e6f329b952586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366d51485ea6e606585e6f329b952586">&#9670;&nbsp;</a></span>function_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.function_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds the range of a function in a given domain.
This method is limited by the ability to determine the singularities and
determine limits.

Parameters
==========

f : :py:class:`~.Expr`
    The concerned function.
symbol : :py:class:`~.Symbol`
    The variable for which the range of function is to be determined.
domain : :py:class:`~.Interval`
    The domain under which the range of the function has to be found.

Examples
========

&gt;&gt;&gt; from sympy import Interval, Symbol, S, exp, log, pi, sqrt, sin, tan
&gt;&gt;&gt; from sympy.calculus.util import function_range
&gt;&gt;&gt; x = Symbol('x')
&gt;&gt;&gt; function_range(sin(x), x, Interval(0, 2*pi))
Interval(-1, 1)
&gt;&gt;&gt; function_range(tan(x), x, Interval(-pi/2, pi/2))
Interval(-oo, oo)
&gt;&gt;&gt; function_range(1/x, x, S.Reals)
Union(Interval.open(-oo, 0), Interval.open(0, oo))
&gt;&gt;&gt; function_range(exp(x), x, S.Reals)
Interval.open(0, oo)
&gt;&gt;&gt; function_range(log(x), x, S.Reals)
Interval(-oo, oo)
&gt;&gt;&gt; function_range(sqrt(x), x, Interval(-5, 9))
Interval(0, 3)

Returns
=======

:py:class:`~.Interval`
    Union of all ranges for all intervals under domain where function is
    continuous.

Raises
======

NotImplementedError
    If any of the intervals, in the given domain, for which function
    is continuous are not finite or real,
    OR if the critical points of the function on the domain cannot be found.
</pre> 
</div>
</div>
<a id="a081538fb7e991d6aabb72c1cff83170a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081538fb7e991d6aabb72c1cff83170a">&#9670;&nbsp;</a></span>is_convex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.is_convex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>S.Reals</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determines the  convexity of the function passed in the argument.

Parameters
==========

f : :py:class:`~.Expr`
    The concerned function.
syms : Tuple of :py:class:`~.Symbol`
    The variables with respect to which the convexity is to be determined.
domain : :py:class:`~.Interval`, optional
    The domain over which the convexity of the function has to be checked.
    If unspecified, S.Reals will be the default domain.

Returns
=======

bool
    The method returns ``True`` if the function is convex otherwise it
    returns ``False``.

Raises
======

NotImplementedError
    The check for the convexity of multivariate functions is not implemented yet.

Notes
=====

To determine concavity of a function pass `-f` as the concerned function.
To determine logarithmic convexity of a function pass `\log(f)` as
concerned function.
To determine logarithmic concavity of a function pass `-\log(f)` as
concerned function.

Currently, convexity check of multivariate functions is not handled.

Examples
========

&gt;&gt;&gt; from sympy import is_convex, symbols, exp, oo, Interval
&gt;&gt;&gt; x = symbols('x')
&gt;&gt;&gt; is_convex(exp(x), x)
True
&gt;&gt;&gt; is_convex(x**3, x, domain = Interval(-1, oo))
False
&gt;&gt;&gt; is_convex(1/x**2, x, domain=Interval.open(0, oo))
True

References
==========

.. [1] https://en.wikipedia.org/wiki/Convex_function
.. [2] http://www.ifp.illinois.edu/~angelia/L3_convfunc.pdf
.. [3] https://en.wikipedia.org/wiki/Logarithmically_convex_function
.. [4] https://en.wikipedia.org/wiki/Logarithmically_concave_function
.. [5] https://en.wikipedia.org/wiki/Concave_function</pre> 
</div>
</div>
<a id="a42bbbd61002f8ec3390a0297e2ed64cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bbbd61002f8ec3390a0297e2ed64cc">&#9670;&nbsp;</a></span>lcim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.lcim </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numbers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the least common integral multiple of a list of numbers.

The numbers can be rational or irrational or a mixture of both.
`None` is returned for incommensurable numbers.

Parameters
==========

numbers : list
    Numbers (rational and/or irrational) for which lcim is to be found.

Returns
=======

number
    lcim if it exists, otherwise ``None`` for incommensurable numbers.

Examples
========

&gt;&gt;&gt; from sympy.calculus.util import lcim
&gt;&gt;&gt; from sympy import S, pi
&gt;&gt;&gt; lcim([S(1)/2, S(3)/4, S(5)/6])
15/2
&gt;&gt;&gt; lcim([2*pi, 3*pi, pi, pi/2])
6*pi
&gt;&gt;&gt; lcim([S(1), 2*pi])
</pre> 
</div>
</div>
<a id="abcaa5ae3699f7afce6bb3e266164f742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcaa5ae3699f7afce6bb3e266164f742">&#9670;&nbsp;</a></span>maximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.maximum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>S.Reals</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the maximum value of a function in the given domain.

Parameters
==========

f : :py:class:`~.Expr`
    The concerned function.
symbol : :py:class:`~.Symbol`
    The variable for maximum value needs to be determined.
domain : :py:class:`~.Interval`
    The domain over which the maximum have to be checked.
    If unspecified, then the global maximum is returned.

Returns
=======

number
    Maximum value of the function in given domain.

Examples
========

&gt;&gt;&gt; from sympy import Interval, Symbol, S, sin, cos, pi, maximum
&gt;&gt;&gt; x = Symbol('x')

&gt;&gt;&gt; f = -x**2 + 2*x + 5
&gt;&gt;&gt; maximum(f, x, S.Reals)
6

&gt;&gt;&gt; maximum(sin(x), x, Interval(-pi, pi/4))
sqrt(2)/2

&gt;&gt;&gt; maximum(sin(x)*cos(x), x)
1/2</pre> 
</div>
</div>
<a id="a1dac9f7b68b2bf8ce2347fb81c66bbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dac9f7b68b2bf8ce2347fb81c66bbbc">&#9670;&nbsp;</a></span>minimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.minimum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>S.Reals</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the minimum value of a function in the given domain.

Parameters
==========

f : :py:class:`~.Expr`
    The concerned function.
symbol : :py:class:`~.Symbol`
    The variable for minimum value needs to be determined.
domain : :py:class:`~.Interval`
    The domain over which the minimum have to be checked.
    If unspecified, then the global minimum is returned.

Returns
=======

number
    Minimum value of the function in the given domain.

Examples
========

&gt;&gt;&gt; from sympy import Interval, Symbol, S, sin, cos, minimum
&gt;&gt;&gt; x = Symbol('x')

&gt;&gt;&gt; f = x**2 + 2*x + 5
&gt;&gt;&gt; minimum(f, x, S.Reals)
4

&gt;&gt;&gt; minimum(sin(x), x, Interval(2, 3))
sin(3)

&gt;&gt;&gt; minimum(sin(x)*cos(x), x)
-1/2</pre> 
</div>
</div>
<a id="ad581b38187ea088a967d1db8aa3692b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad581b38187ea088a967d1db8aa3692b9">&#9670;&nbsp;</a></span>not_empty_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.not_empty_in </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>finset_intersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>syms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds the domain of the functions in ``finset_intersection`` in which the
``finite_set`` is not-empty.

Parameters
==========

finset_intersection : Intersection of FiniteSet
    The unevaluated intersection of FiniteSet containing
    real-valued functions with Union of Sets
syms : Tuple of symbols
    Symbol for which domain is to be found

Raises
======

NotImplementedError
    The algorithms to find the non-emptiness of the given FiniteSet are
    not yet implemented.
ValueError
    The input is not valid.
RuntimeError
    It is a bug, please report it to the github issue tracker
    (https://github.com/sympy/sympy/issues).

Examples
========

&gt;&gt;&gt; from sympy import FiniteSet, Interval, not_empty_in, oo
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; not_empty_in(FiniteSet(x/2).intersect(Interval(0, 1)), x)
Interval(0, 2)
&gt;&gt;&gt; not_empty_in(FiniteSet(x, x**2).intersect(Interval(1, 2)), x)
Union(Interval(1, 2), Interval(-sqrt(2), -1))
&gt;&gt;&gt; not_empty_in(FiniteSet(x**2/(x + 2)).intersect(Interval(1, oo)), x)
Union(Interval.Lopen(-2, -1), Interval(2, oo))
</pre> 
</div>
</div>
<a id="a8a16d5f7e5df344cb8521e52969cb74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a16d5f7e5df344cb8521e52969cb74f">&#9670;&nbsp;</a></span>periodicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.periodicity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tests the given function for periodicity in the given symbol.

Parameters
==========

f : :py:class:`~.Expr`
    The concerned function.
symbol : :py:class:`~.Symbol`
    The variable for which the period is to be determined.
check : bool, optional
    The flag to verify whether the value being returned is a period or not.

Returns
=======

period
    The period of the function is returned.
    ``None`` is returned when the function is aperiodic or has a complex period.
    The value of $0$ is returned as the period of a constant function.

Raises
======

NotImplementedError
    The value of the period computed cannot be verified.


Notes
=====

Currently, we do not support functions with a complex period.
The period of functions having complex periodic values such
as ``exp``, ``sinh`` is evaluated to ``None``.

The value returned might not be the "fundamental" period of the given
function i.e. it may not be the smallest periodic value of the function.

The verification of the period through the ``check`` flag is not reliable
due to internal simplification of the given expression. Hence, it is set
to ``False`` by default.

Examples
========
&gt;&gt;&gt; from sympy import periodicity, Symbol, sin, cos, tan, exp
&gt;&gt;&gt; x = Symbol('x')
&gt;&gt;&gt; f = sin(x) + sin(2*x) + sin(3*x)
&gt;&gt;&gt; periodicity(f, x)
2*pi
&gt;&gt;&gt; periodicity(sin(x)*cos(x), x)
pi
&gt;&gt;&gt; periodicity(exp(tan(2*x) - 1), x)
pi/2
&gt;&gt;&gt; periodicity(sin(4*x)**cos(2*x), x)
pi
&gt;&gt;&gt; periodicity(exp(x), x)
</pre> 
</div>
</div>
<a id="aee45620ba180f0f2f488c7a836b2e823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee45620ba180f0f2f488c7a836b2e823">&#9670;&nbsp;</a></span>stationary_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.util.stationary_points </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>S.Reals</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the stationary points of a function (where derivative of the
function is 0) in the given domain.

Parameters
==========

f : :py:class:`~.Expr`
    The concerned function.
symbol : :py:class:`~.Symbol`
    The variable for which the stationary points are to be determined.
domain : :py:class:`~.Interval`
    The domain over which the stationary points have to be checked.
    If unspecified, ``S.Reals`` will be the default domain.

Returns
=======

Set
    A set of stationary points for the function. If there are no
    stationary point, an :py:class:`~.EmptySet` is returned.

Examples
========

&gt;&gt;&gt; from sympy import Interval, Symbol, S, sin, pi, pprint, stationary_points
&gt;&gt;&gt; x = Symbol('x')

&gt;&gt;&gt; stationary_points(1/x, x, S.Reals)
EmptySet

&gt;&gt;&gt; pprint(stationary_points(sin(x), x), use_unicode=False)
          pi                              3*pi
{2*n*pi + -- | n in Integers} U {2*n*pi + ---- | n in Integers}
          2                                2

&gt;&gt;&gt; stationary_points(sin(x),x, Interval(0, 4*pi))
{pi/2, 3*pi/2, 5*pi/2, 7*pi/2}</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
