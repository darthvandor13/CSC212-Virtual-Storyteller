<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.calculus.finite_diff Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1calculus_1_1finite__diff.html">finite_diff</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.calculus.finite_diff Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6e6974ef2ade7023369175f8245155fd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1finite__diff.html#a6e6974ef2ade7023369175f8245155fd">finite_diff_weights</a> (order, x_list, x0=S.One)</td></tr>
<tr class="separator:a6e6974ef2ade7023369175f8245155fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8db418cffc63b2bb02cc0ddf4503666"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1finite__diff.html#af8db418cffc63b2bb02cc0ddf4503666">apply_finite_diff</a> (order, x_list, y_list, x0=S.Zero)</td></tr>
<tr class="separator:af8db418cffc63b2bb02cc0ddf4503666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c45e09e1a4e689b31479708dc04db7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1calculus_1_1finite__diff.html#a8c45e09e1a4e689b31479708dc04db7d">differentiate_finite</a> (expr, *symbols, points=1, x0=None, wrt=None, <a class="el" href="classsympy_1_1core_1_1parameters_1_1evaluate.html">evaluate</a>=False)</td></tr>
<tr class="separator:a8c45e09e1a4e689b31479708dc04db7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Finite difference weights
=========================

This module implements an algorithm for efficient generation of finite
difference weights for ordinary differentials of functions for
derivatives from 0 (interpolation) up to arbitrary order.

The core algorithm is provided in the finite difference weight generating
function (``finite_diff_weights``), and two convenience functions are provided
for:

- estimating a derivative (or interpolate) directly from a series of points
    is also provided (``apply_finite_diff``).
- differentiating by using finite difference approximations
    (``differentiate_finite``).</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="af8db418cffc63b2bb02cc0ddf4503666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8db418cffc63b2bb02cc0ddf4503666">&#9670;&nbsp;</a></span>apply_finite_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.finite_diff.apply_finite_diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>S.Zero</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the finite difference approximation of
the derivative of requested order at ``x0`` from points
provided in ``x_list`` and ``y_list``.

Parameters
==========

order: int
    order of derivative to approximate. 0 corresponds to interpolation.
x_list: sequence
    Sequence of (unique) values for the independent variable.
y_list: sequence
    The function value at corresponding values for the independent
    variable in x_list.
x0: Number or Symbol
    At what value of the independent variable the derivative should be
    evaluated. Defaults to 0.

Returns
=======

sympy.core.add.Add or sympy.core.numbers.Number
    The finite difference expression approximating the requested
    derivative order at ``x0``.

Examples
========

&gt;&gt;&gt; from sympy import apply_finite_diff
&gt;&gt;&gt; cube = lambda arg: (1.0*arg)**3
&gt;&gt;&gt; xlist = range(-3,3+1)
&gt;&gt;&gt; apply_finite_diff(2, xlist, map(cube, xlist), 2) - 12 # doctest: +SKIP
-3.55271367880050e-15

we see that the example above only contain rounding errors.
apply_finite_diff can also be used on more abstract objects:

&gt;&gt;&gt; from sympy import IndexedBase, Idx
&gt;&gt;&gt; x, y = map(IndexedBase, 'xy')
&gt;&gt;&gt; i = Idx('i')
&gt;&gt;&gt; x_list, y_list = zip(*[(x[i+j], y[i+j]) for j in range(-1,2)])
&gt;&gt;&gt; apply_finite_diff(1, x_list, y_list, x[i])
((x[i + 1] - x[i])/(-x[i - 1] + x[i]) - 1)*y[i]/(x[i + 1] - x[i]) -
(x[i + 1] - x[i])*y[i - 1]/((x[i + 1] - x[i - 1])*(-x[i - 1] + x[i])) +
(-x[i - 1] + x[i])*y[i + 1]/((x[i + 1] - x[i - 1])*(x[i + 1] - x[i]))

Notes
=====

Order = 0 corresponds to interpolation.
Only supply so many points you think makes sense
to around x0 when extracting the derivative (the function
need to be well behaved within that region). Also beware
of Runge's phenomenon.

See also
========

sympy.calculus.finite_diff.finite_diff_weights

References
==========

Fortran 90 implementation with Python interface for numerics: finitediff_

.. _finitediff: https://github.com/bjodah/finitediff</pre> 
</div>
</div>
<a id="a8c45e09e1a4e689b31479708dc04db7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c45e09e1a4e689b31479708dc04db7d">&#9670;&nbsp;</a></span>differentiate_finite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.finite_diff.differentiate_finite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wrt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>evaluate</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Differentiate expr and replace Derivatives with finite differences.

Parameters
==========

expr : expression
\*symbols : differentiate with respect to symbols
points: sequence, coefficient or undefined function, optional
    see ``Derivative.as_finite_difference``
x0: number or Symbol, optional
    see ``Derivative.as_finite_difference``
wrt: Symbol, optional
    see ``Derivative.as_finite_difference``

Examples
========

&gt;&gt;&gt; from sympy import sin, Function, differentiate_finite
&gt;&gt;&gt; from sympy.abc import x, y, h
&gt;&gt;&gt; f, g = Function('f'), Function('g')
&gt;&gt;&gt; differentiate_finite(f(x)*g(x), x, points=[x-h, x+h])
-f(-h + x)*g(-h + x)/(2*h) + f(h + x)*g(h + x)/(2*h)

``differentiate_finite`` works on any expression, including the expressions
with embedded derivatives:

&gt;&gt;&gt; differentiate_finite(f(x) + sin(x), x, 2)
-2*f(x) + f(x - 1) + f(x + 1) - 2*sin(x) + sin(x - 1) + sin(x + 1)
&gt;&gt;&gt; differentiate_finite(f(x, y), x, y)
f(x - 1/2, y - 1/2) - f(x - 1/2, y + 1/2) - f(x + 1/2, y - 1/2) + f(x + 1/2, y + 1/2)
&gt;&gt;&gt; differentiate_finite(f(x)*g(x).diff(x), x)
(-g(x) + g(x + 1))*f(x + 1/2) - (g(x) - g(x - 1))*f(x - 1/2)

To make finite difference with non-constant discretization step use
undefined functions:

&gt;&gt;&gt; dx = Function('dx')
&gt;&gt;&gt; differentiate_finite(f(x)*g(x).diff(x), points=dx(x))
-(-g(x - dx(x)/2 - dx(x - dx(x)/2)/2)/dx(x - dx(x)/2) +
g(x - dx(x)/2 + dx(x - dx(x)/2)/2)/dx(x - dx(x)/2))*f(x - dx(x)/2)/dx(x) +
(-g(x + dx(x)/2 - dx(x + dx(x)/2)/2)/dx(x + dx(x)/2) +
g(x + dx(x)/2 + dx(x + dx(x)/2)/2)/dx(x + dx(x)/2))*f(x + dx(x)/2)/dx(x)</pre> 
</div>
</div>
<a id="a6e6974ef2ade7023369175f8245155fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6974ef2ade7023369175f8245155fd">&#9670;&nbsp;</a></span>finite_diff_weights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.calculus.finite_diff.finite_diff_weights </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>S.One</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the finite difference weights for an arbitrarily spaced
one-dimensional grid (``x_list``) for derivatives at ``x0`` of order
0, 1, ..., up to ``order`` using a recursive formula. Order of accuracy
is at least ``len(x_list) - order``, if ``x_list`` is defined correctly.

Parameters
==========

order: int
    Up to what derivative order weights should be calculated.
    0 corresponds to interpolation.
x_list: sequence
    Sequence of (unique) values for the independent variable.
    It is useful (but not necessary) to order ``x_list`` from
    nearest to furthest from ``x0``; see examples below.
x0: Number or Symbol
    Root or value of the independent variable for which the finite
    difference weights should be generated. Default is ``S.One``.

Returns
=======

list
    A list of sublists, each corresponding to coefficients for
    increasing derivative order, and each containing lists of
    coefficients for increasing subsets of x_list.

Examples
========

&gt;&gt;&gt; from sympy import finite_diff_weights, S
&gt;&gt;&gt; res = finite_diff_weights(1, [-S(1)/2, S(1)/2, S(3)/2, S(5)/2], 0)
&gt;&gt;&gt; res
[[[1, 0, 0, 0],
  [1/2, 1/2, 0, 0],
  [3/8, 3/4, -1/8, 0],
  [5/16, 15/16, -5/16, 1/16]],
 [[0, 0, 0, 0],
  [-1, 1, 0, 0],
  [-1, 1, 0, 0],
  [-23/24, 7/8, 1/8, -1/24]]]
&gt;&gt;&gt; res[0][-1]  # FD weights for 0th derivative, using full x_list
[5/16, 15/16, -5/16, 1/16]
&gt;&gt;&gt; res[1][-1]  # FD weights for 1st derivative
[-23/24, 7/8, 1/8, -1/24]
&gt;&gt;&gt; res[1][-2]  # FD weights for 1st derivative, using x_list[:-1]
[-1, 1, 0, 0]
&gt;&gt;&gt; res[1][-1][0]  # FD weight for 1st deriv. for x_list[0]
-23/24
&gt;&gt;&gt; res[1][-1][1]  # FD weight for 1st deriv. for x_list[1], etc.
7/8

Each sublist contains the most accurate formula at the end.
Note, that in the above example ``res[1][1]`` is the same as ``res[1][2]``.
Since res[1][2] has an order of accuracy of
``len(x_list[:3]) - order = 3 - 1 = 2``, the same is true for ``res[1][1]``!

&gt;&gt;&gt; res = finite_diff_weights(1, [S(0), S(1), -S(1), S(2), -S(2)], 0)[1]
&gt;&gt;&gt; res
[[0, 0, 0, 0, 0],
 [-1, 1, 0, 0, 0],
 [0, 1/2, -1/2, 0, 0],
 [-1/2, 1, -1/3, -1/6, 0],
 [0, 2/3, -2/3, -1/12, 1/12]]
&gt;&gt;&gt; res[0]  # no approximation possible, using x_list[0] only
[0, 0, 0, 0, 0]
&gt;&gt;&gt; res[1]  # classic forward step approximation
[-1, 1, 0, 0, 0]
&gt;&gt;&gt; res[2]  # classic centered approximation
[0, 1/2, -1/2, 0, 0]
&gt;&gt;&gt; res[3:]  # higher order approximations
[[-1/2, 1, -1/3, -1/6, 0], [0, 2/3, -2/3, -1/12, 1/12]]

Let us compare this to a differently defined ``x_list``. Pay attention to
``foo[i][k]`` corresponding to the gridpoint defined by ``x_list[k]``.

&gt;&gt;&gt; foo = finite_diff_weights(1, [-S(2), -S(1), S(0), S(1), S(2)], 0)[1]
&gt;&gt;&gt; foo
[[0, 0, 0, 0, 0],
 [-1, 1, 0, 0, 0],
 [1/2, -2, 3/2, 0, 0],
 [1/6, -1, 1/2, 1/3, 0],
 [1/12, -2/3, 0, 2/3, -1/12]]
&gt;&gt;&gt; foo[1]  # not the same and of lower accuracy as res[1]!
[-1, 1, 0, 0, 0]
&gt;&gt;&gt; foo[2]  # classic double backward step approximation
[1/2, -2, 3/2, 0, 0]
&gt;&gt;&gt; foo[4]  # the same as res[4]
[1/12, -2/3, 0, 2/3, -1/12]

Note that, unless you plan on using approximations based on subsets of
``x_list``, the order of gridpoints does not matter.

The capability to generate weights at arbitrary points can be
used e.g. to minimize Runge's phenomenon by using Chebyshev nodes:

&gt;&gt;&gt; from sympy import cos, symbols, pi, simplify
&gt;&gt;&gt; N, (h, x) = 4, symbols('h x')
&gt;&gt;&gt; x_list = [x+h*cos(i*pi/(N)) for i in range(N,-1,-1)] # chebyshev nodes
&gt;&gt;&gt; print(x_list)
[-h + x, -sqrt(2)*h/2 + x, x, sqrt(2)*h/2 + x, h + x]
&gt;&gt;&gt; mycoeffs = finite_diff_weights(1, x_list, 0)[1][4]
&gt;&gt;&gt; [simplify(c) for c in  mycoeffs] #doctest: +NORMALIZE_WHITESPACE
[(h**3/2 + h**2*x - 3*h*x**2 - 4*x**3)/h**4,
(-sqrt(2)*h**3 - 4*h**2*x + 3*sqrt(2)*h*x**2 + 8*x**3)/h**4,
(6*h**2*x - 8*x**3)/h**4,
(sqrt(2)*h**3 - 4*h**2*x - 3*sqrt(2)*h*x**2 + 8*x**3)/h**4,
(-h**3/2 + h**2*x + 3*h*x**2 - 4*x**3)/h**4]

Notes
=====

If weights for a finite difference approximation of 3rd order
derivative is wanted, weights for 0th, 1st and 2nd order are
calculated "for free", so are formulae using subsets of ``x_list``.
This is something one can take advantage of to save computational cost.
Be aware that one should define ``x_list`` from nearest to furthest from
``x0``. If not, subsets of ``x_list`` will yield poorer approximations,
which might not grand an order of accuracy of ``len(x_list) - order``.

See also
========

sympy.calculus.finite_diff.apply_finite_diff

References
==========

.. [1] Generation of Finite Difference Formulas on Arbitrarily Spaced
        Grids, Bengt Fornberg; Mathematics of computation; 51; 184;
        (1988); 699-706; doi:10.1090/S0025-5718-1988-0935077-0</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
