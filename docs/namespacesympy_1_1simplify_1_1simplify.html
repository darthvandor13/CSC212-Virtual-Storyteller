<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.simplify.simplify Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1simplify.html">simplify</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html">simplify</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.simplify.simplify Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a471297a091dbac016883682466f28ff3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a471297a091dbac016883682466f28ff3">separatevars</a> (expr, symbols=[], dict=False, force=False)</td></tr>
<tr class="separator:a471297a091dbac016883682466f28ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0219cc4a2dcaf0dbb7b055a00faddc00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a0219cc4a2dcaf0dbb7b055a00faddc00">posify</a> (eq)</td></tr>
<tr class="separator:a0219cc4a2dcaf0dbb7b055a00faddc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73fda63d8ad8bb4f98fb1a38e7334e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#ab73fda63d8ad8bb4f98fb1a38e7334e5">hypersimp</a> (f, k)</td></tr>
<tr class="separator:ab73fda63d8ad8bb4f98fb1a38e7334e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeff1dad7735076ac197bef86fdfb42"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#adfeff1dad7735076ac197bef86fdfb42">hypersimilar</a> (f, g, k)</td></tr>
<tr class="separator:adfeff1dad7735076ac197bef86fdfb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab236029098cdc795bff77f546f0651b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#ab236029098cdc795bff77f546f0651b7">signsimp</a> (expr, <a class="el" href="classsympy_1_1core_1_1parameters_1_1evaluate.html">evaluate</a>=None)</td></tr>
<tr class="separator:ab236029098cdc795bff77f546f0651b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84ce22e2aa3938404e0e8cc10185207"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#af84ce22e2aa3938404e0e8cc10185207">simplify</a> (expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs)</td></tr>
<tr class="separator:af84ce22e2aa3938404e0e8cc10185207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b23abbb138f9969157346fcedc48caf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a2b23abbb138f9969157346fcedc48caf">sum_simplify</a> (s, **kwargs)</td></tr>
<tr class="separator:a2b23abbb138f9969157346fcedc48caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388a03cf2cc25b7c51bdefb90071ade8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a388a03cf2cc25b7c51bdefb90071ade8">sum_combine</a> (s_t)</td></tr>
<tr class="separator:a388a03cf2cc25b7c51bdefb90071ade8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983422780cf9a8702f32e597b9688afc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a983422780cf9a8702f32e597b9688afc">factor_sum</a> (self, <a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a6503a3c4af5239b14d0459f5a5c1624e">limits</a>=None, radical=False, clear=False, fraction=False, <a class="el" href="classsympy_1_1functions_1_1elementary_1_1complexes_1_1sign.html">sign</a>=True)</td></tr>
<tr class="separator:a983422780cf9a8702f32e597b9688afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aa003c25bbc9093cfb57b9bf309fbe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a45aa003c25bbc9093cfb57b9bf309fbe">sum_add</a> (self, other, method=0)</td></tr>
<tr class="separator:a45aa003c25bbc9093cfb57b9bf309fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4af2332367ad8b3cd1d769ae5f8f861"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#af4af2332367ad8b3cd1d769ae5f8f861">product_simplify</a> (s, **kwargs)</td></tr>
<tr class="separator:af4af2332367ad8b3cd1d769ae5f8f861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d11bdac7a7399b735988e0273ba29ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a9d11bdac7a7399b735988e0273ba29ab">product_mul</a> (self, other, method=0)</td></tr>
<tr class="separator:a9d11bdac7a7399b735988e0273ba29ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f24ff67c38fe3e843593e3deac4cf05"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a2f24ff67c38fe3e843593e3deac4cf05">logcombine</a> (expr, force=False)</td></tr>
<tr class="separator:a2f24ff67c38fe3e843593e3deac4cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3124b46a04de505c19850c804749744a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a3124b46a04de505c19850c804749744a">inversecombine</a> (expr)</td></tr>
<tr class="separator:a3124b46a04de505c19850c804749744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959d54a4dee82acdd4b369ffb3c035a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a959d54a4dee82acdd4b369ffb3c035a7">kroneckersimp</a> (expr)</td></tr>
<tr class="separator:a959d54a4dee82acdd4b369ffb3c035a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4407cc7b21960044c6ef9d62a68e61"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#aad4407cc7b21960044c6ef9d62a68e61">besselsimp</a> (expr)</td></tr>
<tr class="separator:aad4407cc7b21960044c6ef9d62a68e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f6fba94a58933b6e2695554ee21540"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a95f6fba94a58933b6e2695554ee21540">nthroot</a> (expr, n, max_len=4, prec=15)</td></tr>
<tr class="separator:a95f6fba94a58933b6e2695554ee21540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe034f11d1189be7c42afd603f193cf1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#abe034f11d1189be7c42afd603f193cf1">nsimplify</a> (expr, constants=(), tolerance=None, full=False, rational=None, rational_conversion='base10')</td></tr>
<tr class="separator:abe034f11d1189be7c42afd603f193cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d06f86269ad6b5fe3bb1b818047f4b6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a9d06f86269ad6b5fe3bb1b818047f4b6">clear_coefficients</a> (expr, rhs=S.Zero)</td></tr>
<tr class="separator:a9d06f86269ad6b5fe3bb1b818047f4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc77bb974787097bd1511ec683c62222"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#afc77bb974787097bd1511ec683c62222">nc_simplify</a> (expr, deep=True)</td></tr>
<tr class="separator:afc77bb974787097bd1511ec683c62222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab96396b16924cda0455be6bab426783"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#aab96396b16924cda0455be6bab426783">dotprodsimp</a> (expr, withsimp=False)</td></tr>
<tr class="separator:aab96396b16924cda0455be6bab426783"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4257cce4906d8e46baeb23d88445f313"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a4257cce4906d8e46baeb23d88445f313">bottom_up</a></td></tr>
<tr class="separator:a4257cce4906d8e46baeb23d88445f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e641d9dd4a4177f47738318d521920"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#ab5e641d9dd4a4177f47738318d521920">walk</a></td></tr>
<tr class="separator:ab5e641d9dd4a4177f47738318d521920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6503a3c4af5239b14d0459f5a5c1624e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1simplify.html#a6503a3c4af5239b14d0459f5a5c1624e">limits</a></td></tr>
<tr class="separator:a6503a3c4af5239b14d0459f5a5c1624e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aad4407cc7b21960044c6ef9d62a68e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4407cc7b21960044c6ef9d62a68e61">&#9670;&nbsp;</a></span>besselsimp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.besselsimp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplify bessel-type functions.

Explanation
===========

This routine tries to simplify bessel-type functions. Currently it only
works on the Bessel J and I functions, however. It works by looking at all
such functions in turn, and eliminating factors of "I" and "-1" (actually
their polar equivalents) in front of the argument. Then, functions of
half-integer order are rewritten using trigonometric functions and
functions of integer order (&gt; 1) are rewritten using functions
of low order.  Finally, if the expression was changed, compute
factorization of the result with factor().

&gt;&gt;&gt; from sympy import besselj, besseli, besselsimp, polar_lift, I, S
&gt;&gt;&gt; from sympy.abc import z, nu
&gt;&gt;&gt; besselsimp(besselj(nu, z*polar_lift(-1)))
exp(I*pi*nu)*besselj(nu, z)
&gt;&gt;&gt; besselsimp(besseli(nu, z*polar_lift(-I)))
exp(-I*pi*nu/2)*besselj(nu, z)
&gt;&gt;&gt; besselsimp(besseli(S(-1)/2, z))
sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))
&gt;&gt;&gt; besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))
3*z*besseli(0, z)/2
</pre> 
</div>
</div>
<a id="a9d06f86269ad6b5fe3bb1b818047f4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d06f86269ad6b5fe3bb1b818047f4b6">&#9670;&nbsp;</a></span>clear_coefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.clear_coefficients </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rhs</em> = <code>S.Zero</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return `p, r` where `p` is the expression obtained when Rational
additive and multiplicative coefficients of `expr` have been stripped
away in a naive fashion (i.e. without simplification). The operations
needed to remove the coefficients will be applied to `rhs` and returned
as `r`.

Examples
========

&gt;&gt;&gt; from sympy.simplify.simplify import clear_coefficients
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy import Dummy
&gt;&gt;&gt; expr = 4*y*(6*x + 3)
&gt;&gt;&gt; clear_coefficients(expr - 2)
(y*(2*x + 1), 1/6)

When solving 2 or more expressions like `expr = a`,
`expr = b`, etc..., it is advantageous to provide a Dummy symbol
for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.

&gt;&gt;&gt; rhs = Dummy('rhs')
&gt;&gt;&gt; clear_coefficients(expr, rhs)
(y*(2*x + 1), _rhs/12)
&gt;&gt;&gt; _[1].subs(rhs, 2)
1/6
</pre> 
</div>
</div>
<a id="aab96396b16924cda0455be6bab426783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab96396b16924cda0455be6bab426783">&#9670;&nbsp;</a></span>dotprodsimp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.dotprodsimp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>withsimp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplification for a sum of products targeted at the kind of blowup that
occurs during summation of products. Intended to reduce expression blowup
during matrix multiplication or other similar operations. Only works with
algebraic expressions and does not recurse into non.

Parameters
==========

withsimp : bool, optional
    Specifies whether a flag should be returned along with the expression
    to indicate roughly whether simplification was successful. It is used
    in ``MatrixArithmetic._eval_pow_by_recursion`` to avoid attempting to
    simplify an expression repetitively which does not simplify.
</pre> 
</div>
</div>
<a id="a983422780cf9a8702f32e597b9688afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983422780cf9a8702f32e597b9688afc">&#9670;&nbsp;</a></span>factor_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.factor_sum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radical</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clear</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fraction</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sign</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return Sum with constant factors extracted.

If ``limits`` is specified then ``self`` is the summand; the other
keywords are passed to ``factor_terms``.

Examples
========

&gt;&gt;&gt; from sympy import Sum
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.simplify.simplify import factor_sum
&gt;&gt;&gt; s = Sum(x*y, (x, 1, 3))
&gt;&gt;&gt; factor_sum(s)
y*Sum(x, (x, 1, 3))
&gt;&gt;&gt; factor_sum(s.function, s.limits)
y*Sum(x, (x, 1, 3))
</pre> 
</div>
</div>
<a id="adfeff1dad7735076ac197bef86fdfb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfeff1dad7735076ac197bef86fdfb42">&#9670;&nbsp;</a></span>hypersimilar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.hypersimilar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if ``f`` and ``g`` are hyper-similar.

Explanation
===========

Similarity in hypergeometric sense means that a quotient of
f(k) and g(k) is a rational function in ``k``. This procedure
is useful in solving recurrence relations.

For more information see hypersimp().</pre> 
</div>
</div>
<a id="ab73fda63d8ad8bb4f98fb1a38e7334e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73fda63d8ad8bb4f98fb1a38e7334e5">&#9670;&nbsp;</a></span>hypersimp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.hypersimp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given combinatorial term f(k) simplify its consecutive term ratio
   i.e. f(k+1)/f(k).  The input term can be composed of functions and
   integer sequences which have equivalent representation in terms
   of gamma special function.

   Explanation
   ===========

   The algorithm performs three basic steps:

   1. Rewrite all functions in terms of gamma, if possible.

   2. Rewrite all occurrences of gamma in terms of products
      of gamma and rising factorial with integer,  absolute
      constant exponent.

   3. Perform simplification of nested fractions, powers
      and if the resulting expression is a quotient of
      polynomials, reduce their total degree.

   If f(k) is hypergeometric then as result we arrive with a
   quotient of polynomials of minimal degree. Otherwise None
   is returned.

   For more information on the implemented algorithm refer to:

   1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,
      Journal of Symbolic Computation (1995) 20, 399-417
</pre> 
</div>
</div>
<a id="a3124b46a04de505c19850c804749744a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3124b46a04de505c19850c804749744a">&#9670;&nbsp;</a></span>inversecombine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.inversecombine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplify the composition of a function and its inverse.

Explanation
===========

No attention is paid to whether the inverse is a left inverse or a
right inverse; thus, the result will in general not be equivalent
to the original expression.

Examples
========

&gt;&gt;&gt; from sympy.simplify.simplify import inversecombine
&gt;&gt;&gt; from sympy import asin, sin, log, exp
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; inversecombine(asin(sin(x)))
x
&gt;&gt;&gt; inversecombine(2*log(exp(3*x)))
6*x
</pre> 
</div>
</div>
<a id="a959d54a4dee82acdd4b369ffb3c035a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959d54a4dee82acdd4b369ffb3c035a7">&#9670;&nbsp;</a></span>kroneckersimp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.kroneckersimp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplify expressions with KroneckerDelta.

The only simplification currently attempted is to identify multiplicative cancellation:

Examples
========

&gt;&gt;&gt; from sympy import KroneckerDelta, kroneckersimp
&gt;&gt;&gt; from sympy.abc import i
&gt;&gt;&gt; kroneckersimp(1 + KroneckerDelta(0, i) * KroneckerDelta(1, i))
1
</pre> 
</div>
</div>
<a id="a2f24ff67c38fe3e843593e3deac4cf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f24ff67c38fe3e843593e3deac4cf05">&#9670;&nbsp;</a></span>logcombine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.logcombine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Takes logarithms and combines them using the following rules:

- log(x) + log(y) == log(x*y) if both are positive
- a*log(x) == log(x**a) if x is positive and a is real

If ``force`` is ``True`` then the assumptions above will be assumed to hold if
there is no assumption already in place on a quantity. For example, if
``a`` is imaginary or the argument negative, force will not perform a
combination but if ``a`` is a symbol with no assumptions the change will
take place.

Examples
========

&gt;&gt;&gt; from sympy import Symbol, symbols, log, logcombine, I
&gt;&gt;&gt; from sympy.abc import a, x, y, z
&gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z))
a*log(x) + log(y) - log(z)
&gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z), force=True)
log(x**a*y/z)
&gt;&gt;&gt; x,y,z = symbols('x,y,z', positive=True)
&gt;&gt;&gt; a = Symbol('a', real=True)
&gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z))
log(x**a*y/z)

The transformation is limited to factors and/or terms that
contain logs, so the result depends on the initial state of
expansion:

&gt;&gt;&gt; eq = (2 + 3*I)*log(x)
&gt;&gt;&gt; logcombine(eq, force=True) == eq
True
&gt;&gt;&gt; logcombine(eq.expand(), force=True)
log(x**2) + I*log(x**3)

See Also
========

posify: replace all symbols with symbols having positive assumptions
sympy.core.function.expand_log: expand the logarithms of products
    and powers; the opposite of logcombine</pre> 
</div>
</div>
<a id="afc77bb974787097bd1511ec683c62222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc77bb974787097bd1511ec683c62222">&#9670;&nbsp;</a></span>nc_simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.nc_simplify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplify a non-commutative expression composed of multiplication
and raising to a power by grouping repeated subterms into one power.
Priority is given to simplifications that give the fewest number
of arguments in the end (for example, in a*b*a*b*c*a*b*c simplifying
to (a*b)**2*c*a*b*c gives 5 arguments while a*b*(a*b*c)**2 has 3).
If ``expr`` is a sum of such terms, the sum of the simplified terms
is returned.

Keyword argument ``deep`` controls whether or not subexpressions
nested deeper inside the main expression are simplified. See examples
below. Setting `deep` to `False` can save time on nested expressions
that do not need simplifying on all levels.

Examples
========

&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from sympy.simplify.simplify import nc_simplify
&gt;&gt;&gt; a, b, c = symbols("a b c", commutative=False)
&gt;&gt;&gt; nc_simplify(a*b*a*b*c*a*b*c)
a*b*(a*b*c)**2
&gt;&gt;&gt; expr = a**2*b*a**4*b*a**4
&gt;&gt;&gt; nc_simplify(expr)
a**2*(b*a**4)**2
&gt;&gt;&gt; nc_simplify(a*b*a*b*c**2*(a*b)**2*c**2)
((a*b)**2*c**2)**2
&gt;&gt;&gt; nc_simplify(a*b*a*b + 2*a*c*a**2*c*a**2*c*a)
(a*b)**2 + 2*(a*c*a)**3
&gt;&gt;&gt; nc_simplify(b**-1*a**-1*(a*b)**2)
a*b
&gt;&gt;&gt; nc_simplify(a**-1*b**-1*c*a)
(b*a)**(-1)*c*a
&gt;&gt;&gt; expr = (a*b*a*b)**2*a*c*a*c
&gt;&gt;&gt; nc_simplify(expr)
(a*b)**4*(a*c)**2
&gt;&gt;&gt; nc_simplify(expr, deep=False)
(a*b*a*b)**2*(a*c)**2</pre> 
</div>
</div>
<a id="abe034f11d1189be7c42afd603f193cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe034f11d1189be7c42afd603f193cf1">&#9670;&nbsp;</a></span>nsimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.nsimplify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>constants</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rational</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rational_conversion</em> = <code>'base10'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a simple representation for a number or, if there are free symbols or
if ``rational=True``, then replace Floats with their Rational equivalents. If
no change is made and rational is not False then Floats will at least be
converted to Rationals.

Explanation
===========

For numerical expressions, a simple formula that numerically matches the
given numerical expression is sought (and the input should be possible
to evalf to a precision of at least 30 digits).

Optionally, a list of (rationally independent) constants to
include in the formula may be given.

A lower tolerance may be set to find less exact matches. If no tolerance
is given then the least precise value will set the tolerance (e.g. Floats
default to 15 digits of precision, so would be tolerance=10**-15).

With ``full=True``, a more extensive search is performed
(this is useful to find simpler numbers when the tolerance
is set low).

When converting to rational, if rational_conversion='base10' (the default), then
convert floats to rationals using their base-10 (string) representation.
When rational_conversion='exact' it uses the exact, base-2 representation.

Examples
========

&gt;&gt;&gt; from sympy import nsimplify, sqrt, GoldenRatio, exp, I, pi
&gt;&gt;&gt; nsimplify(4/(1+sqrt(5)), [GoldenRatio])
-2 + 2*GoldenRatio
&gt;&gt;&gt; nsimplify((1/(exp(3*pi*I/5)+1)))
1/2 - I*sqrt(sqrt(5)/10 + 1/4)
&gt;&gt;&gt; nsimplify(I**I, [pi])
exp(-pi/2)
&gt;&gt;&gt; nsimplify(pi, tolerance=0.01)
22/7

&gt;&gt;&gt; nsimplify(0.333333333333333, rational=True, rational_conversion='exact')
6004799503160655/18014398509481984
&gt;&gt;&gt; nsimplify(0.333333333333333, rational=True)
1/3

See Also
========

sympy.core.function.nfloat</pre> 
</div>
</div>
<a id="a95f6fba94a58933b6e2695554ee21540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f6fba94a58933b6e2695554ee21540">&#9670;&nbsp;</a></span>nthroot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.nthroot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_len</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prec</em> = <code>15</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a real nth-root of a sum of surds.

Parameters
==========

expr : sum of surds
n : integer
max_len : maximum number of surds passed as constants to ``nsimplify``

Algorithm
=========

First ``nsimplify`` is used to get a candidate root; if it is not a
root the minimal polynomial is computed; the answer is one of its
roots.

Examples
========

&gt;&gt;&gt; from sympy.simplify.simplify import nthroot
&gt;&gt;&gt; from sympy import sqrt
&gt;&gt;&gt; nthroot(90 + 34*sqrt(7), 3)
sqrt(7) + 3</pre> 
</div>
</div>
<a id="a0219cc4a2dcaf0dbb7b055a00faddc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0219cc4a2dcaf0dbb7b055a00faddc00">&#9670;&nbsp;</a></span>posify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.posify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``eq`` (with generic symbols made positive) and a
dictionary containing the mapping between the old and new
symbols.

Explanation
===========

Any symbol that has positive=None will be replaced with a positive dummy
symbol having the same name. This replacement will allow more symbolic
processing of expressions, especially those involving powers and
logarithms.

A dictionary that can be sent to subs to restore ``eq`` to its original
symbols is also returned.

&gt;&gt;&gt; from sympy import posify, Symbol, log, solve
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))
(_x + n + p, {_x: x})

&gt;&gt;&gt; eq = 1/x
&gt;&gt;&gt; log(eq).expand()
log(1/x)
&gt;&gt;&gt; log(posify(eq)[0]).expand()
-log(_x)
&gt;&gt;&gt; p, rep = posify(eq)
&gt;&gt;&gt; log(p).expand().subs(rep)
-log(x)

It is possible to apply the same transformations to an iterable
of expressions:

&gt;&gt;&gt; eq = x**2 - 4
&gt;&gt;&gt; solve(eq, x)
[-2, 2]
&gt;&gt;&gt; eq_x, reps = posify([eq, x]); eq_x
[_x**2 - 4, _x]
&gt;&gt;&gt; solve(*eq_x)
[2]
</pre> 
</div>
</div>
<a id="a9d11bdac7a7399b735988e0273ba29ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d11bdac7a7399b735988e0273ba29ab">&#9670;&nbsp;</a></span>product_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.product_mul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function for Product simplification</pre> 
</div>
</div>
<a id="af4af2332367ad8b3cd1d769ae5f8f861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4af2332367ad8b3cd1d769ae5f8f861">&#9670;&nbsp;</a></span>product_simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.product_simplify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Main function for Product simplification</pre> 
</div>
</div>
<a id="a471297a091dbac016883682466f28ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471297a091dbac016883682466f28ff3">&#9670;&nbsp;</a></span>separatevars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.separatevars </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Separates variables in an expression, if possible.  By
default, it separates with respect to all symbols in an
expression and collects constant coefficients that are
independent of symbols.

Explanation
===========

If ``dict=True`` then the separated terms will be returned
in a dictionary keyed to their corresponding symbols.
By default, all symbols in the expression will appear as
keys; if symbols are provided, then all those symbols will
be used as keys, and any terms in the expression containing
other symbols or non-symbols will be returned keyed to the
string 'coeff'. (Passing None for symbols will return the
expression in a dictionary keyed to 'coeff'.)

If ``force=True``, then bases of powers will be separated regardless
of assumptions on the symbols involved.

Notes
=====

The order of the factors is determined by Mul, so that the
separated expressions may not necessarily be grouped together.

Although factoring is necessary to separate variables in some
expressions, it is not necessary in all cases, so one should not
count on the returned factors being factored.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y, z, alpha
&gt;&gt;&gt; from sympy import separatevars, sin
&gt;&gt;&gt; separatevars((x*y)**y)
(x*y)**y
&gt;&gt;&gt; separatevars((x*y)**y, force=True)
x**y*y**y

&gt;&gt;&gt; e = 2*x**2*z*sin(y)+2*z*x**2
&gt;&gt;&gt; separatevars(e)
2*x**2*z*(sin(y) + 1)
&gt;&gt;&gt; separatevars(e, symbols=(x, y), dict=True)
{'coeff': 2*z, x: x**2, y: sin(y) + 1}
&gt;&gt;&gt; separatevars(e, [x, y, alpha], dict=True)
{'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}

If the expression is not really separable, or is only partially
separable, separatevars will do the best it can to separate it
by using factoring.

&gt;&gt;&gt; separatevars(x + x*y - 3*x**2)
-x*(3*x - y - 1)

If the expression is not separable then expr is returned unchanged
or (if dict=True) then None is returned.

&gt;&gt;&gt; eq = 2*x + y*sin(x)
&gt;&gt;&gt; separatevars(eq) == eq
True
&gt;&gt;&gt; separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) is None
True</pre> 
</div>
</div>
<a id="ab236029098cdc795bff77f546f0651b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab236029098cdc795bff77f546f0651b7">&#9670;&nbsp;</a></span>signsimp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.signsimp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>evaluate</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make all Add sub-expressions canonical wrt sign.

Explanation
===========

If an Add subexpression, ``a``, can have a sign extracted,
as determined by could_extract_minus_sign, it is replaced
with Mul(-1, a, evaluate=False). This allows signs to be
extracted from powers and products.

Examples
========

&gt;&gt;&gt; from sympy import signsimp, exp, symbols
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; i = symbols('i', odd=True)
&gt;&gt;&gt; n = -1 + 1/x
&gt;&gt;&gt; n/x/(-n)**2 - 1/n/x
(-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))
&gt;&gt;&gt; signsimp(_)
0
&gt;&gt;&gt; x*n + x*-n
x*(-1 + 1/x) + x*(1 - 1/x)
&gt;&gt;&gt; signsimp(_)
0

Since powers automatically handle leading signs

&gt;&gt;&gt; (-2)**i
-2**i

signsimp can be used to put the base of a power with an integer
exponent into canonical form:

&gt;&gt;&gt; n**i
(-1 + 1/x)**i

By default, signsimp does not leave behind any hollow simplification:
if making an Add canonical wrt sign didn't change the expression, the
original Add is restored. If this is not desired then the keyword
``evaluate`` can be set to False:

&gt;&gt;&gt; e = exp(y - x)
&gt;&gt;&gt; signsimp(e) == e
True
&gt;&gt;&gt; signsimp(e, evaluate=False)
exp(-(x - y))</pre> 
</div>
</div>
<a id="af84ce22e2aa3938404e0e8cc10185207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84ce22e2aa3938404e0e8cc10185207">&#9670;&nbsp;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.simplify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ratio</em> = <code>1.7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>measure</em> = <code>count_ops</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rational</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>doit</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simplifies the given expression.

Explanation
===========

Simplification is not a well defined term and the exact strategies
this function tries can change in the future versions of SymPy. If
your algorithm relies on "simplification" (whatever it is), try to
determine what you need exactly  -  is it powsimp()?, radsimp()?,
together()?, logcombine()?, or something else? And use this particular
function directly, because those are well defined and thus your algorithm
will be robust.

Nonetheless, especially for interactive use, or when you do not know
anything about the structure of the expression, simplify() tries to apply
intelligent heuristics to make the input expression "simpler".  For
example:

&gt;&gt;&gt; from sympy import simplify, cos, sin
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
&gt;&gt;&gt; a
(x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
&gt;&gt;&gt; simplify(a)
x + 1

Note that we could have obtained the same result by using specific
simplification functions:

&gt;&gt;&gt; from sympy import trigsimp, cancel
&gt;&gt;&gt; trigsimp(a)
(x**2 + x)/x
&gt;&gt;&gt; cancel(_)
x + 1

In some cases, applying :func:`simplify` may actually result in some more
complicated expression. The default ``ratio=1.7`` prevents more extreme
cases: if (result length)/(input length) &gt; ratio, then input is returned
unmodified.  The ``measure`` parameter lets you specify the function used
to determine how complex an expression is.  The function should take a
single argument as an expression and return a number such that if
expression ``a`` is more complex than expression ``b``, then
``measure(a) &gt; measure(b)``.  The default measure function is
:func:`~.count_ops`, which returns the total number of operations in the
expression.

For example, if ``ratio=1``, ``simplify`` output cannot be longer
than input.

::

    &gt;&gt;&gt; from sympy import sqrt, simplify, count_ops, oo
    &gt;&gt;&gt; root = 1/(sqrt(2)+3)

Since ``simplify(root)`` would result in a slightly longer expression,
root is returned unchanged instead::

   &gt;&gt;&gt; simplify(root, ratio=1) == root
   True

If ``ratio=oo``, simplify will be applied anyway::

    &gt;&gt;&gt; count_ops(simplify(root, ratio=oo)) &gt; count_ops(root)
    True

Note that the shortest expression is not necessary the simplest, so
setting ``ratio`` to 1 may not be a good idea.
Heuristically, the default value ``ratio=1.7`` seems like a reasonable
choice.

You can easily define your own measure function based on what you feel
should represent the "size" or "complexity" of the input expression.  Note
that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
good metrics, but have other problems (in this case, the measure function
may slow down simplify too much for very large expressions).  If you do not
know what a good metric would be, the default, ``count_ops``, is a good
one.

For example:

&gt;&gt;&gt; from sympy import symbols, log
&gt;&gt;&gt; a, b = symbols('a b', positive=True)
&gt;&gt;&gt; g = log(a) + log(b) + log(a)*log(1/b)
&gt;&gt;&gt; h = simplify(g)
&gt;&gt;&gt; h
log(a*b**(1 - log(a)))
&gt;&gt;&gt; count_ops(g)
8
&gt;&gt;&gt; count_ops(h)
5

So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
However, we may not like how ``simplify`` (in this case, using
``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
to reduce this would be to give more weight to powers as operations in
``count_ops``.  We can do this by using the ``visual=True`` option:

&gt;&gt;&gt; print(count_ops(g, visual=True))
2*ADD + DIV + 4*LOG + MUL
&gt;&gt;&gt; print(count_ops(h, visual=True))
2*LOG + MUL + POW + SUB

&gt;&gt;&gt; from sympy import Symbol, S
&gt;&gt;&gt; def my_measure(expr):
...     POW = Symbol('POW')
...     # Discourage powers by giving POW a weight of 10
...     count = count_ops(expr, visual=True).subs(POW, 10)
...     # Every other operation gets a weight of 1 (the default)
...     count = count.replace(Symbol, type(S.One))
...     return count
&gt;&gt;&gt; my_measure(g)
8
&gt;&gt;&gt; my_measure(h)
14
&gt;&gt;&gt; 15./8 &gt; 1.7 # 1.7 is the default ratio
True
&gt;&gt;&gt; simplify(g, measure=my_measure)
-log(a)*log(b) + log(a) + log(b)

Note that because ``simplify()`` internally tries many different
simplification strategies and then compares them using the measure
function, we get a completely different result that is still different
from the input expression by doing this.

If ``rational=True``, Floats will be recast as Rationals before simplification.
If ``rational=None``, Floats will be recast as Rationals but the result will
be recast as Floats. If rational=False(default) then nothing will be done
to the Floats.

If ``inverse=True``, it will be assumed that a composition of inverse
functions, such as sin and asin, can be cancelled in any order.
For example, ``asin(sin(x))`` will yield ``x`` without checking whether
x belongs to the set where this relation is true. The default is
False.

Note that ``simplify()`` automatically calls ``doit()`` on the final
expression. You can avoid this behavior by passing ``doit=False`` as
an argument.

Also, it should be noted that simplifying a boolean expression is not
well defined. If the expression prefers automatic evaluation (such as
:obj:`~.Eq()` or :obj:`~.Or()`), simplification will return ``True`` or
``False`` if truth value can be determined. If the expression is not
evaluated by default (such as :obj:`~.Predicate()`), simplification will
not reduce it and you should use :func:`~.refine` or :func:`~.ask`
function. This inconsistency will be resolved in future version.

See Also
========

sympy.assumptions.refine.refine : Simplification using assumptions.
sympy.assumptions.ask.ask : Query for boolean expressions using assumptions.
</pre> 
</div>
</div>
<a id="a45aa003c25bbc9093cfb57b9bf309fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45aa003c25bbc9093cfb57b9bf309fbe">&#9670;&nbsp;</a></span>sum_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.sum_add </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function for Sum simplification</pre> 
</div>
</div>
<a id="a388a03cf2cc25b7c51bdefb90071ade8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388a03cf2cc25b7c51bdefb90071ade8">&#9670;&nbsp;</a></span>sum_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.sum_combine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function for Sum simplification

   Attempts to simplify a list of sums, by combining limits / sum function's
   returns the simplified sum
</pre> 
</div>
</div>
<a id="a2b23abbb138f9969157346fcedc48caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b23abbb138f9969157346fcedc48caf">&#9670;&nbsp;</a></span>sum_simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.simplify.sum_simplify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Main function for Sum simplification</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4257cce4906d8e46baeb23d88445f313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4257cce4906d8e46baeb23d88445f313">&#9670;&nbsp;</a></span>bottom_up</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.simplify.simplify.bottom_up</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  <a class="code" href="namespacedeprecated.html">deprecated</a>(</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    ,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    deprecated_since_version=<span class="stringliteral">&quot;1.10&quot;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    active_deprecations_target=<span class="stringliteral">&quot;deprecated-traversal-functions-moved&quot;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;)(_bottom_up)</div>
<div class="ttc" id="anamespacedeprecated_html"><div class="ttname"><a href="namespacedeprecated.html">deprecated</a></div><div class="ttdef"><b>Definition:</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6503a3c4af5239b14d0459f5a5c1624e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6503a3c4af5239b14d0459f5a5c1624e">&#9670;&nbsp;</a></span>limits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.simplify.simplify.limits</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5e641d9dd4a4177f47738318d521920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e641d9dd4a4177f47738318d521920">&#9670;&nbsp;</a></span>walk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.simplify.simplify.walk</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  <a class="code" href="namespacedeprecated.html">deprecated</a>(</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    ,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    deprecated_since_version=<span class="stringliteral">&quot;1.10&quot;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    active_deprecations_target=<span class="stringliteral">&quot;deprecated-traversal-functions-moved&quot;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;)(_walk)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
