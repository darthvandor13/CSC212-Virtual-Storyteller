<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.discrete.convolutions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1discrete.html">discrete</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html">convolutions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.discrete.convolutions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a712ed8b8e4b9ce04c75725055a41d1fa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html#a712ed8b8e4b9ce04c75725055a41d1fa">convolution</a> (a, b, cycle=0, dps=None, prime=None, dyadic=None, subset=None)</td></tr>
<tr class="separator:a712ed8b8e4b9ce04c75725055a41d1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef18c310850988a9bc668bbfcb92828e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html#aef18c310850988a9bc668bbfcb92828e">convolution_fft</a> (a, b, dps=None)</td></tr>
<tr class="separator:aef18c310850988a9bc668bbfcb92828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785bbfec143e09b479251f0af68b78b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html#a785bbfec143e09b479251f0af68b78b2">convolution_ntt</a> (a, b, prime)</td></tr>
<tr class="separator:a785bbfec143e09b479251f0af68b78b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a63e6f3221a0f23315083b5f270487"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html#a04a63e6f3221a0f23315083b5f270487">convolution_fwht</a> (a, b)</td></tr>
<tr class="separator:a04a63e6f3221a0f23315083b5f270487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a155c5892597c02428ab0c5656a0b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html#a48a155c5892597c02428ab0c5656a0b3">convolution_subset</a> (a, b)</td></tr>
<tr class="separator:a48a155c5892597c02428ab0c5656a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a91d9551badbdb89fd4e8c58cc2eb0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html#a55a91d9551badbdb89fd4e8c58cc2eb0">covering_product</a> (a, b)</td></tr>
<tr class="separator:a55a91d9551badbdb89fd4e8c58cc2eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b70a7ac1fa8708bcf6928ba20651f0b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html#a7b70a7ac1fa8708bcf6928ba20651f0b">intersecting_product</a> (a, b)</td></tr>
<tr class="separator:a7b70a7ac1fa8708bcf6928ba20651f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc185b02425eb77322ebdce07842f0de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1discrete_1_1convolutions.html#adc185b02425eb77322ebdce07842f0de">convolution_int</a> (a, b)</td></tr>
<tr class="separator:adc185b02425eb77322ebdce07842f0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Convolution (using **FFT**, **NTT**, **FWHT**), Subset Convolution,
Covering Product, Intersecting Product
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a712ed8b8e4b9ce04c75725055a41d1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712ed8b8e4b9ce04c75725055a41d1fa">&#9670;&nbsp;</a></span>convolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.discrete.convolutions.convolution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cycle</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dps</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prime</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dyadic</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subset</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs convolution by determining the type of desired
convolution using hints.

Exactly one of ``dps``, ``prime``, ``dyadic``, ``subset`` arguments
should be specified explicitly for identifying the type of convolution,
and the argument ``cycle`` can be specified optionally.

For the default arguments, linear convolution is performed using **FFT**.

Parameters
==========

a, b : iterables
    The sequences for which convolution is performed.
cycle : Integer
    Specifies the length for doing cyclic convolution.
dps : Integer
    Specifies the number of decimal digits for precision for
    performing **FFT** on the sequence.
prime : Integer
    Prime modulus of the form `(m 2^k + 1)` to be used for
    performing **NTT** on the sequence.
dyadic : bool
    Identifies the convolution type as dyadic (*bitwise-XOR*)
    convolution, which is performed using **FWHT**.
subset : bool
    Identifies the convolution type as subset convolution.

Examples
========

&gt;&gt;&gt; from sympy import convolution, symbols, S, I
&gt;&gt;&gt; u, v, w, x, y, z = symbols('u v w x y z')

&gt;&gt;&gt; convolution([1 + 2*I, 4 + 3*I], [S(5)/4, 6], dps=3)
[1.25 + 2.5*I, 11.0 + 15.8*I, 24.0 + 18.0*I]
&gt;&gt;&gt; convolution([1, 2, 3], [4, 5, 6], cycle=3)
[31, 31, 28]

&gt;&gt;&gt; convolution([111, 777], [888, 444], prime=19*2**10 + 1)
[1283, 19351, 14219]
&gt;&gt;&gt; convolution([111, 777], [888, 444], prime=19*2**10 + 1, cycle=2)
[15502, 19351]

&gt;&gt;&gt; convolution([u, v], [x, y, z], dyadic=True)
[u*x + v*y, u*y + v*x, u*z, v*z]
&gt;&gt;&gt; convolution([u, v], [x, y, z], dyadic=True, cycle=2)
[u*x + u*z + v*y, u*y + v*x + v*z]

&gt;&gt;&gt; convolution([u, v, w], [x, y, z], subset=True)
[u*x, u*y + v*x, u*z + w*x, v*z + w*y]
&gt;&gt;&gt; convolution([u, v, w], [x, y, z], subset=True, cycle=3)
[u*x + v*z + w*y, u*y + v*x, u*z + w*x]</pre> 
</div>
</div>
<a id="aef18c310850988a9bc668bbfcb92828e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef18c310850988a9bc668bbfcb92828e">&#9670;&nbsp;</a></span>convolution_fft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.discrete.convolutions.convolution_fft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dps</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs linear convolution using Fast Fourier Transform.

Parameters
==========

a, b : iterables
    The sequences for which convolution is performed.
dps : Integer
    Specifies the number of decimal digits for precision.

Examples
========

&gt;&gt;&gt; from sympy import S, I
&gt;&gt;&gt; from sympy.discrete.convolutions import convolution_fft

&gt;&gt;&gt; convolution_fft([2, 3], [4, 5])
[8, 22, 15]
&gt;&gt;&gt; convolution_fft([2, 5], [6, 7, 3])
[12, 44, 41, 15]
&gt;&gt;&gt; convolution_fft([1 + 2*I, 4 + 3*I], [S(5)/4, 6])
[5/4 + 5*I/2, 11 + 63*I/4, 24 + 18*I]

References
==========

.. [1] https://en.wikipedia.org/wiki/Convolution_theorem
.. [2] https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general%29</pre> 
</div>
</div>
<a id="a04a63e6f3221a0f23315083b5f270487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a63e6f3221a0f23315083b5f270487">&#9670;&nbsp;</a></span>convolution_fwht()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.discrete.convolutions.convolution_fwht </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs dyadic (*bitwise-XOR*) convolution using Fast Walsh Hadamard
Transform.

The convolution is automatically padded to the right with zeros, as the
*radix-2 FWHT* requires the number of sample points to be a power of 2.

Parameters
==========

a, b : iterables
    The sequences for which convolution is performed.

Examples
========

&gt;&gt;&gt; from sympy import symbols, S, I
&gt;&gt;&gt; from sympy.discrete.convolutions import convolution_fwht

&gt;&gt;&gt; u, v, x, y = symbols('u v x y')
&gt;&gt;&gt; convolution_fwht([u, v], [x, y])
[u*x + v*y, u*y + v*x]

&gt;&gt;&gt; convolution_fwht([2, 3], [4, 5])
[23, 22]
&gt;&gt;&gt; convolution_fwht([2, 5 + 4*I, 7], [6*I, 7, 3 + 4*I])
[56 + 68*I, -10 + 30*I, 6 + 50*I, 48 + 32*I]

&gt;&gt;&gt; convolution_fwht([S(33)/7, S(55)/6, S(7)/4], [S(2)/3, 5])
[2057/42, 1870/63, 7/6, 35/4]

References
==========

.. [1] https://www.radioeng.cz/fulltexts/2002/02_03_40_42.pdf
.. [2] https://en.wikipedia.org/wiki/Hadamard_transform</pre> 
</div>
</div>
<a id="adc185b02425eb77322ebdce07842f0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc185b02425eb77322ebdce07842f0de">&#9670;&nbsp;</a></span>convolution_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.discrete.convolutions.convolution_int </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the convolution of two sequences as a list.

The iterables must consist solely of integers.

Parameters
==========

a, b : Sequence
    The sequences for which convolution is performed.

Explanation
===========

This function performs the convolution of ``a`` and ``b`` by packing
each into a single integer, multiplying them together, and then
unpacking the result from the product.  The intuition behind this is
that if we evaluate some polynomial [1]:

.. math ::
    1156x^6 + 3808x^5 + 8440x^4 + 14856x^3 + 16164x^2 + 14040x + 8100

at say $x = 10^5$ we obtain $1156038080844014856161641404008100$.
Note we can read of the coefficients for each term every five digits.
If the $x$ we chose to evaluate at is large enough, the same will hold
for the product.

The idea now is since big integer multiplication in libraries such
as GMP is highly optimised, this will be reasonably fast.

Examples
========

&gt;&gt;&gt; from sympy.discrete.convolutions import convolution_int

&gt;&gt;&gt; convolution_int([2, 3], [4, 5])
[8, 22, 15]
&gt;&gt;&gt; convolution_int([1, 1, -1], [1, 1])
[1, 2, 0, -1]

References
==========

.. [1] Fateman, Richard J.
       Can you save time in multiplying polynomials by encoding them as integers?
       University of California, Berkeley, California (2004).
       https://people.eecs.berkeley.edu/~fateman/papers/polysbyGMP.pdf
</pre> 
</div>
</div>
<a id="a785bbfec143e09b479251f0af68b78b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785bbfec143e09b479251f0af68b78b2">&#9670;&nbsp;</a></span>convolution_ntt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.discrete.convolutions.convolution_ntt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs linear convolution using Number Theoretic Transform.

Parameters
==========

a, b : iterables
    The sequences for which convolution is performed.
prime : Integer
    Prime modulus of the form `(m 2^k + 1)` to be used for performing
    **NTT** on the sequence.

Examples
========

&gt;&gt;&gt; from sympy.discrete.convolutions import convolution_ntt
&gt;&gt;&gt; convolution_ntt([2, 3], [4, 5], prime=19*2**10 + 1)
[8, 22, 15]
&gt;&gt;&gt; convolution_ntt([2, 5], [6, 7, 3], prime=19*2**10 + 1)
[12, 44, 41, 15]
&gt;&gt;&gt; convolution_ntt([333, 555], [222, 666], prime=19*2**10 + 1)
[15555, 14219, 19404]

References
==========

.. [1] https://en.wikipedia.org/wiki/Convolution_theorem
.. [2] https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general%29</pre> 
</div>
</div>
<a id="a48a155c5892597c02428ab0c5656a0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a155c5892597c02428ab0c5656a0b3">&#9670;&nbsp;</a></span>convolution_subset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.discrete.convolutions.convolution_subset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs Subset Convolution of given sequences.

The indices of each argument, considered as bit strings, correspond to
subsets of a finite set.

The sequence is automatically padded to the right with zeros, as the
definition of subset based on bitmasks (indices) requires the size of
sequence to be a power of 2.

Parameters
==========

a, b : iterables
    The sequences for which convolution is performed.

Examples
========

&gt;&gt;&gt; from sympy import symbols, S
&gt;&gt;&gt; from sympy.discrete.convolutions import convolution_subset
&gt;&gt;&gt; u, v, x, y, z = symbols('u v x y z')

&gt;&gt;&gt; convolution_subset([u, v], [x, y])
[u*x, u*y + v*x]
&gt;&gt;&gt; convolution_subset([u, v, x], [y, z])
[u*y, u*z + v*y, x*y, x*z]

&gt;&gt;&gt; convolution_subset([1, S(2)/3], [3, 4])
[3, 6]
&gt;&gt;&gt; convolution_subset([1, 3, S(5)/7], [7])
[7, 21, 5, 0]

References
==========

.. [1] https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf</pre> 
</div>
</div>
<a id="a55a91d9551badbdb89fd4e8c58cc2eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a91d9551badbdb89fd4e8c58cc2eb0">&#9670;&nbsp;</a></span>covering_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.discrete.convolutions.covering_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the covering product of given sequences.

The indices of each argument, considered as bit strings, correspond to
subsets of a finite set.

The covering product of given sequences is a sequence which contains
the sum of products of the elements of the given sequences grouped by
the *bitwise-OR* of the corresponding indices.

The sequence is automatically padded to the right with zeros, as the
definition of subset based on bitmasks (indices) requires the size of
sequence to be a power of 2.

Parameters
==========

a, b : iterables
    The sequences for which covering product is to be obtained.

Examples
========

&gt;&gt;&gt; from sympy import symbols, S, I, covering_product
&gt;&gt;&gt; u, v, x, y, z = symbols('u v x y z')

&gt;&gt;&gt; covering_product([u, v], [x, y])
[u*x, u*y + v*x + v*y]
&gt;&gt;&gt; covering_product([u, v, x], [y, z])
[u*y, u*z + v*y + v*z, x*y, x*z]

&gt;&gt;&gt; covering_product([1, S(2)/3], [3, 4 + 5*I])
[3, 26/3 + 25*I/3]
&gt;&gt;&gt; covering_product([1, 3, S(5)/7], [7, 8])
[7, 53, 5, 40/7]

References
==========

.. [1] https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf</pre> 
</div>
</div>
<a id="a7b70a7ac1fa8708bcf6928ba20651f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b70a7ac1fa8708bcf6928ba20651f0b">&#9670;&nbsp;</a></span>intersecting_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.discrete.convolutions.intersecting_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the intersecting product of given sequences.

The indices of each argument, considered as bit strings, correspond to
subsets of a finite set.

The intersecting product of given sequences is the sequence which
contains the sum of products of the elements of the given sequences
grouped by the *bitwise-AND* of the corresponding indices.

The sequence is automatically padded to the right with zeros, as the
definition of subset based on bitmasks (indices) requires the size of
sequence to be a power of 2.

Parameters
==========

a, b : iterables
    The sequences for which intersecting product is to be obtained.

Examples
========

&gt;&gt;&gt; from sympy import symbols, S, I, intersecting_product
&gt;&gt;&gt; u, v, x, y, z = symbols('u v x y z')

&gt;&gt;&gt; intersecting_product([u, v], [x, y])
[u*x + u*y + v*x, v*y]
&gt;&gt;&gt; intersecting_product([u, v, x], [y, z])
[u*y + u*z + v*y + x*y + x*z, v*z, 0, 0]

&gt;&gt;&gt; intersecting_product([1, S(2)/3], [3, 4 + 5*I])
[9 + 5*I, 8/3 + 10*I/3]
&gt;&gt;&gt; intersecting_product([1, 3, S(5)/7], [7, 8])
[327/7, 24, 0, 0]

References
==========

.. [1] https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
