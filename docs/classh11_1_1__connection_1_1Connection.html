<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: h11._connection.Connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceh11.html">h11</a></li><li class="navelem"><a class="el" href="namespaceh11_1_1__connection.html">_connection</a></li><li class="navelem"><a class="el" href="classh11_1_1__connection_1_1Connection.html">Connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classh11_1_1__connection_1_1Connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">h11._connection.Connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main <a class="el" href="classh11_1_1__connection_1_1Connection.html" title="The main Connection class.">Connection</a> class.  
 <a href="classh11_1_1__connection_1_1Connection.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e5bec244cfb0618fc1627650b979d8e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a8e5bec244cfb0618fc1627650b979d8e">__init__</a> (self, Type[Sentinel] <a class="el" href="classh11_1_1__connection_1_1Connection.html#a6b75dcb5ae09280d5ea094a20767d809">our_role</a>, int max_incomplete_event_size=<a class="el" href="namespaceh11_1_1__connection.html#a527adb20fe32712354a94f57dfeccbb4">DEFAULT_MAX_INCOMPLETE_EVENT_SIZE</a>)</td></tr>
<tr class="separator:a8e5bec244cfb0618fc1627650b979d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ae471204b3c2cac3190c74abbd0f47"><td class="memItemLeft" align="right" valign="top">Dict[Type[Sentinel], Type[Sentinel]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a53ae471204b3c2cac3190c74abbd0f47">states</a> (self)</td></tr>
<tr class="separator:a53ae471204b3c2cac3190c74abbd0f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaee6a91d514fbc94203f88442a10cb5"><td class="memItemLeft" align="right" valign="top">Type[Sentinel]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#acaee6a91d514fbc94203f88442a10cb5">our_state</a> (self)</td></tr>
<tr class="separator:acaee6a91d514fbc94203f88442a10cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682497b538ab2873304100cfc098413"><td class="memItemLeft" align="right" valign="top">Type[Sentinel]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a9682497b538ab2873304100cfc098413">their_state</a> (self)</td></tr>
<tr class="separator:a9682497b538ab2873304100cfc098413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8054c3d09c3409dcb1a689706e246940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a8054c3d09c3409dcb1a689706e246940">they_are_waiting_for_100_continue</a> (self)</td></tr>
<tr class="separator:a8054c3d09c3409dcb1a689706e246940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85247bf7317d88d740d24b904792c8e3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a85247bf7317d88d740d24b904792c8e3">start_next_cycle</a> (self)</td></tr>
<tr class="separator:a85247bf7317d88d740d24b904792c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6800296e776adcce3761c98075a9fe"><td class="memItemLeft" align="right" valign="top">Tuple[bytes, bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a7e6800296e776adcce3761c98075a9fe">trailing_data</a> (self)</td></tr>
<tr class="separator:a7e6800296e776adcce3761c98075a9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202bde926a426b663ec8b5dded72ecd3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a202bde926a426b663ec8b5dded72ecd3">receive_data</a> (self, bytes data)</td></tr>
<tr class="separator:a202bde926a426b663ec8b5dded72ecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31a7686e334702045fb60a67b7db56b"><td class="memItemLeft" align="right" valign="top">Union[<a class="el" href="class__events_1_1Event.html">Event</a>, Type[<a class="el" href="classh11_1_1__connection_1_1NEED__DATA.html">NEED_DATA</a>], Type[<a class="el" href="classh11_1_1__connection_1_1PAUSED.html">PAUSED</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#af31a7686e334702045fb60a67b7db56b">next_event</a> (self)</td></tr>
<tr class="separator:af31a7686e334702045fb60a67b7db56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2c0a8de912c5889acd576766924af"><td class="memItemLeft" align="right" valign="top">Optional[bytes]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a9df2c0a8de912c5889acd576766924af">send</a> (self, <a class="el" href="class__events_1_1Event.html">Event</a> event)</td></tr>
<tr class="separator:a9df2c0a8de912c5889acd576766924af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ede64eaa08e893e3611e821bf8b979"><td class="memItemLeft" align="right" valign="top">Optional[List[bytes]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a36ede64eaa08e893e3611e821bf8b979">send_with_data_passthrough</a> (self, <a class="el" href="class__events_1_1Event.html">Event</a> event)</td></tr>
<tr class="separator:a36ede64eaa08e893e3611e821bf8b979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281460e23471bc92bd4060eee92e91cd"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a281460e23471bc92bd4060eee92e91cd">send_failed</a> (self)</td></tr>
<tr class="separator:a281460e23471bc92bd4060eee92e91cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5bec244cfb0618fc1627650b979d8e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a8e5bec244cfb0618fc1627650b979d8e">__init__</a> (self, Type[Sentinel] <a class="el" href="classh11_1_1__connection_1_1Connection.html#a6b75dcb5ae09280d5ea094a20767d809">our_role</a>, int max_incomplete_event_size=<a class="el" href="namespaceh11_1_1__connection.html#a527adb20fe32712354a94f57dfeccbb4">DEFAULT_MAX_INCOMPLETE_EVENT_SIZE</a>)</td></tr>
<tr class="separator:a8e5bec244cfb0618fc1627650b979d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ae471204b3c2cac3190c74abbd0f47"><td class="memItemLeft" align="right" valign="top">Dict[Type[Sentinel], Type[Sentinel]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a53ae471204b3c2cac3190c74abbd0f47">states</a> (self)</td></tr>
<tr class="separator:a53ae471204b3c2cac3190c74abbd0f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaee6a91d514fbc94203f88442a10cb5"><td class="memItemLeft" align="right" valign="top">Type[Sentinel]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#acaee6a91d514fbc94203f88442a10cb5">our_state</a> (self)</td></tr>
<tr class="separator:acaee6a91d514fbc94203f88442a10cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682497b538ab2873304100cfc098413"><td class="memItemLeft" align="right" valign="top">Type[Sentinel]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a9682497b538ab2873304100cfc098413">their_state</a> (self)</td></tr>
<tr class="separator:a9682497b538ab2873304100cfc098413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8054c3d09c3409dcb1a689706e246940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a8054c3d09c3409dcb1a689706e246940">they_are_waiting_for_100_continue</a> (self)</td></tr>
<tr class="separator:a8054c3d09c3409dcb1a689706e246940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85247bf7317d88d740d24b904792c8e3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a85247bf7317d88d740d24b904792c8e3">start_next_cycle</a> (self)</td></tr>
<tr class="separator:a85247bf7317d88d740d24b904792c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6800296e776adcce3761c98075a9fe"><td class="memItemLeft" align="right" valign="top">Tuple[bytes, bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a7e6800296e776adcce3761c98075a9fe">trailing_data</a> (self)</td></tr>
<tr class="separator:a7e6800296e776adcce3761c98075a9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202bde926a426b663ec8b5dded72ecd3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a202bde926a426b663ec8b5dded72ecd3">receive_data</a> (self, bytes data)</td></tr>
<tr class="separator:a202bde926a426b663ec8b5dded72ecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31a7686e334702045fb60a67b7db56b"><td class="memItemLeft" align="right" valign="top">Union[<a class="el" href="class__events_1_1Event.html">Event</a>, Type[<a class="el" href="classh11_1_1__connection_1_1NEED__DATA.html">NEED_DATA</a>], Type[<a class="el" href="classh11_1_1__connection_1_1PAUSED.html">PAUSED</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#af31a7686e334702045fb60a67b7db56b">next_event</a> (self)</td></tr>
<tr class="separator:af31a7686e334702045fb60a67b7db56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2c0a8de912c5889acd576766924af"><td class="memItemLeft" align="right" valign="top">Optional[bytes]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a9df2c0a8de912c5889acd576766924af">send</a> (self, <a class="el" href="class__events_1_1Event.html">Event</a> event)</td></tr>
<tr class="separator:a9df2c0a8de912c5889acd576766924af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ede64eaa08e893e3611e821bf8b979"><td class="memItemLeft" align="right" valign="top">Optional[List[bytes]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a36ede64eaa08e893e3611e821bf8b979">send_with_data_passthrough</a> (self, <a class="el" href="class__events_1_1Event.html">Event</a> event)</td></tr>
<tr class="separator:a36ede64eaa08e893e3611e821bf8b979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281460e23471bc92bd4060eee92e91cd"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a281460e23471bc92bd4060eee92e91cd">send_failed</a> (self)</td></tr>
<tr class="separator:a281460e23471bc92bd4060eee92e91cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6b75dcb5ae09280d5ea094a20767d809"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a6b75dcb5ae09280d5ea094a20767d809">our_role</a></td></tr>
<tr class="separator:a6b75dcb5ae09280d5ea094a20767d809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da9bea1018d73f99c46fdf66a2b04b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#af1da9bea1018d73f99c46fdf66a2b04b">their_role</a></td></tr>
<tr class="separator:af1da9bea1018d73f99c46fdf66a2b04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5204b5e2a59c9a126e8827d2725818e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#a5204b5e2a59c9a126e8827d2725818e6">client_is_waiting_for_100_continue</a></td></tr>
<tr class="separator:a5204b5e2a59c9a126e8827d2725818e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad561e0aeab3715bbcc8da888f22f90ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classh11_1_1__connection_1_1Connection.html#ad561e0aeab3715bbcc8da888f22f90ae">their_http_version</a></td></tr>
<tr class="separator:ad561e0aeab3715bbcc8da888f22f90ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main <a class="el" href="classh11_1_1__connection_1_1Connection.html" title="The main Connection class.">Connection</a> class. </p>
<pre class="fragment">An object encapsulating the state of an HTTP connection.

Args:
    our_role: If you're implementing a client, pass :data:`h11.CLIENT`. If
        you're implementing a server, pass :data:`h11.SERVER`.

    max_incomplete_event_size (int):
        The maximum number of bytes we're willing to buffer of an
        incomplete event. In practice this mostly sets a limit on the
        maximum size of the request/response line + headers. If this is
        exceeded, then :meth:`next_event` will raise
        :exc:`RemoteProtocolError`.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8e5bec244cfb0618fc1627650b979d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5bec244cfb0618fc1627650b979d8e">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None h11._connection.Connection.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type[Sentinel]&#160;</td>
          <td class="paramname"><em>our_role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>max_incomplete_event_size</em> = <code><a class="el" href="namespaceh11_1_1__connection.html#a527adb20fe32712354a94f57dfeccbb4">DEFAULT_MAX_INCOMPLETE_EVENT_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e5bec244cfb0618fc1627650b979d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5bec244cfb0618fc1627650b979d8e">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None h11._connection.Connection.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type[Sentinel]&#160;</td>
          <td class="paramname"><em>our_role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>max_incomplete_event_size</em> = <code><a class="el" href="namespaceh11_1_1__connection.html#a527adb20fe32712354a94f57dfeccbb4">DEFAULT_MAX_INCOMPLETE_EVENT_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af31a7686e334702045fb60a67b7db56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31a7686e334702045fb60a67b7db56b">&#9670;&nbsp;</a></span>next_event() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[<a class="el" href="class__events_1_1Event.html">Event</a>, Type[<a class="el" href="classh11_1_1__connection_1_1NEED__DATA.html">NEED_DATA</a>], Type[<a class="el" href="classh11_1_1__connection_1_1PAUSED.html">PAUSED</a>]] h11._connection.Connection.next_event </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse the next event out of our receive buffer, update our internal
state, and return it.

This is a mutating operation -- think of it like calling :func:`next`
on an iterator.

Returns:
    : One of three things:

    1) An event object -- see :ref:`events`.

    2) The special constant :data:`NEED_DATA`, which indicates that
       you need to read more data from your socket and pass it to
       :meth:`receive_data` before this method will be able to return
       any more events.

    3) The special constant :data:`PAUSED`, which indicates that we
       are not in a state where we can process incoming data (usually
       because the peer has finished their part of the current
       request/response cycle, and you have not yet called
       :meth:`start_next_cycle`). See :ref:`flow-control` for details.

Raises:
    RemoteProtocolError:
        The peer has misbehaved. You should close the connection
        (possibly after sending some kind of 4xx response).

Once this method returns :class:`ConnectionClosed` once, then all
subsequent calls will also return :class:`ConnectionClosed`.

If this method raises any exception besides :exc:`RemoteProtocolError`
then that's a bug -- if it happens please file a bug report!

If this method raises any exception then it also sets
:attr:`Connection.their_state` to :data:`ERROR` -- see
:ref:`error-handling` for discussion.</pre> 
</div>
</div>
<a id="af31a7686e334702045fb60a67b7db56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31a7686e334702045fb60a67b7db56b">&#9670;&nbsp;</a></span>next_event() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[<a class="el" href="class__events_1_1Event.html">Event</a>, Type[<a class="el" href="classh11_1_1__connection_1_1NEED__DATA.html">NEED_DATA</a>], Type[<a class="el" href="classh11_1_1__connection_1_1PAUSED.html">PAUSED</a>]] h11._connection.Connection.next_event </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse the next event out of our receive buffer, update our internal
state, and return it.

This is a mutating operation -- think of it like calling :func:`next`
on an iterator.

Returns:
    : One of three things:

    1) An event object -- see :ref:`events`.

    2) The special constant :data:`NEED_DATA`, which indicates that
       you need to read more data from your socket and pass it to
       :meth:`receive_data` before this method will be able to return
       any more events.

    3) The special constant :data:`PAUSED`, which indicates that we
       are not in a state where we can process incoming data (usually
       because the peer has finished their part of the current
       request/response cycle, and you have not yet called
       :meth:`start_next_cycle`). See :ref:`flow-control` for details.

Raises:
    RemoteProtocolError:
        The peer has misbehaved. You should close the connection
        (possibly after sending some kind of 4xx response).

Once this method returns :class:`ConnectionClosed` once, then all
subsequent calls will also return :class:`ConnectionClosed`.

If this method raises any exception besides :exc:`RemoteProtocolError`
then that's a bug -- if it happens please file a bug report!

If this method raises any exception then it also sets
:attr:`Connection.their_state` to :data:`ERROR` -- see
:ref:`error-handling` for discussion.</pre> 
</div>
</div>
<a id="acaee6a91d514fbc94203f88442a10cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaee6a91d514fbc94203f88442a10cb5">&#9670;&nbsp;</a></span>our_state() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Type[Sentinel] h11._connection.Connection.our_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The current state of whichever role we are playing. See
:ref:`state-machine` for details.
</pre> 
</div>
</div>
<a id="acaee6a91d514fbc94203f88442a10cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaee6a91d514fbc94203f88442a10cb5">&#9670;&nbsp;</a></span>our_state() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Type[Sentinel] h11._connection.Connection.our_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The current state of whichever role we are playing. See
:ref:`state-machine` for details.
</pre> 
</div>
</div>
<a id="a202bde926a426b663ec8b5dded72ecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202bde926a426b663ec8b5dded72ecd3">&#9670;&nbsp;</a></span>receive_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None h11._connection.Connection.receive_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add data to our internal receive buffer.

This does not actually do any processing on the data, just stores
it. To trigger processing, you have to call :meth:`next_event`.

Args:
    data (:term:`bytes-like object`):
        The new data that was just received.

        Special case: If *data* is an empty byte-string like ``b""``,
        then this indicates that the remote side has closed the
        connection (end of file). Normally this is convenient, because
        standard Python APIs like :meth:`file.read` or
        :meth:`socket.recv` use ``b""`` to indicate end-of-file, while
        other failures to read are indicated using other mechanisms
        like raising :exc:`TimeoutError`. When using such an API you
        can just blindly pass through whatever you get from ``read``
        to :meth:`receive_data`, and everything will work.

        But, if you have an API where reading an empty string is a
        valid non-EOF condition, then you need to be aware of this and
        make sure to check for such strings and avoid passing them to
        :meth:`receive_data`.

Returns:
    Nothing, but after calling this you should call :meth:`next_event`
    to parse the newly received data.

Raises:
    RuntimeError:
        Raised if you pass an empty *data*, indicating EOF, and then
        pass a non-empty *data*, indicating more data that somehow
        arrived after the EOF.

        (Calling ``receive_data(b"")`` multiple times is fine,
        and equivalent to calling it once.)</pre> 
</div>
</div>
<a id="a202bde926a426b663ec8b5dded72ecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202bde926a426b663ec8b5dded72ecd3">&#9670;&nbsp;</a></span>receive_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None h11._connection.Connection.receive_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add data to our internal receive buffer.

This does not actually do any processing on the data, just stores
it. To trigger processing, you have to call :meth:`next_event`.

Args:
    data (:term:`bytes-like object`):
        The new data that was just received.

        Special case: If *data* is an empty byte-string like ``b""``,
        then this indicates that the remote side has closed the
        connection (end of file). Normally this is convenient, because
        standard Python APIs like :meth:`file.read` or
        :meth:`socket.recv` use ``b""`` to indicate end-of-file, while
        other failures to read are indicated using other mechanisms
        like raising :exc:`TimeoutError`. When using such an API you
        can just blindly pass through whatever you get from ``read``
        to :meth:`receive_data`, and everything will work.

        But, if you have an API where reading an empty string is a
        valid non-EOF condition, then you need to be aware of this and
        make sure to check for such strings and avoid passing them to
        :meth:`receive_data`.

Returns:
    Nothing, but after calling this you should call :meth:`next_event`
    to parse the newly received data.

Raises:
    RuntimeError:
        Raised if you pass an empty *data*, indicating EOF, and then
        pass a non-empty *data*, indicating more data that somehow
        arrived after the EOF.

        (Calling ``receive_data(b"")`` multiple times is fine,
        and equivalent to calling it once.)</pre> 
</div>
</div>
<a id="a9df2c0a8de912c5889acd576766924af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2c0a8de912c5889acd576766924af">&#9670;&nbsp;</a></span>send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[bytes] h11._connection.Connection.send </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class__events_1_1Event.html">Event</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a high-level event into bytes that can be sent to the peer,
while updating our internal state machine.

Args:
    event: The :ref:`event &lt;events&gt;` to send.

Returns:
    If ``type(event) is ConnectionClosed``, then returns
    ``None``. Otherwise, returns a :term:`bytes-like object`.

Raises:
    LocalProtocolError:
        Sending this event at this time would violate our
        understanding of the HTTP/1.1 protocol.

If this method raises any exception then it also sets
:attr:`Connection.our_state` to :data:`ERROR` -- see
:ref:`error-handling` for discussion.</pre> 
</div>
</div>
<a id="a9df2c0a8de912c5889acd576766924af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2c0a8de912c5889acd576766924af">&#9670;&nbsp;</a></span>send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[bytes] h11._connection.Connection.send </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class__events_1_1Event.html">Event</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a high-level event into bytes that can be sent to the peer,
while updating our internal state machine.

Args:
    event: The :ref:`event &lt;events&gt;` to send.

Returns:
    If ``type(event) is ConnectionClosed``, then returns
    ``None``. Otherwise, returns a :term:`bytes-like object`.

Raises:
    LocalProtocolError:
        Sending this event at this time would violate our
        understanding of the HTTP/1.1 protocol.

If this method raises any exception then it also sets
:attr:`Connection.our_state` to :data:`ERROR` -- see
:ref:`error-handling` for discussion.</pre> 
</div>
</div>
<a id="a281460e23471bc92bd4060eee92e91cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281460e23471bc92bd4060eee92e91cd">&#9670;&nbsp;</a></span>send_failed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None h11._connection.Connection.send_failed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Notify the state machine that we failed to send the data it gave
us.

This causes :attr:`Connection.our_state` to immediately become
:data:`ERROR` -- see :ref:`error-handling` for discussion.</pre> 
</div>
</div>
<a id="a281460e23471bc92bd4060eee92e91cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281460e23471bc92bd4060eee92e91cd">&#9670;&nbsp;</a></span>send_failed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None h11._connection.Connection.send_failed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Notify the state machine that we failed to send the data it gave
us.

This causes :attr:`Connection.our_state` to immediately become
:data:`ERROR` -- see :ref:`error-handling` for discussion.</pre> 
</div>
</div>
<a id="a36ede64eaa08e893e3611e821bf8b979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ede64eaa08e893e3611e821bf8b979">&#9670;&nbsp;</a></span>send_with_data_passthrough() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[List[bytes]] h11._connection.Connection.send_with_data_passthrough </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class__events_1_1Event.html">Event</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Identical to :meth:`send`, except that in situations where
:meth:`send` returns a single :term:`bytes-like object`, this instead
returns a list of them -- and when sending a :class:`Data` event, this
list is guaranteed to contain the exact object you passed in as
:attr:`Data.data`. See :ref:`sendfile` for discussion.</pre> 
</div>
</div>
<a id="a36ede64eaa08e893e3611e821bf8b979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ede64eaa08e893e3611e821bf8b979">&#9670;&nbsp;</a></span>send_with_data_passthrough() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[List[bytes]] h11._connection.Connection.send_with_data_passthrough </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class__events_1_1Event.html">Event</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Identical to :meth:`send`, except that in situations where
:meth:`send` returns a single :term:`bytes-like object`, this instead
returns a list of them -- and when sending a :class:`Data` event, this
list is guaranteed to contain the exact object you passed in as
:attr:`Data.data`. See :ref:`sendfile` for discussion.</pre> 
</div>
</div>
<a id="a85247bf7317d88d740d24b904792c8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85247bf7317d88d740d24b904792c8e3">&#9670;&nbsp;</a></span>start_next_cycle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None h11._connection.Connection.start_next_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Attempt to reset our connection state for a new request/response
cycle.

If both client and server are in :data:`DONE` state, then resets them
both to :data:`IDLE` state in preparation for a new request/response
cycle on this same connection. Otherwise, raises a
:exc:`LocalProtocolError`.

See :ref:`keepalive-and-pipelining`.</pre> 
</div>
</div>
<a id="a85247bf7317d88d740d24b904792c8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85247bf7317d88d740d24b904792c8e3">&#9670;&nbsp;</a></span>start_next_cycle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None h11._connection.Connection.start_next_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Attempt to reset our connection state for a new request/response
cycle.

If both client and server are in :data:`DONE` state, then resets them
both to :data:`IDLE` state in preparation for a new request/response
cycle on this same connection. Otherwise, raises a
:exc:`LocalProtocolError`.

See :ref:`keepalive-and-pipelining`.</pre> 
</div>
</div>
<a id="a53ae471204b3c2cac3190c74abbd0f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ae471204b3c2cac3190c74abbd0f47">&#9670;&nbsp;</a></span>states() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[Type[Sentinel], Type[Sentinel]] h11._connection.Connection.states </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A dictionary like::

   {CLIENT: &lt;client state&gt;, SERVER: &lt;server state&gt;}

See :ref:`state-machine` for details.</pre> 
</div>
</div>
<a id="a53ae471204b3c2cac3190c74abbd0f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ae471204b3c2cac3190c74abbd0f47">&#9670;&nbsp;</a></span>states() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[Type[Sentinel], Type[Sentinel]] h11._connection.Connection.states </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A dictionary like::

   {CLIENT: &lt;client state&gt;, SERVER: &lt;server state&gt;}

See :ref:`state-machine` for details.</pre> 
</div>
</div>
<a id="a9682497b538ab2873304100cfc098413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682497b538ab2873304100cfc098413">&#9670;&nbsp;</a></span>their_state() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Type[Sentinel] h11._connection.Connection.their_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The current state of whichever role we are NOT playing. See
:ref:`state-machine` for details.
</pre> 
</div>
</div>
<a id="a9682497b538ab2873304100cfc098413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682497b538ab2873304100cfc098413">&#9670;&nbsp;</a></span>their_state() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Type[Sentinel] h11._connection.Connection.their_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The current state of whichever role we are NOT playing. See
:ref:`state-machine` for details.
</pre> 
</div>
</div>
<a id="a8054c3d09c3409dcb1a689706e246940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8054c3d09c3409dcb1a689706e246940">&#9670;&nbsp;</a></span>they_are_waiting_for_100_continue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool h11._connection.Connection.they_are_waiting_for_100_continue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8054c3d09c3409dcb1a689706e246940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8054c3d09c3409dcb1a689706e246940">&#9670;&nbsp;</a></span>they_are_waiting_for_100_continue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool h11._connection.Connection.they_are_waiting_for_100_continue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e6800296e776adcce3761c98075a9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6800296e776adcce3761c98075a9fe">&#9670;&nbsp;</a></span>trailing_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[bytes, bool] h11._connection.Connection.trailing_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Data that has been received, but not yet processed, represented as
a tuple with two elements, where the first is a byte-string containing
the unprocessed data itself, and the second is a bool that is True if
the receive connection was closed.

See :ref:`switching-protocols` for discussion of why you'd want this.
</pre> 
</div>
</div>
<a id="a7e6800296e776adcce3761c98075a9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6800296e776adcce3761c98075a9fe">&#9670;&nbsp;</a></span>trailing_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[bytes, bool] h11._connection.Connection.trailing_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Data that has been received, but not yet processed, represented as
a tuple with two elements, where the first is a byte-string containing
the unprocessed data itself, and the second is a bool that is True if
the receive connection was closed.

See :ref:`switching-protocols` for discussion of why you'd want this.
</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5204b5e2a59c9a126e8827d2725818e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5204b5e2a59c9a126e8827d2725818e6">&#9670;&nbsp;</a></span>client_is_waiting_for_100_continue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">h11._connection.Connection.client_is_waiting_for_100_continue</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b75dcb5ae09280d5ea094a20767d809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b75dcb5ae09280d5ea094a20767d809">&#9670;&nbsp;</a></span>our_role</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">h11._connection.Connection.our_role</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad561e0aeab3715bbcc8da888f22f90ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad561e0aeab3715bbcc8da888f22f90ae">&#9670;&nbsp;</a></span>their_http_version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">h11._connection.Connection.their_http_version</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1da9bea1018d73f99c46fdf66a2b04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da9bea1018d73f99c46fdf66a2b04b">&#9670;&nbsp;</a></span>their_role</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">h11._connection.Connection.their_role</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/h11/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2h11_2__connection_8py.html">_connection.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
