<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.polys.matrices.domainmatrix.DomainMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys.html">polys</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys_1_1matrices.html">matrices</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys_1_1matrices_1_1domainmatrix.html">domainmatrix</a></li><li class="navelem"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html">DomainMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sympy.polys.matrices.domainmatrix.DomainMatrix Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c79b08c8def6c7a4b6528e7c8c0ce4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1c79b08c8def6c7a4b6528e7c8c0ce4e">__new__</a> (cls, rows, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>, *fmt=None)</td></tr>
<tr class="separator:a1c79b08c8def6c7a4b6528e7c8c0ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3641c663c2e010108f2258ab78c7d6ea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a3641c663c2e010108f2258ab78c7d6ea">__reduce__</a> (self)</td></tr>
<tr class="separator:a3641c663c2e010108f2258ab78c7d6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3c8391484f55a085e7e1d7b5b42cb0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abe3c8391484f55a085e7e1d7b5b42cb0">__getitem__</a> (self, key)</td></tr>
<tr class="separator:abe3c8391484f55a085e7e1d7b5b42cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb71d1e7892b1e8a5208a02d95e8a9fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#afb71d1e7892b1e8a5208a02d95e8a9fc">getitem_sympy</a> (self, i, j)</td></tr>
<tr class="separator:afb71d1e7892b1e8a5208a02d95e8a9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f8c75cbc7dbac52120c07164788922"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac4f8c75cbc7dbac52120c07164788922">extract</a> (self, rowslist, colslist)</td></tr>
<tr class="separator:ac4f8c75cbc7dbac52120c07164788922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e34915f537ad7f13149f23cdc22c01"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af4e34915f537ad7f13149f23cdc22c01">__setitem__</a> (self, key, value)</td></tr>
<tr class="separator:af4e34915f537ad7f13149f23cdc22c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137fe98368ba45ea0c213f809fdd9d5a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a137fe98368ba45ea0c213f809fdd9d5a">from_rep</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad68d2cd9a422c71acf52dfeeadd936f4">rep</a>)</td></tr>
<tr class="separator:a137fe98368ba45ea0c213f809fdd9d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e62aa11881828a4b4f2a58078ff74c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa3e62aa11881828a4b4f2a58078ff74c">from_list</a> (cls, rows, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:aa3e62aa11881828a4b4f2a58078ff74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544459607961da9e88b62e14c7afe770"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a544459607961da9e88b62e14c7afe770">from_list_sympy</a> (cls, nrows, ncols, rows, **kwargs)</td></tr>
<tr class="separator:a544459607961da9e88b62e14c7afe770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625d31cf0d0ea2eb30a9ddfadf7a9b51"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a625d31cf0d0ea2eb30a9ddfadf7a9b51">from_dict_sympy</a> (cls, nrows, ncols, elemsdict, **kwargs)</td></tr>
<tr class="separator:a625d31cf0d0ea2eb30a9ddfadf7a9b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac5b26ae644724d9c7ec3b553527353"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abac5b26ae644724d9c7ec3b553527353">from_Matrix</a> (cls, M, fmt='sparse', **kwargs)</td></tr>
<tr class="separator:abac5b26ae644724d9c7ec3b553527353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65147137cdf9ddfd28355460b5d56bb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a65147137cdf9ddfd28355460b5d56bb3">get_domain</a> (cls, items_sympy, **kwargs)</td></tr>
<tr class="separator:a65147137cdf9ddfd28355460b5d56bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17737a3d2e48f2da2021138f79ca4032"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a17737a3d2e48f2da2021138f79ca4032">choose_domain</a> (self, **opts)</td></tr>
<tr class="separator:a17737a3d2e48f2da2021138f79ca4032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e7fe9acba3ff1a7acd2792edaf7dc6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ab6e7fe9acba3ff1a7acd2792edaf7dc6">copy</a> (self)</td></tr>
<tr class="separator:ab6e7fe9acba3ff1a7acd2792edaf7dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed8af726ae1788c852bbc07c4028de2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a2ed8af726ae1788c852bbc07c4028de2">convert_to</a> (self, K)</td></tr>
<tr class="separator:a2ed8af726ae1788c852bbc07c4028de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae36de5045b409649c71209ba204ab6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a3ae36de5045b409649c71209ba204ab6">to_sympy</a> (self)</td></tr>
<tr class="separator:a3ae36de5045b409649c71209ba204ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b02a6b37e1c83d0a60cb52d84bacbc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a52b02a6b37e1c83d0a60cb52d84bacbc">to_field</a> (self)</td></tr>
<tr class="separator:a52b02a6b37e1c83d0a60cb52d84bacbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac93c584a158d80089f203c2cf6eb24"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6ac93c584a158d80089f203c2cf6eb24">to_sparse</a> (self)</td></tr>
<tr class="separator:a6ac93c584a158d80089f203c2cf6eb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddf70e84cf243b2e7bec88c19686f24"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#adddf70e84cf243b2e7bec88c19686f24">to_dense</a> (self)</td></tr>
<tr class="separator:adddf70e84cf243b2e7bec88c19686f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92309ffd7897c60260b58b9dc3d4c621"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a92309ffd7897c60260b58b9dc3d4c621">to_ddm</a> (self)</td></tr>
<tr class="separator:a92309ffd7897c60260b58b9dc3d4c621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a911148bc0f2a22e60a58ab1ed14ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a35a911148bc0f2a22e60a58ab1ed14ae">to_sdm</a> (self)</td></tr>
<tr class="separator:a35a911148bc0f2a22e60a58ab1ed14ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e43ff53f5277989e4ab464289d9b6c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a36e43ff53f5277989e4ab464289d9b6c">to_dfm</a> (self)</td></tr>
<tr class="separator:a36e43ff53f5277989e4ab464289d9b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04746174317b915f668e308cfc4e5494"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a04746174317b915f668e308cfc4e5494">to_dfm_or_ddm</a> (self)</td></tr>
<tr class="separator:a04746174317b915f668e308cfc4e5494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522d813bf89ff4460578f25880c0b004"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a522d813bf89ff4460578f25880c0b004">unify</a> (self, *others, fmt=None)</td></tr>
<tr class="separator:a522d813bf89ff4460578f25880c0b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad84c24617871c77af2e8123e1c86aad"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aad84c24617871c77af2e8123e1c86aad">to_Matrix</a> (self)</td></tr>
<tr class="separator:aad84c24617871c77af2e8123e1c86aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8c46b669b1e3a52d930cbc443c1b33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aec8c46b669b1e3a52d930cbc443c1b33">to_list</a> (self)</td></tr>
<tr class="separator:aec8c46b669b1e3a52d930cbc443c1b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8687488e94e5f9d42dc40b30ae5824e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a8687488e94e5f9d42dc40b30ae5824e6">to_list_flat</a> (self)</td></tr>
<tr class="separator:a8687488e94e5f9d42dc40b30ae5824e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02d30b84a7bc9a74e5761052a5869e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac02d30b84a7bc9a74e5761052a5869e3">from_list_flat</a> (cls, elements, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:ac02d30b84a7bc9a74e5761052a5869e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a77c2dae61d39816ac61a55fa012d58"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a4a77c2dae61d39816ac61a55fa012d58">to_flat_nz</a> (self)</td></tr>
<tr class="separator:a4a77c2dae61d39816ac61a55fa012d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bdf98f78eaad0beced5b755f516209"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac2bdf98f78eaad0beced5b755f516209">from_flat_nz</a> (self, elements, data, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:ac2bdf98f78eaad0beced5b755f516209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c9860c962fb0a944951766a36c2496"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a90c9860c962fb0a944951766a36c2496">to_dod</a> (self)</td></tr>
<tr class="separator:a90c9860c962fb0a944951766a36c2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b73545c9c82c7d0f43db82b6367eff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a27b73545c9c82c7d0f43db82b6367eff">from_dod</a> (cls, dod, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:a27b73545c9c82c7d0f43db82b6367eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfdd0ff12ed0254a6f0db098536d26d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#accfdd0ff12ed0254a6f0db098536d26d">from_dod_like</a> (self, dod, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>=None)</td></tr>
<tr class="separator:accfdd0ff12ed0254a6f0db098536d26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30e4ff4e9c92094591c9a8a4e4fe663"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa30e4ff4e9c92094591c9a8a4e4fe663">to_dok</a> (self)</td></tr>
<tr class="separator:aa30e4ff4e9c92094591c9a8a4e4fe663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351ccec65f22324c009e21b2d85a29a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a351ccec65f22324c009e21b2d85a29a0">from_dok</a> (cls, dok, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:a351ccec65f22324c009e21b2d85a29a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c5eb09e4469056c14a45be62c32e79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a43c5eb09e4469056c14a45be62c32e79">iter_values</a> (self)</td></tr>
<tr class="separator:a43c5eb09e4469056c14a45be62c32e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d0735bd910214f27e25a7582191aaa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a74d0735bd910214f27e25a7582191aaa">iter_items</a> (self)</td></tr>
<tr class="separator:a74d0735bd910214f27e25a7582191aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade91be9261e5f4299983a6d34698afa6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ade91be9261e5f4299983a6d34698afa6">nnz</a> (self)</td></tr>
<tr class="separator:ade91be9261e5f4299983a6d34698afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d5c0e09a12f3d689098b15457d09a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a75d5c0e09a12f3d689098b15457d09a2">__repr__</a> (self)</td></tr>
<tr class="separator:a75d5c0e09a12f3d689098b15457d09a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d4661971ef38eb400d98f6d31491a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a163d4661971ef38eb400d98f6d31491a">transpose</a> (self)</td></tr>
<tr class="separator:a163d4661971ef38eb400d98f6d31491a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931a657dafe2de4aa191eb59ab94fa82"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a931a657dafe2de4aa191eb59ab94fa82">flat</a> (self)</td></tr>
<tr class="separator:a931a657dafe2de4aa191eb59ab94fa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63ca4b56b99e10a996bfc517a389c2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ae63ca4b56b99e10a996bfc517a389c2e">is_zero_matrix</a> (self)</td></tr>
<tr class="separator:ae63ca4b56b99e10a996bfc517a389c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6a068dd2382fcf19c33e189b1ee823"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abe6a068dd2382fcf19c33e189b1ee823">is_upper</a> (self)</td></tr>
<tr class="separator:abe6a068dd2382fcf19c33e189b1ee823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a33b312a5ccd75a2d9f44b3c13d1924"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a9a33b312a5ccd75a2d9f44b3c13d1924">is_lower</a> (self)</td></tr>
<tr class="separator:a9a33b312a5ccd75a2d9f44b3c13d1924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214fa555b0cf49aeb9d73650a18c8f60"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a214fa555b0cf49aeb9d73650a18c8f60">is_diagonal</a> (self)</td></tr>
<tr class="separator:a214fa555b0cf49aeb9d73650a18c8f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cce1761f9b483df9a19c705788dfc5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa1cce1761f9b483df9a19c705788dfc5">diagonal</a> (self)</td></tr>
<tr class="separator:aa1cce1761f9b483df9a19c705788dfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a996fb2f5b2cd07ea389d7df264c7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a26a996fb2f5b2cd07ea389d7df264c7d">is_square</a> (self)</td></tr>
<tr class="separator:a26a996fb2f5b2cd07ea389d7df264c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6cf029de10dccefeb57ab33892a089"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a4c6cf029de10dccefeb57ab33892a089">rank</a> (self)</td></tr>
<tr class="separator:a4c6cf029de10dccefeb57ab33892a089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa736d2c4f1df061b08928b5ec7b44d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a2aa736d2c4f1df061b08928b5ec7b44d">hstack</a> (A, *B)</td></tr>
<tr class="separator:a2aa736d2c4f1df061b08928b5ec7b44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fb8042e3c1c9c678fd4e8773eb5b17"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a27fb8042e3c1c9c678fd4e8773eb5b17">vstack</a> (A, *B)</td></tr>
<tr class="separator:a27fb8042e3c1c9c678fd4e8773eb5b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1991027b5f177b28945bc4b73fd70372"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1991027b5f177b28945bc4b73fd70372">applyfunc</a> (self, func, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>=None)</td></tr>
<tr class="separator:a1991027b5f177b28945bc4b73fd70372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af59957134410153f3d2628f1c900e0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a0af59957134410153f3d2628f1c900e0">__add__</a> (A, B)</td></tr>
<tr class="separator:a0af59957134410153f3d2628f1c900e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189c5557f18174b74be44941febda3cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a189c5557f18174b74be44941febda3cd">__sub__</a> (A, B)</td></tr>
<tr class="separator:a189c5557f18174b74be44941febda3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdafac1ea0966bc08e42b3bfbada4086"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abdafac1ea0966bc08e42b3bfbada4086">__neg__</a> (A)</td></tr>
<tr class="separator:abdafac1ea0966bc08e42b3bfbada4086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd628fecee8ef82126c5bb6d229bc700"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#acd628fecee8ef82126c5bb6d229bc700">__mul__</a> (A, B)</td></tr>
<tr class="separator:acd628fecee8ef82126c5bb6d229bc700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16789b78e218d719a6aca70991e460d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a16789b78e218d719a6aca70991e460d6">__rmul__</a> (A, B)</td></tr>
<tr class="separator:a16789b78e218d719a6aca70991e460d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fd46d81c586fa304986bb6e707368b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad3fd46d81c586fa304986bb6e707368b">__pow__</a> (A, n)</td></tr>
<tr class="separator:ad3fd46d81c586fa304986bb6e707368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a2c67d74599f626722d378416696f1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac7a2c67d74599f626722d378416696f1">add</a> (A, B)</td></tr>
<tr class="separator:ac7a2c67d74599f626722d378416696f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cefbcd0e50322c969261d1ddea53a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af3cefbcd0e50322c969261d1ddea53a2">sub</a> (A, B)</td></tr>
<tr class="separator:af3cefbcd0e50322c969261d1ddea53a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4765f1e4fb6be91e1be509dfda52cc2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa4765f1e4fb6be91e1be509dfda52cc2">neg</a> (A)</td></tr>
<tr class="separator:aa4765f1e4fb6be91e1be509dfda52cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fe1cdac3c60075482677f75c9f7ffb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ab9fe1cdac3c60075482677f75c9f7ffb">mul</a> (A, b)</td></tr>
<tr class="separator:ab9fe1cdac3c60075482677f75c9f7ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e1d5af953a3a03fd46e7dbb3c22ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac08e1d5af953a3a03fd46e7dbb3c22ae">rmul</a> (A, b)</td></tr>
<tr class="separator:ac08e1d5af953a3a03fd46e7dbb3c22ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264a0cbf1e4a79c53e641285ed473498"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a264a0cbf1e4a79c53e641285ed473498">matmul</a> (A, B)</td></tr>
<tr class="separator:a264a0cbf1e4a79c53e641285ed473498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e1edbb49566a35352ab4514710304"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aad2e1edbb49566a35352ab4514710304">scalarmul</a> (A, lamda)</td></tr>
<tr class="separator:aad2e1edbb49566a35352ab4514710304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8c72cfcb427b43bcc69c2ecbc1be8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a5f8c72cfcb427b43bcc69c2ecbc1be8f">rscalarmul</a> (A, lamda)</td></tr>
<tr class="separator:a5f8c72cfcb427b43bcc69c2ecbc1be8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d63c808b2328f6e9d48467d4ba581"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a231d63c808b2328f6e9d48467d4ba581">mul_elementwise</a> (A, B)</td></tr>
<tr class="separator:a231d63c808b2328f6e9d48467d4ba581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3db557dff2d0583bfcdc76350d8f05"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abb3db557dff2d0583bfcdc76350d8f05">__truediv__</a> (A, lamda)</td></tr>
<tr class="separator:abb3db557dff2d0583bfcdc76350d8f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c6e38973f66006dfd1a1379a23f543"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a85c6e38973f66006dfd1a1379a23f543">pow</a> (A, n)</td></tr>
<tr class="separator:a85c6e38973f66006dfd1a1379a23f543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c5a407fdddb5dcac842aa41065c8f5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a76c5a407fdddb5dcac842aa41065c8f5">scc</a> (self)</td></tr>
<tr class="separator:a76c5a407fdddb5dcac842aa41065c8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806ac1d11be8377ae983ca1ef54fd293"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a806ac1d11be8377ae983ca1ef54fd293">clear_denoms</a> (self, convert=False)</td></tr>
<tr class="separator:a806ac1d11be8377ae983ca1ef54fd293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b19aa8f683a5e9f6996d69a927484d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a8b19aa8f683a5e9f6996d69a927484d5">clear_denoms_rowwise</a> (self, convert=False)</td></tr>
<tr class="separator:a8b19aa8f683a5e9f6996d69a927484d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59a4205bb39d868ecb9eb1db660f9cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ab59a4205bb39d868ecb9eb1db660f9cb">cancel_denom</a> (self, denom)</td></tr>
<tr class="separator:ab59a4205bb39d868ecb9eb1db660f9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eeb60aa6932ce0d63c51ad376c596dd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a0eeb60aa6932ce0d63c51ad376c596dd">cancel_denom_elementwise</a> (self, denom)</td></tr>
<tr class="separator:a0eeb60aa6932ce0d63c51ad376c596dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18449aacc0bb08a0b54ccce3c1ad9d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af18449aacc0bb08a0b54ccce3c1ad9d7">content</a> (self)</td></tr>
<tr class="separator:af18449aacc0bb08a0b54ccce3c1ad9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abace3470aee0892f7d4f84924de42202"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abace3470aee0892f7d4f84924de42202">primitive</a> (self)</td></tr>
<tr class="separator:abace3470aee0892f7d4f84924de42202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ac0f550c87c1d77f9682d6ad67a638"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af3ac0f550c87c1d77f9682d6ad67a638">rref</a> (self, *method='auto')</td></tr>
<tr class="separator:af3ac0f550c87c1d77f9682d6ad67a638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7175d96842fdabfeb2ff65b1974c61"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#adb7175d96842fdabfeb2ff65b1974c61">rref_den</a> (self, *method='auto', keep_domain=True)</td></tr>
<tr class="separator:adb7175d96842fdabfeb2ff65b1974c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6b5e468d0d7772e556ecd9d43209fd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aea6b5e468d0d7772e556ecd9d43209fd">columnspace</a> (self)</td></tr>
<tr class="separator:aea6b5e468d0d7772e556ecd9d43209fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbbf66993a0992ecfbb99165473de77"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aecbbf66993a0992ecfbb99165473de77">rowspace</a> (self)</td></tr>
<tr class="separator:aecbbf66993a0992ecfbb99165473de77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94409ecbe7f83f55e90f0c0240b882e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad94409ecbe7f83f55e90f0c0240b882e">nullspace</a> (self, divide_last=False)</td></tr>
<tr class="separator:ad94409ecbe7f83f55e90f0c0240b882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbab0d56703b2017642c81bd8650ffb0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#acbab0d56703b2017642c81bd8650ffb0">nullspace_from_rref</a> (self, pivots=None)</td></tr>
<tr class="separator:acbab0d56703b2017642c81bd8650ffb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdbe31a058eaf83ccdb2e5a7c3b4c1a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a0fdbe31a058eaf83ccdb2e5a7c3b4c1a">inv</a> (self)</td></tr>
<tr class="separator:a0fdbe31a058eaf83ccdb2e5a7c3b4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab514d6ac4370556e8555dfa97c82579d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ab514d6ac4370556e8555dfa97c82579d">det</a> (self)</td></tr>
<tr class="separator:ab514d6ac4370556e8555dfa97c82579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a5afb9e24b0dba10afad10a7bdd947"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a51a5afb9e24b0dba10afad10a7bdd947">adj_det</a> (self)</td></tr>
<tr class="separator:a51a5afb9e24b0dba10afad10a7bdd947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae328d1f4d14f9e63315dc5d41b9dc977"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ae328d1f4d14f9e63315dc5d41b9dc977">adjugate</a> (self)</td></tr>
<tr class="separator:ae328d1f4d14f9e63315dc5d41b9dc977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04da1eeea5423b8bbcbb5e3e4502356"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af04da1eeea5423b8bbcbb5e3e4502356">inv_den</a> (self, method=None)</td></tr>
<tr class="separator:af04da1eeea5423b8bbcbb5e3e4502356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206309103dcb405764eb0ba28a7d01b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a206309103dcb405764eb0ba28a7d01b5">solve_den</a> (self, b, method=None)</td></tr>
<tr class="separator:a206309103dcb405764eb0ba28a7d01b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac603c488948514871b04c9f8a742e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a7ac603c488948514871b04c9f8a742e5">solve_den_rref</a> (self, b)</td></tr>
<tr class="separator:a7ac603c488948514871b04c9f8a742e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553bf71ed99cce7c8b58b203f259b63c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a553bf71ed99cce7c8b58b203f259b63c">solve_den_charpoly</a> (self, b, cp=None, check=True)</td></tr>
<tr class="separator:a553bf71ed99cce7c8b58b203f259b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bcf29815c1bf7d97a525a8b01dfbc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a17bcf29815c1bf7d97a525a8b01dfbc4">adj_poly_det</a> (self, cp=None)</td></tr>
<tr class="separator:a17bcf29815c1bf7d97a525a8b01dfbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a18eaabe983d24a972f74bcfd90dcc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1a18eaabe983d24a972f74bcfd90dcc4">eval_poly</a> (self, p)</td></tr>
<tr class="separator:a1a18eaabe983d24a972f74bcfd90dcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74804739901a7f09ff5e562b5018cbc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a74804739901a7f09ff5e562b5018cbc0">eval_poly_mul</a> (self, p, B)</td></tr>
<tr class="separator:a74804739901a7f09ff5e562b5018cbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e345c3ac35af13fe31541cf9102cefc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1e345c3ac35af13fe31541cf9102cefc">lu</a> (self)</td></tr>
<tr class="separator:a1e345c3ac35af13fe31541cf9102cefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b6b2cc575b58a546a4ee1db14d1775"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a96b6b2cc575b58a546a4ee1db14d1775">lu_solve</a> (self, rhs)</td></tr>
<tr class="separator:a96b6b2cc575b58a546a4ee1db14d1775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d40bea6a14d0ab7f12626bc9d666e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a579d40bea6a14d0ab7f12626bc9d666e">charpoly</a> (self)</td></tr>
<tr class="separator:a579d40bea6a14d0ab7f12626bc9d666e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ea9de9eefb1eb1439cdf51206c0a42"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad1ea9de9eefb1eb1439cdf51206c0a42">charpoly_factor_list</a> (self)</td></tr>
<tr class="separator:ad1ea9de9eefb1eb1439cdf51206c0a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10470f142bdd75dde28f1c41e773372"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af10470f142bdd75dde28f1c41e773372">charpoly_factor_blocks</a> (self)</td></tr>
<tr class="separator:af10470f142bdd75dde28f1c41e773372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb0a59fed5686a70ab53d56b3c668c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a89eb0a59fed5686a70ab53d56b3c668c">charpoly_base</a> (self)</td></tr>
<tr class="separator:a89eb0a59fed5686a70ab53d56b3c668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ea816289e1682b6540de3d874d0046"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad5ea816289e1682b6540de3d874d0046">charpoly_berk</a> (self)</td></tr>
<tr class="separator:ad5ea816289e1682b6540de3d874d0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7281ea94508cab033f30593522f2febb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a7281ea94508cab033f30593522f2febb">eye</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:a7281ea94508cab033f30593522f2febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5dafe5d5142c49ba83a81663645450"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1f5dafe5d5142c49ba83a81663645450">diag</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa1cce1761f9b483df9a19c705788dfc5">diagonal</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>=None)</td></tr>
<tr class="separator:a1f5dafe5d5142c49ba83a81663645450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f3b0156cd71e88c455974a8dc30da1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a10f3b0156cd71e88c455974a8dc30da1">zeros</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>, *fmt='sparse')</td></tr>
<tr class="separator:a10f3b0156cd71e88c455974a8dc30da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3807892dc98f02717632590a8726a69"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad3807892dc98f02717632590a8726a69">ones</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:ad3807892dc98f02717632590a8726a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70da03ba46f04a99da54ed9741f159"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a9d70da03ba46f04a99da54ed9741f159">__eq__</a> (A, B)</td></tr>
<tr class="separator:a9d70da03ba46f04a99da54ed9741f159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7b59737913339c3b8a136b9fda68bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#afb7b59737913339c3b8a136b9fda68bf">unify_eq</a> (A, B)</td></tr>
<tr class="separator:afb7b59737913339c3b8a136b9fda68bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5946e386c771ee7d7700393e5d8cb6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a7a5946e386c771ee7d7700393e5d8cb6">lll</a> (A, delta=QQ(3, 4))</td></tr>
<tr class="separator:a7a5946e386c771ee7d7700393e5d8cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfacbc23ca3701f45fe2d04ad92061d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a3bfacbc23ca3701f45fe2d04ad92061d">lll_transform</a> (A, delta=QQ(3, 4))</td></tr>
<tr class="separator:a3bfacbc23ca3701f45fe2d04ad92061d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c79b08c8def6c7a4b6528e7c8c0ce4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1c79b08c8def6c7a4b6528e7c8c0ce4e">__new__</a> (cls, rows, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>, *fmt=None)</td></tr>
<tr class="separator:a1c79b08c8def6c7a4b6528e7c8c0ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3641c663c2e010108f2258ab78c7d6ea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a3641c663c2e010108f2258ab78c7d6ea">__reduce__</a> (self)</td></tr>
<tr class="separator:a3641c663c2e010108f2258ab78c7d6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3c8391484f55a085e7e1d7b5b42cb0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abe3c8391484f55a085e7e1d7b5b42cb0">__getitem__</a> (self, key)</td></tr>
<tr class="separator:abe3c8391484f55a085e7e1d7b5b42cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb71d1e7892b1e8a5208a02d95e8a9fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#afb71d1e7892b1e8a5208a02d95e8a9fc">getitem_sympy</a> (self, i, j)</td></tr>
<tr class="separator:afb71d1e7892b1e8a5208a02d95e8a9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f8c75cbc7dbac52120c07164788922"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac4f8c75cbc7dbac52120c07164788922">extract</a> (self, rowslist, colslist)</td></tr>
<tr class="separator:ac4f8c75cbc7dbac52120c07164788922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e34915f537ad7f13149f23cdc22c01"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af4e34915f537ad7f13149f23cdc22c01">__setitem__</a> (self, key, value)</td></tr>
<tr class="separator:af4e34915f537ad7f13149f23cdc22c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137fe98368ba45ea0c213f809fdd9d5a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a137fe98368ba45ea0c213f809fdd9d5a">from_rep</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad68d2cd9a422c71acf52dfeeadd936f4">rep</a>)</td></tr>
<tr class="separator:a137fe98368ba45ea0c213f809fdd9d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e62aa11881828a4b4f2a58078ff74c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa3e62aa11881828a4b4f2a58078ff74c">from_list</a> (cls, rows, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:aa3e62aa11881828a4b4f2a58078ff74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544459607961da9e88b62e14c7afe770"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a544459607961da9e88b62e14c7afe770">from_list_sympy</a> (cls, nrows, ncols, rows, **kwargs)</td></tr>
<tr class="separator:a544459607961da9e88b62e14c7afe770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625d31cf0d0ea2eb30a9ddfadf7a9b51"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a625d31cf0d0ea2eb30a9ddfadf7a9b51">from_dict_sympy</a> (cls, nrows, ncols, elemsdict, **kwargs)</td></tr>
<tr class="separator:a625d31cf0d0ea2eb30a9ddfadf7a9b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac5b26ae644724d9c7ec3b553527353"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abac5b26ae644724d9c7ec3b553527353">from_Matrix</a> (cls, M, fmt='sparse', **kwargs)</td></tr>
<tr class="separator:abac5b26ae644724d9c7ec3b553527353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65147137cdf9ddfd28355460b5d56bb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a65147137cdf9ddfd28355460b5d56bb3">get_domain</a> (cls, items_sympy, **kwargs)</td></tr>
<tr class="separator:a65147137cdf9ddfd28355460b5d56bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17737a3d2e48f2da2021138f79ca4032"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a17737a3d2e48f2da2021138f79ca4032">choose_domain</a> (self, **opts)</td></tr>
<tr class="separator:a17737a3d2e48f2da2021138f79ca4032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e7fe9acba3ff1a7acd2792edaf7dc6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ab6e7fe9acba3ff1a7acd2792edaf7dc6">copy</a> (self)</td></tr>
<tr class="separator:ab6e7fe9acba3ff1a7acd2792edaf7dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed8af726ae1788c852bbc07c4028de2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a2ed8af726ae1788c852bbc07c4028de2">convert_to</a> (self, K)</td></tr>
<tr class="separator:a2ed8af726ae1788c852bbc07c4028de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae36de5045b409649c71209ba204ab6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a3ae36de5045b409649c71209ba204ab6">to_sympy</a> (self)</td></tr>
<tr class="separator:a3ae36de5045b409649c71209ba204ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b02a6b37e1c83d0a60cb52d84bacbc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a52b02a6b37e1c83d0a60cb52d84bacbc">to_field</a> (self)</td></tr>
<tr class="separator:a52b02a6b37e1c83d0a60cb52d84bacbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac93c584a158d80089f203c2cf6eb24"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6ac93c584a158d80089f203c2cf6eb24">to_sparse</a> (self)</td></tr>
<tr class="separator:a6ac93c584a158d80089f203c2cf6eb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddf70e84cf243b2e7bec88c19686f24"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#adddf70e84cf243b2e7bec88c19686f24">to_dense</a> (self)</td></tr>
<tr class="separator:adddf70e84cf243b2e7bec88c19686f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92309ffd7897c60260b58b9dc3d4c621"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a92309ffd7897c60260b58b9dc3d4c621">to_ddm</a> (self)</td></tr>
<tr class="separator:a92309ffd7897c60260b58b9dc3d4c621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a911148bc0f2a22e60a58ab1ed14ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a35a911148bc0f2a22e60a58ab1ed14ae">to_sdm</a> (self)</td></tr>
<tr class="separator:a35a911148bc0f2a22e60a58ab1ed14ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e43ff53f5277989e4ab464289d9b6c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a36e43ff53f5277989e4ab464289d9b6c">to_dfm</a> (self)</td></tr>
<tr class="separator:a36e43ff53f5277989e4ab464289d9b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04746174317b915f668e308cfc4e5494"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a04746174317b915f668e308cfc4e5494">to_dfm_or_ddm</a> (self)</td></tr>
<tr class="separator:a04746174317b915f668e308cfc4e5494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522d813bf89ff4460578f25880c0b004"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a522d813bf89ff4460578f25880c0b004">unify</a> (self, *others, fmt=None)</td></tr>
<tr class="separator:a522d813bf89ff4460578f25880c0b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad84c24617871c77af2e8123e1c86aad"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aad84c24617871c77af2e8123e1c86aad">to_Matrix</a> (self)</td></tr>
<tr class="separator:aad84c24617871c77af2e8123e1c86aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8c46b669b1e3a52d930cbc443c1b33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aec8c46b669b1e3a52d930cbc443c1b33">to_list</a> (self)</td></tr>
<tr class="separator:aec8c46b669b1e3a52d930cbc443c1b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8687488e94e5f9d42dc40b30ae5824e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a8687488e94e5f9d42dc40b30ae5824e6">to_list_flat</a> (self)</td></tr>
<tr class="separator:a8687488e94e5f9d42dc40b30ae5824e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02d30b84a7bc9a74e5761052a5869e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac02d30b84a7bc9a74e5761052a5869e3">from_list_flat</a> (cls, elements, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:ac02d30b84a7bc9a74e5761052a5869e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a77c2dae61d39816ac61a55fa012d58"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a4a77c2dae61d39816ac61a55fa012d58">to_flat_nz</a> (self)</td></tr>
<tr class="separator:a4a77c2dae61d39816ac61a55fa012d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bdf98f78eaad0beced5b755f516209"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac2bdf98f78eaad0beced5b755f516209">from_flat_nz</a> (self, elements, data, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:ac2bdf98f78eaad0beced5b755f516209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c9860c962fb0a944951766a36c2496"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a90c9860c962fb0a944951766a36c2496">to_dod</a> (self)</td></tr>
<tr class="separator:a90c9860c962fb0a944951766a36c2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b73545c9c82c7d0f43db82b6367eff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a27b73545c9c82c7d0f43db82b6367eff">from_dod</a> (cls, dod, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:a27b73545c9c82c7d0f43db82b6367eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfdd0ff12ed0254a6f0db098536d26d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#accfdd0ff12ed0254a6f0db098536d26d">from_dod_like</a> (self, dod, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>=None)</td></tr>
<tr class="separator:accfdd0ff12ed0254a6f0db098536d26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30e4ff4e9c92094591c9a8a4e4fe663"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa30e4ff4e9c92094591c9a8a4e4fe663">to_dok</a> (self)</td></tr>
<tr class="separator:aa30e4ff4e9c92094591c9a8a4e4fe663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351ccec65f22324c009e21b2d85a29a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a351ccec65f22324c009e21b2d85a29a0">from_dok</a> (cls, dok, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:a351ccec65f22324c009e21b2d85a29a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c5eb09e4469056c14a45be62c32e79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a43c5eb09e4469056c14a45be62c32e79">iter_values</a> (self)</td></tr>
<tr class="separator:a43c5eb09e4469056c14a45be62c32e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d0735bd910214f27e25a7582191aaa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a74d0735bd910214f27e25a7582191aaa">iter_items</a> (self)</td></tr>
<tr class="separator:a74d0735bd910214f27e25a7582191aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade91be9261e5f4299983a6d34698afa6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ade91be9261e5f4299983a6d34698afa6">nnz</a> (self)</td></tr>
<tr class="separator:ade91be9261e5f4299983a6d34698afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d5c0e09a12f3d689098b15457d09a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a75d5c0e09a12f3d689098b15457d09a2">__repr__</a> (self)</td></tr>
<tr class="separator:a75d5c0e09a12f3d689098b15457d09a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d4661971ef38eb400d98f6d31491a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a163d4661971ef38eb400d98f6d31491a">transpose</a> (self)</td></tr>
<tr class="separator:a163d4661971ef38eb400d98f6d31491a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931a657dafe2de4aa191eb59ab94fa82"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a931a657dafe2de4aa191eb59ab94fa82">flat</a> (self)</td></tr>
<tr class="separator:a931a657dafe2de4aa191eb59ab94fa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63ca4b56b99e10a996bfc517a389c2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ae63ca4b56b99e10a996bfc517a389c2e">is_zero_matrix</a> (self)</td></tr>
<tr class="separator:ae63ca4b56b99e10a996bfc517a389c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6a068dd2382fcf19c33e189b1ee823"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abe6a068dd2382fcf19c33e189b1ee823">is_upper</a> (self)</td></tr>
<tr class="separator:abe6a068dd2382fcf19c33e189b1ee823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a33b312a5ccd75a2d9f44b3c13d1924"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a9a33b312a5ccd75a2d9f44b3c13d1924">is_lower</a> (self)</td></tr>
<tr class="separator:a9a33b312a5ccd75a2d9f44b3c13d1924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214fa555b0cf49aeb9d73650a18c8f60"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a214fa555b0cf49aeb9d73650a18c8f60">is_diagonal</a> (self)</td></tr>
<tr class="separator:a214fa555b0cf49aeb9d73650a18c8f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cce1761f9b483df9a19c705788dfc5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa1cce1761f9b483df9a19c705788dfc5">diagonal</a> (self)</td></tr>
<tr class="separator:aa1cce1761f9b483df9a19c705788dfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a996fb2f5b2cd07ea389d7df264c7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a26a996fb2f5b2cd07ea389d7df264c7d">is_square</a> (self)</td></tr>
<tr class="separator:a26a996fb2f5b2cd07ea389d7df264c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6cf029de10dccefeb57ab33892a089"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a4c6cf029de10dccefeb57ab33892a089">rank</a> (self)</td></tr>
<tr class="separator:a4c6cf029de10dccefeb57ab33892a089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa736d2c4f1df061b08928b5ec7b44d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a2aa736d2c4f1df061b08928b5ec7b44d">hstack</a> (A, *B)</td></tr>
<tr class="separator:a2aa736d2c4f1df061b08928b5ec7b44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fb8042e3c1c9c678fd4e8773eb5b17"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a27fb8042e3c1c9c678fd4e8773eb5b17">vstack</a> (A, *B)</td></tr>
<tr class="separator:a27fb8042e3c1c9c678fd4e8773eb5b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1991027b5f177b28945bc4b73fd70372"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1991027b5f177b28945bc4b73fd70372">applyfunc</a> (self, func, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>=None)</td></tr>
<tr class="separator:a1991027b5f177b28945bc4b73fd70372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af59957134410153f3d2628f1c900e0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a0af59957134410153f3d2628f1c900e0">__add__</a> (A, B)</td></tr>
<tr class="separator:a0af59957134410153f3d2628f1c900e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189c5557f18174b74be44941febda3cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a189c5557f18174b74be44941febda3cd">__sub__</a> (A, B)</td></tr>
<tr class="separator:a189c5557f18174b74be44941febda3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdafac1ea0966bc08e42b3bfbada4086"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abdafac1ea0966bc08e42b3bfbada4086">__neg__</a> (A)</td></tr>
<tr class="separator:abdafac1ea0966bc08e42b3bfbada4086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd628fecee8ef82126c5bb6d229bc700"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#acd628fecee8ef82126c5bb6d229bc700">__mul__</a> (A, B)</td></tr>
<tr class="separator:acd628fecee8ef82126c5bb6d229bc700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16789b78e218d719a6aca70991e460d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a16789b78e218d719a6aca70991e460d6">__rmul__</a> (A, B)</td></tr>
<tr class="separator:a16789b78e218d719a6aca70991e460d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fd46d81c586fa304986bb6e707368b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad3fd46d81c586fa304986bb6e707368b">__pow__</a> (A, n)</td></tr>
<tr class="separator:ad3fd46d81c586fa304986bb6e707368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a2c67d74599f626722d378416696f1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac7a2c67d74599f626722d378416696f1">add</a> (A, B)</td></tr>
<tr class="separator:ac7a2c67d74599f626722d378416696f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cefbcd0e50322c969261d1ddea53a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af3cefbcd0e50322c969261d1ddea53a2">sub</a> (A, B)</td></tr>
<tr class="separator:af3cefbcd0e50322c969261d1ddea53a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4765f1e4fb6be91e1be509dfda52cc2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa4765f1e4fb6be91e1be509dfda52cc2">neg</a> (A)</td></tr>
<tr class="separator:aa4765f1e4fb6be91e1be509dfda52cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fe1cdac3c60075482677f75c9f7ffb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ab9fe1cdac3c60075482677f75c9f7ffb">mul</a> (A, b)</td></tr>
<tr class="separator:ab9fe1cdac3c60075482677f75c9f7ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e1d5af953a3a03fd46e7dbb3c22ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ac08e1d5af953a3a03fd46e7dbb3c22ae">rmul</a> (A, b)</td></tr>
<tr class="separator:ac08e1d5af953a3a03fd46e7dbb3c22ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264a0cbf1e4a79c53e641285ed473498"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a264a0cbf1e4a79c53e641285ed473498">matmul</a> (A, B)</td></tr>
<tr class="separator:a264a0cbf1e4a79c53e641285ed473498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e1edbb49566a35352ab4514710304"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aad2e1edbb49566a35352ab4514710304">scalarmul</a> (A, lamda)</td></tr>
<tr class="separator:aad2e1edbb49566a35352ab4514710304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8c72cfcb427b43bcc69c2ecbc1be8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a5f8c72cfcb427b43bcc69c2ecbc1be8f">rscalarmul</a> (A, lamda)</td></tr>
<tr class="separator:a5f8c72cfcb427b43bcc69c2ecbc1be8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d63c808b2328f6e9d48467d4ba581"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a231d63c808b2328f6e9d48467d4ba581">mul_elementwise</a> (A, B)</td></tr>
<tr class="separator:a231d63c808b2328f6e9d48467d4ba581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3db557dff2d0583bfcdc76350d8f05"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abb3db557dff2d0583bfcdc76350d8f05">__truediv__</a> (A, lamda)</td></tr>
<tr class="separator:abb3db557dff2d0583bfcdc76350d8f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c6e38973f66006dfd1a1379a23f543"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a85c6e38973f66006dfd1a1379a23f543">pow</a> (A, n)</td></tr>
<tr class="separator:a85c6e38973f66006dfd1a1379a23f543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c5a407fdddb5dcac842aa41065c8f5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a76c5a407fdddb5dcac842aa41065c8f5">scc</a> (self)</td></tr>
<tr class="separator:a76c5a407fdddb5dcac842aa41065c8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806ac1d11be8377ae983ca1ef54fd293"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a806ac1d11be8377ae983ca1ef54fd293">clear_denoms</a> (self, convert=False)</td></tr>
<tr class="separator:a806ac1d11be8377ae983ca1ef54fd293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b19aa8f683a5e9f6996d69a927484d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a8b19aa8f683a5e9f6996d69a927484d5">clear_denoms_rowwise</a> (self, convert=False)</td></tr>
<tr class="separator:a8b19aa8f683a5e9f6996d69a927484d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59a4205bb39d868ecb9eb1db660f9cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ab59a4205bb39d868ecb9eb1db660f9cb">cancel_denom</a> (self, denom)</td></tr>
<tr class="separator:ab59a4205bb39d868ecb9eb1db660f9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eeb60aa6932ce0d63c51ad376c596dd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a0eeb60aa6932ce0d63c51ad376c596dd">cancel_denom_elementwise</a> (self, denom)</td></tr>
<tr class="separator:a0eeb60aa6932ce0d63c51ad376c596dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18449aacc0bb08a0b54ccce3c1ad9d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af18449aacc0bb08a0b54ccce3c1ad9d7">content</a> (self)</td></tr>
<tr class="separator:af18449aacc0bb08a0b54ccce3c1ad9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abace3470aee0892f7d4f84924de42202"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#abace3470aee0892f7d4f84924de42202">primitive</a> (self)</td></tr>
<tr class="separator:abace3470aee0892f7d4f84924de42202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ac0f550c87c1d77f9682d6ad67a638"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af3ac0f550c87c1d77f9682d6ad67a638">rref</a> (self, *method='auto')</td></tr>
<tr class="separator:af3ac0f550c87c1d77f9682d6ad67a638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7175d96842fdabfeb2ff65b1974c61"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#adb7175d96842fdabfeb2ff65b1974c61">rref_den</a> (self, *method='auto', keep_domain=True)</td></tr>
<tr class="separator:adb7175d96842fdabfeb2ff65b1974c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6b5e468d0d7772e556ecd9d43209fd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aea6b5e468d0d7772e556ecd9d43209fd">columnspace</a> (self)</td></tr>
<tr class="separator:aea6b5e468d0d7772e556ecd9d43209fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbbf66993a0992ecfbb99165473de77"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aecbbf66993a0992ecfbb99165473de77">rowspace</a> (self)</td></tr>
<tr class="separator:aecbbf66993a0992ecfbb99165473de77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94409ecbe7f83f55e90f0c0240b882e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad94409ecbe7f83f55e90f0c0240b882e">nullspace</a> (self, divide_last=False)</td></tr>
<tr class="separator:ad94409ecbe7f83f55e90f0c0240b882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbab0d56703b2017642c81bd8650ffb0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#acbab0d56703b2017642c81bd8650ffb0">nullspace_from_rref</a> (self, pivots=None)</td></tr>
<tr class="separator:acbab0d56703b2017642c81bd8650ffb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdbe31a058eaf83ccdb2e5a7c3b4c1a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a0fdbe31a058eaf83ccdb2e5a7c3b4c1a">inv</a> (self)</td></tr>
<tr class="separator:a0fdbe31a058eaf83ccdb2e5a7c3b4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab514d6ac4370556e8555dfa97c82579d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ab514d6ac4370556e8555dfa97c82579d">det</a> (self)</td></tr>
<tr class="separator:ab514d6ac4370556e8555dfa97c82579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a5afb9e24b0dba10afad10a7bdd947"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a51a5afb9e24b0dba10afad10a7bdd947">adj_det</a> (self)</td></tr>
<tr class="separator:a51a5afb9e24b0dba10afad10a7bdd947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae328d1f4d14f9e63315dc5d41b9dc977"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ae328d1f4d14f9e63315dc5d41b9dc977">adjugate</a> (self)</td></tr>
<tr class="separator:ae328d1f4d14f9e63315dc5d41b9dc977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04da1eeea5423b8bbcbb5e3e4502356"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af04da1eeea5423b8bbcbb5e3e4502356">inv_den</a> (self, method=None)</td></tr>
<tr class="separator:af04da1eeea5423b8bbcbb5e3e4502356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206309103dcb405764eb0ba28a7d01b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a206309103dcb405764eb0ba28a7d01b5">solve_den</a> (self, b, method=None)</td></tr>
<tr class="separator:a206309103dcb405764eb0ba28a7d01b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac603c488948514871b04c9f8a742e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a7ac603c488948514871b04c9f8a742e5">solve_den_rref</a> (self, b)</td></tr>
<tr class="separator:a7ac603c488948514871b04c9f8a742e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553bf71ed99cce7c8b58b203f259b63c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a553bf71ed99cce7c8b58b203f259b63c">solve_den_charpoly</a> (self, b, cp=None, check=True)</td></tr>
<tr class="separator:a553bf71ed99cce7c8b58b203f259b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bcf29815c1bf7d97a525a8b01dfbc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a17bcf29815c1bf7d97a525a8b01dfbc4">adj_poly_det</a> (self, cp=None)</td></tr>
<tr class="separator:a17bcf29815c1bf7d97a525a8b01dfbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a18eaabe983d24a972f74bcfd90dcc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1a18eaabe983d24a972f74bcfd90dcc4">eval_poly</a> (self, p)</td></tr>
<tr class="separator:a1a18eaabe983d24a972f74bcfd90dcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74804739901a7f09ff5e562b5018cbc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a74804739901a7f09ff5e562b5018cbc0">eval_poly_mul</a> (self, p, B)</td></tr>
<tr class="separator:a74804739901a7f09ff5e562b5018cbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e345c3ac35af13fe31541cf9102cefc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1e345c3ac35af13fe31541cf9102cefc">lu</a> (self)</td></tr>
<tr class="separator:a1e345c3ac35af13fe31541cf9102cefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b6b2cc575b58a546a4ee1db14d1775"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a96b6b2cc575b58a546a4ee1db14d1775">lu_solve</a> (self, rhs)</td></tr>
<tr class="separator:a96b6b2cc575b58a546a4ee1db14d1775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d40bea6a14d0ab7f12626bc9d666e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a579d40bea6a14d0ab7f12626bc9d666e">charpoly</a> (self)</td></tr>
<tr class="separator:a579d40bea6a14d0ab7f12626bc9d666e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ea9de9eefb1eb1439cdf51206c0a42"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad1ea9de9eefb1eb1439cdf51206c0a42">charpoly_factor_list</a> (self)</td></tr>
<tr class="separator:ad1ea9de9eefb1eb1439cdf51206c0a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10470f142bdd75dde28f1c41e773372"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#af10470f142bdd75dde28f1c41e773372">charpoly_factor_blocks</a> (self)</td></tr>
<tr class="separator:af10470f142bdd75dde28f1c41e773372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb0a59fed5686a70ab53d56b3c668c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a89eb0a59fed5686a70ab53d56b3c668c">charpoly_base</a> (self)</td></tr>
<tr class="separator:a89eb0a59fed5686a70ab53d56b3c668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ea816289e1682b6540de3d874d0046"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad5ea816289e1682b6540de3d874d0046">charpoly_berk</a> (self)</td></tr>
<tr class="separator:ad5ea816289e1682b6540de3d874d0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7281ea94508cab033f30593522f2febb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a7281ea94508cab033f30593522f2febb">eye</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:a7281ea94508cab033f30593522f2febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5dafe5d5142c49ba83a81663645450"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a1f5dafe5d5142c49ba83a81663645450">diag</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#aa1cce1761f9b483df9a19c705788dfc5">diagonal</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>=None)</td></tr>
<tr class="separator:a1f5dafe5d5142c49ba83a81663645450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f3b0156cd71e88c455974a8dc30da1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a10f3b0156cd71e88c455974a8dc30da1">zeros</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>, *fmt='sparse')</td></tr>
<tr class="separator:a10f3b0156cd71e88c455974a8dc30da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3807892dc98f02717632590a8726a69"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad3807892dc98f02717632590a8726a69">ones</a> (cls, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a>, <a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a>)</td></tr>
<tr class="separator:ad3807892dc98f02717632590a8726a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70da03ba46f04a99da54ed9741f159"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a9d70da03ba46f04a99da54ed9741f159">__eq__</a> (A, B)</td></tr>
<tr class="separator:a9d70da03ba46f04a99da54ed9741f159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7b59737913339c3b8a136b9fda68bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#afb7b59737913339c3b8a136b9fda68bf">unify_eq</a> (A, B)</td></tr>
<tr class="separator:afb7b59737913339c3b8a136b9fda68bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5946e386c771ee7d7700393e5d8cb6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a7a5946e386c771ee7d7700393e5d8cb6">lll</a> (A, delta=QQ(3, 4))</td></tr>
<tr class="separator:a7a5946e386c771ee7d7700393e5d8cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfacbc23ca3701f45fe2d04ad92061d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a3bfacbc23ca3701f45fe2d04ad92061d">lll_transform</a> (A, delta=QQ(3, 4))</td></tr>
<tr class="separator:a3bfacbc23ca3701f45fe2d04ad92061d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad68d2cd9a422c71acf52dfeeadd936f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#ad68d2cd9a422c71acf52dfeeadd936f4">rep</a></td></tr>
<tr class="separator:ad68d2cd9a422c71acf52dfeeadd936f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc710d92b1f836b0dbaba2021ab01ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a6fc710d92b1f836b0dbaba2021ab01ad">shape</a></td></tr>
<tr class="separator:a6fc710d92b1f836b0dbaba2021ab01ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590fc8ed6069ee33048267257aae111f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1matrices_1_1domainmatrix_1_1DomainMatrix.html#a590fc8ed6069ee33048267257aae111f">domain</a></td></tr>
<tr class="separator:a590fc8ed6069ee33048267257aae111f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Associate Matrix with :py:class:`~.Domain`

Explanation
===========

DomainMatrix uses :py:class:`~.Domain` for its internal representation
which makes it faster than the SymPy Matrix class (currently) for many
common operations, but this advantage makes it not entirely compatible
with Matrix. DomainMatrix are analogous to numpy arrays with "dtype".
In the DomainMatrix, each element has a domain such as :ref:`ZZ`
or  :ref:`QQ(a)`.


Examples
========

Creating a DomainMatrix from the existing Matrix class:

&gt;&gt;&gt; from sympy import Matrix
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; Matrix1 = Matrix([
...    [1, 2],
...    [3, 4]])
&gt;&gt;&gt; A = DomainMatrix.from_Matrix(Matrix1)
&gt;&gt;&gt; A
DomainMatrix({0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}, (2, 2), ZZ)

Directly forming a DomainMatrix:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; A
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)

See Also
========

DDM
SDM
Domain
Poly</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0af59957134410153f3d2628f1c900e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af59957134410153f3d2628f1c900e0">&#9670;&nbsp;</a></span>__add__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__add__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0af59957134410153f3d2628f1c900e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af59957134410153f3d2628f1c900e0">&#9670;&nbsp;</a></span>__add__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__add__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d70da03ba46f04a99da54ed9741f159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d70da03ba46f04a99da54ed9741f159">&#9670;&nbsp;</a></span>__eq__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks for two DomainMatrix matrices to be equal or not

Parameters
==========

A, B: DomainMatrix
    to check equality

Returns
=======

Boolean
    True for equal, else False

Raises
======

NotImplementedError
    If B is not a DomainMatrix

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([
...    [ZZ(1), ZZ(1)],
...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)
&gt;&gt;&gt; A.__eq__(A)
True
&gt;&gt;&gt; A.__eq__(B)
False</pre> 
</div>
</div>
<a id="a9d70da03ba46f04a99da54ed9741f159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d70da03ba46f04a99da54ed9741f159">&#9670;&nbsp;</a></span>__eq__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks for two DomainMatrix matrices to be equal or not

Parameters
==========

A, B: DomainMatrix
    to check equality

Returns
=======

Boolean
    True for equal, else False

Raises
======

NotImplementedError
    If B is not a DomainMatrix

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([
...    [ZZ(1), ZZ(1)],
...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)
&gt;&gt;&gt; A.__eq__(A)
True
&gt;&gt;&gt; A.__eq__(B)
False</pre> 
</div>
</div>
<a id="abe3c8391484f55a085e7e1d7b5b42cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3c8391484f55a085e7e1d7b5b42cb0">&#9670;&nbsp;</a></span>__getitem__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__getitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe3c8391484f55a085e7e1d7b5b42cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3c8391484f55a085e7e1d7b5b42cb0">&#9670;&nbsp;</a></span>__getitem__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__getitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd628fecee8ef82126c5bb6d229bc700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd628fecee8ef82126c5bb6d229bc700">&#9670;&nbsp;</a></span>__mul__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__mul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A * B</pre> 
</div>
</div>
<a id="acd628fecee8ef82126c5bb6d229bc700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd628fecee8ef82126c5bb6d229bc700">&#9670;&nbsp;</a></span>__mul__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__mul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A * B</pre> 
</div>
</div>
<a id="abdafac1ea0966bc08e42b3bfbada4086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdafac1ea0966bc08e42b3bfbada4086">&#9670;&nbsp;</a></span>__neg__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__neg__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdafac1ea0966bc08e42b3bfbada4086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdafac1ea0966bc08e42b3bfbada4086">&#9670;&nbsp;</a></span>__neg__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__neg__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c79b08c8def6c7a4b6528e7c8c0ce4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c79b08c8def6c7a4b6528e7c8c0ce4e">&#9670;&nbsp;</a></span>__new__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__new__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a :py:class:`~.DomainMatrix`.

Parameters
==========

rows : Represents elements of DomainMatrix as list of lists
shape : Represents dimension of DomainMatrix
domain : Represents :py:class:`~.Domain` of DomainMatrix

Raises
======

TypeError
    If any of rows, shape and domain are not provided</pre> 
</div>
</div>
<a id="a1c79b08c8def6c7a4b6528e7c8c0ce4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c79b08c8def6c7a4b6528e7c8c0ce4e">&#9670;&nbsp;</a></span>__new__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__new__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a :py:class:`~.DomainMatrix`.

Parameters
==========

rows : Represents elements of DomainMatrix as list of lists
shape : Represents dimension of DomainMatrix
domain : Represents :py:class:`~.Domain` of DomainMatrix

Raises
======

TypeError
    If any of rows, shape and domain are not provided</pre> 
</div>
</div>
<a id="ad3fd46d81c586fa304986bb6e707368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fd46d81c586fa304986bb6e707368b">&#9670;&nbsp;</a></span>__pow__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__pow__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A ** n</pre> 
</div>
</div>
<a id="ad3fd46d81c586fa304986bb6e707368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fd46d81c586fa304986bb6e707368b">&#9670;&nbsp;</a></span>__pow__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__pow__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A ** n</pre> 
</div>
</div>
<a id="a3641c663c2e010108f2258ab78c7d6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3641c663c2e010108f2258ab78c7d6ea">&#9670;&nbsp;</a></span>__reduce__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__reduce__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3641c663c2e010108f2258ab78c7d6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3641c663c2e010108f2258ab78c7d6ea">&#9670;&nbsp;</a></span>__reduce__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__reduce__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75d5c0e09a12f3d689098b15457d09a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d5c0e09a12f3d689098b15457d09a2">&#9670;&nbsp;</a></span>__repr__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75d5c0e09a12f3d689098b15457d09a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d5c0e09a12f3d689098b15457d09a2">&#9670;&nbsp;</a></span>__repr__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16789b78e218d719a6aca70991e460d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16789b78e218d719a6aca70991e460d6">&#9670;&nbsp;</a></span>__rmul__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__rmul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16789b78e218d719a6aca70991e460d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16789b78e218d719a6aca70991e460d6">&#9670;&nbsp;</a></span>__rmul__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__rmul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4e34915f537ad7f13149f23cdc22c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e34915f537ad7f13149f23cdc22c01">&#9670;&nbsp;</a></span>__setitem__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__setitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4e34915f537ad7f13149f23cdc22c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e34915f537ad7f13149f23cdc22c01">&#9670;&nbsp;</a></span>__setitem__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__setitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a189c5557f18174b74be44941febda3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189c5557f18174b74be44941febda3cd">&#9670;&nbsp;</a></span>__sub__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__sub__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a189c5557f18174b74be44941febda3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189c5557f18174b74be44941febda3cd">&#9670;&nbsp;</a></span>__sub__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__sub__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb3db557dff2d0583bfcdc76350d8f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3db557dff2d0583bfcdc76350d8f05">&#9670;&nbsp;</a></span>__truediv__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__truediv__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Method for Scalar Division</pre> 
</div>
</div>
<a id="abb3db557dff2d0583bfcdc76350d8f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3db557dff2d0583bfcdc76350d8f05">&#9670;&nbsp;</a></span>__truediv__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.__truediv__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Method for Scalar Division</pre> 
</div>
</div>
<a id="ac7a2c67d74599f626722d378416696f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2c67d74599f626722d378416696f1">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.add </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adds two DomainMatrix matrices of the same Domain

Parameters
==========

A, B: DomainMatrix
    matrices to add

Returns
=======

DomainMatrix
    DomainMatrix after Addition

Raises
======

DMShapeError
    If the dimensions of the two DomainMatrix are not equal

ValueError
    If the domain of the two DomainMatrix are not same

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([
...    [ZZ(4), ZZ(3)],
...    [ZZ(2), ZZ(1)]], (2, 2), ZZ)

&gt;&gt;&gt; A.add(B)
DomainMatrix([[5, 5], [5, 5]], (2, 2), ZZ)

See Also
========

sub, matmul</pre> 
</div>
</div>
<a id="ac7a2c67d74599f626722d378416696f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2c67d74599f626722d378416696f1">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.add </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adds two DomainMatrix matrices of the same Domain

Parameters
==========

A, B: DomainMatrix
    matrices to add

Returns
=======

DomainMatrix
    DomainMatrix after Addition

Raises
======

DMShapeError
    If the dimensions of the two DomainMatrix are not equal

ValueError
    If the domain of the two DomainMatrix are not same

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([
...    [ZZ(4), ZZ(3)],
...    [ZZ(2), ZZ(1)]], (2, 2), ZZ)

&gt;&gt;&gt; A.add(B)
DomainMatrix([[5, 5], [5, 5]], (2, 2), ZZ)

See Also
========

sub, matmul</pre> 
</div>
</div>
<a id="a51a5afb9e24b0dba10afad10a7bdd947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a5afb9e24b0dba10afad10a7bdd947">&#9670;&nbsp;</a></span>adj_det() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.adj_det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adjugate and determinant of a square :class:`DomainMatrix`.

Returns
=======

(adjugate, determinant) : (DomainMatrix, DomainScalar)
    The adjugate matrix and determinant of this matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([
...     [ZZ(1), ZZ(2)],
...     [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; adjA, detA = A.adj_det()
&gt;&gt;&gt; adjA
DomainMatrix([[4, -2], [-3, 1]], (2, 2), ZZ)
&gt;&gt;&gt; detA
-2

See Also
========

adjugate
    Returns only the adjugate matrix.
det
    Returns only the determinant.
inv_den
    Returns a matrix/denominator pair representing the inverse matrix
    but perhaps differing from the adjugate and determinant by a common
    factor.
</pre> 
</div>
</div>
<a id="a51a5afb9e24b0dba10afad10a7bdd947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a5afb9e24b0dba10afad10a7bdd947">&#9670;&nbsp;</a></span>adj_det() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.adj_det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adjugate and determinant of a square :class:`DomainMatrix`.

Returns
=======

(adjugate, determinant) : (DomainMatrix, DomainScalar)
    The adjugate matrix and determinant of this matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([
...     [ZZ(1), ZZ(2)],
...     [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; adjA, detA = A.adj_det()
&gt;&gt;&gt; adjA
DomainMatrix([[4, -2], [-3, 1]], (2, 2), ZZ)
&gt;&gt;&gt; detA
-2

See Also
========

adjugate
    Returns only the adjugate matrix.
det
    Returns only the determinant.
inv_den
    Returns a matrix/denominator pair representing the inverse matrix
    but perhaps differing from the adjugate and determinant by a common
    factor.
</pre> 
</div>
</div>
<a id="a17bcf29815c1bf7d97a525a8b01dfbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bcf29815c1bf7d97a525a8b01dfbc4">&#9670;&nbsp;</a></span>adj_poly_det() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.adj_poly_det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cp</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the polynomial $p$ such that $p(A) = adj(A)$ and also the
determinant of $A$.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)
&gt;&gt;&gt; p, detA = A.adj_poly_det()
&gt;&gt;&gt; p
[-1, 5]
&gt;&gt;&gt; p_A = A.eval_poly(p)
&gt;&gt;&gt; p_A
DomainMatrix([[4, -2], [-3, 1]], (2, 2), QQ)
&gt;&gt;&gt; p[0]*A**1 + p[1]*A**0 == p_A
True
&gt;&gt;&gt; p_A == A.adjugate()
True
&gt;&gt;&gt; A * A.adjugate() == detA * A.eye(A.shape, A.domain).to_dense()
True

See Also
========

adjugate
eval_poly
adj_det
</pre> 
</div>
</div>
<a id="a17bcf29815c1bf7d97a525a8b01dfbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bcf29815c1bf7d97a525a8b01dfbc4">&#9670;&nbsp;</a></span>adj_poly_det() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.adj_poly_det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cp</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the polynomial $p$ such that $p(A) = adj(A)$ and also the
determinant of $A$.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)
&gt;&gt;&gt; p, detA = A.adj_poly_det()
&gt;&gt;&gt; p
[-1, 5]
&gt;&gt;&gt; p_A = A.eval_poly(p)
&gt;&gt;&gt; p_A
DomainMatrix([[4, -2], [-3, 1]], (2, 2), QQ)
&gt;&gt;&gt; p[0]*A**1 + p[1]*A**0 == p_A
True
&gt;&gt;&gt; p_A == A.adjugate()
True
&gt;&gt;&gt; A * A.adjugate() == detA * A.eye(A.shape, A.domain).to_dense()
True

See Also
========

adjugate
eval_poly
adj_det
</pre> 
</div>
</div>
<a id="ae328d1f4d14f9e63315dc5d41b9dc977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae328d1f4d14f9e63315dc5d41b9dc977">&#9670;&nbsp;</a></span>adjugate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.adjugate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adjugate of a square :class:`DomainMatrix`.

The adjugate matrix is the transpose of the cofactor matrix and is
related to the inverse by::

    adj(A) = det(A) * A.inv()

Unlike the inverse matrix the adjugate matrix can be computed and
expressed without division or fractions in the ground domain.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; A.adjugate()
DomainMatrix([[4, -2], [-3, 1]], (2, 2), ZZ)

Returns
=======

DomainMatrix
    The adjugate matrix of this matrix with the same domain.

See Also
========

adj_det
</pre> 
</div>
</div>
<a id="ae328d1f4d14f9e63315dc5d41b9dc977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae328d1f4d14f9e63315dc5d41b9dc977">&#9670;&nbsp;</a></span>adjugate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.adjugate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adjugate of a square :class:`DomainMatrix`.

The adjugate matrix is the transpose of the cofactor matrix and is
related to the inverse by::

    adj(A) = det(A) * A.inv()

Unlike the inverse matrix the adjugate matrix can be computed and
expressed without division or fractions in the ground domain.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; A.adjugate()
DomainMatrix([[4, -2], [-3, 1]], (2, 2), ZZ)

Returns
=======

DomainMatrix
    The adjugate matrix of this matrix with the same domain.

See Also
========

adj_det
</pre> 
</div>
</div>
<a id="a1991027b5f177b28945bc4b73fd70372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1991027b5f177b28945bc4b73fd70372">&#9670;&nbsp;</a></span>applyfunc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.applyfunc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1991027b5f177b28945bc4b73fd70372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1991027b5f177b28945bc4b73fd70372">&#9670;&nbsp;</a></span>applyfunc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.applyfunc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab59a4205bb39d868ecb9eb1db660f9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59a4205bb39d868ecb9eb1db660f9cb">&#9670;&nbsp;</a></span>cancel_denom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.cancel_denom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cancel factors between a matrix and a denominator.

Returns a matrix and denominator on lowest terms.

Requires ``gcd`` in the ground domain.

Methods like :meth:`solve_den`, :meth:`inv_den` and :meth:`rref_den`
return a matrix and denominator but not necessarily on lowest terms.
Reduction to lowest terms without fractions can be performed with
:meth:`cancel_denom`.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[2, 2, 0],
...         [0, 2, 2],
...         [0, 0, 2]], ZZ)
&gt;&gt;&gt; Minv, den = M.inv_den()
&gt;&gt;&gt; Minv.to_Matrix()
Matrix([
[1, -1,  1],
[0,  1, -1],
[0,  0,  1]])
&gt;&gt;&gt; den
2
&gt;&gt;&gt; Minv_reduced, den_reduced = Minv.cancel_denom(den)
&gt;&gt;&gt; Minv_reduced.to_Matrix()
Matrix([
[1, -1,  1],
[0,  1, -1],
[0,  0,  1]])
&gt;&gt;&gt; den_reduced
2
&gt;&gt;&gt; Minv_reduced.to_field() / den_reduced == Minv.to_field() / den
True

The denominator is made canonical with respect to units (e.g. a
negative denominator is made positive):

&gt;&gt;&gt; M = DM([[2, 2, 0]], ZZ)
&gt;&gt;&gt; den = ZZ(-4)
&gt;&gt;&gt; M.cancel_denom(den)
(DomainMatrix([[-1, -1, 0]], (1, 3), ZZ), 2)

Any factor common to _all_ elements will be cancelled but there can
still be factors in common between _some_ elements of the matrix and
the denominator. To cancel factors between each element and the
denominator, use :meth:`cancel_denom_elementwise` or otherwise convert
to a field and use division:

&gt;&gt;&gt; M = DM([[4, 6]], ZZ)
&gt;&gt;&gt; den = ZZ(12)
&gt;&gt;&gt; M.cancel_denom(den)
(DomainMatrix([[2, 3]], (1, 2), ZZ), 6)
&gt;&gt;&gt; numers, denoms = M.cancel_denom_elementwise(den)
&gt;&gt;&gt; numers
DomainMatrix([[1, 1]], (1, 2), ZZ)
&gt;&gt;&gt; denoms
DomainMatrix([[3, 2]], (1, 2), ZZ)
&gt;&gt;&gt; M.to_field() / den
DomainMatrix([[1/3, 1/2]], (1, 2), QQ)

See Also
========

solve_den
inv_den
rref_den
cancel_denom_elementwise
</pre> 
</div>
</div>
<a id="ab59a4205bb39d868ecb9eb1db660f9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59a4205bb39d868ecb9eb1db660f9cb">&#9670;&nbsp;</a></span>cancel_denom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.cancel_denom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cancel factors between a matrix and a denominator.

Returns a matrix and denominator on lowest terms.

Requires ``gcd`` in the ground domain.

Methods like :meth:`solve_den`, :meth:`inv_den` and :meth:`rref_den`
return a matrix and denominator but not necessarily on lowest terms.
Reduction to lowest terms without fractions can be performed with
:meth:`cancel_denom`.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[2, 2, 0],
...         [0, 2, 2],
...         [0, 0, 2]], ZZ)
&gt;&gt;&gt; Minv, den = M.inv_den()
&gt;&gt;&gt; Minv.to_Matrix()
Matrix([
[1, -1,  1],
[0,  1, -1],
[0,  0,  1]])
&gt;&gt;&gt; den
2
&gt;&gt;&gt; Minv_reduced, den_reduced = Minv.cancel_denom(den)
&gt;&gt;&gt; Minv_reduced.to_Matrix()
Matrix([
[1, -1,  1],
[0,  1, -1],
[0,  0,  1]])
&gt;&gt;&gt; den_reduced
2
&gt;&gt;&gt; Minv_reduced.to_field() / den_reduced == Minv.to_field() / den
True

The denominator is made canonical with respect to units (e.g. a
negative denominator is made positive):

&gt;&gt;&gt; M = DM([[2, 2, 0]], ZZ)
&gt;&gt;&gt; den = ZZ(-4)
&gt;&gt;&gt; M.cancel_denom(den)
(DomainMatrix([[-1, -1, 0]], (1, 3), ZZ), 2)

Any factor common to _all_ elements will be cancelled but there can
still be factors in common between _some_ elements of the matrix and
the denominator. To cancel factors between each element and the
denominator, use :meth:`cancel_denom_elementwise` or otherwise convert
to a field and use division:

&gt;&gt;&gt; M = DM([[4, 6]], ZZ)
&gt;&gt;&gt; den = ZZ(12)
&gt;&gt;&gt; M.cancel_denom(den)
(DomainMatrix([[2, 3]], (1, 2), ZZ), 6)
&gt;&gt;&gt; numers, denoms = M.cancel_denom_elementwise(den)
&gt;&gt;&gt; numers
DomainMatrix([[1, 1]], (1, 2), ZZ)
&gt;&gt;&gt; denoms
DomainMatrix([[3, 2]], (1, 2), ZZ)
&gt;&gt;&gt; M.to_field() / den
DomainMatrix([[1/3, 1/2]], (1, 2), QQ)

See Also
========

solve_den
inv_den
rref_den
cancel_denom_elementwise
</pre> 
</div>
</div>
<a id="a0eeb60aa6932ce0d63c51ad376c596dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eeb60aa6932ce0d63c51ad376c596dd">&#9670;&nbsp;</a></span>cancel_denom_elementwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.cancel_denom_elementwise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cancel factors between the elements of a matrix and a denominator.

Returns a matrix of numerators and matrix of denominators.

Requires ``gcd`` in the ground domain.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[2, 3], [4, 12]], ZZ)
&gt;&gt;&gt; denom = ZZ(6)
&gt;&gt;&gt; numers, denoms = M.cancel_denom_elementwise(denom)
&gt;&gt;&gt; numers.to_Matrix()
Matrix([
[1, 1],
[2, 2]])
&gt;&gt;&gt; denoms.to_Matrix()
Matrix([
[3, 2],
[3, 1]])
&gt;&gt;&gt; M_frac = (M.to_field() / denom).to_Matrix()
&gt;&gt;&gt; M_frac
Matrix([
[1/3, 1/2],
[2/3,   2]])
&gt;&gt;&gt; denoms_inverted = denoms.to_Matrix().applyfunc(lambda e: 1/e)
&gt;&gt;&gt; numers.to_Matrix().multiply_elementwise(denoms_inverted) == M_frac
True

Use :meth:`cancel_denom` to cancel factors between the matrix and the
denominator while preserving the form of a matrix with a scalar
denominator.

See Also
========

cancel_denom
</pre> 
</div>
</div>
<a id="a0eeb60aa6932ce0d63c51ad376c596dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eeb60aa6932ce0d63c51ad376c596dd">&#9670;&nbsp;</a></span>cancel_denom_elementwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.cancel_denom_elementwise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cancel factors between the elements of a matrix and a denominator.

Returns a matrix of numerators and matrix of denominators.

Requires ``gcd`` in the ground domain.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[2, 3], [4, 12]], ZZ)
&gt;&gt;&gt; denom = ZZ(6)
&gt;&gt;&gt; numers, denoms = M.cancel_denom_elementwise(denom)
&gt;&gt;&gt; numers.to_Matrix()
Matrix([
[1, 1],
[2, 2]])
&gt;&gt;&gt; denoms.to_Matrix()
Matrix([
[3, 2],
[3, 1]])
&gt;&gt;&gt; M_frac = (M.to_field() / denom).to_Matrix()
&gt;&gt;&gt; M_frac
Matrix([
[1/3, 1/2],
[2/3,   2]])
&gt;&gt;&gt; denoms_inverted = denoms.to_Matrix().applyfunc(lambda e: 1/e)
&gt;&gt;&gt; numers.to_Matrix().multiply_elementwise(denoms_inverted) == M_frac
True

Use :meth:`cancel_denom` to cancel factors between the matrix and the
denominator while preserving the form of a matrix with a scalar
denominator.

See Also
========

cancel_denom
</pre> 
</div>
</div>
<a id="a579d40bea6a14d0ab7f12626bc9d666e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579d40bea6a14d0ab7f12626bc9d666e">&#9670;&nbsp;</a></span>charpoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Characteristic polynomial of a square matrix.

Computes the characteristic polynomial in a fully expanded form using
division free arithmetic. If a factorization of the characteristic
polynomial is needed then it is more efficient to call
:meth:`charpoly_factor_list` than calling :meth:`charpoly` and then
factorizing the result.

Returns
=======

list: list of DomainElement
    coefficients of the characteristic polynomial

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.charpoly()
[1, -5, -2]

See Also
========

charpoly_factor_list
    Compute the factorisation of the characteristic polynomial.
charpoly_factor_blocks
    A partial factorisation of the characteristic polynomial that can
    be computed more efficiently than either the full factorisation or
    the fully expanded polynomial.
</pre> 
</div>
</div>
<a id="a579d40bea6a14d0ab7f12626bc9d666e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579d40bea6a14d0ab7f12626bc9d666e">&#9670;&nbsp;</a></span>charpoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Characteristic polynomial of a square matrix.

Computes the characteristic polynomial in a fully expanded form using
division free arithmetic. If a factorization of the characteristic
polynomial is needed then it is more efficient to call
:meth:`charpoly_factor_list` than calling :meth:`charpoly` and then
factorizing the result.

Returns
=======

list: list of DomainElement
    coefficients of the characteristic polynomial

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.charpoly()
[1, -5, -2]

See Also
========

charpoly_factor_list
    Compute the factorisation of the characteristic polynomial.
charpoly_factor_blocks
    A partial factorisation of the characteristic polynomial that can
    be computed more efficiently than either the full factorisation or
    the fully expanded polynomial.
</pre> 
</div>
</div>
<a id="a89eb0a59fed5686a70ab53d56b3c668c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89eb0a59fed5686a70ab53d56b3c668c">&#9670;&nbsp;</a></span>charpoly_base() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_base </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Base case for :meth:`charpoly_factor_blocks` after block decomposition.

This method is used internally by :meth:`charpoly_factor_blocks` as the
base case for computing the characteristic polynomial of a block. It is
more efficient to call :meth:`charpoly_factor_blocks`, :meth:`charpoly`
or :meth:`charpoly_factor_list` rather than call this method directly.

This will use either the dense or the sparse implementation depending
on the sparsity of the matrix and will clear denominators if possible
before calling :meth:`charpoly_berk` to compute the characteristic
polynomial using the Berkowitz algorithm.

See Also
========

charpoly
charpoly_factor_list
charpoly_factor_blocks
charpoly_berk
</pre> 
</div>
</div>
<a id="a89eb0a59fed5686a70ab53d56b3c668c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89eb0a59fed5686a70ab53d56b3c668c">&#9670;&nbsp;</a></span>charpoly_base() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_base </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Base case for :meth:`charpoly_factor_blocks` after block decomposition.

This method is used internally by :meth:`charpoly_factor_blocks` as the
base case for computing the characteristic polynomial of a block. It is
more efficient to call :meth:`charpoly_factor_blocks`, :meth:`charpoly`
or :meth:`charpoly_factor_list` rather than call this method directly.

This will use either the dense or the sparse implementation depending
on the sparsity of the matrix and will clear denominators if possible
before calling :meth:`charpoly_berk` to compute the characteristic
polynomial using the Berkowitz algorithm.

See Also
========

charpoly
charpoly_factor_list
charpoly_factor_blocks
charpoly_berk
</pre> 
</div>
</div>
<a id="ad5ea816289e1682b6540de3d874d0046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ea816289e1682b6540de3d874d0046">&#9670;&nbsp;</a></span>charpoly_berk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_berk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the characteristic polynomial using the Berkowitz algorithm.

This method directly calls the underlying implementation of the
Berkowitz algorithm (:meth:`sympy.polys.matrices.dense.ddm_berk` or
:meth:`sympy.polys.matrices.sdm.sdm_berk`).

This is used by :meth:`charpoly` and other methods as the base case for
for computing the characteristic polynomial. However those methods will
apply other optimizations such as block decomposition, clearing
denominators and converting between dense and sparse representations
before calling this method. It is more efficient to call those methods
instead of this one but this method is provided for direct access to
the Berkowitz algorithm.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; M = DM([[6, -1, 0, 0],
...         [9, 12, 0, 0],
...         [0,  0, 1, 2],
...         [0,  0, 5, 6]], QQ)
&gt;&gt;&gt; M.charpoly_berk()
[1, -25, 203, -495, -324]

See Also
========

charpoly
charpoly_base
charpoly_factor_list
charpoly_factor_blocks
sympy.polys.matrices.dense.ddm_berk
sympy.polys.matrices.sdm.sdm_berk
</pre> 
</div>
</div>
<a id="ad5ea816289e1682b6540de3d874d0046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ea816289e1682b6540de3d874d0046">&#9670;&nbsp;</a></span>charpoly_berk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_berk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the characteristic polynomial using the Berkowitz algorithm.

This method directly calls the underlying implementation of the
Berkowitz algorithm (:meth:`sympy.polys.matrices.dense.ddm_berk` or
:meth:`sympy.polys.matrices.sdm.sdm_berk`).

This is used by :meth:`charpoly` and other methods as the base case for
for computing the characteristic polynomial. However those methods will
apply other optimizations such as block decomposition, clearing
denominators and converting between dense and sparse representations
before calling this method. It is more efficient to call those methods
instead of this one but this method is provided for direct access to
the Berkowitz algorithm.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; M = DM([[6, -1, 0, 0],
...         [9, 12, 0, 0],
...         [0,  0, 1, 2],
...         [0,  0, 5, 6]], QQ)
&gt;&gt;&gt; M.charpoly_berk()
[1, -25, 203, -495, -324]

See Also
========

charpoly
charpoly_base
charpoly_factor_list
charpoly_factor_blocks
sympy.polys.matrices.dense.ddm_berk
sympy.polys.matrices.sdm.sdm_berk
</pre> 
</div>
</div>
<a id="af10470f142bdd75dde28f1c41e773372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10470f142bdd75dde28f1c41e773372">&#9670;&nbsp;</a></span>charpoly_factor_blocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_factor_blocks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Partial factorisation of the characteristic polynomial.

This factorisation arises from a block structure of the matrix (if any)
and so the factors are not guaranteed to be irreducible. The
:meth:`charpoly_factor_blocks` method is the most efficient way to get
a representation of the characteristic polynomial but the result is
neither fully expanded nor fully factored.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[6, -1, 0, 0],
...         [9, 12, 0, 0],
...         [0,  0, 1, 2],
...         [0,  0, 5, 6]], ZZ)

This computes a partial factorization using only the block structure of
the matrix to reveal factors:

&gt;&gt;&gt; M.charpoly_factor_blocks()
[([1, -18, 81], 1), ([1, -7, -4], 1)]

These factors correspond to the two diagonal blocks in the matrix:

&gt;&gt;&gt; DM([[6, -1], [9, 12]], ZZ).charpoly()
[1, -18, 81]
&gt;&gt;&gt; DM([[1, 2], [5, 6]], ZZ).charpoly()
[1, -7, -4]

Use :meth:`charpoly_factor_list` to get a complete factorization into
irreducibles:

&gt;&gt;&gt; M.charpoly_factor_list()
[([1, -9], 2), ([1, -7, -4], 1)]

Use :meth:`charpoly` to get the expanded characteristic polynomial:

&gt;&gt;&gt; M.charpoly()
[1, -25, 203, -495, -324]

Returns
=======

list: list of pairs (factor, multiplicity)
    A partial factorization of the characteristic polynomial.

See Also
========

charpoly
    Compute the fully expanded characteristic polynomial.
charpoly_factor_list
    Compute a full factorization of the characteristic polynomial.
</pre> 
</div>
</div>
<a id="af10470f142bdd75dde28f1c41e773372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10470f142bdd75dde28f1c41e773372">&#9670;&nbsp;</a></span>charpoly_factor_blocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_factor_blocks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Partial factorisation of the characteristic polynomial.

This factorisation arises from a block structure of the matrix (if any)
and so the factors are not guaranteed to be irreducible. The
:meth:`charpoly_factor_blocks` method is the most efficient way to get
a representation of the characteristic polynomial but the result is
neither fully expanded nor fully factored.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[6, -1, 0, 0],
...         [9, 12, 0, 0],
...         [0,  0, 1, 2],
...         [0,  0, 5, 6]], ZZ)

This computes a partial factorization using only the block structure of
the matrix to reveal factors:

&gt;&gt;&gt; M.charpoly_factor_blocks()
[([1, -18, 81], 1), ([1, -7, -4], 1)]

These factors correspond to the two diagonal blocks in the matrix:

&gt;&gt;&gt; DM([[6, -1], [9, 12]], ZZ).charpoly()
[1, -18, 81]
&gt;&gt;&gt; DM([[1, 2], [5, 6]], ZZ).charpoly()
[1, -7, -4]

Use :meth:`charpoly_factor_list` to get a complete factorization into
irreducibles:

&gt;&gt;&gt; M.charpoly_factor_list()
[([1, -9], 2), ([1, -7, -4], 1)]

Use :meth:`charpoly` to get the expanded characteristic polynomial:

&gt;&gt;&gt; M.charpoly()
[1, -25, 203, -495, -324]

Returns
=======

list: list of pairs (factor, multiplicity)
    A partial factorization of the characteristic polynomial.

See Also
========

charpoly
    Compute the fully expanded characteristic polynomial.
charpoly_factor_list
    Compute a full factorization of the characteristic polynomial.
</pre> 
</div>
</div>
<a id="ad1ea9de9eefb1eb1439cdf51206c0a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ea9de9eefb1eb1439cdf51206c0a42">&#9670;&nbsp;</a></span>charpoly_factor_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_factor_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Full factorization of the characteristic polynomial.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[6, -1, 0, 0],
...         [9, 12, 0, 0],
...         [0,  0, 1, 2],
...         [0,  0, 5, 6]], ZZ)

Compute the factorization of the characteristic polynomial:

&gt;&gt;&gt; M.charpoly_factor_list()
[([1, -9], 2), ([1, -7, -4], 1)]

Use :meth:`charpoly` to get the unfactorized characteristic polynomial:

&gt;&gt;&gt; M.charpoly()
[1, -25, 203, -495, -324]

The same calculations with ``Matrix``:

&gt;&gt;&gt; M.to_Matrix().charpoly().as_expr()
lambda**4 - 25*lambda**3 + 203*lambda**2 - 495*lambda - 324
&gt;&gt;&gt; M.to_Matrix().charpoly().as_expr().factor()
(lambda - 9)**2*(lambda**2 - 7*lambda - 4)

Returns
=======

list: list of pairs (factor, multiplicity)
    A full factorization of the characteristic polynomial.

See Also
========

charpoly
    Expanded form of the characteristic polynomial.
charpoly_factor_blocks
    A partial factorisation of the characteristic polynomial that can
    be computed more efficiently.
</pre> 
</div>
</div>
<a id="ad1ea9de9eefb1eb1439cdf51206c0a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ea9de9eefb1eb1439cdf51206c0a42">&#9670;&nbsp;</a></span>charpoly_factor_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_factor_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Full factorization of the characteristic polynomial.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[6, -1, 0, 0],
...         [9, 12, 0, 0],
...         [0,  0, 1, 2],
...         [0,  0, 5, 6]], ZZ)

Compute the factorization of the characteristic polynomial:

&gt;&gt;&gt; M.charpoly_factor_list()
[([1, -9], 2), ([1, -7, -4], 1)]

Use :meth:`charpoly` to get the unfactorized characteristic polynomial:

&gt;&gt;&gt; M.charpoly()
[1, -25, 203, -495, -324]

The same calculations with ``Matrix``:

&gt;&gt;&gt; M.to_Matrix().charpoly().as_expr()
lambda**4 - 25*lambda**3 + 203*lambda**2 - 495*lambda - 324
&gt;&gt;&gt; M.to_Matrix().charpoly().as_expr().factor()
(lambda - 9)**2*(lambda**2 - 7*lambda - 4)

Returns
=======

list: list of pairs (factor, multiplicity)
    A full factorization of the characteristic polynomial.

See Also
========

charpoly
    Expanded form of the characteristic polynomial.
charpoly_factor_blocks
    A partial factorisation of the characteristic polynomial that can
    be computed more efficiently.
</pre> 
</div>
</div>
<a id="a17737a3d2e48f2da2021138f79ca4032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17737a3d2e48f2da2021138f79ca4032">&#9670;&nbsp;</a></span>choose_domain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.choose_domain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert to a domain found by :func:`~.construct_domain`.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; M = DM([[1, 2], [3, 4]], ZZ)
&gt;&gt;&gt; M
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)
&gt;&gt;&gt; M.choose_domain(field=True)
DomainMatrix([[1, 2], [3, 4]], (2, 2), QQ)

&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; M = DM([[1, x], [x**2, x**3]], ZZ[x])
&gt;&gt;&gt; M.choose_domain(field=True).domain
ZZ(x)

Keyword arguments are passed to :func:`~.construct_domain`.

See Also
========

construct_domain
convert_to
</pre> 
</div>
</div>
<a id="a17737a3d2e48f2da2021138f79ca4032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17737a3d2e48f2da2021138f79ca4032">&#9670;&nbsp;</a></span>choose_domain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.choose_domain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert to a domain found by :func:`~.construct_domain`.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; M = DM([[1, 2], [3, 4]], ZZ)
&gt;&gt;&gt; M
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)
&gt;&gt;&gt; M.choose_domain(field=True)
DomainMatrix([[1, 2], [3, 4]], (2, 2), QQ)

&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; M = DM([[1, x], [x**2, x**3]], ZZ[x])
&gt;&gt;&gt; M.choose_domain(field=True).domain
ZZ(x)

Keyword arguments are passed to :func:`~.construct_domain`.

See Also
========

construct_domain
convert_to
</pre> 
</div>
</div>
<a id="a806ac1d11be8377ae983ca1ef54fd293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806ac1d11be8377ae983ca1ef54fd293">&#9670;&nbsp;</a></span>clear_denoms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.clear_denoms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convert</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clear denominators, but keep the domain unchanged.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[(1,2), (1,3)], [(1,4), (1,5)]], QQ)
&gt;&gt;&gt; den, Anum = A.clear_denoms()
&gt;&gt;&gt; den.to_sympy()
60
&gt;&gt;&gt; Anum.to_Matrix()
Matrix([
[30, 20],
[15, 12]])
&gt;&gt;&gt; den * A == Anum
True

The numerator matrix will be in the same domain as the original matrix
unless ``convert`` is set to ``True``:

&gt;&gt;&gt; A.clear_denoms()[1].domain
QQ
&gt;&gt;&gt; A.clear_denoms(convert=True)[1].domain
ZZ

The denominator is always in the associated ring:

&gt;&gt;&gt; A.clear_denoms()[0].domain
ZZ
&gt;&gt;&gt; A.domain.get_ring()
ZZ

See Also
========

sympy.polys.polytools.Poly.clear_denoms
clear_denoms_rowwise
</pre> 
</div>
</div>
<a id="a806ac1d11be8377ae983ca1ef54fd293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806ac1d11be8377ae983ca1ef54fd293">&#9670;&nbsp;</a></span>clear_denoms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.clear_denoms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convert</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clear denominators, but keep the domain unchanged.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[(1,2), (1,3)], [(1,4), (1,5)]], QQ)
&gt;&gt;&gt; den, Anum = A.clear_denoms()
&gt;&gt;&gt; den.to_sympy()
60
&gt;&gt;&gt; Anum.to_Matrix()
Matrix([
[30, 20],
[15, 12]])
&gt;&gt;&gt; den * A == Anum
True

The numerator matrix will be in the same domain as the original matrix
unless ``convert`` is set to ``True``:

&gt;&gt;&gt; A.clear_denoms()[1].domain
QQ
&gt;&gt;&gt; A.clear_denoms(convert=True)[1].domain
ZZ

The denominator is always in the associated ring:

&gt;&gt;&gt; A.clear_denoms()[0].domain
ZZ
&gt;&gt;&gt; A.domain.get_ring()
ZZ

See Also
========

sympy.polys.polytools.Poly.clear_denoms
clear_denoms_rowwise
</pre> 
</div>
</div>
<a id="a8b19aa8f683a5e9f6996d69a927484d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b19aa8f683a5e9f6996d69a927484d5">&#9670;&nbsp;</a></span>clear_denoms_rowwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.clear_denoms_rowwise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convert</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clear denominators from each row of the matrix.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[(1,2), (1,3), (1,4)], [(1,5), (1,6), (1,7)]], QQ)
&gt;&gt;&gt; den, Anum = A.clear_denoms_rowwise()
&gt;&gt;&gt; den.to_Matrix()
Matrix([
[12,   0],
[ 0, 210]])
&gt;&gt;&gt; Anum.to_Matrix()
Matrix([
[ 6,  4,  3],
[42, 35, 30]])

The denominator matrix is a diagonal matrix with the denominators of
each row on the diagonal. The invariants are:

&gt;&gt;&gt; den * A == Anum
True
&gt;&gt;&gt; A == den.to_field().inv() * Anum
True

The numerator matrix will be in the same domain as the original matrix
unless ``convert`` is set to ``True``:

&gt;&gt;&gt; A.clear_denoms_rowwise()[1].domain
QQ
&gt;&gt;&gt; A.clear_denoms_rowwise(convert=True)[1].domain
ZZ

The domain of the denominator matrix is the associated ring:

&gt;&gt;&gt; A.clear_denoms_rowwise()[0].domain
ZZ

See Also
========

sympy.polys.polytools.Poly.clear_denoms
clear_denoms
</pre> 
</div>
</div>
<a id="a8b19aa8f683a5e9f6996d69a927484d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b19aa8f683a5e9f6996d69a927484d5">&#9670;&nbsp;</a></span>clear_denoms_rowwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.clear_denoms_rowwise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convert</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clear denominators from each row of the matrix.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[(1,2), (1,3), (1,4)], [(1,5), (1,6), (1,7)]], QQ)
&gt;&gt;&gt; den, Anum = A.clear_denoms_rowwise()
&gt;&gt;&gt; den.to_Matrix()
Matrix([
[12,   0],
[ 0, 210]])
&gt;&gt;&gt; Anum.to_Matrix()
Matrix([
[ 6,  4,  3],
[42, 35, 30]])

The denominator matrix is a diagonal matrix with the denominators of
each row on the diagonal. The invariants are:

&gt;&gt;&gt; den * A == Anum
True
&gt;&gt;&gt; A == den.to_field().inv() * Anum
True

The numerator matrix will be in the same domain as the original matrix
unless ``convert`` is set to ``True``:

&gt;&gt;&gt; A.clear_denoms_rowwise()[1].domain
QQ
&gt;&gt;&gt; A.clear_denoms_rowwise(convert=True)[1].domain
ZZ

The domain of the denominator matrix is the associated ring:

&gt;&gt;&gt; A.clear_denoms_rowwise()[0].domain
ZZ

See Also
========

sympy.polys.polytools.Poly.clear_denoms
clear_denoms
</pre> 
</div>
</div>
<a id="aea6b5e468d0d7772e556ecd9d43209fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6b5e468d0d7772e556ecd9d43209fd">&#9670;&nbsp;</a></span>columnspace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.columnspace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the columnspace for the DomainMatrix

Returns
=======

DomainMatrix
    The columns of this matrix form a basis for the columnspace.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [QQ(1), QQ(-1)],
...    [QQ(2), QQ(-2)]], (2, 2), QQ)
&gt;&gt;&gt; A.columnspace()
DomainMatrix([[1], [2]], (2, 1), QQ)</pre> 
</div>
</div>
<a id="aea6b5e468d0d7772e556ecd9d43209fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6b5e468d0d7772e556ecd9d43209fd">&#9670;&nbsp;</a></span>columnspace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.columnspace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the columnspace for the DomainMatrix

Returns
=======

DomainMatrix
    The columns of this matrix form a basis for the columnspace.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [QQ(1), QQ(-1)],
...    [QQ(2), QQ(-2)]], (2, 2), QQ)
&gt;&gt;&gt; A.columnspace()
DomainMatrix([[1], [2]], (2, 1), QQ)</pre> 
</div>
</div>
<a id="af18449aacc0bb08a0b54ccce3c1ad9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18449aacc0bb08a0b54ccce3c1ad9d7">&#9670;&nbsp;</a></span>content() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.content </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the gcd of the elements of the matrix.

Requires ``gcd`` in the ground domain.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[2, 4], [4, 12]], ZZ)
&gt;&gt;&gt; M.content()
2

See Also
========

primitive
cancel_denom
</pre> 
</div>
</div>
<a id="af18449aacc0bb08a0b54ccce3c1ad9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18449aacc0bb08a0b54ccce3c1ad9d7">&#9670;&nbsp;</a></span>content() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.content </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the gcd of the elements of the matrix.

Requires ``gcd`` in the ground domain.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[2, 4], [4, 12]], ZZ)
&gt;&gt;&gt; M.content()
2

See Also
========

primitive
cancel_denom
</pre> 
</div>
</div>
<a id="a2ed8af726ae1788c852bbc07c4028de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed8af726ae1788c852bbc07c4028de2">&#9670;&nbsp;</a></span>convert_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.convert_to </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Change the domain of DomainMatrix to desired domain or field

Parameters
==========

K : Represents the desired domain or field.
    Alternatively, ``None`` may be passed, in which case this method
    just returns a copy of this DomainMatrix.

Returns
=======

DomainMatrix
    DomainMatrix with the desired domain or field

Examples
========

&gt;&gt;&gt; from sympy import ZZ, ZZ_I
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.convert_to(ZZ_I)
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ_I)</pre> 
</div>
</div>
<a id="a2ed8af726ae1788c852bbc07c4028de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed8af726ae1788c852bbc07c4028de2">&#9670;&nbsp;</a></span>convert_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.convert_to </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Change the domain of DomainMatrix to desired domain or field

Parameters
==========

K : Represents the desired domain or field.
    Alternatively, ``None`` may be passed, in which case this method
    just returns a copy of this DomainMatrix.

Returns
=======

DomainMatrix
    DomainMatrix with the desired domain or field

Examples
========

&gt;&gt;&gt; from sympy import ZZ, ZZ_I
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.convert_to(ZZ_I)
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ_I)</pre> 
</div>
</div>
<a id="ab6e7fe9acba3ff1a7acd2792edaf7dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e7fe9acba3ff1a7acd2792edaf7dc6">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6e7fe9acba3ff1a7acd2792edaf7dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e7fe9acba3ff1a7acd2792edaf7dc6">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab514d6ac4370556e8555dfa97c82579d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab514d6ac4370556e8555dfa97c82579d">&#9670;&nbsp;</a></span>det() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the determinant of a square :class:`DomainMatrix`.

Returns
=======

determinant: DomainElement
    Determinant of the matrix.

Raises
======

ValueError
    If the domain of DomainMatrix is not a Field

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.det()
-2</pre> 
</div>
</div>
<a id="ab514d6ac4370556e8555dfa97c82579d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab514d6ac4370556e8555dfa97c82579d">&#9670;&nbsp;</a></span>det() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the determinant of a square :class:`DomainMatrix`.

Returns
=======

determinant: DomainElement
    Determinant of the matrix.

Raises
======

ValueError
    If the domain of DomainMatrix is not a Field

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.det()
-2</pre> 
</div>
</div>
<a id="a1f5dafe5d5142c49ba83a81663645450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5dafe5d5142c49ba83a81663645450">&#9670;&nbsp;</a></span>diag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.diag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return diagonal matrix with entries from ``diagonal``.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; DomainMatrix.diag([ZZ(5), ZZ(6)], ZZ)
DomainMatrix({0: {0: 5}, 1: {1: 6}}, (2, 2), ZZ)</pre> 
</div>
</div>
<a id="a1f5dafe5d5142c49ba83a81663645450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5dafe5d5142c49ba83a81663645450">&#9670;&nbsp;</a></span>diag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.diag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return diagonal matrix with entries from ``diagonal``.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; DomainMatrix.diag([ZZ(5), ZZ(6)], ZZ)
DomainMatrix({0: {0: 5}, 1: {1: 6}}, (2, 2), ZZ)</pre> 
</div>
</div>
<a id="aa1cce1761f9b483df9a19c705788dfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cce1761f9b483df9a19c705788dfc5">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.diagonal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the diagonal entries of the matrix as a list.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; M = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; M.diagonal()
[1, 4]

See Also
========

is_diagonal
diag
</pre> 
</div>
</div>
<a id="aa1cce1761f9b483df9a19c705788dfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cce1761f9b483df9a19c705788dfc5">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.diagonal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the diagonal entries of the matrix as a list.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; M = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; M.diagonal()
[1, 4]

See Also
========

is_diagonal
diag
</pre> 
</div>
</div>
<a id="a1a18eaabe983d24a972f74bcfd90dcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a18eaabe983d24a972f74bcfd90dcc4">&#9670;&nbsp;</a></span>eval_poly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.eval_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate polynomial function of a matrix $p(A)$.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)
&gt;&gt;&gt; p = [QQ(1), QQ(2), QQ(3)]
&gt;&gt;&gt; p_A = A.eval_poly(p)
&gt;&gt;&gt; p_A
DomainMatrix([[12, 14], [21, 33]], (2, 2), QQ)
&gt;&gt;&gt; p_A == p[0]*A**2 + p[1]*A + p[2]*A**0
True

See Also
========

eval_poly_mul
</pre> 
</div>
</div>
<a id="a1a18eaabe983d24a972f74bcfd90dcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a18eaabe983d24a972f74bcfd90dcc4">&#9670;&nbsp;</a></span>eval_poly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.eval_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate polynomial function of a matrix $p(A)$.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)
&gt;&gt;&gt; p = [QQ(1), QQ(2), QQ(3)]
&gt;&gt;&gt; p_A = A.eval_poly(p)
&gt;&gt;&gt; p_A
DomainMatrix([[12, 14], [21, 33]], (2, 2), QQ)
&gt;&gt;&gt; p_A == p[0]*A**2 + p[1]*A + p[2]*A**0
True

See Also
========

eval_poly_mul
</pre> 
</div>
</div>
<a id="a74804739901a7f09ff5e562b5018cbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74804739901a7f09ff5e562b5018cbc0">&#9670;&nbsp;</a></span>eval_poly_mul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.eval_poly_mul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate polynomial matrix product $p(A) \times B$.

Evaluate the polynomial matrix product $p(A) \times B$ using Horner's
method without creating the matrix $p(A)$ explicitly. If $B$ is a
column matrix then this method will only use matrix-vector multiplies
and no matrix-matrix multiplies are needed.

If $B$ is square or wide or if $A$ can be represented in a simpler
domain than $B$ then it might be faster to evaluate $p(A)$ explicitly
(see :func:`eval_poly`) and then multiply with $B$.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)
&gt;&gt;&gt; b = DM([[QQ(5)], [QQ(6)]], QQ)
&gt;&gt;&gt; p = [QQ(1), QQ(2), QQ(3)]
&gt;&gt;&gt; p_A_b = A.eval_poly_mul(p, b)
&gt;&gt;&gt; p_A_b
DomainMatrix([[144], [303]], (2, 1), QQ)
&gt;&gt;&gt; p_A_b == p[0]*A**2*b + p[1]*A*b + p[2]*b
True
&gt;&gt;&gt; A.eval_poly_mul(p, b) == A.eval_poly(p)*b
True

See Also
========

eval_poly
solve_den_charpoly
</pre> 
</div>
</div>
<a id="a74804739901a7f09ff5e562b5018cbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74804739901a7f09ff5e562b5018cbc0">&#9670;&nbsp;</a></span>eval_poly_mul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.eval_poly_mul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate polynomial matrix product $p(A) \times B$.

Evaluate the polynomial matrix product $p(A) \times B$ using Horner's
method without creating the matrix $p(A)$ explicitly. If $B$ is a
column matrix then this method will only use matrix-vector multiplies
and no matrix-matrix multiplies are needed.

If $B$ is square or wide or if $A$ can be represented in a simpler
domain than $B$ then it might be faster to evaluate $p(A)$ explicitly
(see :func:`eval_poly`) and then multiply with $B$.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)
&gt;&gt;&gt; b = DM([[QQ(5)], [QQ(6)]], QQ)
&gt;&gt;&gt; p = [QQ(1), QQ(2), QQ(3)]
&gt;&gt;&gt; p_A_b = A.eval_poly_mul(p, b)
&gt;&gt;&gt; p_A_b
DomainMatrix([[144], [303]], (2, 1), QQ)
&gt;&gt;&gt; p_A_b == p[0]*A**2*b + p[1]*A*b + p[2]*b
True
&gt;&gt;&gt; A.eval_poly_mul(p, b) == A.eval_poly(p)*b
True

See Also
========

eval_poly
solve_den_charpoly
</pre> 
</div>
</div>
<a id="ac4f8c75cbc7dbac52120c07164788922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f8c75cbc7dbac52120c07164788922">&#9670;&nbsp;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.extract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rowslist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>colslist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4f8c75cbc7dbac52120c07164788922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f8c75cbc7dbac52120c07164788922">&#9670;&nbsp;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.extract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rowslist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>colslist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7281ea94508cab033f30593522f2febb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7281ea94508cab033f30593522f2febb">&#9670;&nbsp;</a></span>eye() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.eye </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return identity matrix of size n or shape (m, n).

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; DomainMatrix.eye(3, QQ)
DomainMatrix({0: {0: 1}, 1: {1: 1}, 2: {2: 1}}, (3, 3), QQ)</pre> 
</div>
</div>
<a id="a7281ea94508cab033f30593522f2febb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7281ea94508cab033f30593522f2febb">&#9670;&nbsp;</a></span>eye() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.eye </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return identity matrix of size n or shape (m, n).

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; DomainMatrix.eye(3, QQ)
DomainMatrix({0: {0: 1}, 1: {1: 1}, 2: {2: 1}}, (3, 3), QQ)</pre> 
</div>
</div>
<a id="a931a657dafe2de4aa191eb59ab94fa82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931a657dafe2de4aa191eb59ab94fa82">&#9670;&nbsp;</a></span>flat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a931a657dafe2de4aa191eb59ab94fa82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931a657dafe2de4aa191eb59ab94fa82">&#9670;&nbsp;</a></span>flat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a625d31cf0d0ea2eb30a9ddfadf7a9b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625d31cf0d0ea2eb30a9ddfadf7a9b51">&#9670;&nbsp;</a></span>from_dict_sympy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_dict_sympy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>elemsdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

nrows: number of rows
ncols: number of cols
elemsdict: dict of dicts containing non-zero elements of the DomainMatrix

Returns
=======

DomainMatrix containing elements of elemsdict

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy.abc import x,y,z
&gt;&gt;&gt; elemsdict = {0: {0:x}, 1:{1: y}, 2: {2: z}}
&gt;&gt;&gt; A = DomainMatrix.from_dict_sympy(3, 3, elemsdict)
&gt;&gt;&gt; A
DomainMatrix({0: {0: x}, 1: {1: y}, 2: {2: z}}, (3, 3), ZZ[x,y,z])

See Also
========

from_list_sympy</pre> 
</div>
</div>
<a id="a625d31cf0d0ea2eb30a9ddfadf7a9b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625d31cf0d0ea2eb30a9ddfadf7a9b51">&#9670;&nbsp;</a></span>from_dict_sympy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_dict_sympy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>elemsdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

nrows: number of rows
ncols: number of cols
elemsdict: dict of dicts containing non-zero elements of the DomainMatrix

Returns
=======

DomainMatrix containing elements of elemsdict

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy.abc import x,y,z
&gt;&gt;&gt; elemsdict = {0: {0:x}, 1:{1: y}, 2: {2: z}}
&gt;&gt;&gt; A = DomainMatrix.from_dict_sympy(3, 3, elemsdict)
&gt;&gt;&gt; A
DomainMatrix({0: {0: x}, 1: {1: y}, 2: {2: z}}, (3, 3), ZZ[x,y,z])

See Also
========

from_list_sympy</pre> 
</div>
</div>
<a id="a27b73545c9c82c7d0f43db82b6367eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b73545c9c82c7d0f43db82b6367eff">&#9670;&nbsp;</a></span>from_dod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_dod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create sparse :class:`DomainMatrix` from dict of dict (dod) format.

See :meth:`to_dod` for explanation.

See Also
========

to_dod
from_dod_like
</pre> 
</div>
</div>
<a id="a27b73545c9c82c7d0f43db82b6367eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b73545c9c82c7d0f43db82b6367eff">&#9670;&nbsp;</a></span>from_dod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_dod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create sparse :class:`DomainMatrix` from dict of dict (dod) format.

See :meth:`to_dod` for explanation.

See Also
========

to_dod
from_dod_like
</pre> 
</div>
</div>
<a id="accfdd0ff12ed0254a6f0db098536d26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfdd0ff12ed0254a6f0db098536d26d">&#9670;&nbsp;</a></span>from_dod_like() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_dod_like </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create :class:`DomainMatrix` like ``self`` from dict of dict (dod) format.

See :meth:`to_dod` for explanation.

See Also
========

to_dod
from_dod
</pre> 
</div>
</div>
<a id="accfdd0ff12ed0254a6f0db098536d26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfdd0ff12ed0254a6f0db098536d26d">&#9670;&nbsp;</a></span>from_dod_like() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_dod_like </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create :class:`DomainMatrix` like ``self`` from dict of dict (dod) format.

See :meth:`to_dod` for explanation.

See Also
========

to_dod
from_dod
</pre> 
</div>
</div>
<a id="a351ccec65f22324c009e21b2d85a29a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351ccec65f22324c009e21b2d85a29a0">&#9670;&nbsp;</a></span>from_dok() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_dok </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create :class:`DomainMatrix` from dictionary of keys (dok) format.

See :meth:`to_dok` for explanation.

See Also
========

to_dok
</pre> 
</div>
</div>
<a id="a351ccec65f22324c009e21b2d85a29a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351ccec65f22324c009e21b2d85a29a0">&#9670;&nbsp;</a></span>from_dok() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_dok </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create :class:`DomainMatrix` from dictionary of keys (dok) format.

See :meth:`to_dok` for explanation.

See Also
========

to_dok
</pre> 
</div>
</div>
<a id="ac2bdf98f78eaad0beced5b755f516209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bdf98f78eaad0beced5b755f516209">&#9670;&nbsp;</a></span>from_flat_nz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_flat_nz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct :class:`DomainMatrix` after calling :meth:`to_flat_nz`.

See :meth:`to_flat_nz` for explanation.

See Also
========

to_flat_nz
</pre> 
</div>
</div>
<a id="ac2bdf98f78eaad0beced5b755f516209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bdf98f78eaad0beced5b755f516209">&#9670;&nbsp;</a></span>from_flat_nz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_flat_nz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct :class:`DomainMatrix` after calling :meth:`to_flat_nz`.

See :meth:`to_flat_nz` for explanation.

See Also
========

to_flat_nz
</pre> 
</div>
</div>
<a id="aa3e62aa11881828a4b4f2a58078ff74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e62aa11881828a4b4f2a58078ff74c">&#9670;&nbsp;</a></span>from_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a list of lists into a DomainMatrix

Parameters
==========

rows: list of lists
    Each element of the inner lists should be either the single arg,
    or tuple of args, that would be passed to the domain constructor
    in order to form an element of the domain. See examples.

Returns
=======

DomainMatrix containing elements defined in rows

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import FF, QQ, ZZ
&gt;&gt;&gt; A = DomainMatrix.from_list([[1, 0, 1], [0, 0, 1]], ZZ)
&gt;&gt;&gt; A
DomainMatrix([[1, 0, 1], [0, 0, 1]], (2, 3), ZZ)
&gt;&gt;&gt; B = DomainMatrix.from_list([[1, 0, 1], [0, 0, 1]], FF(7))
&gt;&gt;&gt; B
DomainMatrix([[1 mod 7, 0 mod 7, 1 mod 7], [0 mod 7, 0 mod 7, 1 mod 7]], (2, 3), GF(7))
&gt;&gt;&gt; C = DomainMatrix.from_list([[(1, 2), (3, 1)], [(1, 4), (5, 1)]], QQ)
&gt;&gt;&gt; C
DomainMatrix([[1/2, 3], [1/4, 5]], (2, 2), QQ)

See Also
========

from_list_sympy</pre> 
</div>
</div>
<a id="aa3e62aa11881828a4b4f2a58078ff74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e62aa11881828a4b4f2a58078ff74c">&#9670;&nbsp;</a></span>from_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a list of lists into a DomainMatrix

Parameters
==========

rows: list of lists
    Each element of the inner lists should be either the single arg,
    or tuple of args, that would be passed to the domain constructor
    in order to form an element of the domain. See examples.

Returns
=======

DomainMatrix containing elements defined in rows

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import FF, QQ, ZZ
&gt;&gt;&gt; A = DomainMatrix.from_list([[1, 0, 1], [0, 0, 1]], ZZ)
&gt;&gt;&gt; A
DomainMatrix([[1, 0, 1], [0, 0, 1]], (2, 3), ZZ)
&gt;&gt;&gt; B = DomainMatrix.from_list([[1, 0, 1], [0, 0, 1]], FF(7))
&gt;&gt;&gt; B
DomainMatrix([[1 mod 7, 0 mod 7, 1 mod 7], [0 mod 7, 0 mod 7, 1 mod 7]], (2, 3), GF(7))
&gt;&gt;&gt; C = DomainMatrix.from_list([[(1, 2), (3, 1)], [(1, 4), (5, 1)]], QQ)
&gt;&gt;&gt; C
DomainMatrix([[1/2, 3], [1/4, 5]], (2, 2), QQ)

See Also
========

from_list_sympy</pre> 
</div>
</div>
<a id="ac02d30b84a7bc9a74e5761052a5869e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02d30b84a7bc9a74e5761052a5869e3">&#9670;&nbsp;</a></span>from_list_flat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_list_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create :class:`DomainMatrix` from flat list.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; element_list = [ZZ(1), ZZ(2), ZZ(3), ZZ(4)]
&gt;&gt;&gt; A = DomainMatrix.from_list_flat(element_list, (2, 2), ZZ)
&gt;&gt;&gt; A
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)
&gt;&gt;&gt; A == A.from_list_flat(A.to_list_flat(), A.shape, A.domain)
True

See Also
========

to_list_flat
</pre> 
</div>
</div>
<a id="ac02d30b84a7bc9a74e5761052a5869e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02d30b84a7bc9a74e5761052a5869e3">&#9670;&nbsp;</a></span>from_list_flat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_list_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create :class:`DomainMatrix` from flat list.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; element_list = [ZZ(1), ZZ(2), ZZ(3), ZZ(4)]
&gt;&gt;&gt; A = DomainMatrix.from_list_flat(element_list, (2, 2), ZZ)
&gt;&gt;&gt; A
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)
&gt;&gt;&gt; A == A.from_list_flat(A.to_list_flat(), A.shape, A.domain)
True

See Also
========

to_list_flat
</pre> 
</div>
</div>
<a id="a544459607961da9e88b62e14c7afe770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544459607961da9e88b62e14c7afe770">&#9670;&nbsp;</a></span>from_list_sympy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_list_sympy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a list of lists of Expr into a DomainMatrix using construct_domain

Parameters
==========

nrows: number of rows
ncols: number of columns
rows: list of lists

Returns
=======

DomainMatrix containing elements of rows

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; A = DomainMatrix.from_list_sympy(1, 3, [[x, y, z]])
&gt;&gt;&gt; A
DomainMatrix([[x, y, z]], (1, 3), ZZ[x,y,z])

See Also
========

sympy.polys.constructor.construct_domain, from_dict_sympy</pre> 
</div>
</div>
<a id="a544459607961da9e88b62e14c7afe770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544459607961da9e88b62e14c7afe770">&#9670;&nbsp;</a></span>from_list_sympy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_list_sympy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a list of lists of Expr into a DomainMatrix using construct_domain

Parameters
==========

nrows: number of rows
ncols: number of columns
rows: list of lists

Returns
=======

DomainMatrix containing elements of rows

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; A = DomainMatrix.from_list_sympy(1, 3, [[x, y, z]])
&gt;&gt;&gt; A
DomainMatrix([[x, y, z]], (1, 3), ZZ[x,y,z])

See Also
========

sympy.polys.constructor.construct_domain, from_dict_sympy</pre> 
</div>
</div>
<a id="abac5b26ae644724d9c7ec3b553527353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac5b26ae644724d9c7ec3b553527353">&#9670;&nbsp;</a></span>from_Matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_Matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>'sparse'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert Matrix to DomainMatrix

Parameters
==========

M: Matrix

Returns
=======

Returns DomainMatrix with identical elements as M

Examples
========

&gt;&gt;&gt; from sympy import Matrix
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; M = Matrix([
...    [1.0, 3.4],
...    [2.4, 1]])
&gt;&gt;&gt; A = DomainMatrix.from_Matrix(M)
&gt;&gt;&gt; A
DomainMatrix({0: {0: 1.0, 1: 3.4}, 1: {0: 2.4, 1: 1.0}}, (2, 2), RR)

We can keep internal representation as ddm using fmt='dense'
&gt;&gt;&gt; from sympy import Matrix, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix.from_Matrix(Matrix([[QQ(1, 2), QQ(3, 4)], [QQ(0, 1), QQ(0, 1)]]), fmt='dense')
&gt;&gt;&gt; A.rep
[[1/2, 3/4], [0, 0]]

See Also
========

Matrix</pre> 
</div>
</div>
<a id="abac5b26ae644724d9c7ec3b553527353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac5b26ae644724d9c7ec3b553527353">&#9670;&nbsp;</a></span>from_Matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_Matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>'sparse'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert Matrix to DomainMatrix

Parameters
==========

M: Matrix

Returns
=======

Returns DomainMatrix with identical elements as M

Examples
========

&gt;&gt;&gt; from sympy import Matrix
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; M = Matrix([
...    [1.0, 3.4],
...    [2.4, 1]])
&gt;&gt;&gt; A = DomainMatrix.from_Matrix(M)
&gt;&gt;&gt; A
DomainMatrix({0: {0: 1.0, 1: 3.4}, 1: {0: 2.4, 1: 1.0}}, (2, 2), RR)

We can keep internal representation as ddm using fmt='dense'
&gt;&gt;&gt; from sympy import Matrix, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix.from_Matrix(Matrix([[QQ(1, 2), QQ(3, 4)], [QQ(0, 1), QQ(0, 1)]]), fmt='dense')
&gt;&gt;&gt; A.rep
[[1/2, 3/4], [0, 0]]

See Also
========

Matrix</pre> 
</div>
</div>
<a id="a137fe98368ba45ea0c213f809fdd9d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137fe98368ba45ea0c213f809fdd9d5a">&#9670;&nbsp;</a></span>from_rep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_rep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new DomainMatrix efficiently from DDM/SDM.

Examples
========

Create a :py:class:`~.DomainMatrix` with an dense internal
representation as :py:class:`~.DDM`:

&gt;&gt;&gt; from sympy.polys.domains import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy.polys.matrices.ddm import DDM
&gt;&gt;&gt; drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; dM = DomainMatrix.from_rep(drep)
&gt;&gt;&gt; dM
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)

Create a :py:class:`~.DomainMatrix` with a sparse internal
representation as :py:class:`~.SDM`:

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy.polys.matrices.sdm import SDM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)
&gt;&gt;&gt; dM = DomainMatrix.from_rep(drep)
&gt;&gt;&gt; dM
DomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ)

Parameters
==========

rep: SDM or DDM
    The internal sparse or dense representation of the matrix.

Returns
=======

DomainMatrix
    A :py:class:`~.DomainMatrix` wrapping *rep*.

Notes
=====

This takes ownership of rep as its internal representation. If rep is
being mutated elsewhere then a copy should be provided to
``from_rep``. Only minimal verification or checking is done on *rep*
as this is supposed to be an efficient internal routine.</pre> 
</div>
</div>
<a id="a137fe98368ba45ea0c213f809fdd9d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137fe98368ba45ea0c213f809fdd9d5a">&#9670;&nbsp;</a></span>from_rep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.from_rep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new DomainMatrix efficiently from DDM/SDM.

Examples
========

Create a :py:class:`~.DomainMatrix` with an dense internal
representation as :py:class:`~.DDM`:

&gt;&gt;&gt; from sympy.polys.domains import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy.polys.matrices.ddm import DDM
&gt;&gt;&gt; drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; dM = DomainMatrix.from_rep(drep)
&gt;&gt;&gt; dM
DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)

Create a :py:class:`~.DomainMatrix` with a sparse internal
representation as :py:class:`~.SDM`:

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy.polys.matrices.sdm import SDM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)
&gt;&gt;&gt; dM = DomainMatrix.from_rep(drep)
&gt;&gt;&gt; dM
DomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ)

Parameters
==========

rep: SDM or DDM
    The internal sparse or dense representation of the matrix.

Returns
=======

DomainMatrix
    A :py:class:`~.DomainMatrix` wrapping *rep*.

Notes
=====

This takes ownership of rep as its internal representation. If rep is
being mutated elsewhere then a copy should be provided to
``from_rep``. Only minimal verification or checking is done on *rep*
as this is supposed to be an efficient internal routine.</pre> 
</div>
</div>
<a id="a65147137cdf9ddfd28355460b5d56bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65147137cdf9ddfd28355460b5d56bb3">&#9670;&nbsp;</a></span>get_domain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.get_domain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>items_sympy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65147137cdf9ddfd28355460b5d56bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65147137cdf9ddfd28355460b5d56bb3">&#9670;&nbsp;</a></span>get_domain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.get_domain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>items_sympy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb71d1e7892b1e8a5208a02d95e8a9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb71d1e7892b1e8a5208a02d95e8a9fc">&#9670;&nbsp;</a></span>getitem_sympy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.getitem_sympy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb71d1e7892b1e8a5208a02d95e8a9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb71d1e7892b1e8a5208a02d95e8a9fc">&#9670;&nbsp;</a></span>getitem_sympy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.getitem_sympy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2aa736d2c4f1df061b08928b5ec7b44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa736d2c4f1df061b08928b5ec7b44d">&#9670;&nbsp;</a></span>hstack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.hstack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Horizontally stack the given matrices.

Parameters
==========

B: DomainMatrix
    Matrices to stack horizontally.

Returns
=======

DomainMatrix
    DomainMatrix by stacking horizontally.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix

&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)
&gt;&gt;&gt; A.hstack(B)
DomainMatrix([[1, 2, 5, 6], [3, 4, 7, 8]], (2, 4), ZZ)

&gt;&gt;&gt; C = DomainMatrix([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)
&gt;&gt;&gt; A.hstack(B, C)
DomainMatrix([[1, 2, 5, 6, 9, 10], [3, 4, 7, 8, 11, 12]], (2, 6), ZZ)

See Also
========

unify
</pre> 
</div>
</div>
<a id="a2aa736d2c4f1df061b08928b5ec7b44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa736d2c4f1df061b08928b5ec7b44d">&#9670;&nbsp;</a></span>hstack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.hstack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Horizontally stack the given matrices.

Parameters
==========

B: DomainMatrix
    Matrices to stack horizontally.

Returns
=======

DomainMatrix
    DomainMatrix by stacking horizontally.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix

&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)
&gt;&gt;&gt; A.hstack(B)
DomainMatrix([[1, 2, 5, 6], [3, 4, 7, 8]], (2, 4), ZZ)

&gt;&gt;&gt; C = DomainMatrix([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)
&gt;&gt;&gt; A.hstack(B, C)
DomainMatrix([[1, 2, 5, 6, 9, 10], [3, 4, 7, 8, 11, 12]], (2, 6), ZZ)

See Also
========

unify
</pre> 
</div>
</div>
<a id="a0fdbe31a058eaf83ccdb2e5a7c3b4c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdbe31a058eaf83ccdb2e5a7c3b4c1a">&#9670;&nbsp;</a></span>inv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.inv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds the inverse of the DomainMatrix if exists

Returns
=======

DomainMatrix
    DomainMatrix after inverse

Raises
======

ValueError
    If the domain of DomainMatrix not a Field

DMNonSquareMatrixError
    If the DomainMatrix is not a not Square DomainMatrix

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...     [QQ(2), QQ(-1), QQ(0)],
...     [QQ(-1), QQ(2), QQ(-1)],
...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ)
&gt;&gt;&gt; A.inv()
DomainMatrix([[2/3, 1/3, 1/6], [1/3, 2/3, 1/3], [0, 0, 1/2]], (3, 3), QQ)

See Also
========

neg</pre> 
</div>
</div>
<a id="a0fdbe31a058eaf83ccdb2e5a7c3b4c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdbe31a058eaf83ccdb2e5a7c3b4c1a">&#9670;&nbsp;</a></span>inv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.inv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds the inverse of the DomainMatrix if exists

Returns
=======

DomainMatrix
    DomainMatrix after inverse

Raises
======

ValueError
    If the domain of DomainMatrix not a Field

DMNonSquareMatrixError
    If the DomainMatrix is not a not Square DomainMatrix

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...     [QQ(2), QQ(-1), QQ(0)],
...     [QQ(-1), QQ(2), QQ(-1)],
...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ)
&gt;&gt;&gt; A.inv()
DomainMatrix([[2/3, 1/3, 1/6], [1/3, 2/3, 1/3], [0, 0, 1/2]], (3, 3), QQ)

See Also
========

neg</pre> 
</div>
</div>
<a id="af04da1eeea5423b8bbcbb5e3e4502356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04da1eeea5423b8bbcbb5e3e4502356">&#9670;&nbsp;</a></span>inv_den() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.inv_den </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the inverse as a :class:`DomainMatrix` with denominator.

Returns
=======

(inv, den) : (:class:`DomainMatrix`, :class:`~.DomainElement`)
    The inverse matrix and its denominator.

This is more or less equivalent to :meth:`adj_det` except that ``inv``
and ``den`` are not guaranteed to be the adjugate and inverse. The
ratio ``inv/den`` is equivalent to ``adj/det`` but some factors
might be cancelled between ``inv`` and ``den``. In simple cases this
might just be a minus sign so that ``(inv, den) == (-adj, -det)`` but
factors more complicated than ``-1`` can also be cancelled.
Cancellation is not guaranteed to be complete so ``inv`` and ``den``
may not be on lowest terms. The denominator ``den`` will be zero if and
only if the determinant is zero.

If the actual adjugate and determinant are needed, use :meth:`adj_det`
instead. If the intention is to compute the inverse matrix or solve a
system of equations then :meth:`inv_den` is more efficient.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...     [ZZ(2), ZZ(-1), ZZ(0)],
...     [ZZ(-1), ZZ(2), ZZ(-1)],
...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ)
&gt;&gt;&gt; Ainv, den = A.inv_den()
&gt;&gt;&gt; den
6
&gt;&gt;&gt; Ainv
DomainMatrix([[4, 2, 1], [2, 4, 2], [0, 0, 3]], (3, 3), ZZ)
&gt;&gt;&gt; A * Ainv == den * A.eye(A.shape, A.domain).to_dense()
True

Parameters
==========

method : str, optional
    The method to use to compute the inverse. Can be one of ``None``,
    ``'rref'`` or ``'charpoly'``. If ``None`` then the method is
    chosen automatically (see :meth:`solve_den` for details).

See Also
========

inv
det
adj_det
solve_den
</pre> 
</div>
</div>
<a id="af04da1eeea5423b8bbcbb5e3e4502356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04da1eeea5423b8bbcbb5e3e4502356">&#9670;&nbsp;</a></span>inv_den() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.inv_den </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the inverse as a :class:`DomainMatrix` with denominator.

Returns
=======

(inv, den) : (:class:`DomainMatrix`, :class:`~.DomainElement`)
    The inverse matrix and its denominator.

This is more or less equivalent to :meth:`adj_det` except that ``inv``
and ``den`` are not guaranteed to be the adjugate and inverse. The
ratio ``inv/den`` is equivalent to ``adj/det`` but some factors
might be cancelled between ``inv`` and ``den``. In simple cases this
might just be a minus sign so that ``(inv, den) == (-adj, -det)`` but
factors more complicated than ``-1`` can also be cancelled.
Cancellation is not guaranteed to be complete so ``inv`` and ``den``
may not be on lowest terms. The denominator ``den`` will be zero if and
only if the determinant is zero.

If the actual adjugate and determinant are needed, use :meth:`adj_det`
instead. If the intention is to compute the inverse matrix or solve a
system of equations then :meth:`inv_den` is more efficient.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...     [ZZ(2), ZZ(-1), ZZ(0)],
...     [ZZ(-1), ZZ(2), ZZ(-1)],
...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ)
&gt;&gt;&gt; Ainv, den = A.inv_den()
&gt;&gt;&gt; den
6
&gt;&gt;&gt; Ainv
DomainMatrix([[4, 2, 1], [2, 4, 2], [0, 0, 3]], (3, 3), ZZ)
&gt;&gt;&gt; A * Ainv == den * A.eye(A.shape, A.domain).to_dense()
True

Parameters
==========

method : str, optional
    The method to use to compute the inverse. Can be one of ``None``,
    ``'rref'`` or ``'charpoly'``. If ``None`` then the method is
    chosen automatically (see :meth:`solve_den` for details).

See Also
========

inv
det
adj_det
solve_den
</pre> 
</div>
</div>
<a id="a214fa555b0cf49aeb9d73650a18c8f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214fa555b0cf49aeb9d73650a18c8f60">&#9670;&nbsp;</a></span>is_diagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_diagonal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">True if the matrix is diagonal.

Can return true for non-square matrices. A matrix is diagonal if
``M[i,j] == 0`` whenever ``i != j``.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; M = DM([[ZZ(1), ZZ(0)], [ZZ(0), ZZ(1)]], ZZ)
&gt;&gt;&gt; M.is_diagonal
True

See Also
========

is_upper
is_lower
is_square
diagonal
</pre> 
</div>
</div>
<a id="a214fa555b0cf49aeb9d73650a18c8f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214fa555b0cf49aeb9d73650a18c8f60">&#9670;&nbsp;</a></span>is_diagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_diagonal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">True if the matrix is diagonal.

Can return true for non-square matrices. A matrix is diagonal if
``M[i,j] == 0`` whenever ``i != j``.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; M = DM([[ZZ(1), ZZ(0)], [ZZ(0), ZZ(1)]], ZZ)
&gt;&gt;&gt; M.is_diagonal
True

See Also
========

is_upper
is_lower
is_square
diagonal
</pre> 
</div>
</div>
<a id="a9a33b312a5ccd75a2d9f44b3c13d1924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a33b312a5ccd75a2d9f44b3c13d1924">&#9670;&nbsp;</a></span>is_lower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_lower </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Says whether this matrix is lower-triangular. True can be returned
even if the matrix is not square.
</pre> 
</div>
</div>
<a id="a9a33b312a5ccd75a2d9f44b3c13d1924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a33b312a5ccd75a2d9f44b3c13d1924">&#9670;&nbsp;</a></span>is_lower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_lower </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Says whether this matrix is lower-triangular. True can be returned
even if the matrix is not square.
</pre> 
</div>
</div>
<a id="a26a996fb2f5b2cd07ea389d7df264c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a996fb2f5b2cd07ea389d7df264c7d">&#9670;&nbsp;</a></span>is_square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_square </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">True if the matrix is square.
</pre> 
</div>
</div>
<a id="a26a996fb2f5b2cd07ea389d7df264c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a996fb2f5b2cd07ea389d7df264c7d">&#9670;&nbsp;</a></span>is_square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_square </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">True if the matrix is square.
</pre> 
</div>
</div>
<a id="abe6a068dd2382fcf19c33e189b1ee823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6a068dd2382fcf19c33e189b1ee823">&#9670;&nbsp;</a></span>is_upper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_upper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Says whether this matrix is upper-triangular. True can be returned
even if the matrix is not square.
</pre> 
</div>
</div>
<a id="abe6a068dd2382fcf19c33e189b1ee823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6a068dd2382fcf19c33e189b1ee823">&#9670;&nbsp;</a></span>is_upper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_upper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Says whether this matrix is upper-triangular. True can be returned
even if the matrix is not square.
</pre> 
</div>
</div>
<a id="ae63ca4b56b99e10a996bfc517a389c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63ca4b56b99e10a996bfc517a389c2e">&#9670;&nbsp;</a></span>is_zero_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_zero_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae63ca4b56b99e10a996bfc517a389c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63ca4b56b99e10a996bfc517a389c2e">&#9670;&nbsp;</a></span>is_zero_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.is_zero_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74d0735bd910214f27e25a7582191aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d0735bd910214f27e25a7582191aaa">&#9670;&nbsp;</a></span>iter_items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.iter_items </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate over indices and values of nonzero elements of the matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(0)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; list(A.iter_items())
[((0, 0), 1), ((1, 0), 3), ((1, 1), 4)]

See Also
========

iter_values
to_dok
sympy.matrices.matrixbase.MatrixBase.iter_items
</pre> 
</div>
</div>
<a id="a74d0735bd910214f27e25a7582191aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d0735bd910214f27e25a7582191aaa">&#9670;&nbsp;</a></span>iter_items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.iter_items </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate over indices and values of nonzero elements of the matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(0)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; list(A.iter_items())
[((0, 0), 1), ((1, 0), 3), ((1, 1), 4)]

See Also
========

iter_values
to_dok
sympy.matrices.matrixbase.MatrixBase.iter_items
</pre> 
</div>
</div>
<a id="a43c5eb09e4469056c14a45be62c32e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c5eb09e4469056c14a45be62c32e79">&#9670;&nbsp;</a></span>iter_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.iter_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate over nonzero elements of the matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(0)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; list(A.iter_values())
[1, 3, 4]

See Also
========

iter_items
to_list_flat
sympy.matrices.matrixbase.MatrixBase.iter_values
</pre> 
</div>
</div>
<a id="a43c5eb09e4469056c14a45be62c32e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c5eb09e4469056c14a45be62c32e79">&#9670;&nbsp;</a></span>iter_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.iter_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate over nonzero elements of the matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(0)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; list(A.iter_values())
[1, 3, 4]

See Also
========

iter_items
to_list_flat
sympy.matrices.matrixbase.MatrixBase.iter_values
</pre> 
</div>
</div>
<a id="a7a5946e386c771ee7d7700393e5d8cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5946e386c771ee7d7700393e5d8cb6">&#9670;&nbsp;</a></span>lll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.lll </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>QQ(3,&#160;4)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the LenstraLenstraLovsz (LLL) basis reduction algorithm.
See [1]_ and [2]_.

Parameters
==========

delta : QQ, optional
    The Lovsz parameter. Must be in the interval (0.25, 1), with larger
    values producing a more reduced basis. The default is 0.75 for
    historical reasons.

Returns
=======

The reduced basis as a DomainMatrix over ZZ.

Throws
======

DMValueError: if delta is not in the range (0.25, 1)
DMShapeError: if the matrix is not of shape (m, n) with m &lt;= n
DMDomainError: if the matrix domain is not ZZ
DMRankError: if the matrix contains linearly dependent rows

Examples
========

&gt;&gt;&gt; from sympy.polys.domains import ZZ, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; x = DM([[1, 0, 0, 0, -20160],
...         [0, 1, 0, 0, 33768],
...         [0, 0, 1, 0, 39578],
...         [0, 0, 0, 1, 47757]], ZZ)
&gt;&gt;&gt; y = DM([[10, -3, -2, 8, -4],
...         [3, -9, 8, 1, -11],
...         [-3, 13, -9, -3, -9],
...         [-12, -7, -11, 9, -1]], ZZ)
&gt;&gt;&gt; assert x.lll(delta=QQ(5, 6)) == y

Notes
=====

The implementation is derived from the Maple code given in Figures 4.3
and 4.4 of [3]_ (pp.68-69). It uses the efficient method of only calculating
state updates as they are required.

See also
========

lll_transform

References
==========

.. [1] https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm
.. [2] https://web.archive.org/web/20221029115428/https://web.cs.elte.hu/~lovasz/scans/lll.pdf
.. [3] Murray R. Bremner, "Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications"</pre> 
</div>
</div>
<a id="a7a5946e386c771ee7d7700393e5d8cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5946e386c771ee7d7700393e5d8cb6">&#9670;&nbsp;</a></span>lll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.lll </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>QQ(3,&#160;4)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the LenstraLenstraLovsz (LLL) basis reduction algorithm.
See [1]_ and [2]_.

Parameters
==========

delta : QQ, optional
    The Lovsz parameter. Must be in the interval (0.25, 1), with larger
    values producing a more reduced basis. The default is 0.75 for
    historical reasons.

Returns
=======

The reduced basis as a DomainMatrix over ZZ.

Throws
======

DMValueError: if delta is not in the range (0.25, 1)
DMShapeError: if the matrix is not of shape (m, n) with m &lt;= n
DMDomainError: if the matrix domain is not ZZ
DMRankError: if the matrix contains linearly dependent rows

Examples
========

&gt;&gt;&gt; from sympy.polys.domains import ZZ, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; x = DM([[1, 0, 0, 0, -20160],
...         [0, 1, 0, 0, 33768],
...         [0, 0, 1, 0, 39578],
...         [0, 0, 0, 1, 47757]], ZZ)
&gt;&gt;&gt; y = DM([[10, -3, -2, 8, -4],
...         [3, -9, 8, 1, -11],
...         [-3, 13, -9, -3, -9],
...         [-12, -7, -11, 9, -1]], ZZ)
&gt;&gt;&gt; assert x.lll(delta=QQ(5, 6)) == y

Notes
=====

The implementation is derived from the Maple code given in Figures 4.3
and 4.4 of [3]_ (pp.68-69). It uses the efficient method of only calculating
state updates as they are required.

See also
========

lll_transform

References
==========

.. [1] https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm
.. [2] https://web.archive.org/web/20221029115428/https://web.cs.elte.hu/~lovasz/scans/lll.pdf
.. [3] Murray R. Bremner, "Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications"</pre> 
</div>
</div>
<a id="a3bfacbc23ca3701f45fe2d04ad92061d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfacbc23ca3701f45fe2d04ad92061d">&#9670;&nbsp;</a></span>lll_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.lll_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>QQ(3,&#160;4)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the LenstraLenstraLovsz (LLL) basis reduction algorithm
and returns the reduced basis and transformation matrix.

Explanation
===========

Parameters, algorithm and basis are the same as for :meth:`lll` except that
the return value is a tuple `(B, T)` with `B` the reduced basis and
`T` a transformation matrix. The original basis `A` is transformed to
`B` with `T*A == B`. If only `B` is needed then :meth:`lll` should be
used as it is a little faster.

Examples
========

&gt;&gt;&gt; from sympy.polys.domains import ZZ, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; X = DM([[1, 0, 0, 0, -20160],
...         [0, 1, 0, 0, 33768],
...         [0, 0, 1, 0, 39578],
...         [0, 0, 0, 1, 47757]], ZZ)
&gt;&gt;&gt; B, T = X.lll_transform(delta=QQ(5, 6))
&gt;&gt;&gt; T * X == B
True

See also
========

lll</pre> 
</div>
</div>
<a id="a3bfacbc23ca3701f45fe2d04ad92061d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfacbc23ca3701f45fe2d04ad92061d">&#9670;&nbsp;</a></span>lll_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.lll_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>QQ(3,&#160;4)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the LenstraLenstraLovsz (LLL) basis reduction algorithm
and returns the reduced basis and transformation matrix.

Explanation
===========

Parameters, algorithm and basis are the same as for :meth:`lll` except that
the return value is a tuple `(B, T)` with `B` the reduced basis and
`T` a transformation matrix. The original basis `A` is transformed to
`B` with `T*A == B`. If only `B` is needed then :meth:`lll` should be
used as it is a little faster.

Examples
========

&gt;&gt;&gt; from sympy.polys.domains import ZZ, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; X = DM([[1, 0, 0, 0, -20160],
...         [0, 1, 0, 0, 33768],
...         [0, 0, 1, 0, 39578],
...         [0, 0, 0, 1, 47757]], ZZ)
&gt;&gt;&gt; B, T = X.lll_transform(delta=QQ(5, 6))
&gt;&gt;&gt; T * X == B
True

See also
========

lll</pre> 
</div>
</div>
<a id="a1e345c3ac35af13fe31541cf9102cefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e345c3ac35af13fe31541cf9102cefc">&#9670;&nbsp;</a></span>lu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.lu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns Lower and Upper decomposition of the DomainMatrix

Returns
=======

(L, U, exchange)
    L, U are Lower and Upper decomposition of the DomainMatrix,
    exchange is the list of indices of rows exchanged in the
    decomposition.

Raises
======

ValueError
    If the domain of DomainMatrix not a Field

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [QQ(1), QQ(-1)],
...    [QQ(2), QQ(-2)]], (2, 2), QQ)
&gt;&gt;&gt; L, U, exchange = A.lu()
&gt;&gt;&gt; L
DomainMatrix([[1, 0], [2, 1]], (2, 2), QQ)
&gt;&gt;&gt; U
DomainMatrix([[1, -1], [0, 0]], (2, 2), QQ)
&gt;&gt;&gt; exchange
[]

See Also
========

lu_solve</pre> 
</div>
</div>
<a id="a1e345c3ac35af13fe31541cf9102cefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e345c3ac35af13fe31541cf9102cefc">&#9670;&nbsp;</a></span>lu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.lu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns Lower and Upper decomposition of the DomainMatrix

Returns
=======

(L, U, exchange)
    L, U are Lower and Upper decomposition of the DomainMatrix,
    exchange is the list of indices of rows exchanged in the
    decomposition.

Raises
======

ValueError
    If the domain of DomainMatrix not a Field

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [QQ(1), QQ(-1)],
...    [QQ(2), QQ(-2)]], (2, 2), QQ)
&gt;&gt;&gt; L, U, exchange = A.lu()
&gt;&gt;&gt; L
DomainMatrix([[1, 0], [2, 1]], (2, 2), QQ)
&gt;&gt;&gt; U
DomainMatrix([[1, -1], [0, 0]], (2, 2), QQ)
&gt;&gt;&gt; exchange
[]

See Also
========

lu_solve</pre> 
</div>
</div>
<a id="a96b6b2cc575b58a546a4ee1db14d1775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b6b2cc575b58a546a4ee1db14d1775">&#9670;&nbsp;</a></span>lu_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.lu_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solver for DomainMatrix x in the A*x = B

Parameters
==========

rhs : DomainMatrix B

Returns
=======

DomainMatrix
    x in A*x = B

Raises
======

DMShapeError
    If the DomainMatrix A and rhs have different number of rows

ValueError
    If the domain of DomainMatrix A not a Field

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [QQ(1), QQ(2)],
...    [QQ(3), QQ(4)]], (2, 2), QQ)
&gt;&gt;&gt; B = DomainMatrix([
...    [QQ(1), QQ(1)],
...    [QQ(0), QQ(1)]], (2, 2), QQ)

&gt;&gt;&gt; A.lu_solve(B)
DomainMatrix([[-2, -1], [3/2, 1]], (2, 2), QQ)

See Also
========

lu</pre> 
</div>
</div>
<a id="a96b6b2cc575b58a546a4ee1db14d1775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b6b2cc575b58a546a4ee1db14d1775">&#9670;&nbsp;</a></span>lu_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.lu_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solver for DomainMatrix x in the A*x = B

Parameters
==========

rhs : DomainMatrix B

Returns
=======

DomainMatrix
    x in A*x = B

Raises
======

DMShapeError
    If the DomainMatrix A and rhs have different number of rows

ValueError
    If the domain of DomainMatrix A not a Field

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [QQ(1), QQ(2)],
...    [QQ(3), QQ(4)]], (2, 2), QQ)
&gt;&gt;&gt; B = DomainMatrix([
...    [QQ(1), QQ(1)],
...    [QQ(0), QQ(1)]], (2, 2), QQ)

&gt;&gt;&gt; A.lu_solve(B)
DomainMatrix([[-2, -1], [3/2, 1]], (2, 2), QQ)

See Also
========

lu</pre> 
</div>
</div>
<a id="a264a0cbf1e4a79c53e641285ed473498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264a0cbf1e4a79c53e641285ed473498">&#9670;&nbsp;</a></span>matmul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.matmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs matrix multiplication of two DomainMatrix matrices

Parameters
==========

A, B: DomainMatrix
    to multiply

Returns
=======

DomainMatrix
    DomainMatrix after multiplication

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([
...    [ZZ(1), ZZ(1)],
...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)

&gt;&gt;&gt; A.matmul(B)
DomainMatrix([[1, 3], [3, 7]], (2, 2), ZZ)

See Also
========

mul, pow, add, sub</pre> 
</div>
</div>
<a id="a264a0cbf1e4a79c53e641285ed473498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264a0cbf1e4a79c53e641285ed473498">&#9670;&nbsp;</a></span>matmul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.matmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs matrix multiplication of two DomainMatrix matrices

Parameters
==========

A, B: DomainMatrix
    to multiply

Returns
=======

DomainMatrix
    DomainMatrix after multiplication

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([
...    [ZZ(1), ZZ(1)],
...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)

&gt;&gt;&gt; A.matmul(B)
DomainMatrix([[1, 3], [3, 7]], (2, 2), ZZ)

See Also
========

mul, pow, add, sub</pre> 
</div>
</div>
<a id="ab9fe1cdac3c60075482677f75c9f7ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fe1cdac3c60075482677f75c9f7ffb">&#9670;&nbsp;</a></span>mul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.mul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs term by term multiplication for the second DomainMatrix
w.r.t first DomainMatrix. Returns a DomainMatrix whose rows are
list of DomainMatrix matrices created after term by term multiplication.

Parameters
==========

A, B: DomainMatrix
    matrices to multiply term-wise

Returns
=======

DomainMatrix
    DomainMatrix after term by term multiplication

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; b = ZZ(2)

&gt;&gt;&gt; A.mul(b)
DomainMatrix([[2, 4], [6, 8]], (2, 2), ZZ)

See Also
========

matmul</pre> 
</div>
</div>
<a id="ab9fe1cdac3c60075482677f75c9f7ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fe1cdac3c60075482677f75c9f7ffb">&#9670;&nbsp;</a></span>mul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.mul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs term by term multiplication for the second DomainMatrix
w.r.t first DomainMatrix. Returns a DomainMatrix whose rows are
list of DomainMatrix matrices created after term by term multiplication.

Parameters
==========

A, B: DomainMatrix
    matrices to multiply term-wise

Returns
=======

DomainMatrix
    DomainMatrix after term by term multiplication

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; b = ZZ(2)

&gt;&gt;&gt; A.mul(b)
DomainMatrix([[2, 4], [6, 8]], (2, 2), ZZ)

See Also
========

matmul</pre> 
</div>
</div>
<a id="a231d63c808b2328f6e9d48467d4ba581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231d63c808b2328f6e9d48467d4ba581">&#9670;&nbsp;</a></span>mul_elementwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.mul_elementwise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a231d63c808b2328f6e9d48467d4ba581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231d63c808b2328f6e9d48467d4ba581">&#9670;&nbsp;</a></span>mul_elementwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.mul_elementwise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4765f1e4fb6be91e1be509dfda52cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4765f1e4fb6be91e1be509dfda52cc2">&#9670;&nbsp;</a></span>neg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.neg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the negative of DomainMatrix

Parameters
==========

A : Represents a DomainMatrix

Returns
=======

DomainMatrix
    DomainMatrix after Negation

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.neg()
DomainMatrix([[-1, -2], [-3, -4]], (2, 2), ZZ)</pre> 
</div>
</div>
<a id="aa4765f1e4fb6be91e1be509dfda52cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4765f1e4fb6be91e1be509dfda52cc2">&#9670;&nbsp;</a></span>neg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.neg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the negative of DomainMatrix

Parameters
==========

A : Represents a DomainMatrix

Returns
=======

DomainMatrix
    DomainMatrix after Negation

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.neg()
DomainMatrix([[-1, -2], [-3, -4]], (2, 2), ZZ)</pre> 
</div>
</div>
<a id="ade91be9261e5f4299983a6d34698afa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade91be9261e5f4299983a6d34698afa6">&#9670;&nbsp;</a></span>nnz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.nnz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Number of nonzero elements in the matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[1, 0], [0, 4]], ZZ)
&gt;&gt;&gt; A.nnz()
2
</pre> 
</div>
</div>
<a id="ade91be9261e5f4299983a6d34698afa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade91be9261e5f4299983a6d34698afa6">&#9670;&nbsp;</a></span>nnz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.nnz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Number of nonzero elements in the matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[1, 0], [0, 4]], ZZ)
&gt;&gt;&gt; A.nnz()
2
</pre> 
</div>
</div>
<a id="ad94409ecbe7f83f55e90f0c0240b882e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94409ecbe7f83f55e90f0c0240b882e">&#9670;&nbsp;</a></span>nullspace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>divide_last</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the nullspace for the DomainMatrix

Returns
=======

DomainMatrix
    The rows of this matrix form a basis for the nullspace.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([
...    [QQ(2), QQ(-2)],
...    [QQ(4), QQ(-4)]], QQ)
&gt;&gt;&gt; A.nullspace()
DomainMatrix([[1, 1]], (1, 2), QQ)

The returned matrix is a basis for the nullspace:

&gt;&gt;&gt; A_null = A.nullspace().transpose()
&gt;&gt;&gt; A * A_null
DomainMatrix([[0], [0]], (2, 1), QQ)
&gt;&gt;&gt; rows, cols = A.shape
&gt;&gt;&gt; nullity = rows - A.rank()
&gt;&gt;&gt; A_null.shape == (cols, nullity)
True

Nullspace can also be computed for non-field rings. If the ring is not
a field then division is not used. Setting ``divide_last`` to True will
raise an error in this case:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; B = DM([[6, -3],
...         [4, -2]], ZZ)
&gt;&gt;&gt; B.nullspace()
DomainMatrix([[3, 6]], (1, 2), ZZ)
&gt;&gt;&gt; B.nullspace(divide_last=True)
Traceback (most recent call last):
...
DMNotAField: Cannot normalize vectors over a non-field

Over a ring with ``gcd`` defined the nullspace can potentially be
reduced with :meth:`primitive`:

&gt;&gt;&gt; B.nullspace().primitive()
(3, DomainMatrix([[1, 2]], (1, 2), ZZ))

A matrix over a ring can often be normalized by converting it to a
field but it is often a bad idea to do so:

&gt;&gt;&gt; from sympy.abc import a, b, c
&gt;&gt;&gt; from sympy import Matrix
&gt;&gt;&gt; M = Matrix([[        a*b,       b + c,        c],
...             [      a - b,         b*c,     c**2],
...             [a*b + a - b, b*c + b + c, c**2 + c]])
&gt;&gt;&gt; M.to_DM().domain
ZZ[a,b,c]
&gt;&gt;&gt; M.to_DM().nullspace().to_Matrix().transpose()
Matrix([
[                             c**3],
[            -a*b*c**2 + a*c - b*c],
[a*b**2*c - a*b - a*c + b**2 + b*c]])

The unnormalized form here is nicer than the normalized form that
spreads a large denominator throughout the matrix:

&gt;&gt;&gt; M.to_DM().to_field().nullspace(divide_last=True).to_Matrix().transpose()
Matrix([
[                   c**3/(a*b**2*c - a*b - a*c + b**2 + b*c)],
[(-a*b*c**2 + a*c - b*c)/(a*b**2*c - a*b - a*c + b**2 + b*c)],
[                                                          1]])

Parameters
==========

divide_last : bool, optional
    If False (the default), the vectors are not normalized and the RREF
    is computed using :meth:`rref_den` and the denominator is
    discarded. If True, then each row is divided by its final element;
    the domain must be a field in this case.

See Also
========

nullspace_from_rref
rref
rref_den
rowspace
</pre> 
</div>
</div>
<a id="ad94409ecbe7f83f55e90f0c0240b882e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94409ecbe7f83f55e90f0c0240b882e">&#9670;&nbsp;</a></span>nullspace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>divide_last</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the nullspace for the DomainMatrix

Returns
=======

DomainMatrix
    The rows of this matrix form a basis for the nullspace.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([
...    [QQ(2), QQ(-2)],
...    [QQ(4), QQ(-4)]], QQ)
&gt;&gt;&gt; A.nullspace()
DomainMatrix([[1, 1]], (1, 2), QQ)

The returned matrix is a basis for the nullspace:

&gt;&gt;&gt; A_null = A.nullspace().transpose()
&gt;&gt;&gt; A * A_null
DomainMatrix([[0], [0]], (2, 1), QQ)
&gt;&gt;&gt; rows, cols = A.shape
&gt;&gt;&gt; nullity = rows - A.rank()
&gt;&gt;&gt; A_null.shape == (cols, nullity)
True

Nullspace can also be computed for non-field rings. If the ring is not
a field then division is not used. Setting ``divide_last`` to True will
raise an error in this case:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; B = DM([[6, -3],
...         [4, -2]], ZZ)
&gt;&gt;&gt; B.nullspace()
DomainMatrix([[3, 6]], (1, 2), ZZ)
&gt;&gt;&gt; B.nullspace(divide_last=True)
Traceback (most recent call last):
...
DMNotAField: Cannot normalize vectors over a non-field

Over a ring with ``gcd`` defined the nullspace can potentially be
reduced with :meth:`primitive`:

&gt;&gt;&gt; B.nullspace().primitive()
(3, DomainMatrix([[1, 2]], (1, 2), ZZ))

A matrix over a ring can often be normalized by converting it to a
field but it is often a bad idea to do so:

&gt;&gt;&gt; from sympy.abc import a, b, c
&gt;&gt;&gt; from sympy import Matrix
&gt;&gt;&gt; M = Matrix([[        a*b,       b + c,        c],
...             [      a - b,         b*c,     c**2],
...             [a*b + a - b, b*c + b + c, c**2 + c]])
&gt;&gt;&gt; M.to_DM().domain
ZZ[a,b,c]
&gt;&gt;&gt; M.to_DM().nullspace().to_Matrix().transpose()
Matrix([
[                             c**3],
[            -a*b*c**2 + a*c - b*c],
[a*b**2*c - a*b - a*c + b**2 + b*c]])

The unnormalized form here is nicer than the normalized form that
spreads a large denominator throughout the matrix:

&gt;&gt;&gt; M.to_DM().to_field().nullspace(divide_last=True).to_Matrix().transpose()
Matrix([
[                   c**3/(a*b**2*c - a*b - a*c + b**2 + b*c)],
[(-a*b*c**2 + a*c - b*c)/(a*b**2*c - a*b - a*c + b**2 + b*c)],
[                                                          1]])

Parameters
==========

divide_last : bool, optional
    If False (the default), the vectors are not normalized and the RREF
    is computed using :meth:`rref_den` and the denominator is
    discarded. If True, then each row is divided by its final element;
    the domain must be a field in this case.

See Also
========

nullspace_from_rref
rref
rref_den
rowspace
</pre> 
</div>
</div>
<a id="acbab0d56703b2017642c81bd8650ffb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbab0d56703b2017642c81bd8650ffb0">&#9670;&nbsp;</a></span>nullspace_from_rref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace_from_rref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pivots</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute nullspace from rref and pivots.

The domain of the matrix can be any domain.

The matrix must be in reduced row echelon form already. Otherwise the
result will be incorrect. Use :meth:`rref` or :meth:`rref_den` first
to get the reduced row echelon form or use :meth:`nullspace` instead.

See Also
========

nullspace
rref
rref_den
sympy.polys.matrices.sdm.SDM.nullspace_from_rref
sympy.polys.matrices.ddm.DDM.nullspace_from_rref
</pre> 
</div>
</div>
<a id="acbab0d56703b2017642c81bd8650ffb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbab0d56703b2017642c81bd8650ffb0">&#9670;&nbsp;</a></span>nullspace_from_rref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace_from_rref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pivots</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute nullspace from rref and pivots.

The domain of the matrix can be any domain.

The matrix must be in reduced row echelon form already. Otherwise the
result will be incorrect. Use :meth:`rref` or :meth:`rref_den` first
to get the reduced row echelon form or use :meth:`nullspace` instead.

See Also
========

nullspace
rref
rref_den
sympy.polys.matrices.sdm.SDM.nullspace_from_rref
sympy.polys.matrices.ddm.DDM.nullspace_from_rref
</pre> 
</div>
</div>
<a id="ad3807892dc98f02717632590a8726a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3807892dc98f02717632590a8726a69">&#9670;&nbsp;</a></span>ones() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.ones </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a DomainMatrix of 1s, of size shape, belonging to the specified domain

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; DomainMatrix.ones((2,3), QQ)
DomainMatrix([[1, 1, 1], [1, 1, 1]], (2, 3), QQ)</pre> 
</div>
</div>
<a id="ad3807892dc98f02717632590a8726a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3807892dc98f02717632590a8726a69">&#9670;&nbsp;</a></span>ones() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.ones </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a DomainMatrix of 1s, of size shape, belonging to the specified domain

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; DomainMatrix.ones((2,3), QQ)
DomainMatrix([[1, 1, 1], [1, 1, 1]], (2, 3), QQ)</pre> 
</div>
</div>
<a id="a85c6e38973f66006dfd1a1379a23f543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c6e38973f66006dfd1a1379a23f543">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.pow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes A**n

Parameters
==========

A : DomainMatrix

n : exponent for A

Returns
=======

DomainMatrix
    DomainMatrix on computing A**n

Raises
======

NotImplementedError
    if n is negative.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(1)],
...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)

&gt;&gt;&gt; A.pow(2)
DomainMatrix([[1, 2], [0, 1]], (2, 2), ZZ)

See Also
========

matmul</pre> 
</div>
</div>
<a id="a85c6e38973f66006dfd1a1379a23f543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c6e38973f66006dfd1a1379a23f543">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.pow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes A**n

Parameters
==========

A : DomainMatrix

n : exponent for A

Returns
=======

DomainMatrix
    DomainMatrix on computing A**n

Raises
======

NotImplementedError
    if n is negative.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(1)],
...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)

&gt;&gt;&gt; A.pow(2)
DomainMatrix([[1, 2], [0, 1]], (2, 2), ZZ)

See Also
========

matmul</pre> 
</div>
</div>
<a id="abace3470aee0892f7d4f84924de42202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abace3470aee0892f7d4f84924de42202">&#9670;&nbsp;</a></span>primitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.primitive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Factor out gcd of the elements of a matrix.

Requires ``gcd`` in the ground domain.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[2, 4], [4, 12]], ZZ)
&gt;&gt;&gt; content, M_primitive = M.primitive()
&gt;&gt;&gt; content
2
&gt;&gt;&gt; M_primitive
DomainMatrix([[1, 2], [2, 6]], (2, 2), ZZ)
&gt;&gt;&gt; content * M_primitive == M
True
&gt;&gt;&gt; M_primitive.content() == ZZ(1)
True

See Also
========

content
cancel_denom
</pre> 
</div>
</div>
<a id="abace3470aee0892f7d4f84924de42202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abace3470aee0892f7d4f84924de42202">&#9670;&nbsp;</a></span>primitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.primitive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Factor out gcd of the elements of a matrix.

Requires ``gcd`` in the ground domain.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; M = DM([[2, 4], [4, 12]], ZZ)
&gt;&gt;&gt; content, M_primitive = M.primitive()
&gt;&gt;&gt; content
2
&gt;&gt;&gt; M_primitive
DomainMatrix([[1, 2], [2, 6]], (2, 2), ZZ)
&gt;&gt;&gt; content * M_primitive == M
True
&gt;&gt;&gt; M_primitive.content() == ZZ(1)
True

See Also
========

content
cancel_denom
</pre> 
</div>
</div>
<a id="a4c6cf029de10dccefeb57ab33892a089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6cf029de10dccefeb57ab33892a089">&#9670;&nbsp;</a></span>rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c6cf029de10dccefeb57ab33892a089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6cf029de10dccefeb57ab33892a089">&#9670;&nbsp;</a></span>rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac08e1d5af953a3a03fd46e7dbb3c22ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08e1d5af953a3a03fd46e7dbb3c22ae">&#9670;&nbsp;</a></span>rmul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac08e1d5af953a3a03fd46e7dbb3c22ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08e1d5af953a3a03fd46e7dbb3c22ae">&#9670;&nbsp;</a></span>rmul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aecbbf66993a0992ecfbb99165473de77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbbf66993a0992ecfbb99165473de77">&#9670;&nbsp;</a></span>rowspace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rowspace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the rowspace for the DomainMatrix

Returns
=======

DomainMatrix
    The rows of this matrix form a basis for the rowspace.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [QQ(1), QQ(-1)],
...    [QQ(2), QQ(-2)]], (2, 2), QQ)
&gt;&gt;&gt; A.rowspace()
DomainMatrix([[1, -1]], (1, 2), QQ)</pre> 
</div>
</div>
<a id="aecbbf66993a0992ecfbb99165473de77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbbf66993a0992ecfbb99165473de77">&#9670;&nbsp;</a></span>rowspace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rowspace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the rowspace for the DomainMatrix

Returns
=======

DomainMatrix
    The rows of this matrix form a basis for the rowspace.

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [QQ(1), QQ(-1)],
...    [QQ(2), QQ(-2)]], (2, 2), QQ)
&gt;&gt;&gt; A.rowspace()
DomainMatrix([[1, -1]], (1, 2), QQ)</pre> 
</div>
</div>
<a id="af3ac0f550c87c1d77f9682d6ad67a638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ac0f550c87c1d77f9682d6ad67a638">&#9670;&nbsp;</a></span>rref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns reduced-row echelon form (RREF) and list of pivots.

If the domain is not a field then it will be converted to a field. See
:meth:`rref_den` for the fraction-free version of this routine that
returns RREF with denominator instead.

The domain must either be a field or have an associated fraction field
(see :meth:`to_field`).

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...     [QQ(2), QQ(-1), QQ(0)],
...     [QQ(-1), QQ(2), QQ(-1)],
...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ)

&gt;&gt;&gt; rref_matrix, rref_pivots = A.rref()
&gt;&gt;&gt; rref_matrix
DomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)
&gt;&gt;&gt; rref_pivots
(0, 1, 2)

Parameters
==========

method : str, optional (default: 'auto')
    The method to use to compute the RREF. The default is ``'auto'``,
    which will attempt to choose the fastest method. The other options
    are:

    - ``A.rref(method='GJ')`` uses Gauss-Jordan elimination with
      division. If the domain is not a field then it will be converted
      to a field with :meth:`to_field` first and RREF will be computed
      by inverting the pivot elements in each row. This is most
      efficient for very sparse matrices or for matrices whose elements
      have complex denominators.

    - ``A.rref(method='FF')`` uses fraction-free Gauss-Jordan
      elimination. Elimination is performed using exact division
      (``exquo``) to control the growth of the coefficients. In this
      case the current domain is always used for elimination but if
      the domain is not a field then it will be converted to a field
      at the end and divided by the denominator. This is most efficient
      for dense matrices or for matrices with simple denominators.

    - ``A.rref(method='CD')`` clears the denominators before using
      fraction-free Gauss-Jordan elimination in the assoicated ring.
      This is most efficient for dense matrices with very simple
      denominators.

    - ``A.rref(method='GJ_dense')``, ``A.rref(method='FF_dense')``, and
      ``A.rref(method='CD_dense')`` are the same as the above methods
      except that the dense implementations of the algorithms are used.
      By default ``A.rref(method='auto')`` will usually choose the
      sparse implementations for RREF.

    Regardless of which algorithm is used the returned matrix will
    always have the same format (sparse or dense) as the input and its
    domain will always be the field of fractions of the input domain.

Returns
=======

(DomainMatrix, list)
    reduced-row echelon form and list of pivots for the DomainMatrix

See Also
========

rref_den
    RREF with denominator
sympy.polys.matrices.sdm.sdm_irref
    Sparse implementation of ``method='GJ'``.
sympy.polys.matrices.sdm.sdm_rref_den
    Sparse implementation of ``method='FF'`` and ``method='CD'``.
sympy.polys.matrices.dense.ddm_irref
    Dense implementation of ``method='GJ'``.
sympy.polys.matrices.dense.ddm_irref_den
    Dense implementation of ``method='FF'`` and ``method='CD'``.
clear_denoms
    Clear denominators from a matrix, used by ``method='CD'`` and
    by ``method='GJ'`` when the original domain is not a field.</pre> 
</div>
</div>
<a id="af3ac0f550c87c1d77f9682d6ad67a638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ac0f550c87c1d77f9682d6ad67a638">&#9670;&nbsp;</a></span>rref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns reduced-row echelon form (RREF) and list of pivots.

If the domain is not a field then it will be converted to a field. See
:meth:`rref_den` for the fraction-free version of this routine that
returns RREF with denominator instead.

The domain must either be a field or have an associated fraction field
(see :meth:`to_field`).

Examples
========

&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...     [QQ(2), QQ(-1), QQ(0)],
...     [QQ(-1), QQ(2), QQ(-1)],
...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ)

&gt;&gt;&gt; rref_matrix, rref_pivots = A.rref()
&gt;&gt;&gt; rref_matrix
DomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)
&gt;&gt;&gt; rref_pivots
(0, 1, 2)

Parameters
==========

method : str, optional (default: 'auto')
    The method to use to compute the RREF. The default is ``'auto'``,
    which will attempt to choose the fastest method. The other options
    are:

    - ``A.rref(method='GJ')`` uses Gauss-Jordan elimination with
      division. If the domain is not a field then it will be converted
      to a field with :meth:`to_field` first and RREF will be computed
      by inverting the pivot elements in each row. This is most
      efficient for very sparse matrices or for matrices whose elements
      have complex denominators.

    - ``A.rref(method='FF')`` uses fraction-free Gauss-Jordan
      elimination. Elimination is performed using exact division
      (``exquo``) to control the growth of the coefficients. In this
      case the current domain is always used for elimination but if
      the domain is not a field then it will be converted to a field
      at the end and divided by the denominator. This is most efficient
      for dense matrices or for matrices with simple denominators.

    - ``A.rref(method='CD')`` clears the denominators before using
      fraction-free Gauss-Jordan elimination in the assoicated ring.
      This is most efficient for dense matrices with very simple
      denominators.

    - ``A.rref(method='GJ_dense')``, ``A.rref(method='FF_dense')``, and
      ``A.rref(method='CD_dense')`` are the same as the above methods
      except that the dense implementations of the algorithms are used.
      By default ``A.rref(method='auto')`` will usually choose the
      sparse implementations for RREF.

    Regardless of which algorithm is used the returned matrix will
    always have the same format (sparse or dense) as the input and its
    domain will always be the field of fractions of the input domain.

Returns
=======

(DomainMatrix, list)
    reduced-row echelon form and list of pivots for the DomainMatrix

See Also
========

rref_den
    RREF with denominator
sympy.polys.matrices.sdm.sdm_irref
    Sparse implementation of ``method='GJ'``.
sympy.polys.matrices.sdm.sdm_rref_den
    Sparse implementation of ``method='FF'`` and ``method='CD'``.
sympy.polys.matrices.dense.ddm_irref
    Dense implementation of ``method='GJ'``.
sympy.polys.matrices.dense.ddm_irref_den
    Dense implementation of ``method='FF'`` and ``method='CD'``.
clear_denoms
    Clear denominators from a matrix, used by ``method='CD'`` and
    by ``method='GJ'`` when the original domain is not a field.</pre> 
</div>
</div>
<a id="adb7175d96842fdabfeb2ff65b1974c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7175d96842fdabfeb2ff65b1974c61">&#9670;&nbsp;</a></span>rref_den() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keep_domain</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns reduced-row echelon form with denominator and list of pivots.

Requires exact division in the ground domain (``exquo``).

Examples
========

&gt;&gt;&gt; from sympy import ZZ, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...     [ZZ(2), ZZ(-1), ZZ(0)],
...     [ZZ(-1), ZZ(2), ZZ(-1)],
...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ)

&gt;&gt;&gt; A_rref, denom, pivots = A.rref_den()
&gt;&gt;&gt; A_rref
DomainMatrix([[6, 0, 0], [0, 6, 0], [0, 0, 6]], (3, 3), ZZ)
&gt;&gt;&gt; denom
6
&gt;&gt;&gt; pivots
(0, 1, 2)
&gt;&gt;&gt; A_rref.to_field() / denom
DomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)
&gt;&gt;&gt; A_rref.to_field() / denom == A.convert_to(QQ).rref()[0]
True

Parameters
==========

method : str, optional (default: 'auto')
    The method to use to compute the RREF. The default is ``'auto'``,
    which will attempt to choose the fastest method. The other options
    are:

    - ``A.rref(method='FF')`` uses fraction-free Gauss-Jordan
      elimination. Elimination is performed using exact division
      (``exquo``) to control the growth of the coefficients. In this
      case the current domain is always used for elimination and the
      result is always returned as a matrix over the current domain.
      This is most efficient for dense matrices or for matrices with
      simple denominators.

    - ``A.rref(method='CD')`` clears denominators before using
      fraction-free Gauss-Jordan elimination in the assoicated ring.
      The result will be converted back to the original domain unless
      ``keep_domain=False`` is passed in which case the result will be
      over the ring used for elimination. This is most efficient for
      dense matrices with very simple denominators.

    - ``A.rref(method='GJ')`` uses Gauss-Jordan elimination with
      division. If the domain is not a field then it will be converted
      to a field with :meth:`to_field` first and RREF will be computed
      by inverting the pivot elements in each row. The result is
      converted back to the original domain by clearing denominators
      unless ``keep_domain=False`` is passed in which case the result
      will be over the field used for elimination. This is most
      efficient for very sparse matrices or for matrices whose elements
      have complex denominators.

    - ``A.rref(method='GJ_dense')``, ``A.rref(method='FF_dense')``, and
      ``A.rref(method='CD_dense')`` are the same as the above methods
      except that the dense implementations of the algorithms are used.
      By default ``A.rref(method='auto')`` will usually choose the
      sparse implementations for RREF.

    Regardless of which algorithm is used the returned matrix will
    always have the same format (sparse or dense) as the input and if
    ``keep_domain=True`` its domain will always be the same as the
    input.

keep_domain : bool, optional
    If True (the default), the domain of the returned matrix and
    denominator are the same as the domain of the input matrix. If
    False, the domain of the returned matrix might be changed to an
    associated ring or field if the algorithm used a different domain.
    This is useful for efficiency if the caller does not need the
    result to be in the original domain e.g. it avoids clearing
    denominators in the case of ``A.rref(method='GJ')``.

Returns
=======

(DomainMatrix, scalar, list)
    Reduced-row echelon form, denominator and list of pivot indices.

See Also
========

rref
    RREF without denominator for field domains.
sympy.polys.matrices.sdm.sdm_irref
    Sparse implementation of ``method='GJ'``.
sympy.polys.matrices.sdm.sdm_rref_den
    Sparse implementation of ``method='FF'`` and ``method='CD'``.
sympy.polys.matrices.dense.ddm_irref
    Dense implementation of ``method='GJ'``.
sympy.polys.matrices.dense.ddm_irref_den
    Dense implementation of ``method='FF'`` and ``method='CD'``.
clear_denoms
    Clear denominators from a matrix, used by ``method='CD'``.</pre> 
</div>
</div>
<a id="adb7175d96842fdabfeb2ff65b1974c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7175d96842fdabfeb2ff65b1974c61">&#9670;&nbsp;</a></span>rref_den() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keep_domain</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns reduced-row echelon form with denominator and list of pivots.

Requires exact division in the ground domain (``exquo``).

Examples
========

&gt;&gt;&gt; from sympy import ZZ, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...     [ZZ(2), ZZ(-1), ZZ(0)],
...     [ZZ(-1), ZZ(2), ZZ(-1)],
...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ)

&gt;&gt;&gt; A_rref, denom, pivots = A.rref_den()
&gt;&gt;&gt; A_rref
DomainMatrix([[6, 0, 0], [0, 6, 0], [0, 0, 6]], (3, 3), ZZ)
&gt;&gt;&gt; denom
6
&gt;&gt;&gt; pivots
(0, 1, 2)
&gt;&gt;&gt; A_rref.to_field() / denom
DomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)
&gt;&gt;&gt; A_rref.to_field() / denom == A.convert_to(QQ).rref()[0]
True

Parameters
==========

method : str, optional (default: 'auto')
    The method to use to compute the RREF. The default is ``'auto'``,
    which will attempt to choose the fastest method. The other options
    are:

    - ``A.rref(method='FF')`` uses fraction-free Gauss-Jordan
      elimination. Elimination is performed using exact division
      (``exquo``) to control the growth of the coefficients. In this
      case the current domain is always used for elimination and the
      result is always returned as a matrix over the current domain.
      This is most efficient for dense matrices or for matrices with
      simple denominators.

    - ``A.rref(method='CD')`` clears denominators before using
      fraction-free Gauss-Jordan elimination in the assoicated ring.
      The result will be converted back to the original domain unless
      ``keep_domain=False`` is passed in which case the result will be
      over the ring used for elimination. This is most efficient for
      dense matrices with very simple denominators.

    - ``A.rref(method='GJ')`` uses Gauss-Jordan elimination with
      division. If the domain is not a field then it will be converted
      to a field with :meth:`to_field` first and RREF will be computed
      by inverting the pivot elements in each row. The result is
      converted back to the original domain by clearing denominators
      unless ``keep_domain=False`` is passed in which case the result
      will be over the field used for elimination. This is most
      efficient for very sparse matrices or for matrices whose elements
      have complex denominators.

    - ``A.rref(method='GJ_dense')``, ``A.rref(method='FF_dense')``, and
      ``A.rref(method='CD_dense')`` are the same as the above methods
      except that the dense implementations of the algorithms are used.
      By default ``A.rref(method='auto')`` will usually choose the
      sparse implementations for RREF.

    Regardless of which algorithm is used the returned matrix will
    always have the same format (sparse or dense) as the input and if
    ``keep_domain=True`` its domain will always be the same as the
    input.

keep_domain : bool, optional
    If True (the default), the domain of the returned matrix and
    denominator are the same as the domain of the input matrix. If
    False, the domain of the returned matrix might be changed to an
    associated ring or field if the algorithm used a different domain.
    This is useful for efficiency if the caller does not need the
    result to be in the original domain e.g. it avoids clearing
    denominators in the case of ``A.rref(method='GJ')``.

Returns
=======

(DomainMatrix, scalar, list)
    Reduced-row echelon form, denominator and list of pivot indices.

See Also
========

rref
    RREF without denominator for field domains.
sympy.polys.matrices.sdm.sdm_irref
    Sparse implementation of ``method='GJ'``.
sympy.polys.matrices.sdm.sdm_rref_den
    Sparse implementation of ``method='FF'`` and ``method='CD'``.
sympy.polys.matrices.dense.ddm_irref
    Dense implementation of ``method='GJ'``.
sympy.polys.matrices.dense.ddm_irref_den
    Dense implementation of ``method='FF'`` and ``method='CD'``.
clear_denoms
    Clear denominators from a matrix, used by ``method='CD'``.</pre> 
</div>
</div>
<a id="a5f8c72cfcb427b43bcc69c2ecbc1be8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8c72cfcb427b43bcc69c2ecbc1be8f">&#9670;&nbsp;</a></span>rscalarmul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rscalarmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f8c72cfcb427b43bcc69c2ecbc1be8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8c72cfcb427b43bcc69c2ecbc1be8f">&#9670;&nbsp;</a></span>rscalarmul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.rscalarmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad2e1edbb49566a35352ab4514710304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2e1edbb49566a35352ab4514710304">&#9670;&nbsp;</a></span>scalarmul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.scalarmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad2e1edbb49566a35352ab4514710304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2e1edbb49566a35352ab4514710304">&#9670;&nbsp;</a></span>scalarmul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.scalarmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lamda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76c5a407fdddb5dcac842aa41065c8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c5a407fdddb5dcac842aa41065c8f5">&#9670;&nbsp;</a></span>scc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.scc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the strongly connected components of a DomainMatrix

Explanation
===========

A square matrix can be considered as the adjacency matrix for a
directed graph where the row and column indices are the vertices. In
this graph if there is an edge from vertex ``i`` to vertex ``j`` if
``M[i, j]`` is nonzero. This routine computes the strongly connected
components of that graph which are subsets of the rows and columns that
are connected by some nonzero element of the matrix. The strongly
connected components are useful because many operations such as the
determinant can be computed by working with the submatrices
corresponding to each component.

Examples
========

Find the strongly connected components of a matrix:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; M = DomainMatrix([[ZZ(1), ZZ(0), ZZ(2)],
...                   [ZZ(0), ZZ(3), ZZ(0)],
...                   [ZZ(4), ZZ(6), ZZ(5)]], (3, 3), ZZ)
&gt;&gt;&gt; M.scc()
[[1], [0, 2]]

Compute the determinant from the components:

&gt;&gt;&gt; MM = M.to_Matrix()
&gt;&gt;&gt; MM
Matrix([
[1, 0, 2],
[0, 3, 0],
[4, 6, 5]])
&gt;&gt;&gt; MM[[1], [1]]
Matrix([[3]])
&gt;&gt;&gt; MM[[0, 2], [0, 2]]
Matrix([
[1, 2],
[4, 5]])
&gt;&gt;&gt; MM.det()
-9
&gt;&gt;&gt; MM[[1], [1]].det() * MM[[0, 2], [0, 2]].det()
-9

The components are given in reverse topological order and represent a
permutation of the rows and columns that will bring the matrix into
block lower-triangular form:

&gt;&gt;&gt; MM[[1, 0, 2], [1, 0, 2]]
Matrix([
[3, 0, 0],
[0, 1, 2],
[6, 4, 5]])

Returns
=======

List of lists of integers
    Each list represents a strongly connected component.

See also
========

sympy.matrices.matrixbase.MatrixBase.strongly_connected_components
sympy.utilities.iterables.strongly_connected_components</pre> 
</div>
</div>
<a id="a76c5a407fdddb5dcac842aa41065c8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c5a407fdddb5dcac842aa41065c8f5">&#9670;&nbsp;</a></span>scc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.scc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the strongly connected components of a DomainMatrix

Explanation
===========

A square matrix can be considered as the adjacency matrix for a
directed graph where the row and column indices are the vertices. In
this graph if there is an edge from vertex ``i`` to vertex ``j`` if
``M[i, j]`` is nonzero. This routine computes the strongly connected
components of that graph which are subsets of the rows and columns that
are connected by some nonzero element of the matrix. The strongly
connected components are useful because many operations such as the
determinant can be computed by working with the submatrices
corresponding to each component.

Examples
========

Find the strongly connected components of a matrix:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; M = DomainMatrix([[ZZ(1), ZZ(0), ZZ(2)],
...                   [ZZ(0), ZZ(3), ZZ(0)],
...                   [ZZ(4), ZZ(6), ZZ(5)]], (3, 3), ZZ)
&gt;&gt;&gt; M.scc()
[[1], [0, 2]]

Compute the determinant from the components:

&gt;&gt;&gt; MM = M.to_Matrix()
&gt;&gt;&gt; MM
Matrix([
[1, 0, 2],
[0, 3, 0],
[4, 6, 5]])
&gt;&gt;&gt; MM[[1], [1]]
Matrix([[3]])
&gt;&gt;&gt; MM[[0, 2], [0, 2]]
Matrix([
[1, 2],
[4, 5]])
&gt;&gt;&gt; MM.det()
-9
&gt;&gt;&gt; MM[[1], [1]].det() * MM[[0, 2], [0, 2]].det()
-9

The components are given in reverse topological order and represent a
permutation of the rows and columns that will bring the matrix into
block lower-triangular form:

&gt;&gt;&gt; MM[[1, 0, 2], [1, 0, 2]]
Matrix([
[3, 0, 0],
[0, 1, 2],
[6, 4, 5]])

Returns
=======

List of lists of integers
    Each list represents a strongly connected component.

See also
========

sympy.matrices.matrixbase.MatrixBase.strongly_connected_components
sympy.utilities.iterables.strongly_connected_components</pre> 
</div>
</div>
<a id="a206309103dcb405764eb0ba28a7d01b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206309103dcb405764eb0ba28a7d01b5">&#9670;&nbsp;</a></span>solve_den() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve matrix equation $Ax = b$ without fractions in the ground domain.

Examples
========

Solve a matrix equation over the integers:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; b = DM([[ZZ(5)], [ZZ(6)]], ZZ)
&gt;&gt;&gt; xnum, xden = A.solve_den(b)
&gt;&gt;&gt; xden
-2
&gt;&gt;&gt; xnum
DomainMatrix([[8], [-9]], (2, 1), ZZ)
&gt;&gt;&gt; A * xnum == xden * b
True

Solve a matrix equation over a polynomial ring:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.abc import x, y, z, a, b
&gt;&gt;&gt; R = ZZ[x, y, z, a, b]
&gt;&gt;&gt; M = DM([[x*y, x*z], [y*z, x*z]], R)
&gt;&gt;&gt; b = DM([[a], [b]], R)
&gt;&gt;&gt; M.to_Matrix()
Matrix([
[x*y, x*z],
[y*z, x*z]])
&gt;&gt;&gt; b.to_Matrix()
Matrix([
[a],
[b]])
&gt;&gt;&gt; xnum, xden = M.solve_den(b)
&gt;&gt;&gt; xden
x**2*y*z - x*y*z**2
&gt;&gt;&gt; xnum.to_Matrix()
Matrix([
[ a*x*z - b*x*z],
[-a*y*z + b*x*y]])
&gt;&gt;&gt; M * xnum == xden * b
True

The solution can be expressed over a fraction field which will cancel
gcds between the denominator and the elements of the numerator:

&gt;&gt;&gt; xsol = xnum.to_field() / xden
&gt;&gt;&gt; xsol.to_Matrix()
Matrix([
[           (a - b)/(x*y - y*z)],
[(-a*z + b*x)/(x**2*z - x*z**2)]])
&gt;&gt;&gt; (M * xsol).to_Matrix() == b.to_Matrix()
True

When solving a large system of equations this cancellation step might
be a lot slower than :func:`solve_den` itself. The solution can also be
expressed as a ``Matrix`` without attempting any polynomial
cancellation between the numerator and denominator giving a less
simplified result more quickly:

&gt;&gt;&gt; xsol_uncancelled = xnum.to_Matrix() / xnum.domain.to_sympy(xden)
&gt;&gt;&gt; xsol_uncancelled
Matrix([
[ (a*x*z - b*x*z)/(x**2*y*z - x*y*z**2)],
[(-a*y*z + b*x*y)/(x**2*y*z - x*y*z**2)]])
&gt;&gt;&gt; from sympy import cancel
&gt;&gt;&gt; cancel(xsol_uncancelled) == xsol.to_Matrix()
True

Parameters
==========

self : :class:`DomainMatrix`
    The ``m x n`` matrix $A$ in the equation $Ax = b$. Underdetermined
    systems are not supported so ``m &gt;= n``: $A$ should be square or
    have more rows than columns.
b : :class:`DomainMatrix`
    The ``n x m`` matrix $b$ for the rhs.
cp : list of :class:`~.DomainElement`, optional
    The characteristic polynomial of the matrix $A$. If not given, it
    will be computed using :meth:`charpoly`.
method: str, optional
    The method to use for solving the system. Can be one of ``None``,
    ``'charpoly'`` or ``'rref'``. If ``None`` (the default) then the
    method will be chosen automatically.

    The ``charpoly`` method uses :meth:`solve_den_charpoly` and can
    only be used if the matrix is square. This method is division free
    and can be used with any domain.

    The ``rref`` method is fraction free but requires exact division
    in the ground domain (``exquo``). This is also suitable for most
    domains. This method can be used with overdetermined systems (more
    equations than unknowns) but not underdetermined systems as a
    unique solution is sought.

Returns
=======

(xnum, xden) : (DomainMatrix, DomainElement)
    The solution of the equation $Ax = b$ as a pair consisting of an
    ``n x m`` matrix numerator ``xnum`` and a scalar denominator
    ``xden``.

The solution $x$ is given by ``x = xnum / xden``. The division free
invariant is ``A * xnum == xden * b``. If $A$ is square then the
denominator ``xden`` will be a divisor of the determinant $det(A)$.

Raises
======

DMNonInvertibleMatrixError
    If the system $Ax = b$ does not have a unique solution.

See Also
========

solve_den_charpoly
solve_den_rref
inv_den
</pre> 
</div>
</div>
<a id="a206309103dcb405764eb0ba28a7d01b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206309103dcb405764eb0ba28a7d01b5">&#9670;&nbsp;</a></span>solve_den() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve matrix equation $Ax = b$ without fractions in the ground domain.

Examples
========

Solve a matrix equation over the integers:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; b = DM([[ZZ(5)], [ZZ(6)]], ZZ)
&gt;&gt;&gt; xnum, xden = A.solve_den(b)
&gt;&gt;&gt; xden
-2
&gt;&gt;&gt; xnum
DomainMatrix([[8], [-9]], (2, 1), ZZ)
&gt;&gt;&gt; A * xnum == xden * b
True

Solve a matrix equation over a polynomial ring:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.abc import x, y, z, a, b
&gt;&gt;&gt; R = ZZ[x, y, z, a, b]
&gt;&gt;&gt; M = DM([[x*y, x*z], [y*z, x*z]], R)
&gt;&gt;&gt; b = DM([[a], [b]], R)
&gt;&gt;&gt; M.to_Matrix()
Matrix([
[x*y, x*z],
[y*z, x*z]])
&gt;&gt;&gt; b.to_Matrix()
Matrix([
[a],
[b]])
&gt;&gt;&gt; xnum, xden = M.solve_den(b)
&gt;&gt;&gt; xden
x**2*y*z - x*y*z**2
&gt;&gt;&gt; xnum.to_Matrix()
Matrix([
[ a*x*z - b*x*z],
[-a*y*z + b*x*y]])
&gt;&gt;&gt; M * xnum == xden * b
True

The solution can be expressed over a fraction field which will cancel
gcds between the denominator and the elements of the numerator:

&gt;&gt;&gt; xsol = xnum.to_field() / xden
&gt;&gt;&gt; xsol.to_Matrix()
Matrix([
[           (a - b)/(x*y - y*z)],
[(-a*z + b*x)/(x**2*z - x*z**2)]])
&gt;&gt;&gt; (M * xsol).to_Matrix() == b.to_Matrix()
True

When solving a large system of equations this cancellation step might
be a lot slower than :func:`solve_den` itself. The solution can also be
expressed as a ``Matrix`` without attempting any polynomial
cancellation between the numerator and denominator giving a less
simplified result more quickly:

&gt;&gt;&gt; xsol_uncancelled = xnum.to_Matrix() / xnum.domain.to_sympy(xden)
&gt;&gt;&gt; xsol_uncancelled
Matrix([
[ (a*x*z - b*x*z)/(x**2*y*z - x*y*z**2)],
[(-a*y*z + b*x*y)/(x**2*y*z - x*y*z**2)]])
&gt;&gt;&gt; from sympy import cancel
&gt;&gt;&gt; cancel(xsol_uncancelled) == xsol.to_Matrix()
True

Parameters
==========

self : :class:`DomainMatrix`
    The ``m x n`` matrix $A$ in the equation $Ax = b$. Underdetermined
    systems are not supported so ``m &gt;= n``: $A$ should be square or
    have more rows than columns.
b : :class:`DomainMatrix`
    The ``n x m`` matrix $b$ for the rhs.
cp : list of :class:`~.DomainElement`, optional
    The characteristic polynomial of the matrix $A$. If not given, it
    will be computed using :meth:`charpoly`.
method: str, optional
    The method to use for solving the system. Can be one of ``None``,
    ``'charpoly'`` or ``'rref'``. If ``None`` (the default) then the
    method will be chosen automatically.

    The ``charpoly`` method uses :meth:`solve_den_charpoly` and can
    only be used if the matrix is square. This method is division free
    and can be used with any domain.

    The ``rref`` method is fraction free but requires exact division
    in the ground domain (``exquo``). This is also suitable for most
    domains. This method can be used with overdetermined systems (more
    equations than unknowns) but not underdetermined systems as a
    unique solution is sought.

Returns
=======

(xnum, xden) : (DomainMatrix, DomainElement)
    The solution of the equation $Ax = b$ as a pair consisting of an
    ``n x m`` matrix numerator ``xnum`` and a scalar denominator
    ``xden``.

The solution $x$ is given by ``x = xnum / xden``. The division free
invariant is ``A * xnum == xden * b``. If $A$ is square then the
denominator ``xden`` will be a divisor of the determinant $det(A)$.

Raises
======

DMNonInvertibleMatrixError
    If the system $Ax = b$ does not have a unique solution.

See Also
========

solve_den_charpoly
solve_den_rref
inv_den
</pre> 
</div>
</div>
<a id="a553bf71ed99cce7c8b58b203f259b63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553bf71ed99cce7c8b58b203f259b63c">&#9670;&nbsp;</a></span>solve_den_charpoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den_charpoly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cp</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve matrix equation $Ax = b$ using the characteristic polynomial.

This method solves the square matrix equation $Ax = b$ for $x$ using
the characteristic polynomial without any division or fractions in the
ground domain.

Examples
========

Solve a matrix equation over the integers:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; b = DM([[ZZ(5)], [ZZ(6)]], ZZ)
&gt;&gt;&gt; xnum, detA = A.solve_den_charpoly(b)
&gt;&gt;&gt; detA
-2
&gt;&gt;&gt; xnum
DomainMatrix([[8], [-9]], (2, 1), ZZ)
&gt;&gt;&gt; A * xnum == detA * b
True

Parameters
==========

self : DomainMatrix
    The ``n x n`` matrix `A` in the equation `Ax = b`. Must be square
    and invertible.
b : DomainMatrix
    The ``n x m`` matrix `b` for the rhs.
cp : list, optional
    The characteristic polynomial of the matrix `A` if known. If not
    given, it will be computed using :meth:`charpoly`.
check : bool, optional
    If ``True`` (the default) check that the determinant is not zero
    and raise an error if it is. If ``False`` then if the determinant
    is zero the return value will be equal to ``(A.adjugate()*b, 0)``.

Returns
=======

(xnum, detA) : (DomainMatrix, DomainElement)
    The solution of the equation `Ax = b` as a matrix numerator and
    scalar denominator pair. The denominator is equal to the
    determinant of `A` and the numerator is ``adj(A)*b``.

The solution $x$ is given by ``x = xnum / detA``. The division free
invariant is ``A * xnum == detA * b``.

If ``b`` is the identity matrix, then ``xnum`` is the adjugate matrix
and we have ``A * adj(A) == detA * I``.

See Also
========

solve_den
    Main frontend for solving matrix equations with denominator.
solve_den_rref
    Solve matrix equations using fraction-free RREF.
inv_den
    Invert a matrix using the characteristic polynomial.
</pre> 
</div>
</div>
<a id="a553bf71ed99cce7c8b58b203f259b63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553bf71ed99cce7c8b58b203f259b63c">&#9670;&nbsp;</a></span>solve_den_charpoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den_charpoly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cp</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve matrix equation $Ax = b$ using the characteristic polynomial.

This method solves the square matrix equation $Ax = b$ for $x$ using
the characteristic polynomial without any division or fractions in the
ground domain.

Examples
========

Solve a matrix equation over the integers:

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; b = DM([[ZZ(5)], [ZZ(6)]], ZZ)
&gt;&gt;&gt; xnum, detA = A.solve_den_charpoly(b)
&gt;&gt;&gt; detA
-2
&gt;&gt;&gt; xnum
DomainMatrix([[8], [-9]], (2, 1), ZZ)
&gt;&gt;&gt; A * xnum == detA * b
True

Parameters
==========

self : DomainMatrix
    The ``n x n`` matrix `A` in the equation `Ax = b`. Must be square
    and invertible.
b : DomainMatrix
    The ``n x m`` matrix `b` for the rhs.
cp : list, optional
    The characteristic polynomial of the matrix `A` if known. If not
    given, it will be computed using :meth:`charpoly`.
check : bool, optional
    If ``True`` (the default) check that the determinant is not zero
    and raise an error if it is. If ``False`` then if the determinant
    is zero the return value will be equal to ``(A.adjugate()*b, 0)``.

Returns
=======

(xnum, detA) : (DomainMatrix, DomainElement)
    The solution of the equation `Ax = b` as a matrix numerator and
    scalar denominator pair. The denominator is equal to the
    determinant of `A` and the numerator is ``adj(A)*b``.

The solution $x$ is given by ``x = xnum / detA``. The division free
invariant is ``A * xnum == detA * b``.

If ``b`` is the identity matrix, then ``xnum`` is the adjugate matrix
and we have ``A * adj(A) == detA * I``.

See Also
========

solve_den
    Main frontend for solving matrix equations with denominator.
solve_den_rref
    Solve matrix equations using fraction-free RREF.
inv_den
    Invert a matrix using the characteristic polynomial.
</pre> 
</div>
</div>
<a id="a7ac603c488948514871b04c9f8a742e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac603c488948514871b04c9f8a742e5">&#9670;&nbsp;</a></span>solve_den_rref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den_rref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve matrix equation $Ax = b$ using fraction-free RREF

Solves the matrix equation $Ax = b$ for $x$ and returns the solution
as a numerator/denominator pair.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; b = DM([[ZZ(5)], [ZZ(6)]], ZZ)
&gt;&gt;&gt; xnum, xden = A.solve_den_rref(b)
&gt;&gt;&gt; xden
-2
&gt;&gt;&gt; xnum
DomainMatrix([[8], [-9]], (2, 1), ZZ)
&gt;&gt;&gt; A * xnum == xden * b
True

See Also
========

solve_den
solve_den_charpoly
</pre> 
</div>
</div>
<a id="a7ac603c488948514871b04c9f8a742e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac603c488948514871b04c9f8a742e5">&#9670;&nbsp;</a></span>solve_den_rref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den_rref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve matrix equation $Ax = b$ using fraction-free RREF

Solves the matrix equation $Ax = b$ for $x$ and returns the solution
as a numerator/denominator pair.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)
&gt;&gt;&gt; b = DM([[ZZ(5)], [ZZ(6)]], ZZ)
&gt;&gt;&gt; xnum, xden = A.solve_den_rref(b)
&gt;&gt;&gt; xden
-2
&gt;&gt;&gt; xnum
DomainMatrix([[8], [-9]], (2, 1), ZZ)
&gt;&gt;&gt; A * xnum == xden * b
True

See Also
========

solve_den
solve_den_charpoly
</pre> 
</div>
</div>
<a id="af3cefbcd0e50322c969261d1ddea53a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cefbcd0e50322c969261d1ddea53a2">&#9670;&nbsp;</a></span>sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.sub </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Subtracts two DomainMatrix matrices of the same Domain

Parameters
==========

A, B: DomainMatrix
    matrices to subtract

Returns
=======

DomainMatrix
    DomainMatrix after Subtraction

Raises
======

DMShapeError
    If the dimensions of the two DomainMatrix are not equal

ValueError
    If the domain of the two DomainMatrix are not same

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([
...    [ZZ(4), ZZ(3)],
...    [ZZ(2), ZZ(1)]], (2, 2), ZZ)

&gt;&gt;&gt; A.sub(B)
DomainMatrix([[-3, -1], [1, 3]], (2, 2), ZZ)

See Also
========

add, matmul</pre> 
</div>
</div>
<a id="af3cefbcd0e50322c969261d1ddea53a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cefbcd0e50322c969261d1ddea53a2">&#9670;&nbsp;</a></span>sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.sub </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Subtracts two DomainMatrix matrices of the same Domain

Parameters
==========

A, B: DomainMatrix
    matrices to subtract

Returns
=======

DomainMatrix
    DomainMatrix after Subtraction

Raises
======

DMShapeError
    If the dimensions of the two DomainMatrix are not equal

ValueError
    If the domain of the two DomainMatrix are not same

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([
...    [ZZ(4), ZZ(3)],
...    [ZZ(2), ZZ(1)]], (2, 2), ZZ)

&gt;&gt;&gt; A.sub(B)
DomainMatrix([[-3, -1], [1, 3]], (2, 2), ZZ)

See Also
========

add, matmul</pre> 
</div>
</div>
<a id="a92309ffd7897c60260b58b9dc3d4c621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92309ffd7897c60260b58b9dc3d4c621">&#9670;&nbsp;</a></span>to_ddm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_ddm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`~.DDM` representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix({0: {0: 1}, 1: {1: 2}}, (2, 2), QQ)
&gt;&gt;&gt; ddm = A.to_ddm()
&gt;&gt;&gt; ddm
[[1, 0], [0, 2]]
&gt;&gt;&gt; type(ddm)
&lt;class 'sympy.polys.matrices.ddm.DDM'&gt;

See Also
========

to_sdm
to_dense
sympy.polys.matrices.ddm.DDM.to_sdm
</pre> 
</div>
</div>
<a id="a92309ffd7897c60260b58b9dc3d4c621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92309ffd7897c60260b58b9dc3d4c621">&#9670;&nbsp;</a></span>to_ddm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_ddm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`~.DDM` representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix({0: {0: 1}, 1: {1: 2}}, (2, 2), QQ)
&gt;&gt;&gt; ddm = A.to_ddm()
&gt;&gt;&gt; ddm
[[1, 0], [0, 2]]
&gt;&gt;&gt; type(ddm)
&lt;class 'sympy.polys.matrices.ddm.DDM'&gt;

See Also
========

to_sdm
to_dense
sympy.polys.matrices.ddm.DDM.to_sdm
</pre> 
</div>
</div>
<a id="adddf70e84cf243b2e7bec88c19686f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddf70e84cf243b2e7bec88c19686f24">&#9670;&nbsp;</a></span>to_dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dense </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dense DomainMatrix representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix({0: {0: 1}, 1: {1: 2}}, (2, 2), QQ)
&gt;&gt;&gt; A.rep
{0: {0: 1}, 1: {1: 2}}
&gt;&gt;&gt; B = A.to_dense()
&gt;&gt;&gt; B.rep
[[1, 0], [0, 2]]</pre> 
</div>
</div>
<a id="adddf70e84cf243b2e7bec88c19686f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddf70e84cf243b2e7bec88c19686f24">&#9670;&nbsp;</a></span>to_dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dense </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dense DomainMatrix representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix({0: {0: 1}, 1: {1: 2}}, (2, 2), QQ)
&gt;&gt;&gt; A.rep
{0: {0: 1}, 1: {1: 2}}
&gt;&gt;&gt; B = A.to_dense()
&gt;&gt;&gt; B.rep
[[1, 0], [0, 2]]</pre> 
</div>
</div>
<a id="a36e43ff53f5277989e4ab464289d9b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e43ff53f5277989e4ab464289d9b6c">&#9670;&nbsp;</a></span>to_dfm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`~.DFM` representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)
&gt;&gt;&gt; dfm = A.to_dfm()
&gt;&gt;&gt; dfm
[[1, 0], [0, 2]]
&gt;&gt;&gt; type(dfm)
&lt;class 'sympy.polys.matrices._dfm.DFM'&gt;

See Also
========

to_ddm
to_dense
DFM
</pre> 
</div>
</div>
<a id="a36e43ff53f5277989e4ab464289d9b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e43ff53f5277989e4ab464289d9b6c">&#9670;&nbsp;</a></span>to_dfm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`~.DFM` representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)
&gt;&gt;&gt; dfm = A.to_dfm()
&gt;&gt;&gt; dfm
[[1, 0], [0, 2]]
&gt;&gt;&gt; type(dfm)
&lt;class 'sympy.polys.matrices._dfm.DFM'&gt;

See Also
========

to_ddm
to_dense
DFM
</pre> 
</div>
</div>
<a id="a04746174317b915f668e308cfc4e5494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04746174317b915f668e308cfc4e5494">&#9670;&nbsp;</a></span>to_dfm_or_ddm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm_or_ddm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`~.DFM` or :class:`~.DDM` representation of *self*.

Explanation
===========

The :class:`~.DFM` representation can only be used if the ground types
are ``flint`` and the ground domain is supported by ``python-flint``.
This method will return a :class:`~.DFM` representation if possible,
but will return a :class:`~.DDM` representation otherwise.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)
&gt;&gt;&gt; dfm = A.to_dfm_or_ddm()
&gt;&gt;&gt; dfm
[[1, 0], [0, 2]]
&gt;&gt;&gt; type(dfm)  # Depends on the ground domain and ground types
&lt;class 'sympy.polys.matrices._dfm.DFM'&gt;

See Also
========

to_ddm: Always return a :class:`~.DDM` representation.
to_dfm: Returns a :class:`~.DFM` representation or raise an error.
to_dense: Convert internally to a :class:`~.DFM` or :class:`~.DDM`
DFM: The :class:`~.DFM` dense FLINT matrix representation.
DDM: The Python :class:`~.DDM` dense domain matrix representation.
</pre> 
</div>
</div>
<a id="a04746174317b915f668e308cfc4e5494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04746174317b915f668e308cfc4e5494">&#9670;&nbsp;</a></span>to_dfm_or_ddm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm_or_ddm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`~.DFM` or :class:`~.DDM` representation of *self*.

Explanation
===========

The :class:`~.DFM` representation can only be used if the ground types
are ``flint`` and the ground domain is supported by ``python-flint``.
This method will return a :class:`~.DFM` representation if possible,
but will return a :class:`~.DDM` representation otherwise.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)
&gt;&gt;&gt; dfm = A.to_dfm_or_ddm()
&gt;&gt;&gt; dfm
[[1, 0], [0, 2]]
&gt;&gt;&gt; type(dfm)  # Depends on the ground domain and ground types
&lt;class 'sympy.polys.matrices._dfm.DFM'&gt;

See Also
========

to_ddm: Always return a :class:`~.DDM` representation.
to_dfm: Returns a :class:`~.DFM` representation or raise an error.
to_dense: Convert internally to a :class:`~.DFM` or :class:`~.DDM`
DFM: The :class:`~.DFM` dense FLINT matrix representation.
DDM: The Python :class:`~.DDM` dense domain matrix representation.
</pre> 
</div>
</div>
<a id="a90c9860c962fb0a944951766a36c2496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c9860c962fb0a944951766a36c2496">&#9670;&nbsp;</a></span>to_dod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to dictionary of dictionaries (dod) format.

Explanation
===========

Returns a dictionary of dictionaries representing the matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2), ZZ(0)], [ZZ(3), ZZ(0), ZZ(4)]], ZZ)
&gt;&gt;&gt; A.to_dod()
{0: {0: 1, 1: 2}, 1: {0: 3, 2: 4}}
&gt;&gt;&gt; A.to_sparse() == A.from_dod(A.to_dod(), A.shape, A.domain)
True
&gt;&gt;&gt; A == A.from_dod_like(A.to_dod())
True

See Also
========

from_dod
from_dod_like
to_dok
to_list
to_list_flat
to_flat_nz
sympy.matrices.matrixbase.MatrixBase.todod
</pre> 
</div>
</div>
<a id="a90c9860c962fb0a944951766a36c2496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c9860c962fb0a944951766a36c2496">&#9670;&nbsp;</a></span>to_dod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to dictionary of dictionaries (dod) format.

Explanation
===========

Returns a dictionary of dictionaries representing the matrix.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DM
&gt;&gt;&gt; A = DM([[ZZ(1), ZZ(2), ZZ(0)], [ZZ(3), ZZ(0), ZZ(4)]], ZZ)
&gt;&gt;&gt; A.to_dod()
{0: {0: 1, 1: 2}, 1: {0: 3, 2: 4}}
&gt;&gt;&gt; A.to_sparse() == A.from_dod(A.to_dod(), A.shape, A.domain)
True
&gt;&gt;&gt; A == A.from_dod_like(A.to_dod())
True

See Also
========

from_dod
from_dod_like
to_dok
to_list
to_list_flat
to_flat_nz
sympy.matrices.matrixbase.MatrixBase.todod
</pre> 
</div>
</div>
<a id="aa30e4ff4e9c92094591c9a8a4e4fe663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30e4ff4e9c92094591c9a8a4e4fe663">&#9670;&nbsp;</a></span>to_dok() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dok </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to dictionary of keys (dok) format.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(0)],
...    [ZZ(0), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; A.to_dok()
{(0, 0): 1, (1, 1): 4}

The matrix can be reconstructed by calling :meth:`from_dok` although
the reconstructed matrix will always be in sparse format:

&gt;&gt;&gt; A.to_sparse() == A.from_dok(A.to_dok(), A.shape, A.domain)
True

See Also
========

from_dok
to_list
to_list_flat
to_flat_nz
</pre> 
</div>
</div>
<a id="aa30e4ff4e9c92094591c9a8a4e4fe663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30e4ff4e9c92094591c9a8a4e4fe663">&#9670;&nbsp;</a></span>to_dok() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_dok </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to dictionary of keys (dok) format.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(0)],
...    [ZZ(0), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; A.to_dok()
{(0, 0): 1, (1, 1): 4}

The matrix can be reconstructed by calling :meth:`from_dok` although
the reconstructed matrix will always be in sparse format:

&gt;&gt;&gt; A.to_sparse() == A.from_dok(A.to_dok(), A.shape, A.domain)
True

See Also
========

from_dok
to_list
to_list_flat
to_flat_nz
</pre> 
</div>
</div>
<a id="a52b02a6b37e1c83d0a60cb52d84bacbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b02a6b37e1c83d0a60cb52d84bacbc">&#9670;&nbsp;</a></span>to_field() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_field </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a DomainMatrix with the appropriate field

Returns
=======

DomainMatrix
    DomainMatrix with the appropriate field

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.to_field()
DomainMatrix([[1, 2], [3, 4]], (2, 2), QQ)</pre> 
</div>
</div>
<a id="a52b02a6b37e1c83d0a60cb52d84bacbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b02a6b37e1c83d0a60cb52d84bacbc">&#9670;&nbsp;</a></span>to_field() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_field </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a DomainMatrix with the appropriate field

Returns
=======

DomainMatrix
    DomainMatrix with the appropriate field

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.to_field()
DomainMatrix([[1, 2], [3, 4]], (2, 2), QQ)</pre> 
</div>
</div>
<a id="a4a77c2dae61d39816ac61a55fa012d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a77c2dae61d39816ac61a55fa012d58">&#9670;&nbsp;</a></span>to_flat_nz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_flat_nz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to list of nonzero elements and data.

Explanation
===========

Returns a tuple ``(elements, data)`` where ``elements`` is a list of
elements of the matrix with zeros possibly excluded. The matrix can be
reconstructed by passing these to :meth:`from_flat_nz`. The idea is to
be able to modify a flat list of the elements and then create a new
matrix of the same shape with the modified elements in the same
positions.

The format of ``data`` differs depending on whether the underlying
representation is dense or sparse but either way it represents the
positions of the elements in the list in a way that
:meth:`from_flat_nz` can use to reconstruct the matrix. The
:meth:`from_flat_nz` method should be called on the same
:class:`DomainMatrix` that was used to call :meth:`to_flat_nz`.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; elements, data = A.to_flat_nz()
&gt;&gt;&gt; elements
[1, 2, 3, 4]
&gt;&gt;&gt; A == A.from_flat_nz(elements, data, A.domain)
True

Create a matrix with the elements doubled:

&gt;&gt;&gt; elements_doubled = [2*x for x in elements]
&gt;&gt;&gt; A2 = A.from_flat_nz(elements_doubled, data, A.domain)
&gt;&gt;&gt; A2 == 2*A
True

See Also
========

from_flat_nz
</pre> 
</div>
</div>
<a id="a4a77c2dae61d39816ac61a55fa012d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a77c2dae61d39816ac61a55fa012d58">&#9670;&nbsp;</a></span>to_flat_nz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_flat_nz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to list of nonzero elements and data.

Explanation
===========

Returns a tuple ``(elements, data)`` where ``elements`` is a list of
elements of the matrix with zeros possibly excluded. The matrix can be
reconstructed by passing these to :meth:`from_flat_nz`. The idea is to
be able to modify a flat list of the elements and then create a new
matrix of the same shape with the modified elements in the same
positions.

The format of ``data`` differs depending on whether the underlying
representation is dense or sparse but either way it represents the
positions of the elements in the list in a way that
:meth:`from_flat_nz` can use to reconstruct the matrix. The
:meth:`from_flat_nz` method should be called on the same
:class:`DomainMatrix` that was used to call :meth:`to_flat_nz`.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; elements, data = A.to_flat_nz()
&gt;&gt;&gt; elements
[1, 2, 3, 4]
&gt;&gt;&gt; A == A.from_flat_nz(elements, data, A.domain)
True

Create a matrix with the elements doubled:

&gt;&gt;&gt; elements_doubled = [2*x for x in elements]
&gt;&gt;&gt; A2 = A.from_flat_nz(elements_doubled, data, A.domain)
&gt;&gt;&gt; A2 == 2*A
True

See Also
========

from_flat_nz
</pre> 
</div>
</div>
<a id="aec8c46b669b1e3a52d930cbc443c1b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8c46b669b1e3a52d930cbc443c1b33">&#9670;&nbsp;</a></span>to_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to list of lists.

See Also
========

from_list
to_list_flat
to_flat_nz
to_dok
</pre> 
</div>
</div>
<a id="aec8c46b669b1e3a52d930cbc443c1b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8c46b669b1e3a52d930cbc443c1b33">&#9670;&nbsp;</a></span>to_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to list of lists.

See Also
========

from_list
to_list_flat
to_flat_nz
to_dok
</pre> 
</div>
</div>
<a id="a8687488e94e5f9d42dc40b30ae5824e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8687488e94e5f9d42dc40b30ae5824e6">&#9670;&nbsp;</a></span>to_list_flat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_list_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to flat list.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; A.to_list_flat()
[1, 2, 3, 4]

See Also
========

from_list_flat
to_list
to_flat_nz
to_dok
</pre> 
</div>
</div>
<a id="a8687488e94e5f9d42dc40b30ae5824e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8687488e94e5f9d42dc40b30ae5824e6">&#9670;&nbsp;</a></span>to_list_flat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_list_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert :class:`DomainMatrix` to flat list.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; A.to_list_flat()
[1, 2, 3, 4]

See Also
========

from_list_flat
to_list
to_flat_nz
to_dok
</pre> 
</div>
</div>
<a id="aad84c24617871c77af2e8123e1c86aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad84c24617871c77af2e8123e1c86aad">&#9670;&nbsp;</a></span>to_Matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_Matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert DomainMatrix to Matrix

Returns
=======

Matrix
    MutableDenseMatrix for the DomainMatrix

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.to_Matrix()
Matrix([
    [1, 2],
    [3, 4]])

See Also
========

from_Matrix</pre> 
</div>
</div>
<a id="aad84c24617871c77af2e8123e1c86aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad84c24617871c77af2e8123e1c86aad">&#9670;&nbsp;</a></span>to_Matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_Matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert DomainMatrix to Matrix

Returns
=======

Matrix
    MutableDenseMatrix for the DomainMatrix

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([
...    [ZZ(1), ZZ(2)],
...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)

&gt;&gt;&gt; A.to_Matrix()
Matrix([
    [1, 2],
    [3, 4]])

See Also
========

from_Matrix</pre> 
</div>
</div>
<a id="a35a911148bc0f2a22e60a58ab1ed14ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a911148bc0f2a22e60a58ab1ed14ae">&#9670;&nbsp;</a></span>to_sdm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_sdm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`~.SDM` representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)
&gt;&gt;&gt; sdm = A.to_sdm()
&gt;&gt;&gt; sdm
{0: {0: 1}, 1: {1: 2}}
&gt;&gt;&gt; type(sdm)
&lt;class 'sympy.polys.matrices.sdm.SDM'&gt;

See Also
========

to_ddm
to_sparse
sympy.polys.matrices.sdm.SDM.to_ddm
</pre> 
</div>
</div>
<a id="a35a911148bc0f2a22e60a58ab1ed14ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a911148bc0f2a22e60a58ab1ed14ae">&#9670;&nbsp;</a></span>to_sdm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_sdm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`~.SDM` representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)
&gt;&gt;&gt; sdm = A.to_sdm()
&gt;&gt;&gt; sdm
{0: {0: 1}, 1: {1: 2}}
&gt;&gt;&gt; type(sdm)
&lt;class 'sympy.polys.matrices.sdm.SDM'&gt;

See Also
========

to_ddm
to_sparse
sympy.polys.matrices.sdm.SDM.to_ddm
</pre> 
</div>
</div>
<a id="a6ac93c584a158d80089f203c2cf6eb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac93c584a158d80089f203c2cf6eb24">&#9670;&nbsp;</a></span>to_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_sparse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sparse DomainMatrix representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)
&gt;&gt;&gt; A.rep
[[1, 0], [0, 2]]
&gt;&gt;&gt; B = A.to_sparse()
&gt;&gt;&gt; B.rep
{0: {0: 1}, 1: {1: 2}}
</pre> 
</div>
</div>
<a id="a6ac93c584a158d80089f203c2cf6eb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac93c584a158d80089f203c2cf6eb24">&#9670;&nbsp;</a></span>to_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_sparse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sparse DomainMatrix representation of *self*.

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)
&gt;&gt;&gt; A.rep
[[1, 0], [0, 2]]
&gt;&gt;&gt; B = A.to_sparse()
&gt;&gt;&gt; B.rep
{0: {0: 1}, 1: {1: 2}}
</pre> 
</div>
</div>
<a id="a3ae36de5045b409649c71209ba204ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae36de5045b409649c71209ba204ab6">&#9670;&nbsp;</a></span>to_sympy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_sympy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae36de5045b409649c71209ba204ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae36de5045b409649c71209ba204ab6">&#9670;&nbsp;</a></span>to_sympy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.to_sympy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a163d4661971ef38eb400d98f6d31491a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163d4661971ef38eb400d98f6d31491a">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.transpose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Matrix transpose of ``self``</pre> 
</div>
</div>
<a id="a163d4661971ef38eb400d98f6d31491a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163d4661971ef38eb400d98f6d31491a">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.transpose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Matrix transpose of ``self``</pre> 
</div>
</div>
<a id="a522d813bf89ff4460578f25880c0b004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522d813bf89ff4460578f25880c0b004">&#9670;&nbsp;</a></span>unify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.unify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>others</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Unifies the domains and the format of self and other
matrices.

Parameters
==========

others : DomainMatrix

fmt: string 'dense', 'sparse' or `None` (default)
    The preferred format to convert to if self and other are not
    already in the same format. If `None` or not specified then no
    conversion if performed.

Returns
=======

Tuple[DomainMatrix]
    Matrices with unified domain and format

Examples
========

Unify the domain of DomainMatrix that have different domains:

&gt;&gt;&gt; from sympy import ZZ, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([[QQ(1, 2), QQ(2)]], (1, 2), QQ)
&gt;&gt;&gt; Aq, Bq = A.unify(B)
&gt;&gt;&gt; Aq
DomainMatrix([[1, 2]], (1, 2), QQ)
&gt;&gt;&gt; Bq
DomainMatrix([[1/2, 2]], (1, 2), QQ)

Unify the format (dense or sparse):

&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix({0:{0: ZZ(1)}}, (2, 2), ZZ)
&gt;&gt;&gt; B.rep
{0: {0: 1}}

&gt;&gt;&gt; A2, B2 = A.unify(B, fmt='dense')
&gt;&gt;&gt; B2.rep
[[1, 0], [0, 0]]

See Also
========

convert_to, to_dense, to_sparse</pre> 
</div>
</div>
<a id="a522d813bf89ff4460578f25880c0b004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522d813bf89ff4460578f25880c0b004">&#9670;&nbsp;</a></span>unify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.unify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>others</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Unifies the domains and the format of self and other
matrices.

Parameters
==========

others : DomainMatrix

fmt: string 'dense', 'sparse' or `None` (default)
    The preferred format to convert to if self and other are not
    already in the same format. If `None` or not specified then no
    conversion if performed.

Returns
=======

Tuple[DomainMatrix]
    Matrices with unified domain and format

Examples
========

Unify the domain of DomainMatrix that have different domains:

&gt;&gt;&gt; from sympy import ZZ, QQ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([[QQ(1, 2), QQ(2)]], (1, 2), QQ)
&gt;&gt;&gt; Aq, Bq = A.unify(B)
&gt;&gt;&gt; Aq
DomainMatrix([[1, 2]], (1, 2), QQ)
&gt;&gt;&gt; Bq
DomainMatrix([[1/2, 2]], (1, 2), QQ)

Unify the format (dense or sparse):

&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix({0:{0: ZZ(1)}}, (2, 2), ZZ)
&gt;&gt;&gt; B.rep
{0: {0: 1}}

&gt;&gt;&gt; A2, B2 = A.unify(B, fmt='dense')
&gt;&gt;&gt; B2.rep
[[1, 0], [0, 0]]

See Also
========

convert_to, to_dense, to_sparse</pre> 
</div>
</div>
<a id="afb7b59737913339c3b8a136b9fda68bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7b59737913339c3b8a136b9fda68bf">&#9670;&nbsp;</a></span>unify_eq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.unify_eq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb7b59737913339c3b8a136b9fda68bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7b59737913339c3b8a136b9fda68bf">&#9670;&nbsp;</a></span>unify_eq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.unify_eq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27fb8042e3c1c9c678fd4e8773eb5b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fb8042e3c1c9c678fd4e8773eb5b17">&#9670;&nbsp;</a></span>vstack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.vstack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Vertically stack the given matrices.

Parameters
==========

B: DomainMatrix
    Matrices to stack vertically.

Returns
=======

DomainMatrix
    DomainMatrix by stacking vertically.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix

&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)
&gt;&gt;&gt; A.vstack(B)
DomainMatrix([[1, 2], [3, 4], [5, 6], [7, 8]], (4, 2), ZZ)

&gt;&gt;&gt; C = DomainMatrix([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)
&gt;&gt;&gt; A.vstack(B, C)
DomainMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]], (6, 2), ZZ)

See Also
========

unify
</pre> 
</div>
</div>
<a id="a27fb8042e3c1c9c678fd4e8773eb5b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fb8042e3c1c9c678fd4e8773eb5b17">&#9670;&nbsp;</a></span>vstack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.vstack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Vertically stack the given matrices.

Parameters
==========

B: DomainMatrix
    Matrices to stack vertically.

Returns
=======

DomainMatrix
    DomainMatrix by stacking vertically.

Examples
========

&gt;&gt;&gt; from sympy import ZZ
&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix

&gt;&gt;&gt; A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)
&gt;&gt;&gt; B = DomainMatrix([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)
&gt;&gt;&gt; A.vstack(B)
DomainMatrix([[1, 2], [3, 4], [5, 6], [7, 8]], (4, 2), ZZ)

&gt;&gt;&gt; C = DomainMatrix([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)
&gt;&gt;&gt; A.vstack(B, C)
DomainMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]], (6, 2), ZZ)

See Also
========

unify
</pre> 
</div>
</div>
<a id="a10f3b0156cd71e88c455974a8dc30da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f3b0156cd71e88c455974a8dc30da1">&#9670;&nbsp;</a></span>zeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.zeros </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>'sparse'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a zero DomainMatrix of size shape, belonging to the specified domain

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; DomainMatrix.zeros((2, 3), QQ)
DomainMatrix({}, (2, 3), QQ)</pre> 
</div>
</div>
<a id="a10f3b0156cd71e88c455974a8dc30da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f3b0156cd71e88c455974a8dc30da1">&#9670;&nbsp;</a></span>zeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.matrices.domainmatrix.DomainMatrix.zeros </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>'sparse'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a zero DomainMatrix of size shape, belonging to the specified domain

Examples
========

&gt;&gt;&gt; from sympy.polys.matrices import DomainMatrix
&gt;&gt;&gt; from sympy import QQ
&gt;&gt;&gt; DomainMatrix.zeros((2, 3), QQ)
DomainMatrix({}, (2, 3), QQ)</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a590fc8ed6069ee33048267257aae111f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590fc8ed6069ee33048267257aae111f">&#9670;&nbsp;</a></span>domain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.matrices.domainmatrix.DomainMatrix.domain</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad68d2cd9a422c71acf52dfeeadd936f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68d2cd9a422c71acf52dfeeadd936f4">&#9670;&nbsp;</a></span>rep</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.matrices.domainmatrix.DomainMatrix.rep</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fc710d92b1f836b0dbaba2021ab01ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc710d92b1f836b0dbaba2021ab01ad">&#9670;&nbsp;</a></span>shape</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.matrices.domainmatrix.DomainMatrix.shape</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/sympy/polys/matrices/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2sympy_2polys_2matrices_2domainmatrix_8py.html">domainmatrix.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
