<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.solvers.ode.lie_group Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1ode.html">ode</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html">lie_group</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.solvers.ode.lie_group Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5dd124a755ea18d5338be2bdb516bc2c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#a5dd124a755ea18d5338be2bdb516bc2c">infinitesimals</a> (eq, func=None, order=None, hint='default', match=None)</td></tr>
<tr class="separator:a5dd124a755ea18d5338be2bdb516bc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e26dd313c2c0de36ae1f1e3068369d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#a7e26dd313c2c0de36ae1f1e3068369d1">lie_heuristic_abaco1_simple</a> (match, comp=False)</td></tr>
<tr class="separator:a7e26dd313c2c0de36ae1f1e3068369d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87335c5bd4d2fb34d33a61216f6c534"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#ad87335c5bd4d2fb34d33a61216f6c534">lie_heuristic_abaco1_product</a> (match, comp=False)</td></tr>
<tr class="separator:ad87335c5bd4d2fb34d33a61216f6c534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f65f68a21fb7e1e6e7353e56d3575c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#a0f65f68a21fb7e1e6e7353e56d3575c3">lie_heuristic_bivariate</a> (match, comp=False)</td></tr>
<tr class="separator:a0f65f68a21fb7e1e6e7353e56d3575c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84724bd81775920dbff7a07ea37f66e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#a84724bd81775920dbff7a07ea37f66e1">lie_heuristic_chi</a> (match, comp=False)</td></tr>
<tr class="separator:a84724bd81775920dbff7a07ea37f66e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceb8ff5cffac991159dd119d99fbf9b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#abceb8ff5cffac991159dd119d99fbf9b">lie_heuristic_function_sum</a> (match, comp=False)</td></tr>
<tr class="separator:abceb8ff5cffac991159dd119d99fbf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c597fef61ab70ef1bdd065c6a674ec9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#a1c597fef61ab70ef1bdd065c6a674ec9">lie_heuristic_abaco2_similar</a> (match, comp=False)</td></tr>
<tr class="separator:a1c597fef61ab70ef1bdd065c6a674ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8885306f976a4fbc6c3312a365d4f50a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#a8885306f976a4fbc6c3312a365d4f50a">lie_heuristic_abaco2_unique_unknown</a> (match, comp=False)</td></tr>
<tr class="separator:a8885306f976a4fbc6c3312a365d4f50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a725f64ed9b928dac1cecee901ef524"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#a1a725f64ed9b928dac1cecee901ef524">lie_heuristic_abaco2_unique_general</a> (match, comp=False)</td></tr>
<tr class="separator:a1a725f64ed9b928dac1cecee901ef524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d818fbc6a561272fe1e7505e3bef14"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1ode_1_1lie__group.html#a22d818fbc6a561272fe1e7505e3bef14">lie_heuristic_linear</a> (match, comp=False)</td></tr>
<tr class="separator:a22d818fbc6a561272fe1e7505e3bef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module contains the implementation of the internal helper functions for the lie_group hint for
dsolve. These helper functions apply different heuristics on the given equation
and return the solution. These functions are used by :py:meth:`sympy.solvers.ode.single.LieGroup`

References
=========

- `abaco1_simple`, `function_sum` and `chi`  are referenced from E.S Cheb-Terrab, L.G.S Duarte
and L.A,C.P da Mota, Computer Algebra Solving of First Order ODEs Using
Symmetry Methods, pp. 7 - pp. 8

- `abaco1_product`, `abaco2_similar`, `abaco2_unique_unknown`, `linear`  and `abaco2_unique_general`
are referenced from E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 12

- `bivariate` from Lie Groups and Differential Equations pp. 327 - pp. 329</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a5dd124a755ea18d5338be2bdb516bc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd124a755ea18d5338be2bdb516bc2c">&#9670;&nbsp;</a></span>infinitesimals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.infinitesimals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hint</em> = <code>'default'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The infinitesimal functions of an ordinary differential equation, `\xi(x,y)`
and `\eta(x,y)`, are the infinitesimals of the Lie group of point transformations
for which the differential equation is invariant. So, the ODE `y'=f(x,y)`
would admit a Lie group `x^*=X(x,y;\varepsilon)=x+\varepsilon\xi(x,y)`,
`y^*=Y(x,y;\varepsilon)=y+\varepsilon\eta(x,y)` such that `(y^*)'=f(x^*, y^*)`.
A change of coordinates, to `r(x,y)` and `s(x,y)`, can be performed so this Lie group
becomes the translation group, `r^*=r` and `s^*=s+\varepsilon`.
They are tangents to the coordinate curves of the new system.

Consider the transformation `(x, y) \to (X, Y)` such that the
differential equation remains invariant. `\xi` and `\eta` are the tangents to
the transformed coordinates `X` and `Y`, at `\varepsilon=0`.

.. math:: \left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon
            }\right)|_{\varepsilon=0} = \xi,
          \left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon
            }\right)|_{\varepsilon=0} = \eta,

The infinitesimals can be found by solving the following PDE:

    &gt;&gt;&gt; from sympy import Function, Eq, pprint
    &gt;&gt;&gt; from sympy.abc import x, y
    &gt;&gt;&gt; xi, eta, h = map(Function, ['xi', 'eta', 'h'])
    &gt;&gt;&gt; h = h(x, y)  # dy/dx = h
    &gt;&gt;&gt; eta = eta(x, y)
    &gt;&gt;&gt; xi = xi(x, y)
    &gt;&gt;&gt; genform = Eq(eta.diff(x) + (eta.diff(y) - xi.diff(x))*h
    ... - (xi.diff(y))*h**2 - xi*(h.diff(x)) - eta*(h.diff(y)), 0)
    &gt;&gt;&gt; pprint(genform)
    /d               d           \                     d              2       d                       d             d
    |--(eta(x, y)) - --(xi(x, y))|*h(x, y) - eta(x, y)*--(h(x, y)) - h (x, y)*--(xi(x, y)) - xi(x, y)*--(h(x, y)) + --(eta(x, y)) = 0
    \dy              dx          /                     dy                     dy                      dx            dx

Solving the above mentioned PDE is not trivial, and can be solved only by
making intelligent assumptions for `\xi` and `\eta` (heuristics). Once an
infinitesimal is found, the attempt to find more heuristics stops. This is done to
optimise the speed of solving the differential equation. If a list of all the
infinitesimals is needed, ``hint`` should be flagged as ``all``, which gives
the complete list of infinitesimals. If the infinitesimals for a particular
heuristic needs to be found, it can be passed as a flag to ``hint``.

Examples
========

&gt;&gt;&gt; from sympy import Function
&gt;&gt;&gt; from sympy.solvers.ode.lie_group import infinitesimals
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; eq = f(x).diff(x) - x**2*f(x)
&gt;&gt;&gt; infinitesimals(eq)
[{eta(x, f(x)): exp(x**3/3), xi(x, f(x)): 0}]

References
==========

- Solving differential equations by Symmetry Groups,
  John Starrett, pp. 1 - pp. 14</pre> 
</div>
</div>
<a id="ad87335c5bd4d2fb34d33a61216f6c534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87335c5bd4d2fb34d33a61216f6c534">&#9670;&nbsp;</a></span>lie_heuristic_abaco1_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_abaco1_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The second heuristic uses the following two assumptions on `\xi` and `\eta`

.. math:: \eta = 0, \xi = f(x)*g(y)

.. math:: \eta = f(x)*g(y), \xi = 0

The first assumption of this heuristic holds good if
`\frac{1}{h^{2}}\frac{\partial^2}{\partial x \partial y}\log(h)` is
separable in `x` and `y`, then the separated factors containing `x`
is `f(x)`, and `g(y)` is obtained by

.. math:: e^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}

provided `f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)` is a function
of `y` only.

The second assumption holds good if `\frac{dy}{dx} = h(x, y)` is rewritten as
`\frac{dy}{dx} = \frac{1}{h(y, x)}` and the same properties of the first assumption
satisfies. After obtaining `f(x)` and `g(y)`, the coordinates are again
interchanged, to get `\eta` as `f(x)*g(y)`


References
==========
- E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
  ODE Patterns, pp. 7 - pp. 8</pre> 
</div>
</div>
<a id="a7e26dd313c2c0de36ae1f1e3068369d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e26dd313c2c0de36ae1f1e3068369d1">&#9670;&nbsp;</a></span>lie_heuristic_abaco1_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_abaco1_simple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The first heuristic uses the following four sets of
assumptions on `\xi` and `\eta`

.. math:: \xi = 0, \eta = f(x)

.. math:: \xi = 0, \eta = f(y)

.. math:: \xi = f(x), \eta = 0

.. math:: \xi = f(y), \eta = 0

The success of this heuristic is determined by algebraic factorisation.
For the first assumption `\xi = 0` and `\eta` to be a function of `x`, the PDE

.. math:: \frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y}
            - \frac{\partial \xi}{\partial x})*h
            - \frac{\partial \xi}{\partial y}*h^{2}
            - \xi*\frac{\partial h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0

reduces to `f'(x) - f\frac{\partial h}{\partial y} = 0`
If `\frac{\partial h}{\partial y}` is a function of `x`, then this can usually
be integrated easily. A similar idea is applied to the other 3 assumptions as well.


References
==========

- E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
  Solving of First Order ODEs Using Symmetry Methods, pp. 8</pre> 
</div>
</div>
<a id="a1c597fef61ab70ef1bdd065c6a674ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c597fef61ab70ef1bdd065c6a674ec9">&#9670;&nbsp;</a></span>lie_heuristic_abaco2_similar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_abaco2_similar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This heuristic uses the following two assumptions on `\xi` and `\eta`

.. math:: \eta = g(x), \xi = f(x)

.. math:: \eta = f(y), \xi = g(y)

For the first assumption,

1. First `\frac{\frac{\partial h}{\partial y}}{\frac{\partial^{2} h}{
   \partial yy}}` is calculated. Let us say this value is A

2. If this is constant, then `h` is matched to the form `A(x) + B(x)e^{
   \frac{y}{C}}` then, `\frac{e^{\int \frac{A(x)}{C} \,dx}}{B(x)}` gives `f(x)`
   and `A(x)*f(x)` gives `g(x)`

3. Otherwise `\frac{\frac{\partial A}{\partial X}}{\frac{\partial A}{
   \partial Y}} = \gamma` is calculated. If

   a] `\gamma` is a function of `x` alone

   b] `\frac{\gamma\frac{\partial h}{\partial y} - \gamma'(x) - \frac{
   \partial h}{\partial x}}{h + \gamma} = G` is a function of `x` alone.
   then, `e^{\int G \,dx}` gives `f(x)` and `-\gamma*f(x)` gives `g(x)`

The second assumption holds good if `\frac{dy}{dx} = h(x, y)` is rewritten as
`\frac{dy}{dx} = \frac{1}{h(y, x)}` and the same properties of the first assumption
satisfies. After obtaining `f(x)` and `g(x)`, the coordinates are again
interchanged, to get `\xi` as `f(x^*)` and `\eta` as `g(y^*)`

References
==========
- E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
  ODE Patterns, pp. 10 - pp. 12</pre> 
</div>
</div>
<a id="a1a725f64ed9b928dac1cecee901ef524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a725f64ed9b928dac1cecee901ef524">&#9670;&nbsp;</a></span>lie_heuristic_abaco2_unique_general()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_general </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This heuristic finds if infinitesimals of the form `\eta = f(x)`, `\xi = g(y)`
without making any assumptions on `h`.

The complete sequence of steps is given in the paper mentioned below.

References
==========
- E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
  ODE Patterns, pp. 10 - pp. 12</pre> 
</div>
</div>
<a id="a8885306f976a4fbc6c3312a365d4f50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8885306f976a4fbc6c3312a365d4f50a">&#9670;&nbsp;</a></span>lie_heuristic_abaco2_unique_unknown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_unknown </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This heuristic assumes the presence of unknown functions or known functions
with non-integer powers.

1. A list of all functions and non-integer powers containing x and y
2. Loop over each element `f` in the list, find `\frac{\frac{\partial f}{\partial x}}{
   \frac{\partial f}{\partial x}} = R`

   If it is separable in `x` and `y`, let `X` be the factors containing `x`. Then

   a] Check if `\xi = X` and `\eta = -\frac{X}{R}` satisfy the PDE. If yes, then return
      `\xi` and `\eta`
   b] Check if `\xi = \frac{-R}{X}` and `\eta = -\frac{1}{X}` satisfy the PDE.
       If yes, then return `\xi` and `\eta`

   If not, then check if

   a] :math:`\xi = -R,\eta = 1`

   b] :math:`\xi = 1, \eta = -\frac{1}{R}`

   are solutions.

References
==========
- E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
  ODE Patterns, pp. 10 - pp. 12</pre> 
</div>
</div>
<a id="a0f65f68a21fb7e1e6e7353e56d3575c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f65f68a21fb7e1e6e7353e56d3575c3">&#9670;&nbsp;</a></span>lie_heuristic_bivariate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_bivariate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The third heuristic assumes the infinitesimals `\xi` and `\eta`
to be bi-variate polynomials in `x` and `y`. The assumption made here
for the logic below is that `h` is a rational function in `x` and `y`
though that may not be necessary for the infinitesimals to be
bivariate polynomials. The coefficients of the infinitesimals
are found out by substituting them in the PDE and grouping similar terms
that are polynomials and since they form a linear system, solve and check
for non trivial solutions. The degree of the assumed bivariates
are increased till a certain maximum value.

References
==========
- Lie Groups and Differential Equations
  pp. 327 - pp. 329</pre> 
</div>
</div>
<a id="a84724bd81775920dbff7a07ea37f66e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84724bd81775920dbff7a07ea37f66e1">&#9670;&nbsp;</a></span>lie_heuristic_chi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_chi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The aim of the fourth heuristic is to find the function `\chi(x, y)`
that satisfies the PDE `\frac{d\chi}{dx} + h\frac{d\chi}{dx}
- \frac{\partial h}{\partial y}\chi = 0`.

This assumes `\chi` to be a bivariate polynomial in `x` and `y`. By intuition,
`h` should be a rational function in `x` and `y`. The method used here is
to substitute a general binomial for `\chi` up to a certain maximum degree
is reached. The coefficients of the polynomials, are calculated by by collecting
terms of the same order in `x` and `y`.

After finding `\chi`, the next step is to use `\eta = \xi*h + \chi`, to
determine `\xi` and `\eta`. This can be done by dividing `\chi` by `h`
which would give `-\xi` as the quotient and `\eta` as the remainder.


References
==========
- E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
  Solving of First Order ODEs Using Symmetry Methods, pp. 8</pre> 
</div>
</div>
<a id="abceb8ff5cffac991159dd119d99fbf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abceb8ff5cffac991159dd119d99fbf9b">&#9670;&nbsp;</a></span>lie_heuristic_function_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_function_sum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This heuristic uses the following two assumptions on `\xi` and `\eta`

.. math:: \eta = 0, \xi = f(x) + g(y)

.. math:: \eta = f(x) + g(y), \xi = 0

The first assumption of this heuristic holds good if

.. math:: \frac{\partial}{\partial y}[(h\frac{\partial^{2}}{
            \partial x^{2}}(h^{-1}))^{-1}]

is separable in `x` and `y`,

1. The separated factors containing `y` is `\frac{\partial g}{\partial y}`.
   From this `g(y)` can be determined.
2. The separated factors containing `x` is `f''(x)`.
3. `h\frac{\partial^{2}}{\partial x^{2}}(h^{-1})` equals
   `\frac{f''(x)}{f(x) + g(y)}`. From this `f(x)` can be determined.

The second assumption holds good if `\frac{dy}{dx} = h(x, y)` is rewritten as
`\frac{dy}{dx} = \frac{1}{h(y, x)}` and the same properties of the first
assumption satisfies. After obtaining `f(x)` and `g(y)`, the coordinates
are again interchanged, to get `\eta` as `f(x) + g(y)`.

For both assumptions, the constant factors are separated among `g(y)`
and `f''(x)`, such that `f''(x)` obtained from 3] is the same as that
obtained from 2]. If not possible, then this heuristic fails.


References
==========
- E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
  ODE Patterns, pp. 7 - pp. 8</pre> 
</div>
</div>
<a id="a22d818fbc6a561272fe1e7505e3bef14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d818fbc6a561272fe1e7505e3bef14">&#9670;&nbsp;</a></span>lie_heuristic_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.ode.lie_group.lie_heuristic_linear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This heuristic assumes

1. `\xi = ax + by + c` and
2. `\eta = fx + gy + h`

After substituting the following assumptions in the determining PDE, it
reduces to

.. math:: f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x}
             - (fx + gy + c)\frac{\partial h}{\partial y}

Solving the reduced PDE obtained, using the method of characteristics, becomes
impractical. The method followed is grouping similar terms and solving the system
of linear equations obtained. The difference between the bivariate heuristic is that
`h` need not be a rational function in this case.

References
==========
- E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
  ODE Patterns, pp. 10 - pp. 12</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
