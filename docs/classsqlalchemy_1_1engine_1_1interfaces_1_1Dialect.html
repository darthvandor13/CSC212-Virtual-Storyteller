<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sqlalchemy.engine.interfaces.Dialect Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesqlalchemy.html">sqlalchemy</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1engine.html">engine</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html">interfaces</a></li><li class="navelem"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html">Dialect</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sqlalchemy.engine.interfaces.Dialect Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for sqlalchemy.engine.interfaces.Dialect:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect__inherit__graph.png" border="0" usemap="#asqlalchemy_8engine_8interfaces_8Dialect_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sqlalchemy.engine.interfaces.Dialect:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect__coll__graph.png" border="0" usemap="#asqlalchemy_8engine_8interfaces_8Dialect_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae096b335a170bfb99606402e5bee2c74"><td class="memItemLeft" align="right" valign="top">ModuleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ae096b335a170bfb99606402e5bee2c74">loaded_dbapi</a> (self)</td></tr>
<tr class="separator:ae096b335a170bfb99606402e5bee2c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17c3e80219095db566f3bc77ce9189e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a32a0aae2e7a7fec50cb9feab31432f84">ConnectArgsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ac17c3e80219095db566f3bc77ce9189e">create_connect_args</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a> url)</td></tr>
<tr class="separator:ac17c3e80219095db566f3bc77ce9189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417857da41a52bba237ce53f663a6d62"><td class="memItemLeft" align="right" valign="top">ModuleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a417857da41a52bba237ce53f663a6d62">import_dbapi</a> (cls)</td></tr>
<tr class="separator:a417857da41a52bba237ce53f663a6d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0845b1a46c3a56b96a6667150a6eb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1type__api_1_1TypeEngine.html">TypeEngine</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ae0845b1a46c3a56b96a6667150a6eb73">type_descriptor</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1type__api_1_1TypeEngine.html">TypeEngine</a>[_T] typeobj)</td></tr>
<tr class="separator:ae0845b1a46c3a56b96a6667150a6eb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0740e4bee2d710a375b93b4582227d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a9d0740e4bee2d710a375b93b4582227d">initialize</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection)</td></tr>
<tr class="separator:a9d0740e4bee2d710a375b93b4582227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c25b5d5fafce2fa6a0dc9794bcb5a6"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedColumn.html">ReflectedColumn</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a47c25b5d5fafce2fa6a0dc9794bcb5a6">get_columns</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a47c25b5d5fafce2fa6a0dc9794bcb5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147733e2b078d13b7f7b38ed95ecb9de"><td class="memItemLeft" align="right" valign="top">Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedColumn.html">ReflectedColumn</a>]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a147733e2b078d13b7f7b38ed95ecb9de">get_multi_columns</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, *Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] filter_names=None, **Any kw)</td></tr>
<tr class="separator:a147733e2b078d13b7f7b38ed95ecb9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866ab408ea6fb87e2996c3e9774dbd0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedPrimaryKeyConstraint.html">ReflectedPrimaryKeyConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a866ab408ea6fb87e2996c3e9774dbd0b">get_pk_constraint</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a866ab408ea6fb87e2996c3e9774dbd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92afd1630b6b3401c2565ff74b41c5b"><td class="memItemLeft" align="right" valign="top">Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedPrimaryKeyConstraint.html">ReflectedPrimaryKeyConstraint</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#af92afd1630b6b3401c2565ff74b41c5b">get_multi_pk_constraint</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, *Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] filter_names=None, **Any kw)</td></tr>
<tr class="separator:af92afd1630b6b3401c2565ff74b41c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82da4bda7f0b45259186a121c1a72952"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedForeignKeyConstraint.html">ReflectedForeignKeyConstraint</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a82da4bda7f0b45259186a121c1a72952">get_foreign_keys</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a82da4bda7f0b45259186a121c1a72952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87211d40b33d060e0411e09507d09ad"><td class="memItemLeft" align="right" valign="top">Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedForeignKeyConstraint.html">ReflectedForeignKeyConstraint</a>]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ae87211d40b33d060e0411e09507d09ad">get_multi_foreign_keys</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, *Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] filter_names=None, **Any kw)</td></tr>
<tr class="separator:ae87211d40b33d060e0411e09507d09ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90057a4acc617ec1e45748df1c931717"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a90057a4acc617ec1e45748df1c931717">get_table_names</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a90057a4acc617ec1e45748df1c931717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd7701ed25a406e17fd2d481697aaac"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#accd7701ed25a406e17fd2d481697aaac">get_temp_table_names</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:accd7701ed25a406e17fd2d481697aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732b5b6b5b780005151995a9e67c8a4d"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a732b5b6b5b780005151995a9e67c8a4d">get_view_names</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a732b5b6b5b780005151995a9e67c8a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137549bb4c79e2d5932378a14627b712"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a137549bb4c79e2d5932378a14627b712">get_materialized_view_names</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a137549bb4c79e2d5932378a14627b712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef54ba944cd264683758a15ce40a36f"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a1ef54ba944cd264683758a15ce40a36f">get_sequence_names</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a1ef54ba944cd264683758a15ce40a36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ff6f4e985fcab223c81fff498203bb"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#af0ff6f4e985fcab223c81fff498203bb">get_temp_view_names</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:af0ff6f4e985fcab223c81fff498203bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b6f9a473320a4d2d403ffce26e6356"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a36b6f9a473320a4d2d403ffce26e6356">get_schema_names</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, **Any kw)</td></tr>
<tr class="separator:a36b6f9a473320a4d2d403ffce26e6356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a47fb696e63ae324780fc43a3b6b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#af1a47fb696e63ae324780fc43a3b6b80">get_view_definition</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> view_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:af1a47fb696e63ae324780fc43a3b6b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac481ad3f66b83549eff7498a6358e7"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedIndex.html">ReflectedIndex</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a0ac481ad3f66b83549eff7498a6358e7">get_indexes</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a0ac481ad3f66b83549eff7498a6358e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271fcd2f479b238da20306ba24a69cd2"><td class="memItemLeft" align="right" valign="top">Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedIndex.html">ReflectedIndex</a>]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a271fcd2f479b238da20306ba24a69cd2">get_multi_indexes</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, *Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] filter_names=None, **Any kw)</td></tr>
<tr class="separator:a271fcd2f479b238da20306ba24a69cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d44dd7e9ee28e3df25597bdbae0a7bb"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedUniqueConstraint.html">ReflectedUniqueConstraint</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a5d44dd7e9ee28e3df25597bdbae0a7bb">get_unique_constraints</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a5d44dd7e9ee28e3df25597bdbae0a7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f7181a102143867bedcfcec4471494"><td class="memItemLeft" align="right" valign="top">Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedUniqueConstraint.html">ReflectedUniqueConstraint</a>]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a63f7181a102143867bedcfcec4471494">get_multi_unique_constraints</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, *Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] filter_names=None, **Any kw)</td></tr>
<tr class="separator:a63f7181a102143867bedcfcec4471494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada51fd6dad9c5a6b194f6298fccd613d"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedCheckConstraint.html">ReflectedCheckConstraint</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ada51fd6dad9c5a6b194f6298fccd613d">get_check_constraints</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:ada51fd6dad9c5a6b194f6298fccd613d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d97c4f983902a3e684eed46b48e206"><td class="memItemLeft" align="right" valign="top">Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedCheckConstraint.html">ReflectedCheckConstraint</a>]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a13d97c4f983902a3e684eed46b48e206">get_multi_check_constraints</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, *Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] filter_names=None, **Any kw)</td></tr>
<tr class="separator:a13d97c4f983902a3e684eed46b48e206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58959d271517a981eb6137dfd6ddee8c"><td class="memItemLeft" align="right" valign="top">Dict[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a58959d271517a981eb6137dfd6ddee8c">get_table_options</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a58959d271517a981eb6137dfd6ddee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73de1d8b647cdb87c9f192f2dbb8592a"><td class="memItemLeft" align="right" valign="top">Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, Dict[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>, Any]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a73de1d8b647cdb87c9f192f2dbb8592a">get_multi_table_options</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, *Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] filter_names=None, **Any kw)</td></tr>
<tr class="separator:a73de1d8b647cdb87c9f192f2dbb8592a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcea3ba59111eadab9f9ca92074c9a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedTableComment.html">ReflectedTableComment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a3bcea3ba59111eadab9f9ca92074c9a3">get_table_comment</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a3bcea3ba59111eadab9f9ca92074c9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdc6d3f974f6e2a788212fae1602937"><td class="memItemLeft" align="right" valign="top">Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedTableComment.html">ReflectedTableComment</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a5fdc6d3f974f6e2a788212fae1602937">get_multi_table_comment</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, *Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] filter_names=None, **Any kw)</td></tr>
<tr class="separator:a5fdc6d3f974f6e2a788212fae1602937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a13df0c526efa08863cd5fa4055f419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a6a13df0c526efa08863cd5fa4055f419">normalize_name</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> name)</td></tr>
<tr class="separator:a6a13df0c526efa08863cd5fa4055f419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9a53a777422e933ab1391930c41eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a2d9a53a777422e933ab1391930c41eeb">denormalize_name</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> name)</td></tr>
<tr class="separator:a2d9a53a777422e933ab1391930c41eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27810845a860a76e098cee263164321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa27810845a860a76e098cee263164321">has_table</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:aa27810845a860a76e098cee263164321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a00cb59fbed5f82d7e85e0a83d1521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a56a00cb59fbed5f82d7e85e0a83d1521">has_index</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> table_name, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> index_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:a56a00cb59fbed5f82d7e85e0a83d1521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08ab86d2f50ad668c98a4367755f6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#af08ab86d2f50ad668c98a4367755f6e0">has_sequence</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> sequence_name, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] schema=None, **Any kw)</td></tr>
<tr class="separator:af08ab86d2f50ad668c98a4367755f6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1eb6ed4f8c4a102135462292e31277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a2c1eb6ed4f8c4a102135462292e31277">has_schema</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> schema_name, **Any kw)</td></tr>
<tr class="separator:a2c1eb6ed4f8c4a102135462292e31277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9f2a19530cd1f580be3ec852f3d8eb"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a1c9f2a19530cd1f580be3ec852f3d8eb">do_begin</a> (self, PoolProxiedConnection dbapi_connection)</td></tr>
<tr class="separator:a1c9f2a19530cd1f580be3ec852f3d8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685dc07df5609be6eb46f1da0d741bbb"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a685dc07df5609be6eb46f1da0d741bbb">do_rollback</a> (self, PoolProxiedConnection dbapi_connection)</td></tr>
<tr class="separator:a685dc07df5609be6eb46f1da0d741bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adf39cacec6168f1ef453c8125d2c25"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a3adf39cacec6168f1ef453c8125d2c25">do_commit</a> (self, PoolProxiedConnection dbapi_connection)</td></tr>
<tr class="separator:a3adf39cacec6168f1ef453c8125d2c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a9b4972743d37993260ab17b6aa647"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a42a9b4972743d37993260ab17b6aa647">do_terminate</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> dbapi_connection)</td></tr>
<tr class="separator:a42a9b4972743d37993260ab17b6aa647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02607f330c1c0de4ef05490bd9381ea0"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a02607f330c1c0de4ef05490bd9381ea0">do_close</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> dbapi_connection)</td></tr>
<tr class="separator:a02607f330c1c0de4ef05490bd9381ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fe7bce4ed03176e46f6cd5a3e11da2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a73fe7bce4ed03176e46f6cd5a3e11da2">do_ping</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> dbapi_connection)</td></tr>
<tr class="separator:a73fe7bce4ed03176e46f6cd5a3e11da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a201025bd31893dea8eed649fd54de"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a40a201025bd31893dea8eed649fd54de">do_set_input_sizes</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a> cursor, _GenericSetInputSizesType list_of_tuples, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a> context)</td></tr>
<tr class="separator:a40a201025bd31893dea8eed649fd54de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbacf1cceef62e411d0af55d26a061a5"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#acbacf1cceef62e411d0af55d26a061a5">create_xid</a> (self)</td></tr>
<tr class="separator:acbacf1cceef62e411d0af55d26a061a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd563d3b77797ff1f68573d7823cc2d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a9cd563d3b77797ff1f68573d7823cc2d">do_savepoint</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> name)</td></tr>
<tr class="separator:a9cd563d3b77797ff1f68573d7823cc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3961117ed7c27c0e0e6f004c8db1edf"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ae3961117ed7c27c0e0e6f004c8db1edf">do_rollback_to_savepoint</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> name)</td></tr>
<tr class="separator:ae3961117ed7c27c0e0e6f004c8db1edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49941b83b67edcfe21d59e77c9e07837"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a49941b83b67edcfe21d59e77c9e07837">do_release_savepoint</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> name)</td></tr>
<tr class="separator:a49941b83b67edcfe21d59e77c9e07837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aacd5c543631b77377f4dd62cb039e6"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a4aacd5c543631b77377f4dd62cb039e6">do_begin_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Any xid)</td></tr>
<tr class="separator:a4aacd5c543631b77377f4dd62cb039e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224695bb7534f6bb7daf3e9c70b5e405"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a224695bb7534f6bb7daf3e9c70b5e405">do_prepare_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Any xid)</td></tr>
<tr class="separator:a224695bb7534f6bb7daf3e9c70b5e405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a9e087c76a728483938e6c9d10fdd2"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a89a9e087c76a728483938e6c9d10fdd2">do_rollback_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Any xid, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> is_prepared=True, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> recover=False)</td></tr>
<tr class="separator:a89a9e087c76a728483938e6c9d10fdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388c9b7f4d77525d00f4987c0f267497"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a388c9b7f4d77525d00f4987c0f267497">do_commit_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, Any xid, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> is_prepared=True, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> recover=False)</td></tr>
<tr class="separator:a388c9b7f4d77525d00f4987c0f267497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7244c590ac07252754c53044ef8c5a79"><td class="memItemLeft" align="right" valign="top">List[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7244c590ac07252754c53044ef8c5a79">do_recover_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection)</td></tr>
<tr class="separator:a7244c590ac07252754c53044ef8c5a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0414412d6b650ade7225311b8f60c8"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a4d0414412d6b650ade7225311b8f60c8">do_executemany</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a> cursor, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> statement, _DBAPIMultiExecuteParams parameters, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>] context=None)</td></tr>
<tr class="separator:a4d0414412d6b650ade7225311b8f60c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aabfa54b47239de17cee3ced4fb55a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a91aabfa54b47239de17cee3ced4fb55a">do_execute</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a> cursor, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> statement, Optional[_DBAPISingleExecuteParams] parameters, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>] context=None)</td></tr>
<tr class="separator:a91aabfa54b47239de17cee3ced4fb55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467cb27febf787c0f3953e66d03ee57d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a467cb27febf787c0f3953e66d03ee57d">do_execute_no_params</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a> cursor, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> statement, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>] context=None)</td></tr>
<tr class="separator:a467cb27febf787c0f3953e66d03ee57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf7aa86595aa127b208715a08ac868c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a9cf7aa86595aa127b208715a08ac868c">is_disconnect</a> (self, Exception e, Optional[Union[PoolProxiedConnection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>]] connection, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a>] cursor)</td></tr>
<tr class="separator:a9cf7aa86595aa127b208715a08ac868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccf2564a19895db7b12d3c077a667a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7ccf2564a19895db7b12d3c077a667a9">connect</a> (self, *Any cargs, **Any cparams)</td></tr>
<tr class="separator:a7ccf2564a19895db7b12d3c077a667a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ca76161603e09334f198d80e3f77cf"><td class="memItemLeft" align="right" valign="top">Optional[Callable[[Any], Any]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ae5ca76161603e09334f198d80e3f77cf">on_connect_url</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a> url)</td></tr>
<tr class="separator:ae5ca76161603e09334f198d80e3f77cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7595b90dd2168d710e3c2b6e64749297"><td class="memItemLeft" align="right" valign="top">Optional[Callable[[Any], Any]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7595b90dd2168d710e3c2b6e64749297">on_connect</a> (self)</td></tr>
<tr class="separator:a7595b90dd2168d710e3c2b6e64749297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8374978088a2275065d40f85e6a488b0"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a8374978088a2275065d40f85e6a488b0">reset_isolation_level</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> dbapi_connection)</td></tr>
<tr class="separator:a8374978088a2275065d40f85e6a488b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4cdce324bc510c4f23a6e689c65f41"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a0f4cdce324bc510c4f23a6e689c65f41">set_isolation_level</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> dbapi_connection, <a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a3dc373f12f63294e1841371cad21f03c">IsolationLevel</a> level)</td></tr>
<tr class="separator:a0f4cdce324bc510c4f23a6e689c65f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7157dc0c269d1a7cc103cd7323bfbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a3dc373f12f63294e1841371cad21f03c">IsolationLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a0a7157dc0c269d1a7cc103cd7323bfbf">get_isolation_level</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> dbapi_connection)</td></tr>
<tr class="separator:a0a7157dc0c269d1a7cc103cd7323bfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab682f8db821a5a9543baf811452b044a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a3dc373f12f63294e1841371cad21f03c">IsolationLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ab682f8db821a5a9543baf811452b044a">get_default_isolation_level</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> dbapi_conn)</td></tr>
<tr class="separator:ab682f8db821a5a9543baf811452b044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5cc99709d07eaf997b954243ca56e4"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a3dc373f12f63294e1841371cad21f03c">IsolationLevel</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a5e5cc99709d07eaf997b954243ca56e4">get_isolation_level_values</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> dbapi_conn)</td></tr>
<tr class="separator:a5e5cc99709d07eaf997b954243ca56e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f4716964f16306f053fdb6a8d6a30e"><td class="memItemLeft" align="right" valign="top">Type[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html">Dialect</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a43f4716964f16306f053fdb6a8d6a30e">get_dialect_cls</a> (cls, <a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a> url)</td></tr>
<tr class="separator:a43f4716964f16306f053fdb6a8d6a30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cc7f0bf417dafa4b6821d72ef15d89"><td class="memItemLeft" align="right" valign="top">Type[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html">Dialect</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ae8cc7f0bf417dafa4b6821d72ef15d89">get_async_dialect_cls</a> (cls, <a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a> url)</td></tr>
<tr class="separator:ae8cc7f0bf417dafa4b6821d72ef15d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea88178769bbe7f6bef4bcbf8d7e994"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a9ea88178769bbe7f6bef4bcbf8d7e994">load_provisioning</a> (cls)</td></tr>
<tr class="separator:a9ea88178769bbe7f6bef4bcbf8d7e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae532631d29dc2f4d721f9cea5c36ae86"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ae532631d29dc2f4d721f9cea5c36ae86">engine_created</a> (cls, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a> engine)</td></tr>
<tr class="separator:ae532631d29dc2f4d721f9cea5c36ae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0691b3c6dcaa96d1e94d2aa6d21d82"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#abd0691b3c6dcaa96d1e94d2aa6d21d82">get_driver_connection</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> connection)</td></tr>
<tr class="separator:abd0691b3c6dcaa96d1e94d2aa6d21d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1a08c3089ca031004338c4c2326426"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a8b1a08c3089ca031004338c4c2326426">set_engine_execution_options</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a> engine, <a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#aee89f55fe5c28034b3219bd2fbcb96da">CoreExecuteOptionsParameter</a> opts)</td></tr>
<tr class="separator:a8b1a08c3089ca031004338c4c2326426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ad7d9639b679a7e58898124a6b3dfe"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a81ad7d9639b679a7e58898124a6b3dfe">set_connection_execution_options</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, <a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#aee89f55fe5c28034b3219bd2fbcb96da">CoreExecuteOptionsParameter</a> opts)</td></tr>
<tr class="separator:a81ad7d9639b679a7e58898124a6b3dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b320b44a23df890e48846446ffb904"><td class="memItemLeft" align="right" valign="top">Type[Pool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ac6b320b44a23df890e48846446ffb904">get_dialect_pool_class</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a> url)</td></tr>
<tr class="separator:ac6b320b44a23df890e48846446ffb904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a46828c8c089c6c56d8a8cc5b176bef46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a46828c8c089c6c56d8a8cc5b176bef46">CACHE_HIT</a> = CacheStats.CACHE_HIT</td></tr>
<tr class="separator:a46828c8c089c6c56d8a8cc5b176bef46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d6de8ecccc8067a722a37aec04db57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a73d6de8ecccc8067a722a37aec04db57">CACHE_MISS</a> = CacheStats.CACHE_MISS</td></tr>
<tr class="separator:a73d6de8ecccc8067a722a37aec04db57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0615540bcd58ca82a58c8940e118d45b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a0615540bcd58ca82a58c8940e118d45b">CACHING_DISABLED</a> = CacheStats.CACHING_DISABLED</td></tr>
<tr class="separator:a0615540bcd58ca82a58c8940e118d45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab053c34d026573c5c3cd86c64729705f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#ab053c34d026573c5c3cd86c64729705f">NO_CACHE_KEY</a> = CacheStats.NO_CACHE_KEY</td></tr>
<tr class="separator:ab053c34d026573c5c3cd86c64729705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e91573dd56ffd4d4c1310bd27351f8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a0e91573dd56ffd4d4c1310bd27351f8a">NO_DIALECT_SUPPORT</a> = CacheStats.NO_DIALECT_SUPPORT</td></tr>
<tr class="separator:a0e91573dd56ffd4d4c1310bd27351f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c5179c04f4f3788cd63300f112f11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a></td></tr>
<tr class="separator:a7a0c5179c04f4f3788cd63300f112f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2389902fa49192b13251d38666b5586"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a></td></tr>
<tr class="separator:aa2389902fa49192b13251d38666b5586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0506b5fb75deb163e961a9a215aa4f8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a0506b5fb75deb163e961a9a215aa4f8d">bind_typing</a> = <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1BindTyping.html#ac5d716244dbbc999938eb2f70e50dd02">BindTyping.NONE</a></td></tr>
<tr class="separator:a0506b5fb75deb163e961a9a215aa4f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Define the behavior of a specific database and DB-API combination.

Any aspect of metadata definition, SQL query generation,
execution, result-set handling, or anything else which varies
between databases is defined under the general category of the
Dialect.  The Dialect acts as a factory for other
database-specific object implementations including
ExecutionContext, Compiled, DefaultGenerator, and TypeEngine.

.. note:: Third party dialects should not subclass :class:`.Dialect`
   directly.  Instead, subclass :class:`.default.DefaultDialect` or
   descendant class.</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ccf2564a19895db7b12d3c077a667a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccf2564a19895db7b12d3c077a667a9">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a> sqlalchemy.engine.interfaces.Dialect.connect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Any&#160;</td>
          <td class="paramname"><em>cargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>cparams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Establish a connection using this dialect's DBAPI.

The default implementation of this method is::

    def connect(self, *cargs, **cparams):
        return self.dbapi.connect(*cargs, **cparams)

The ``*cargs, **cparams`` parameters are generated directly
from this dialect's :meth:`.Dialect.create_connect_args` method.

This method may be used for dialects that need to perform programmatic
per-connection steps when a new connection is procured from the
DBAPI.


:param \*cargs: positional parameters returned from the
 :meth:`.Dialect.create_connect_args` method

:param \*\*cparams: keyword parameters returned from the
 :meth:`.Dialect.create_connect_args` method.

:return: a DBAPI connection, typically from the :pep:`249` module
 level ``.connect()`` function.

.. seealso::

    :meth:`.Dialect.create_connect_args`

    :meth:`.Dialect.on_connect`</pre> 
</div>
</div>
<a id="ac17c3e80219095db566f3bc77ce9189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17c3e80219095db566f3bc77ce9189e">&#9670;&nbsp;</a></span>create_connect_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a32a0aae2e7a7fec50cb9feab31432f84">ConnectArgsType</a> sqlalchemy.engine.interfaces.Dialect.create_connect_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a>&#160;</td>
          <td class="paramname"><em>url</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build DB-API compatible connection arguments.

Given a :class:`.URL` object, returns a tuple
consisting of a ``(*args, **kwargs)`` suitable to send directly
to the dbapi's connect function.   The arguments are sent to the
:meth:`.Dialect.connect` method which then runs the DBAPI-level
``connect()`` function.

The method typically makes use of the
:meth:`.URL.translate_connect_args`
method in order to generate a dictionary of options.

The default implementation is::

    def create_connect_args(self, url):
        opts = url.translate_connect_args()
        opts.update(url.query)
        return ([], opts)

:param url: a :class:`.URL` object

:return: a tuple of ``(*args, **kwargs)`` which will be passed to the
 :meth:`.Dialect.connect` method.

.. seealso::

    :meth:`.URL.translate_connect_args`</pre> 
</div>
</div>
<a id="acbacf1cceef62e411d0af55d26a061a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbacf1cceef62e411d0af55d26a061a5">&#9670;&nbsp;</a></span>create_xid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any sqlalchemy.engine.interfaces.Dialect.create_xid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a two-phase transaction ID.

This id will be passed to do_begin_twophase(),
do_rollback_twophase(), do_commit_twophase().  Its format is
unspecified.
</pre> 
<p>Reimplemented in <a class="el" href="classsqlalchemy_1_1engine_1_1default_1_1DefaultDialect.html#aed9ea9d65a7e55c4a8a148f8f8c16eed">sqlalchemy.engine.default.DefaultDialect</a>.</p>

</div>
</div>
<a id="a2d9a53a777422e933ab1391930c41eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9a53a777422e933ab1391930c41eeb">&#9670;&nbsp;</a></span>denormalize_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> sqlalchemy.engine.interfaces.Dialect.denormalize_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">convert the given name to a case insensitive identifier
for the backend if it is an all-lowercase name.

This method is only used if the dialect defines
requires_name_normalize=True.</pre> 
</div>
</div>
<a id="a1c9f2a19530cd1f580be3ec852f3d8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9f2a19530cd1f580be3ec852f3d8eb">&#9670;&nbsp;</a></span>do_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_begin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PoolProxiedConnection&#160;</td>
          <td class="paramname"><em>dbapi_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide an implementation of ``connection.begin()``, given a
DB-API connection.

The DBAPI has no dedicated "begin" method and it is expected
that transactions are implicit.  This hook is provided for those
DBAPIs that might need additional help in this area.

:param dbapi_connection: a DBAPI connection, typically
 proxied within a :class:`.ConnectionFairy`.</pre> 
</div>
</div>
<a id="a4aacd5c543631b77377f4dd62cb039e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aacd5c543631b77377f4dd62cb039e6">&#9670;&nbsp;</a></span>do_begin_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_begin_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>xid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Begin a two phase transaction on the given connection.

:param connection: a :class:`_engine.Connection`.
:param xid: xid</pre> 
</div>
</div>
<a id="a02607f330c1c0de4ef05490bd9381ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02607f330c1c0de4ef05490bd9381ea0">&#9670;&nbsp;</a></span>do_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>&#160;</td>
          <td class="paramname"><em>dbapi_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide an implementation of ``connection.close()``, given a DBAPI
connection.

This hook is called by the :class:`_pool.Pool`
when a connection has been
detached from the pool, or is being returned beyond the normal
capacity of the pool.</pre> 
</div>
</div>
<a id="a3adf39cacec6168f1ef453c8125d2c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adf39cacec6168f1ef453c8125d2c25">&#9670;&nbsp;</a></span>do_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_commit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PoolProxiedConnection&#160;</td>
          <td class="paramname"><em>dbapi_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide an implementation of ``connection.commit()``, given a
DB-API connection.

:param dbapi_connection: a DBAPI connection, typically
 proxied within a :class:`.ConnectionFairy`.</pre> 
</div>
</div>
<a id="a388c9b7f4d77525d00f4987c0f267497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388c9b7f4d77525d00f4987c0f267497">&#9670;&nbsp;</a></span>do_commit_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_commit_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> &#160;</td>
          <td class="paramname"><em>is_prepared</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> &#160;</td>
          <td class="paramname"><em>recover</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Commit a two phase transaction on the given connection.


:param connection: a :class:`_engine.Connection`.
:param xid: xid
:param is_prepared: whether or not
 :meth:`.TwoPhaseTransaction.prepare` was called.
:param recover: if the recover flag was passed.</pre> 
</div>
</div>
<a id="a91aabfa54b47239de17cee3ced4fb55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91aabfa54b47239de17cee3ced4fb55a">&#9670;&nbsp;</a></span>do_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a>&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_DBAPISingleExecuteParams]&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>] &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide an implementation of ``cursor.execute(statement,
parameters)``.</pre> 
</div>
</div>
<a id="a467cb27febf787c0f3953e66d03ee57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467cb27febf787c0f3953e66d03ee57d">&#9670;&nbsp;</a></span>do_execute_no_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_execute_no_params </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a>&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>] &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide an implementation of ``cursor.execute(statement)``.

The parameter collection should not be sent.</pre> 
</div>
</div>
<a id="a4d0414412d6b650ade7225311b8f60c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0414412d6b650ade7225311b8f60c8">&#9670;&nbsp;</a></span>do_executemany()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_executemany </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a>&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_DBAPIMultiExecuteParams&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>] &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide an implementation of ``cursor.executemany(statement,
parameters)``.</pre> 
</div>
</div>
<a id="a73fe7bce4ed03176e46f6cd5a3e11da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fe7bce4ed03176e46f6cd5a3e11da2">&#9670;&nbsp;</a></span>do_ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> sqlalchemy.engine.interfaces.Dialect.do_ping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>&#160;</td>
          <td class="paramname"><em>dbapi_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">ping the DBAPI connection and return True if the connection is
usable.</pre> 
<p>Reimplemented in <a class="el" href="classsqlalchemy_1_1engine_1_1default_1_1DefaultDialect.html#aa10758e2b9555bdb88d6eeb557628cf6">sqlalchemy.engine.default.DefaultDialect</a>.</p>

</div>
</div>
<a id="a224695bb7534f6bb7daf3e9c70b5e405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224695bb7534f6bb7daf3e9c70b5e405">&#9670;&nbsp;</a></span>do_prepare_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_prepare_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>xid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Prepare a two phase transaction on the given connection.

:param connection: a :class:`_engine.Connection`.
:param xid: xid</pre> 
</div>
</div>
<a id="a7244c590ac07252754c53044ef8c5a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7244c590ac07252754c53044ef8c5a79">&#9670;&nbsp;</a></span>do_recover_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[Any] sqlalchemy.engine.interfaces.Dialect.do_recover_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Recover list of uncommitted prepared two phase transaction
identifiers on the given connection.

:param connection: a :class:`_engine.Connection`.</pre> 
</div>
</div>
<a id="a49941b83b67edcfe21d59e77c9e07837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49941b83b67edcfe21d59e77c9e07837">&#9670;&nbsp;</a></span>do_release_savepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_release_savepoint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Release the named savepoint on a connection.

:param connection: a :class:`_engine.Connection`.
:param name: savepoint name.
</pre> 
</div>
</div>
<a id="a685dc07df5609be6eb46f1da0d741bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685dc07df5609be6eb46f1da0d741bbb">&#9670;&nbsp;</a></span>do_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_rollback </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PoolProxiedConnection&#160;</td>
          <td class="paramname"><em>dbapi_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide an implementation of ``connection.rollback()``, given
a DB-API connection.

:param dbapi_connection: a DBAPI connection, typically
 proxied within a :class:`.ConnectionFairy`.</pre> 
</div>
</div>
<a id="ae3961117ed7c27c0e0e6f004c8db1edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3961117ed7c27c0e0e6f004c8db1edf">&#9670;&nbsp;</a></span>do_rollback_to_savepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_rollback_to_savepoint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>
    &#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rollback a connection to the named savepoint.

:param connection: a :class:`_engine.Connection`.
:param name: savepoint name.</pre> 
</div>
</div>
<a id="a89a9e087c76a728483938e6c9d10fdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a9e087c76a728483938e6c9d10fdd2">&#9670;&nbsp;</a></span>do_rollback_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_rollback_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> &#160;</td>
          <td class="paramname"><em>is_prepared</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> &#160;</td>
          <td class="paramname"><em>recover</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rollback a two phase transaction on the given connection.

:param connection: a :class:`_engine.Connection`.
:param xid: xid
:param is_prepared: whether or not
 :meth:`.TwoPhaseTransaction.prepare` was called.
:param recover: if the recover flag was passed.</pre> 
</div>
</div>
<a id="a9cd563d3b77797ff1f68573d7823cc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd563d3b77797ff1f68573d7823cc2d">&#9670;&nbsp;</a></span>do_savepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_savepoint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a savepoint with the given name.

:param connection: a :class:`_engine.Connection`.
:param name: savepoint name.</pre> 
</div>
</div>
<a id="a40a201025bd31893dea8eed649fd54de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a201025bd31893dea8eed649fd54de">&#9670;&nbsp;</a></span>do_set_input_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any sqlalchemy.engine.interfaces.Dialect.do_set_input_sizes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a>&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_GenericSetInputSizesType&#160;</td>
          <td class="paramname"><em>list_of_tuples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">invoke the cursor.setinputsizes() method with appropriate arguments

This hook is called if the :attr:`.Dialect.bind_typing` attribute is
set to the
:attr:`.BindTyping.SETINPUTSIZES` value.
Parameter data is passed in a list of tuples (paramname, dbtype,
sqltype), where ``paramname`` is the key of the parameter in the
statement, ``dbtype`` is the DBAPI datatype and ``sqltype`` is the
SQLAlchemy type. The order of tuples is in the correct parameter order.

.. versionadded:: 1.4

.. versionchanged:: 2.0  - setinputsizes mode is now enabled by
   setting :attr:`.Dialect.bind_typing` to
   :attr:`.BindTyping.SETINPUTSIZES`.  Dialects which accept
   a ``use_setinputsizes`` parameter should set this value
   appropriately.</pre> 
</div>
</div>
<a id="a42a9b4972743d37993260ab17b6aa647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a9b4972743d37993260ab17b6aa647">&#9670;&nbsp;</a></span>do_terminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.do_terminate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>&#160;</td>
          <td class="paramname"><em>dbapi_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide an implementation of ``connection.close()`` that tries as
much as possible to not block, given a DBAPI
connection.

In the vast majority of cases this just calls .close(), however
for some asyncio dialects may call upon different API features.

This hook is called by the :class:`_pool.Pool`
when a connection is being recycled or has been invalidated.

.. versionadded:: 1.4.41</pre> 
</div>
</div>
<a id="ae532631d29dc2f4d721f9cea5c36ae86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae532631d29dc2f4d721f9cea5c36ae86">&#9670;&nbsp;</a></span>engine_created()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.engine_created </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a>&#160;</td>
          <td class="paramname"><em>engine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A convenience hook called before returning the final
:class:`_engine.Engine`.

If the dialect returned a different class from the
:meth:`.get_dialect_cls`
method, then the hook is called on both classes, first on
the dialect class returned by the :meth:`.get_dialect_cls` method and
then on the class on which the method was called.

The hook should be used by dialects and/or wrappers to apply special
events to the engine or its components.   In particular, it allows
a dialect-wrapping class to apply dialect-level events.</pre> 
</div>
</div>
<a id="ae8cc7f0bf417dafa4b6821d72ef15d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cc7f0bf417dafa4b6821d72ef15d89">&#9670;&nbsp;</a></span>get_async_dialect_cls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Type[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html">Dialect</a>] sqlalchemy.engine.interfaces.Dialect.get_async_dialect_cls </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a>&#160;</td>
          <td class="paramname"><em>url</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a URL, return the :class:`.Dialect` that will be used by
an async engine.

By default this is an alias of :meth:`.Dialect.get_dialect_cls` and
just returns the cls. It may be used if a dialect provides
both a sync and async version under the same name, like the
``psycopg`` driver.

.. versionadded:: 2

.. seealso::

    :meth:`.Dialect.get_dialect_cls`</pre> 
</div>
</div>
<a id="ada51fd6dad9c5a6b194f6298fccd613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada51fd6dad9c5a6b194f6298fccd613d">&#9670;&nbsp;</a></span>get_check_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedCheckConstraint.html">ReflectedCheckConstraint</a>] sqlalchemy.engine.interfaces.Dialect.get_check_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about check constraints in ``table_name``.

Given a string ``table_name`` and an optional string ``schema``, return
check constraint information as a list of dicts corresponding
to the :class:`.ReflectedCheckConstraint` dictionary.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_check_constraints`.</pre> 
</div>
</div>
<a id="a47c25b5d5fafce2fa6a0dc9794bcb5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c25b5d5fafce2fa6a0dc9794bcb5a6">&#9670;&nbsp;</a></span>get_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedColumn.html">ReflectedColumn</a>] sqlalchemy.engine.interfaces.Dialect.get_columns </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about columns in ``table_name``.

Given a :class:`_engine.Connection`, a string
``table_name``, and an optional string ``schema``, return column
information as a list of dictionaries
corresponding to the :class:`.ReflectedColumn` dictionary.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_columns`.</pre> 
</div>
</div>
<a id="ab682f8db821a5a9543baf811452b044a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab682f8db821a5a9543baf811452b044a">&#9670;&nbsp;</a></span>get_default_isolation_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a3dc373f12f63294e1841371cad21f03c">IsolationLevel</a> sqlalchemy.engine.interfaces.Dialect.get_default_isolation_level </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>
    &#160;</td>
          <td class="paramname"><em>dbapi_conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a DBAPI connection, return its isolation level, or
a default isolation level if one cannot be retrieved.

This method may only raise NotImplementedError and
**must not raise any other exception**, as it is used implicitly upon
first connect.

The method **must return a value** for a dialect that supports
isolation level settings, as this level is what will be reverted
towards when a per-connection isolation level change is made.

The method defaults to using the :meth:`.Dialect.get_isolation_level`
method unless overridden by a dialect.

.. versionadded:: 1.3.22</pre> 
</div>
</div>
<a id="a43f4716964f16306f053fdb6a8d6a30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f4716964f16306f053fdb6a8d6a30e">&#9670;&nbsp;</a></span>get_dialect_cls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Type[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html">Dialect</a>] sqlalchemy.engine.interfaces.Dialect.get_dialect_cls </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a>&#160;</td>
          <td class="paramname"><em>url</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a URL, return the :class:`.Dialect` that will be used.

This is a hook that allows an external plugin to provide functionality
around an existing dialect, by allowing the plugin to be loaded
from the url based on an entrypoint, and then the plugin returns
the actual dialect to be used.

By default this just returns the cls.</pre> 
</div>
</div>
<a id="ac6b320b44a23df890e48846446ffb904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b320b44a23df890e48846446ffb904">&#9670;&nbsp;</a></span>get_dialect_pool_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Type[Pool] sqlalchemy.engine.interfaces.Dialect.get_dialect_pool_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a>&#160;</td>
          <td class="paramname"><em>url</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">return a Pool class to use for a given URL</pre> 
<p>Reimplemented in <a class="el" href="classsqlalchemy_1_1engine_1_1default_1_1DefaultDialect.html#afd7c5d3f1925a95c6fcd865210a35320">sqlalchemy.engine.default.DefaultDialect</a>.</p>

</div>
</div>
<a id="abd0691b3c6dcaa96d1e94d2aa6d21d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0691b3c6dcaa96d1e94d2aa6d21d82">&#9670;&nbsp;</a></span>get_driver_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any sqlalchemy.engine.interfaces.Dialect.get_driver_connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the connection object as returned by the external driver
package.

For normal dialects that use a DBAPI compliant driver this call
will just return the ``connection`` passed as argument.
For dialects that instead adapt a non DBAPI compliant driver, like
when adapting an asyncio driver, this call will return the
connection-like object as returned by the driver.

.. versionadded:: 1.4.24</pre> 
</div>
</div>
<a id="a82da4bda7f0b45259186a121c1a72952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82da4bda7f0b45259186a121c1a72952">&#9670;&nbsp;</a></span>get_foreign_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedForeignKeyConstraint.html">ReflectedForeignKeyConstraint</a>] sqlalchemy.engine.interfaces.Dialect.get_foreign_keys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about foreign_keys in ``table_name``.

Given a :class:`_engine.Connection`, a string
``table_name``, and an optional string ``schema``, return foreign
key information as a list of dicts corresponding to the
:class:`.ReflectedForeignKeyConstraint` dictionary.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_foreign_keys`.
</pre> 
</div>
</div>
<a id="a0ac481ad3f66b83549eff7498a6358e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac481ad3f66b83549eff7498a6358e7">&#9670;&nbsp;</a></span>get_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedIndex.html">ReflectedIndex</a>] sqlalchemy.engine.interfaces.Dialect.get_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about indexes in ``table_name``.

Given a :class:`_engine.Connection`, a string
``table_name`` and an optional string ``schema``, return index
information as a list of dictionaries corresponding to the
:class:`.ReflectedIndex` dictionary.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_indexes`.
</pre> 
</div>
</div>
<a id="a0a7157dc0c269d1a7cc103cd7323bfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7157dc0c269d1a7cc103cd7323bfbf">&#9670;&nbsp;</a></span>get_isolation_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a3dc373f12f63294e1841371cad21f03c">IsolationLevel</a> sqlalchemy.engine.interfaces.Dialect.get_isolation_level </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>
    &#160;</td>
          <td class="paramname"><em>dbapi_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a DBAPI connection, return its isolation level.

When working with a :class:`_engine.Connection` object,
the corresponding
DBAPI connection may be procured using the
:attr:`_engine.Connection.connection` accessor.

Note that this is a dialect-level method which is used as part
of the implementation of the :class:`_engine.Connection` and
:class:`_engine.Engine` isolation level facilities;
these APIs should be preferred for most typical use cases.


.. seealso::

    :meth:`_engine.Connection.get_isolation_level`
    - view current level

    :attr:`_engine.Connection.default_isolation_level`
    - view default level

    :paramref:`.Connection.execution_options.isolation_level` -
    set per :class:`_engine.Connection` isolation level

    :paramref:`_sa.create_engine.isolation_level` -
    set per :class:`_engine.Engine` isolation level</pre> 
</div>
</div>
<a id="a5e5cc99709d07eaf997b954243ca56e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5cc99709d07eaf997b954243ca56e4">&#9670;&nbsp;</a></span>get_isolation_level_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a3dc373f12f63294e1841371cad21f03c">IsolationLevel</a>] sqlalchemy.engine.interfaces.Dialect.get_isolation_level_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>
    &#160;</td>
          <td class="paramname"><em>dbapi_conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">return a sequence of string isolation level names that are accepted
by this dialect.

The available names should use the following conventions:

* use UPPERCASE names.   isolation level methods will accept lowercase
  names but these are normalized into UPPERCASE before being passed
  along to the dialect.
* separate words should be separated by spaces, not underscores, e.g.
  ``REPEATABLE READ``.  isolation level names will have underscores
  converted to spaces before being passed along to the dialect.
* The names for the four standard isolation names to the extent that
  they are supported by the backend should be ``READ UNCOMMITTED``,
  ``READ COMMITTED``, ``REPEATABLE READ``, ``SERIALIZABLE``
* if the dialect supports an autocommit option it should be provided
  using the isolation level name ``AUTOCOMMIT``.
* Other isolation modes may also be present, provided that they
  are named in UPPERCASE and use spaces not underscores.

This function is used so that the default dialect can check that
a given isolation level parameter is valid, else raises an
:class:`_exc.ArgumentError`.

A DBAPI connection is passed to the method, in the unlikely event that
the dialect needs to interrogate the connection itself to determine
this list, however it is expected that most backends will return
a hardcoded list of values.  If the dialect supports "AUTOCOMMIT",
that value should also be present in the sequence returned.

The method raises ``NotImplementedError`` by default.  If a dialect
does not implement this method, then the default dialect will not
perform any checking on a given isolation level value before passing
it onto the :meth:`.Dialect.set_isolation_level` method.  This is
to allow backwards-compatibility with third party dialects that may
not yet be implementing this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="a137549bb4c79e2d5932378a14627b712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137549bb4c79e2d5932378a14627b712">&#9670;&nbsp;</a></span>get_materialized_view_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] sqlalchemy.engine.interfaces.Dialect.get_materialized_view_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of all materialized view names available in the
database.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_materialized_view_names`.

:param schema: schema name to query, if not the default schema.

 .. versionadded:: 2.0</pre> 
</div>
</div>
<a id="a13d97c4f983902a3e684eed46b48e206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d97c4f983902a3e684eed46b48e206">&#9670;&nbsp;</a></span>get_multi_check_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedCheckConstraint.html">ReflectedCheckConstraint</a>]]] sqlalchemy.engine.interfaces.Dialect.get_multi_check_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] &#160;</td>
          <td class="paramname"><em>filter_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about check constraints in all tables
in the given ``schema``.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_multi_check_constraints`.

.. note:: The :class:`_engine.DefaultDialect` provides a default
  implementation that will call the single table method for
  each object returned by :meth:`Dialect.get_table_names`,
  :meth:`Dialect.get_view_names` or
  :meth:`Dialect.get_materialized_view_names` depending on the
  provided ``kind``. Dialects that want to support a faster
  implementation should implement this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="a147733e2b078d13b7f7b38ed95ecb9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147733e2b078d13b7f7b38ed95ecb9de">&#9670;&nbsp;</a></span>get_multi_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedColumn.html">ReflectedColumn</a>]]] sqlalchemy.engine.interfaces.Dialect.get_multi_columns </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] &#160;</td>
          <td class="paramname"><em>filter_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about columns in all tables in the
given ``schema``.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_multi_columns`.

.. note:: The :class:`_engine.DefaultDialect` provides a default
  implementation that will call the single table method for
  each object returned by :meth:`Dialect.get_table_names`,
  :meth:`Dialect.get_view_names` or
  :meth:`Dialect.get_materialized_view_names` depending on the
  provided ``kind``. Dialects that want to support a faster
  implementation should implement this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="ae87211d40b33d060e0411e09507d09ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87211d40b33d060e0411e09507d09ad">&#9670;&nbsp;</a></span>get_multi_foreign_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedForeignKeyConstraint.html">ReflectedForeignKeyConstraint</a>]]] sqlalchemy.engine.interfaces.Dialect.get_multi_foreign_keys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] &#160;</td>
          <td class="paramname"><em>filter_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about foreign_keys in all tables
in the given ``schema``.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_multi_foreign_keys`.

.. note:: The :class:`_engine.DefaultDialect` provides a default
  implementation that will call the single table method for
  each object returned by :meth:`Dialect.get_table_names`,
  :meth:`Dialect.get_view_names` or
  :meth:`Dialect.get_materialized_view_names` depending on the
  provided ``kind``. Dialects that want to support a faster
  implementation should implement this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="a271fcd2f479b238da20306ba24a69cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271fcd2f479b238da20306ba24a69cd2">&#9670;&nbsp;</a></span>get_multi_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedIndex.html">ReflectedIndex</a>]]] sqlalchemy.engine.interfaces.Dialect.get_multi_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] &#160;</td>
          <td class="paramname"><em>filter_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about indexes in in all tables
in the given ``schema``.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_multi_indexes`.

.. note:: The :class:`_engine.DefaultDialect` provides a default
  implementation that will call the single table method for
  each object returned by :meth:`Dialect.get_table_names`,
  :meth:`Dialect.get_view_names` or
  :meth:`Dialect.get_materialized_view_names` depending on the
  provided ``kind``. Dialects that want to support a faster
  implementation should implement this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="af92afd1630b6b3401c2565ff74b41c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92afd1630b6b3401c2565ff74b41c5b">&#9670;&nbsp;</a></span>get_multi_pk_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedPrimaryKeyConstraint.html">ReflectedPrimaryKeyConstraint</a>]] sqlalchemy.engine.interfaces.Dialect.get_multi_pk_constraint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] &#160;</td>
          <td class="paramname"><em>filter_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about primary key constraints in
all tables in the given ``schema``.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_multi_pk_constraint`.

.. note:: The :class:`_engine.DefaultDialect` provides a default
  implementation that will call the single table method for
  each object returned by :meth:`Dialect.get_table_names`,
  :meth:`Dialect.get_view_names` or
  :meth:`Dialect.get_materialized_view_names` depending on the
  provided ``kind``. Dialects that want to support a faster
  implementation should implement this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="a5fdc6d3f974f6e2a788212fae1602937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdc6d3f974f6e2a788212fae1602937">&#9670;&nbsp;</a></span>get_multi_table_comment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedTableComment.html">ReflectedTableComment</a>]] sqlalchemy.engine.interfaces.Dialect.get_multi_table_comment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] &#160;</td>
          <td class="paramname"><em>filter_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about the table comment in all tables
in the given ``schema``.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_multi_table_comment`.

.. note:: The :class:`_engine.DefaultDialect` provides a default
  implementation that will call the single table method for
  each object returned by :meth:`Dialect.get_table_names`,
  :meth:`Dialect.get_view_names` or
  :meth:`Dialect.get_materialized_view_names` depending on the
  provided ``kind``. Dialects that want to support a faster
  implementation should implement this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="a73de1d8b647cdb87c9f192f2dbb8592a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73de1d8b647cdb87c9f192f2dbb8592a">&#9670;&nbsp;</a></span>get_multi_table_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, Dict[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>, Any]]] sqlalchemy.engine.interfaces.Dialect.get_multi_table_options </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] &#160;</td>
          <td class="paramname"><em>filter_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dictionary of options specified when the tables in the
given schema were created.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_multi_table_options`.

.. note:: The :class:`_engine.DefaultDialect` provides a default
  implementation that will call the single table method for
  each object returned by :meth:`Dialect.get_table_names`,
  :meth:`Dialect.get_view_names` or
  :meth:`Dialect.get_materialized_view_names` depending on the
  provided ``kind``. Dialects that want to support a faster
  implementation should implement this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="a63f7181a102143867bedcfcec4471494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f7181a102143867bedcfcec4471494">&#9670;&nbsp;</a></span>get_multi_unique_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[Tuple[<a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a6ff5ad94e6ef438d6ac38132a81351a3">TableKey</a>, List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedUniqueConstraint.html">ReflectedUniqueConstraint</a>]]] sqlalchemy.engine.interfaces.Dialect.get_multi_unique_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Collection[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>]] &#160;</td>
          <td class="paramname"><em>filter_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about unique constraints in all tables
in the given ``schema``.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_multi_unique_constraints`.

.. note:: The :class:`_engine.DefaultDialect` provides a default
  implementation that will call the single table method for
  each object returned by :meth:`Dialect.get_table_names`,
  :meth:`Dialect.get_view_names` or
  :meth:`Dialect.get_materialized_view_names` depending on the
  provided ``kind``. Dialects that want to support a faster
  implementation should implement this method.

.. versionadded:: 2.0</pre> 
</div>
</div>
<a id="a866ab408ea6fb87e2996c3e9774dbd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866ab408ea6fb87e2996c3e9774dbd0b">&#9670;&nbsp;</a></span>get_pk_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedPrimaryKeyConstraint.html">ReflectedPrimaryKeyConstraint</a> sqlalchemy.engine.interfaces.Dialect.get_pk_constraint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about the primary key constraint on
table_name`.

Given a :class:`_engine.Connection`, a string
``table_name``, and an optional string ``schema``, return primary
key information as a dictionary corresponding to the
:class:`.ReflectedPrimaryKeyConstraint` dictionary.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_pk_constraint`.</pre> 
</div>
</div>
<a id="a36b6f9a473320a4d2d403ffce26e6356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b6f9a473320a4d2d403ffce26e6356">&#9670;&nbsp;</a></span>get_schema_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] sqlalchemy.engine.interfaces.Dialect.get_schema_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of all schema names available in the database.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_schema_names`.
</pre> 
</div>
</div>
<a id="a1ef54ba944cd264683758a15ce40a36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef54ba944cd264683758a15ce40a36f">&#9670;&nbsp;</a></span>get_sequence_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] sqlalchemy.engine.interfaces.Dialect.get_sequence_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of all sequence names available in the database.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_sequence_names`.

:param schema: schema name to query, if not the default schema.

.. versionadded:: 1.4
</pre> 
</div>
</div>
<a id="a3bcea3ba59111eadab9f9ca92074c9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcea3ba59111eadab9f9ca92074c9a3">&#9670;&nbsp;</a></span>get_table_comment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedTableComment.html">ReflectedTableComment</a> sqlalchemy.engine.interfaces.Dialect.get_table_comment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the "comment" for the table identified by ``table_name``.

Given a string ``table_name`` and an optional string ``schema``, return
table comment information as a dictionary corresponding to the
:class:`.ReflectedTableComment` dictionary.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_table_comment`.

:raise: ``NotImplementedError`` for dialects that don't support
 comments.

.. versionadded:: 1.2</pre> 
</div>
</div>
<a id="a90057a4acc617ec1e45748df1c931717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90057a4acc617ec1e45748df1c931717">&#9670;&nbsp;</a></span>get_table_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] sqlalchemy.engine.interfaces.Dialect.get_table_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of table names for ``schema``.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_table_names`.</pre> 
</div>
</div>
<a id="a58959d271517a981eb6137dfd6ddee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58959d271517a981eb6137dfd6ddee8c">&#9670;&nbsp;</a></span>get_table_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>, Any] sqlalchemy.engine.interfaces.Dialect.get_table_options </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dictionary of options specified when ``table_name``
was created.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_table_options`.
</pre> 
</div>
</div>
<a id="accd7701ed25a406e17fd2d481697aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd7701ed25a406e17fd2d481697aaac">&#9670;&nbsp;</a></span>get_temp_table_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] sqlalchemy.engine.interfaces.Dialect.get_temp_table_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of temporary table names on the given connection,
if supported by the underlying backend.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_temp_table_names`.</pre> 
</div>
</div>
<a id="af0ff6f4e985fcab223c81fff498203bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ff6f4e985fcab223c81fff498203bb">&#9670;&nbsp;</a></span>get_temp_view_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] sqlalchemy.engine.interfaces.Dialect.get_temp_view_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of temporary view names on the given connection,
if supported by the underlying backend.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_temp_view_names`.</pre> 
</div>
</div>
<a id="a5d44dd7e9ee28e3df25597bdbae0a7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d44dd7e9ee28e3df25597bdbae0a7bb">&#9670;&nbsp;</a></span>get_unique_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ReflectedUniqueConstraint.html">ReflectedUniqueConstraint</a>] sqlalchemy.engine.interfaces.Dialect.get_unique_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information about unique constraints in ``table_name``.

Given a string ``table_name`` and an optional string ``schema``, return
unique constraint information as a list of dicts corresponding
to the :class:`.ReflectedUniqueConstraint` dictionary.

This is an internal dialect method. Applications should use
:meth:`.Inspector.get_unique_constraints`.
</pre> 
</div>
</div>
<a id="af1a47fb696e63ae324780fc43a3b6b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a47fb696e63ae324780fc43a3b6b80">&#9670;&nbsp;</a></span>get_view_definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> sqlalchemy.engine.interfaces.Dialect.get_view_definition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>view_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return plain or materialized view definition.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_view_definition`.

Given a :class:`_engine.Connection`, a string
``view_name``, and an optional string ``schema``, return the view
definition.
</pre> 
</div>
</div>
<a id="a732b5b6b5b780005151995a9e67c8a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732b5b6b5b780005151995a9e67c8a4d">&#9670;&nbsp;</a></span>get_view_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] sqlalchemy.engine.interfaces.Dialect.get_view_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of all non-materialized view names available in the
database.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.get_view_names`.

:param schema: schema name to query, if not the default schema.</pre> 
</div>
</div>
<a id="a56a00cb59fbed5f82d7e85e0a83d1521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a00cb59fbed5f82d7e85e0a83d1521">&#9670;&nbsp;</a></span>has_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> sqlalchemy.engine.interfaces.Dialect.has_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>index_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check the existence of a particular index name in the database.

Given a :class:`_engine.Connection` object, a string
``table_name`` and string index name, return ``True`` if an index of
the given name on the given table exists, ``False`` otherwise.

The :class:`.DefaultDialect` implements this in terms of the
:meth:`.Dialect.has_table` and :meth:`.Dialect.get_indexes` methods,
however dialects can implement a more performant version.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.has_index`.

.. versionadded:: 1.4</pre> 
</div>
</div>
<a id="a2c1eb6ed4f8c4a102135462292e31277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1eb6ed4f8c4a102135462292e31277">&#9670;&nbsp;</a></span>has_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> sqlalchemy.engine.interfaces.Dialect.has_schema </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>schema_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check the existence of a particular schema name in the database.

Given a :class:`_engine.Connection` object, a string
``schema_name``, return ``True`` if a schema of the
given exists, ``False`` otherwise.

The :class:`.DefaultDialect` implements this by checking
the presence of ``schema_name`` among the schemas returned by
:meth:`.Dialect.get_schema_names`,
however dialects can implement a more performant version.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.has_schema`.

.. versionadded:: 2.0</pre> 
<p>Reimplemented in <a class="el" href="classsqlalchemy_1_1engine_1_1default_1_1DefaultDialect.html#a965cd7c1433f6c9a98a37a97aadb13bf">sqlalchemy.engine.default.DefaultDialect</a>.</p>

</div>
</div>
<a id="af08ab86d2f50ad668c98a4367755f6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08ab86d2f50ad668c98a4367755f6e0">&#9670;&nbsp;</a></span>has_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> sqlalchemy.engine.interfaces.Dialect.has_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>sequence_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check the existence of a particular sequence in the database.

Given a :class:`_engine.Connection` object and a string
`sequence_name`, return ``True`` if the given sequence exists in
the database, ``False`` otherwise.

This is an internal dialect method. Applications should use
:meth:`_engine.Inspector.has_sequence`.
</pre> 
</div>
</div>
<a id="aa27810845a860a76e098cee263164321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27810845a860a76e098cee263164321">&#9670;&nbsp;</a></span>has_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> sqlalchemy.engine.interfaces.Dialect.has_table </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>] &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For internal dialect use, check the existence of a particular table
or view in the database.

Given a :class:`_engine.Connection` object, a string table_name and
optional schema name, return True if the given table exists in the
database, False otherwise.

This method serves as the underlying implementation of the
public facing :meth:`.Inspector.has_table` method, and is also used
internally to implement the "checkfirst" behavior for methods like
:meth:`_schema.Table.create` and :meth:`_schema.MetaData.create_all`.

.. note:: This method is used internally by SQLAlchemy, and is
   published so that third-party dialects may provide an
   implementation. It is **not** the public API for checking for table
   presence. Please use the :meth:`.Inspector.has_table` method.

.. versionchanged:: 2.0:: :meth:`_engine.Dialect.has_table` now
   formally supports checking for additional table-like objects:

   * any type of views (plain or materialized)
   * temporary tables of any kind

   Previously, these two checks were not formally specified and
   different dialects would vary in their behavior.   The dialect
   testing suite now includes tests for all of these object types,
   and dialects to the degree that the backing database supports views
   or temporary tables should seek to support locating these objects
   for full compliance.</pre> 
</div>
</div>
<a id="a417857da41a52bba237ce53f663a6d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417857da41a52bba237ce53f663a6d62">&#9670;&nbsp;</a></span>import_dbapi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ModuleType sqlalchemy.engine.interfaces.Dialect.import_dbapi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Import the DBAPI module that is used by this dialect.

The Python module object returned here will be assigned as an
instance variable to a constructed dialect under the name
``.dbapi``.

.. versionchanged:: 2.0  The :meth:`.Dialect.import_dbapi` class
   method is renamed from the previous method ``.Dialect.dbapi()``,
   which would be replaced at dialect instantiation time by the
   DBAPI module itself, thus using the same name in two different ways.
   If a ``.Dialect.dbapi()`` classmethod is present on a third-party
   dialect, it will be used and a deprecation warning will be emitted.</pre> 
</div>
</div>
<a id="a9d0740e4bee2d710a375b93b4582227d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0740e4bee2d710a375b93b4582227d">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.initialize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Called during strategized creation of the dialect with a
connection.

Allows dialects to configure options based on server version info or
other properties.

The connection passed here is a SQLAlchemy Connection object,
with full capabilities.

The initialize() method of the base dialect should be called via
super().

.. note:: as of SQLAlchemy 1.4, this method is called **before**
   any :meth:`_engine.Dialect.on_connect` hooks are called.</pre> 
</div>
</div>
<a id="a9cf7aa86595aa127b208715a08ac868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf7aa86595aa127b208715a08ac868c">&#9670;&nbsp;</a></span>is_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#aa2389902fa49192b13251d38666b5586">bool</a> sqlalchemy.engine.interfaces.Dialect.is_disconnect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Exception&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Union[PoolProxiedConnection, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>]]&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a>]&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if the given DB-API error indicates an invalid
connection</pre> 
</div>
</div>
<a id="a9ea88178769bbe7f6bef4bcbf8d7e994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea88178769bbe7f6bef4bcbf8d7e994">&#9670;&nbsp;</a></span>load_provisioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.load_provisioning </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">set up the provision.py module for this dialect.

For dialects that include a provision.py module that sets up
provisioning followers, this method should initiate that process.

A typical implementation would be::

    @classmethod
    def load_provisioning(cls):
        __import__("mydialect.provision")

The default method assumes a module named ``provision.py`` inside
the owning package of the current dialect, based on the ``__module__``
attribute::

    @classmethod
    def load_provisioning(cls):
        package = ".".join(cls.__module__.split(".")[0:-1])
        try:
            __import__(package + ".provision")
        except ImportError:
            pass

.. versionadded:: 1.3.14</pre> 
<p>Reimplemented in <a class="el" href="classsqlalchemy_1_1engine_1_1default_1_1DefaultDialect.html#ae3cc59b13d9ac06f05e687f2529ffdc6">sqlalchemy.engine.default.DefaultDialect</a>.</p>

</div>
</div>
<a id="ae096b335a170bfb99606402e5bee2c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae096b335a170bfb99606402e5bee2c74">&#9670;&nbsp;</a></span>loaded_dbapi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ModuleType sqlalchemy.engine.interfaces.Dialect.loaded_dbapi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">same as .dbapi, but is never None; will raise an error if no
DBAPI was set up.

.. versionadded:: 2.0</pre> 
<p>Reimplemented in <a class="el" href="classsqlalchemy_1_1engine_1_1default_1_1DefaultDialect.html#ac58acac43ba64b53cca091cf702510ee">sqlalchemy.engine.default.DefaultDialect</a>.</p>

</div>
</div>
<a id="a6a13df0c526efa08863cd5fa4055f419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a13df0c526efa08863cd5fa4055f419">&#9670;&nbsp;</a></span>normalize_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a> sqlalchemy.engine.interfaces.Dialect.normalize_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1Dialect.html#a7a0c5179c04f4f3788cd63300f112f11">str</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">convert the given name to lowercase if it is detected as
case insensitive.

This method is only used if the dialect defines
requires_name_normalize=True.</pre> 
</div>
</div>
<a id="a7595b90dd2168d710e3c2b6e64749297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7595b90dd2168d710e3c2b6e64749297">&#9670;&nbsp;</a></span>on_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[Callable[[Any], Any]] sqlalchemy.engine.interfaces.Dialect.on_connect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">return a callable which sets up a newly created DBAPI connection.

The callable should accept a single argument "conn" which is the
DBAPI connection itself.  The inner callable has no
return value.

E.g.::

    class MyDialect(default.DefaultDialect):
        # ...

        def on_connect(self):
            def do_on_connect(connection):
                connection.execute("SET SPECIAL FLAGS etc")

            return do_on_connect

This is used to set dialect-wide per-connection options such as
isolation modes, Unicode modes, etc.

The "do_on_connect" callable is invoked by using the
:meth:`_events.PoolEvents.connect` event
hook, then unwrapping the DBAPI connection and passing it into the
callable.

.. versionchanged:: 1.4 the on_connect hook is no longer called twice
   for the first connection of a dialect.  The on_connect hook is still
   called before the :meth:`_engine.Dialect.initialize` method however.

.. versionchanged:: 1.4.3 the on_connect hook is invoked from a new
   method on_connect_url that passes the URL that was used to create
   the connect args.   Dialects can implement on_connect_url instead
   of on_connect if they need the URL object that was used for the
   connection in order to get additional context.

If None is returned, no event listener is generated.

:return: a callable that accepts a single DBAPI connection as an
 argument, or None.

.. seealso::

    :meth:`.Dialect.connect` - allows the DBAPI ``connect()`` sequence
    itself to be controlled.

    :meth:`.Dialect.on_connect_url` - supersedes
    :meth:`.Dialect.on_connect` to also receive the
    :class:`_engine.URL` object in context.</pre> 
<p>Reimplemented in <a class="el" href="classsqlalchemy_1_1engine_1_1default_1_1DefaultDialect.html#acc88fd8ef6ee6e40d0586cc81cea8237">sqlalchemy.engine.default.DefaultDialect</a>.</p>

</div>
</div>
<a id="ae5ca76161603e09334f198d80e3f77cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ca76161603e09334f198d80e3f77cf">&#9670;&nbsp;</a></span>on_connect_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[Callable[[Any], Any]] sqlalchemy.engine.interfaces.Dialect.on_connect_url </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1url_1_1URL.html">URL</a>&#160;</td>
          <td class="paramname"><em>url</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">return a callable which sets up a newly created DBAPI connection.

This method is a new hook that supersedes the
:meth:`_engine.Dialect.on_connect` method when implemented by a
dialect.   When not implemented by a dialect, it invokes the
:meth:`_engine.Dialect.on_connect` method directly to maintain
compatibility with existing dialects.   There is no deprecation
for :meth:`_engine.Dialect.on_connect` expected.

The callable should accept a single argument "conn" which is the
DBAPI connection itself.  The inner callable has no
return value.

E.g.::

    class MyDialect(default.DefaultDialect):
        # ...

        def on_connect_url(self, url):
            def do_on_connect(connection):
                connection.execute("SET SPECIAL FLAGS etc")

            return do_on_connect

This is used to set dialect-wide per-connection options such as
isolation modes, Unicode modes, etc.

This method differs from :meth:`_engine.Dialect.on_connect` in that
it is passed the :class:`_engine.URL` object that's relevant to the
connect args.  Normally the only way to get this is from the
:meth:`_engine.Dialect.on_connect` hook is to look on the
:class:`_engine.Engine` itself, however this URL object may have been
replaced by plugins.

.. note::

    The default implementation of
    :meth:`_engine.Dialect.on_connect_url` is to invoke the
    :meth:`_engine.Dialect.on_connect` method. Therefore if a dialect
    implements this method, the :meth:`_engine.Dialect.on_connect`
    method **will not be called** unless the overriding dialect calls
    it directly from here.

.. versionadded:: 1.4.3 added :meth:`_engine.Dialect.on_connect_url`
   which normally calls into :meth:`_engine.Dialect.on_connect`.

:param url: a :class:`_engine.URL` object representing the
 :class:`_engine.URL` that was passed to the
 :meth:`_engine.Dialect.create_connect_args` method.

:return: a callable that accepts a single DBAPI connection as an
 argument, or None.

.. seealso::

    :meth:`_engine.Dialect.on_connect`</pre> 
</div>
</div>
<a id="a8374978088a2275065d40f85e6a488b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8374978088a2275065d40f85e6a488b0">&#9670;&nbsp;</a></span>reset_isolation_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.reset_isolation_level </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>&#160;</td>
          <td class="paramname"><em>dbapi_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a DBAPI connection, revert its isolation to the default.

Note that this is a dialect-level method which is used as part
of the implementation of the :class:`_engine.Connection` and
:class:`_engine.Engine`
isolation level facilities; these APIs should be preferred for
most typical use cases.

.. seealso::

    :meth:`_engine.Connection.get_isolation_level`
    - view current level

    :attr:`_engine.Connection.default_isolation_level`
    - view default level

    :paramref:`.Connection.execution_options.isolation_level` -
    set per :class:`_engine.Connection` isolation level

    :paramref:`_sa.create_engine.isolation_level` -
    set per :class:`_engine.Engine` isolation level</pre> 
</div>
</div>
<a id="a81ad7d9639b679a7e58898124a6b3dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ad7d9639b679a7e58898124a6b3dfe">&#9670;&nbsp;</a></span>set_connection_execution_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.set_connection_execution_options </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#aee89f55fe5c28034b3219bd2fbcb96da">CoreExecuteOptionsParameter</a>
    &#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Establish execution options for a given connection.

This is implemented by :class:`.DefaultDialect` in order to implement
the :paramref:`_engine.Connection.execution_options.isolation_level`
execution option.  Dialects can intercept various execution options
which may need to modify state on a particular DBAPI connection.

.. versionadded:: 1.4</pre> 
</div>
</div>
<a id="a8b1a08c3089ca031004338c4c2326426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1a08c3089ca031004338c4c2326426">&#9670;&nbsp;</a></span>set_engine_execution_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.set_engine_execution_options </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a>&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#aee89f55fe5c28034b3219bd2fbcb96da">CoreExecuteOptionsParameter</a>
    &#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Establish execution options for a given engine.

This is implemented by :class:`.DefaultDialect` to establish
event hooks for new :class:`.Connection` instances created
by the given :class:`.Engine` which will then invoke the
:meth:`.Dialect.set_connection_execution_options` method for that
connection.</pre> 
</div>
</div>
<a id="a0f4cdce324bc510c4f23a6e689c65f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4cdce324bc510c4f23a6e689c65f41">&#9670;&nbsp;</a></span>set_isolation_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.interfaces.Dialect.set_isolation_level </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPIConnection.html">DBAPIConnection</a>&#160;</td>
          <td class="paramname"><em>dbapi_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesqlalchemy_1_1engine_1_1interfaces.html#a3dc373f12f63294e1841371cad21f03c">IsolationLevel</a>
    &#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a DBAPI connection, set its isolation level.

Note that this is a dialect-level method which is used as part
of the implementation of the :class:`_engine.Connection` and
:class:`_engine.Engine`
isolation level facilities; these APIs should be preferred for
most typical use cases.

If the dialect also implements the
:meth:`.Dialect.get_isolation_level_values` method, then the given
level is guaranteed to be one of the string names within that sequence,
and the method will not need to anticipate a lookup failure.

.. seealso::

    :meth:`_engine.Connection.get_isolation_level`
    - view current level

    :attr:`_engine.Connection.default_isolation_level`
    - view default level

    :paramref:`.Connection.execution_options.isolation_level` -
    set per :class:`_engine.Connection` isolation level

    :paramref:`_sa.create_engine.isolation_level` -
    set per :class:`_engine.Engine` isolation level</pre> 
</div>
</div>
<a id="ae0845b1a46c3a56b96a6667150a6eb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0845b1a46c3a56b96a6667150a6eb73">&#9670;&nbsp;</a></span>type_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1type__api_1_1TypeEngine.html">TypeEngine</a>[_T] sqlalchemy.engine.interfaces.Dialect.type_descriptor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1type__api_1_1TypeEngine.html">TypeEngine</a>[_T]&#160;</td>
          <td class="paramname"><em>typeobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform a generic type to a dialect-specific type.

Dialect classes will usually use the
:func:`_types.adapt_type` function in the types module to
accomplish this.

The returned result is cached *per dialect class* so can
contain no dialect-instance state.</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0506b5fb75deb163e961a9a215aa4f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0506b5fb75deb163e961a9a215aa4f8d">&#9670;&nbsp;</a></span>bind_typing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.engine.interfaces.Dialect.bind_typing = <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1BindTyping.html#ac5d716244dbbc999938eb2f70e50dd02">BindTyping.NONE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2389902fa49192b13251d38666b5586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2389902fa49192b13251d38666b5586">&#9670;&nbsp;</a></span>bool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.engine.interfaces.Dialect.bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46828c8c089c6c56d8a8cc5b176bef46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46828c8c089c6c56d8a8cc5b176bef46">&#9670;&nbsp;</a></span>CACHE_HIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.engine.interfaces.Dialect.CACHE_HIT = CacheStats.CACHE_HIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73d6de8ecccc8067a722a37aec04db57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d6de8ecccc8067a722a37aec04db57">&#9670;&nbsp;</a></span>CACHE_MISS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.engine.interfaces.Dialect.CACHE_MISS = CacheStats.CACHE_MISS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0615540bcd58ca82a58c8940e118d45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0615540bcd58ca82a58c8940e118d45b">&#9670;&nbsp;</a></span>CACHING_DISABLED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.engine.interfaces.Dialect.CACHING_DISABLED = CacheStats.CACHING_DISABLED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab053c34d026573c5c3cd86c64729705f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab053c34d026573c5c3cd86c64729705f">&#9670;&nbsp;</a></span>NO_CACHE_KEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.engine.interfaces.Dialect.NO_CACHE_KEY = CacheStats.NO_CACHE_KEY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e91573dd56ffd4d4c1310bd27351f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e91573dd56ffd4d4c1310bd27351f8a">&#9670;&nbsp;</a></span>NO_DIALECT_SUPPORT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.engine.interfaces.Dialect.NO_DIALECT_SUPPORT = CacheStats.NO_DIALECT_SUPPORT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a0c5179c04f4f3788cd63300f112f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0c5179c04f4f3788cd63300f112f11">&#9670;&nbsp;</a></span>str</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.engine.interfaces.Dialect.str</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>py3_env/lib/python3.10/site-packages/sqlalchemy/engine/<a class="el" href="py3__env_2lib_2python3_810_2site-packages_2sqlalchemy_2engine_2interfaces_8py.html">interfaces.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
