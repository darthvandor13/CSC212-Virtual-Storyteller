<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.simplify.radsimp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1simplify.html">simplify</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html">radsimp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.simplify.radsimp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a85834b3191218f075bd407786ff03f92"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a85834b3191218f075bd407786ff03f92">collect</a> (expr, syms, func=None, <a class="el" href="classsympy_1_1core_1_1parameters_1_1evaluate.html">evaluate</a>=None, exact=False, distribute_order_term=True)</td></tr>
<tr class="separator:a85834b3191218f075bd407786ff03f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bac1cf1616e6a25e6d782676c0bdc56"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a3bac1cf1616e6a25e6d782676c0bdc56">rcollect</a> (expr, *vars)</td></tr>
<tr class="separator:a3bac1cf1616e6a25e6d782676c0bdc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb2d581a7c2de36a7f9f46f961ccd8d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a9cb2d581a7c2de36a7f9f46f961ccd8d">collect_sqrt</a> (expr, <a class="el" href="classsympy_1_1core_1_1parameters_1_1evaluate.html">evaluate</a>=None)</td></tr>
<tr class="separator:a9cb2d581a7c2de36a7f9f46f961ccd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7642893f7dc607ec30ae6967dc743552"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a7642893f7dc607ec30ae6967dc743552">collect_abs</a> (expr)</td></tr>
<tr class="separator:a7642893f7dc607ec30ae6967dc743552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cd655ea3122c215e247aca86ec655d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a69cd655ea3122c215e247aca86ec655d">collect_const</a> (expr, *vars, Numbers=True)</td></tr>
<tr class="separator:a69cd655ea3122c215e247aca86ec655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52c45910bf23cbfac7d77decbd0b302"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#af52c45910bf23cbfac7d77decbd0b302">radsimp</a> (expr, symbolic=True, max_terms=4)</td></tr>
<tr class="separator:af52c45910bf23cbfac7d77decbd0b302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae770ba7a249fddf37270ad91fb6fe9dc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#ae770ba7a249fddf37270ad91fb6fe9dc">rad_rationalize</a> (num, den)</td></tr>
<tr class="separator:ae770ba7a249fddf37270ad91fb6fe9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88df6cbbb960d85ee4591c1973327ad3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a88df6cbbb960d85ee4591c1973327ad3">fraction</a> (expr, exact=False)</td></tr>
<tr class="separator:a88df6cbbb960d85ee4591c1973327ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7275bd71a54447ebf19a8635667f4654"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a7275bd71a54447ebf19a8635667f4654">numer</a> (expr, exact=False)</td></tr>
<tr class="separator:a7275bd71a54447ebf19a8635667f4654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3969e62f56fa0f6a2deb5a0a28cb940"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#ae3969e62f56fa0f6a2deb5a0a28cb940">denom</a> (expr, exact=False)</td></tr>
<tr class="separator:ae3969e62f56fa0f6a2deb5a0a28cb940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a26e7291983c3c985edf42de01c4579"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a8a26e7291983c3c985edf42de01c4579">fraction_expand</a> (expr, **hints)</td></tr>
<tr class="separator:a8a26e7291983c3c985edf42de01c4579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46f48a5a2ac8ecf3903daf481370e66"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#ad46f48a5a2ac8ecf3903daf481370e66">numer_expand</a> (expr, **hints)</td></tr>
<tr class="separator:ad46f48a5a2ac8ecf3903daf481370e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6796290b9d67ce4e2c6a982046f2effb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a6796290b9d67ce4e2c6a982046f2effb">denom_expand</a> (expr, **hints)</td></tr>
<tr class="separator:a6796290b9d67ce4e2c6a982046f2effb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b89ea63a039420469a1234e6dfc9df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#ab6b89ea63a039420469a1234e6dfc9df">split_surds</a> (expr)</td></tr>
<tr class="separator:ab6b89ea63a039420469a1234e6dfc9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae8f4613c873ede74bb4fbac755bb39b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#ae8f4613c873ede74bb4fbac755bb39b2">expand_numer</a> = <a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#ad46f48a5a2ac8ecf3903daf481370e66">numer_expand</a></td></tr>
<tr class="separator:ae8f4613c873ede74bb4fbac755bb39b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfd19ea4938357c4097f11890137c21"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a1cfd19ea4938357c4097f11890137c21">expand_denom</a> = <a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a6796290b9d67ce4e2c6a982046f2effb">denom_expand</a></td></tr>
<tr class="separator:a1cfd19ea4938357c4097f11890137c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bf2294f40a19ecf083a9b454d32ba0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a80bf2294f40a19ecf083a9b454d32ba0">expand_fraction</a> = <a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a8a26e7291983c3c985edf42de01c4579">fraction_expand</a></td></tr>
<tr class="separator:a80bf2294f40a19ecf083a9b454d32ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a85834b3191218f075bd407786ff03f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85834b3191218f075bd407786ff03f92">&#9670;&nbsp;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.collect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>evaluate</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exact</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distribute_order_term</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Collect additive terms of an expression.

Explanation
===========

This function collects additive terms of an expression with respect
to a list of expression up to powers with rational exponents. By the
term symbol here are meant arbitrary expressions, which can contain
powers, products, sums etc. In other words symbol is a pattern which
will be searched for in the expression's terms.

The input expression is not expanded by :func:`collect`, so user is
expected to provide an expression in an appropriate form. This makes
:func:`collect` more predictable as there is no magic happening behind the
scenes. However, it is important to note, that powers of products are
converted to products of powers using the :func:`~.expand_power_base`
function.

There are two possible types of output. First, if ``evaluate`` flag is
set, this function will return an expression with collected terms or
else it will return a dictionary with expressions up to rational powers
as keys and collected coefficients as values.

Examples
========

&gt;&gt;&gt; from sympy import S, collect, expand, factor, Wild
&gt;&gt;&gt; from sympy.abc import a, b, c, x, y

This function can collect symbolic coefficients in polynomials or
rational expressions. It will manage to find all integer or rational
powers of collection variable::

    &gt;&gt;&gt; collect(a*x**2 + b*x**2 + a*x - b*x + c, x)
    c + x**2*(a + b) + x*(a - b)

The same result can be achieved in dictionary form::

    &gt;&gt;&gt; d = collect(a*x**2 + b*x**2 + a*x - b*x + c, x, evaluate=False)
    &gt;&gt;&gt; d[x**2]
    a + b
    &gt;&gt;&gt; d[x]
    a - b
    &gt;&gt;&gt; d[S.One]
    c

You can also work with multivariate polynomials. However, remember that
this function is greedy so it will care only about a single symbol at time,
in specification order::

    &gt;&gt;&gt; collect(x**2 + y*x**2 + x*y + y + a*y, [x, y])
    x**2*(y + 1) + x*y + y*(a + 1)

Also more complicated expressions can be used as patterns::

    &gt;&gt;&gt; from sympy import sin, log
    &gt;&gt;&gt; collect(a*sin(2*x) + b*sin(2*x), sin(2*x))
    (a + b)*sin(2*x)

    &gt;&gt;&gt; collect(a*x*log(x) + b*(x*log(x)), x*log(x))
    x*(a + b)*log(x)

You can use wildcards in the pattern::

    &gt;&gt;&gt; w = Wild('w1')
    &gt;&gt;&gt; collect(a*x**y - b*x**y, w**y)
    x**y*(a - b)

It is also possible to work with symbolic powers, although it has more
complicated behavior, because in this case power's base and symbolic part
of the exponent are treated as a single symbol::

    &gt;&gt;&gt; collect(a*x**c + b*x**c, x)
    a*x**c + b*x**c
    &gt;&gt;&gt; collect(a*x**c + b*x**c, x**c)
    x**c*(a + b)

However if you incorporate rationals to the exponents, then you will get
well known behavior::

    &gt;&gt;&gt; collect(a*x**(2*c) + b*x**(2*c), x**c)
    x**(2*c)*(a + b)

Note also that all previously stated facts about :func:`collect` function
apply to the exponential function, so you can get::

    &gt;&gt;&gt; from sympy import exp
    &gt;&gt;&gt; collect(a*exp(2*x) + b*exp(2*x), exp(x))
    (a + b)*exp(2*x)

If you are interested only in collecting specific powers of some symbols
then set ``exact`` flag to True::

    &gt;&gt;&gt; collect(a*x**7 + b*x**7, x, exact=True)
    a*x**7 + b*x**7
    &gt;&gt;&gt; collect(a*x**7 + b*x**7, x**7, exact=True)
    x**7*(a + b)

If you want to collect on any object containing symbols, set
``exact`` to None:

    &gt;&gt;&gt; collect(x*exp(x) + sin(x)*y + sin(x)*2 + 3*x, x, exact=None)
    x*exp(x) + 3*x + (y + 2)*sin(x)
    &gt;&gt;&gt; collect(a*x*y + x*y + b*x + x, [x, y], exact=None)
    x*y*(a + 1) + x*(b + 1)

You can also apply this function to differential equations, where
derivatives of arbitrary order can be collected. Note that if you
collect with respect to a function or a derivative of a function, all
derivatives of that function will also be collected. Use
``exact=True`` to prevent this from happening::

    &gt;&gt;&gt; from sympy import Derivative as D, collect, Function
    &gt;&gt;&gt; f = Function('f') (x)

    &gt;&gt;&gt; collect(a*D(f,x) + b*D(f,x), D(f,x))
    (a + b)*Derivative(f(x), x)

    &gt;&gt;&gt; collect(a*D(D(f,x),x) + b*D(D(f,x),x), f)
    (a + b)*Derivative(f(x), (x, 2))

    &gt;&gt;&gt; collect(a*D(D(f,x),x) + b*D(D(f,x),x), D(f,x), exact=True)
    a*Derivative(f(x), (x, 2)) + b*Derivative(f(x), (x, 2))

    &gt;&gt;&gt; collect(a*D(f,x) + b*D(f,x) + a*f + b*f, f)
    (a + b)*f(x) + (a + b)*Derivative(f(x), x)

Or you can even match both derivative order and exponent at the same time::

    &gt;&gt;&gt; collect(a*D(D(f,x),x)**2 + b*D(D(f,x),x)**2, D(f,x))
    (a + b)*Derivative(f(x), (x, 2))**2

Finally, you can apply a function to each of the collected coefficients.
For example you can factorize symbolic coefficients of polynomial::

    &gt;&gt;&gt; f = expand((x + a + 1)**3)

    &gt;&gt;&gt; collect(f, x, factor)
    x**3 + 3*x**2*(a + 1) + 3*x*(a + 1)**2 + (a + 1)**3

.. note:: Arguments are expected to be in expanded form, so you might have
          to call :func:`~.expand` prior to calling this function.

See Also
========

collect_const, collect_sqrt, rcollect
</pre> 
</div>
</div>
<a id="a7642893f7dc607ec30ae6967dc743552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7642893f7dc607ec30ae6967dc743552">&#9670;&nbsp;</a></span>collect_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.collect_abs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``expr`` with arguments of multiple Abs in a term collected
under a single instance.

Examples
========

&gt;&gt;&gt; from sympy.simplify.radsimp import collect_abs
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; collect_abs(abs(x + 1)/abs(x**2 - 1))
Abs((x + 1)/(x**2 - 1))
&gt;&gt;&gt; collect_abs(abs(1/x))
Abs(1/x)
</pre> 
</div>
</div>
<a id="a69cd655ea3122c215e247aca86ec655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cd655ea3122c215e247aca86ec655d">&#9670;&nbsp;</a></span>collect_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.collect_const </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Numbers</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A non-greedy collection of terms with similar number coefficients in
an Add expr. If ``vars`` is given then only those constants will be
targeted. Although any Number can also be targeted, if this is not
desired set ``Numbers=False`` and no Float or Rational will be collected.

Parameters
==========

expr : SymPy expression
    This parameter defines the expression the expression from which
    terms with similar coefficients are to be collected. A non-Add
    expression is returned as it is.

vars : variable length collection of Numbers, optional
    Specifies the constants to target for collection. Can be multiple in
    number.

Numbers : bool
    Specifies to target all instance of
    :class:`sympy.core.numbers.Number` class. If ``Numbers=False``, then
    no Float or Rational will be collected.

Returns
=======

expr : Expr
    Returns an expression with similar coefficient terms collected.

Examples
========

&gt;&gt;&gt; from sympy import sqrt
&gt;&gt;&gt; from sympy.abc import s, x, y, z
&gt;&gt;&gt; from sympy.simplify.radsimp import collect_const
&gt;&gt;&gt; collect_const(sqrt(3) + sqrt(3)*(1 + sqrt(2)))
sqrt(3)*(sqrt(2) + 2)
&gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(7)*s + sqrt(3) + sqrt(7))
(sqrt(3) + sqrt(7))*(s + 1)
&gt;&gt;&gt; s = sqrt(2) + 2
&gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7))
(sqrt(2) + 3)*(sqrt(3) + sqrt(7))
&gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7), sqrt(3))
sqrt(7) + sqrt(3)*(sqrt(2) + 3) + sqrt(7)*(sqrt(2) + 2)

The collection is sign-sensitive, giving higher precedence to the
unsigned values:

&gt;&gt;&gt; collect_const(x - y - z)
x - (y + z)
&gt;&gt;&gt; collect_const(-y - z)
-(y + z)
&gt;&gt;&gt; collect_const(2*x - 2*y - 2*z, 2)
2*(x - y - z)
&gt;&gt;&gt; collect_const(2*x - 2*y - 2*z, -2)
2*x - 2*(y + z)

See Also
========

collect, collect_sqrt, rcollect
</pre> 
</div>
</div>
<a id="a9cb2d581a7c2de36a7f9f46f961ccd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb2d581a7c2de36a7f9f46f961ccd8d">&#9670;&nbsp;</a></span>collect_sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.collect_sqrt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>evaluate</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return expr with terms having common square roots collected together.
If ``evaluate`` is False a count indicating the number of sqrt-containing
terms will be returned and, if non-zero, the terms of the Add will be
returned, else the expression itself will be returned as a single term.
If ``evaluate`` is True, the expression with any collected terms will be
returned.

Note: since I = sqrt(-1), it is collected, too.

Examples
========

&gt;&gt;&gt; from sympy import sqrt
&gt;&gt;&gt; from sympy.simplify.radsimp import collect_sqrt
&gt;&gt;&gt; from sympy.abc import a, b

&gt;&gt;&gt; r2, r3, r5 = [sqrt(i) for i in [2, 3, 5]]
&gt;&gt;&gt; collect_sqrt(a*r2 + b*r2)
sqrt(2)*(a + b)
&gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r3)
sqrt(2)*(a + b) + sqrt(3)*(a + b)
&gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5)
sqrt(3)*a + sqrt(5)*b + sqrt(2)*(a + b)

If evaluate is False then the arguments will be sorted and
returned as a list and a count of the number of sqrt-containing
terms will be returned:

&gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5, evaluate=False)
((sqrt(3)*a, sqrt(5)*b, sqrt(2)*(a + b)), 3)
&gt;&gt;&gt; collect_sqrt(a*sqrt(2) + b, evaluate=False)
((b, sqrt(2)*a), 1)
&gt;&gt;&gt; collect_sqrt(a + b, evaluate=False)
((a + b,), 0)

See Also
========

collect, collect_const, rcollect
</pre> 
</div>
</div>
<a id="ae3969e62f56fa0f6a2deb5a0a28cb940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3969e62f56fa0f6a2deb5a0a28cb940">&#9670;&nbsp;</a></span>denom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.denom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exact</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6796290b9d67ce4e2c6a982046f2effb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6796290b9d67ce4e2c6a982046f2effb">&#9670;&nbsp;</a></span>denom_expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.denom_expand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88df6cbbb960d85ee4591c1973327ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88df6cbbb960d85ee4591c1973327ad3">&#9670;&nbsp;</a></span>fraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.fraction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exact</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a pair with expression's numerator and denominator.
   If the given expression is not a fraction then this function
   will return the tuple (expr, 1).

   This function will not make any attempt to simplify nested
   fractions or to do any term rewriting at all.

   If only one of the numerator/denominator pair is needed then
   use numer(expr) or denom(expr) functions respectively.

   &gt;&gt;&gt; from sympy import fraction, Rational, Symbol
   &gt;&gt;&gt; from sympy.abc import x, y

   &gt;&gt;&gt; fraction(x/y)
   (x, y)
   &gt;&gt;&gt; fraction(x)
   (x, 1)

   &gt;&gt;&gt; fraction(1/y**2)
   (1, y**2)

   &gt;&gt;&gt; fraction(x*y/2)
   (x*y, 2)
   &gt;&gt;&gt; fraction(Rational(1, 2))
   (1, 2)

   This function will also work fine with assumptions:

   &gt;&gt;&gt; k = Symbol('k', negative=True)
   &gt;&gt;&gt; fraction(x * y**k)
   (x, y**(-k))

   If we know nothing about sign of some exponent and ``exact``
   flag is unset, then the exponent's structure will
   be analyzed and pretty fraction will be returned:

   &gt;&gt;&gt; from sympy import exp, Mul
   &gt;&gt;&gt; fraction(2*x**(-y))
   (2, x**y)

   &gt;&gt;&gt; fraction(exp(-x))
   (1, exp(x))

   &gt;&gt;&gt; fraction(exp(-x), exact=True)
   (exp(-x), 1)

   The ``exact`` flag will also keep any unevaluated Muls from
   being evaluated:

   &gt;&gt;&gt; u = Mul(2, x + 1, evaluate=False)
   &gt;&gt;&gt; fraction(u)
   (2*x + 2, 1)
   &gt;&gt;&gt; fraction(u, exact=True)
   (2*(x  + 1), 1)
</pre> 
</div>
</div>
<a id="a8a26e7291983c3c985edf42de01c4579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a26e7291983c3c985edf42de01c4579">&#9670;&nbsp;</a></span>fraction_expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.fraction_expand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7275bd71a54447ebf19a8635667f4654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7275bd71a54447ebf19a8635667f4654">&#9670;&nbsp;</a></span>numer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.numer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exact</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad46f48a5a2ac8ecf3903daf481370e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46f48a5a2ac8ecf3903daf481370e66">&#9670;&nbsp;</a></span>numer_expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.numer_expand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae770ba7a249fddf37270ad91fb6fe9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae770ba7a249fddf37270ad91fb6fe9dc">&#9670;&nbsp;</a></span>rad_rationalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.rad_rationalize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rationalize ``num/den`` by removing square roots in the denominator;
num and den are sum of terms whose squares are positive rationals.

Examples
========

&gt;&gt;&gt; from sympy import sqrt
&gt;&gt;&gt; from sympy.simplify.radsimp import rad_rationalize
&gt;&gt;&gt; rad_rationalize(sqrt(3), 1 + sqrt(2)/3)
(-sqrt(3) + sqrt(6)/3, -7/9)
</pre> 
</div>
</div>
<a id="af52c45910bf23cbfac7d77decbd0b302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52c45910bf23cbfac7d77decbd0b302">&#9670;&nbsp;</a></span>radsimp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.radsimp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbolic</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_terms</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rationalize the denominator by removing square roots.

Explanation
===========

The expression returned from radsimp must be used with caution
since if the denominator contains symbols, it will be possible to make
substitutions that violate the assumptions of the simplification process:
that for a denominator matching a + b*sqrt(c), a != +/-b*sqrt(c). (If
there are no symbols, this assumptions is made valid by collecting terms
of sqrt(c) so the match variable ``a`` does not contain ``sqrt(c)``.) If
you do not want the simplification to occur for symbolic denominators, set
``symbolic`` to False.

If there are more than ``max_terms`` radical terms then the expression is
returned unchanged.

Examples
========

&gt;&gt;&gt; from sympy import radsimp, sqrt, Symbol, pprint
&gt;&gt;&gt; from sympy import factor_terms, fraction, signsimp
&gt;&gt;&gt; from sympy.simplify.radsimp import collect_sqrt
&gt;&gt;&gt; from sympy.abc import a, b, c

&gt;&gt;&gt; radsimp(1/(2 + sqrt(2)))
(2 - sqrt(2))/2
&gt;&gt;&gt; x,y = map(Symbol, 'xy')
&gt;&gt;&gt; e = ((2 + 2*sqrt(2))*x + (2 + sqrt(8))*y)/(2 + sqrt(2))
&gt;&gt;&gt; radsimp(e)
sqrt(2)*(x + y)

No simplification beyond removal of the gcd is done. One might
want to polish the result a little, however, by collecting
square root terms:

&gt;&gt;&gt; r2 = sqrt(2)
&gt;&gt;&gt; r5 = sqrt(5)
&gt;&gt;&gt; ans = radsimp(1/(y*r2 + x*r2 + a*r5 + b*r5)); pprint(ans)
    ___       ___       ___       ___
  \/ 5 *a + \/ 5 *b - \/ 2 *x - \/ 2 *y
------------------------------------------
   2               2      2              2
5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y

&gt;&gt;&gt; n, d = fraction(ans)
&gt;&gt;&gt; pprint(factor_terms(signsimp(collect_sqrt(n))/d, radical=True))
        ___             ___
      \/ 5 *(a + b) - \/ 2 *(x + y)
------------------------------------------
   2               2      2              2
5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y

If radicals in the denominator cannot be removed or there is no denominator,
the original expression will be returned.

&gt;&gt;&gt; radsimp(sqrt(2)*x + sqrt(2))
sqrt(2)*x + sqrt(2)

Results with symbols will not always be valid for all substitutions:

&gt;&gt;&gt; eq = 1/(a + b*sqrt(c))
&gt;&gt;&gt; eq.subs(a, b*sqrt(c))
1/(2*b*sqrt(c))
&gt;&gt;&gt; radsimp(eq).subs(a, b*sqrt(c))
nan

If ``symbolic=False``, symbolic denominators will not be transformed (but
numeric denominators will still be processed):

&gt;&gt;&gt; radsimp(eq, symbolic=False)
1/(a + b*sqrt(c))</pre> 
</div>
</div>
<a id="a3bac1cf1616e6a25e6d782676c0bdc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bac1cf1616e6a25e6d782676c0bdc56">&#9670;&nbsp;</a></span>rcollect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.rcollect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Recursively collect sums in an expression.

Examples
========

&gt;&gt;&gt; from sympy.simplify import rcollect
&gt;&gt;&gt; from sympy.abc import x, y

&gt;&gt;&gt; expr = (x**2*y + x*y + x + y)/(x + y)

&gt;&gt;&gt; rcollect(expr, y)
(x + y*(x**2 + x + 1))/(x + y)

See Also
========

collect, collect_const, collect_sqrt
</pre> 
</div>
</div>
<a id="ab6b89ea63a039420469a1234e6dfc9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b89ea63a039420469a1234e6dfc9df">&#9670;&nbsp;</a></span>split_surds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.split_surds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Split an expression with terms whose squares are positive rationals
into a sum of terms whose surds squared have gcd equal to g
and a sum of terms with surds squared prime with g.

Examples
========

&gt;&gt;&gt; from sympy import sqrt
&gt;&gt;&gt; from sympy.simplify.radsimp import split_surds
&gt;&gt;&gt; split_surds(3*sqrt(3) + sqrt(5)/7 + sqrt(6) + sqrt(10) + sqrt(15))
(3, sqrt(2) + sqrt(5) + 3, sqrt(5)/7 + sqrt(10))
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1cfd19ea4938357c4097f11890137c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfd19ea4938357c4097f11890137c21">&#9670;&nbsp;</a></span>expand_denom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.expand_denom = <a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a6796290b9d67ce4e2c6a982046f2effb">denom_expand</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80bf2294f40a19ecf083a9b454d32ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bf2294f40a19ecf083a9b454d32ba0">&#9670;&nbsp;</a></span>expand_fraction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.expand_fraction = <a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#a8a26e7291983c3c985edf42de01c4579">fraction_expand</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8f4613c873ede74bb4fbac755bb39b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f4613c873ede74bb4fbac755bb39b2">&#9670;&nbsp;</a></span>expand_numer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.simplify.radsimp.expand_numer = <a class="el" href="namespacesympy_1_1simplify_1_1radsimp.html#ad46f48a5a2ac8ecf3903daf481370e66">numer_expand</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
