<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.integrals.prde Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1integrals.html">integrals</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html">prde</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.integrals.prde Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a05feffae3cf3808701c1addacc336a22"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a05feffae3cf3808701c1addacc336a22">prde_normal_denom</a> (fa, fd, G, DE)</td></tr>
<tr class="separator:a05feffae3cf3808701c1addacc336a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c02bbbf56dba572c1b3f5cd72681a3a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a5c02bbbf56dba572c1b3f5cd72681a3a">real_imag</a> (ba, bd, gen)</td></tr>
<tr class="separator:a5c02bbbf56dba572c1b3f5cd72681a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa620d52c789afb5ac1a1e56c124fafb1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#aa620d52c789afb5ac1a1e56c124fafb1">prde_special_denom</a> (a, ba, bd, G, DE, case='auto')</td></tr>
<tr class="separator:aa620d52c789afb5ac1a1e56c124fafb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f44263116ce69ee9c07bc597b39f63"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a87f44263116ce69ee9c07bc597b39f63">prde_linear_constraints</a> (a, b, G, DE)</td></tr>
<tr class="separator:a87f44263116ce69ee9c07bc597b39f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3cd42e78731d9109c5b33f265121b8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a0a3cd42e78731d9109c5b33f265121b8">poly_linear_constraints</a> (p, d)</td></tr>
<tr class="separator:a0a3cd42e78731d9109c5b33f265121b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad67b8e786f269995b1955799ba646"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a29ad67b8e786f269995b1955799ba646">constant_system</a> (A, u, DE)</td></tr>
<tr class="separator:a29ad67b8e786f269995b1955799ba646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a195c6d6e9ccbd7f35e39076c3b7bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a89a195c6d6e9ccbd7f35e39076c3b7bb">prde_spde</a> (a, b, Q, n, DE)</td></tr>
<tr class="separator:a89a195c6d6e9ccbd7f35e39076c3b7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0e9d995775beb8bc0f851f14251525"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a6b0e9d995775beb8bc0f851f14251525">prde_no_cancel_b_large</a> (b, Q, n, DE)</td></tr>
<tr class="separator:a6b0e9d995775beb8bc0f851f14251525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63dbca53e26bdf8e430f4f2aca8fd98"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#ac63dbca53e26bdf8e430f4f2aca8fd98">prde_no_cancel_b_small</a> (b, Q, n, DE)</td></tr>
<tr class="separator:ac63dbca53e26bdf8e430f4f2aca8fd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c35881d144dc9ac603bd71bea3337a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a18c35881d144dc9ac603bd71bea3337a">prde_cancel_liouvillian</a> (b, Q, n, DE)</td></tr>
<tr class="separator:a18c35881d144dc9ac603bd71bea3337a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76307ef9bffa143174e16fc22948ef6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#ab76307ef9bffa143174e16fc22948ef6">param_poly_rischDE</a> (a, b, q, n, DE)</td></tr>
<tr class="separator:ab76307ef9bffa143174e16fc22948ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e16e7249af0ec570047300a861f12ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a7e16e7249af0ec570047300a861f12ef">param_rischDE</a> (fa, fd, G, DE)</td></tr>
<tr class="separator:a7e16e7249af0ec570047300a861f12ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf56efc4b0ce5e00cf206d01f996444a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#aaf56efc4b0ce5e00cf206d01f996444a">limited_integrate_reduce</a> (fa, fd, G, DE)</td></tr>
<tr class="separator:aaf56efc4b0ce5e00cf206d01f996444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592cbaf284fa84ce655673d98948d8ca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a592cbaf284fa84ce655673d98948d8ca">limited_integrate</a> (fa, fd, G, DE)</td></tr>
<tr class="separator:a592cbaf284fa84ce655673d98948d8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb1eab09a178e89c750b3fb6c0bdbb4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#aadb1eab09a178e89c750b3fb6c0bdbb4">parametric_log_deriv_heu</a> (fa, fd, wa, wd, DE, c1=None)</td></tr>
<tr class="separator:aadb1eab09a178e89c750b3fb6c0bdbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2e36b7395701b89aa24aa6ea9739aa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a3f2e36b7395701b89aa24aa6ea9739aa">parametric_log_deriv</a> (fa, fd, wa, wd, DE)</td></tr>
<tr class="separator:a3f2e36b7395701b89aa24aa6ea9739aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1b667c41f350af695c16c240f22660"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a8a1b667c41f350af695c16c240f22660">is_deriv_k</a> (fa, fd, DE)</td></tr>
<tr class="separator:a8a1b667c41f350af695c16c240f22660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4cbaa41537cd5309e4a08a32cb959d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#aeb4cbaa41537cd5309e4a08a32cb959d">is_log_deriv_k_t_radical</a> (fa, fd, DE, Df=True)</td></tr>
<tr class="separator:aeb4cbaa41537cd5309e4a08a32cb959d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8731e851cf0ceb097bf1aea40a1c8d0e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a8731e851cf0ceb097bf1aea40a1c8d0e">is_log_deriv_k_t_radical_in_field</a> (fa, fd, DE, case='auto', z=None)</td></tr>
<tr class="separator:a8731e851cf0ceb097bf1aea40a1c8d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a18d67b2e673da585ecca61cbbdb09e56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a18d67b2e673da585ecca61cbbdb09e56">zeros</a> = Matrix.zeros</td></tr>
<tr class="separator:a18d67b2e673da585ecca61cbbdb09e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856495f73d9492387eb10aa9e8cf2e53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1prde.html#a856495f73d9492387eb10aa9e8cf2e53">eye</a> = Matrix.eye</td></tr>
<tr class="separator:a856495f73d9492387eb10aa9e8cf2e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Algorithms for solving Parametric Risch Differential Equations.

The methods used for solving Parametric Risch Differential Equations parallel
those for solving Risch Differential Equations.  See the outline in the
docstring of rde.py for more information.

The Parametric Risch Differential Equation problem is, given f, g1, ..., gm in
K(t), to determine if there exist y in K(t) and c1, ..., cm in Const(K) such
that Dy + f*y == Sum(ci*gi, (i, 1, m)), and to find such y and ci if they exist.

For the algorithms here G is a list of tuples of factions of the terms on the
right hand side of the equation (i.e., gi in k(t)), and Q is a list of terms on
the right hand side of the equation (i.e., qi in k[t]).  See the docstring of
each function for more information.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a29ad67b8e786f269995b1955799ba646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ad67b8e786f269995b1955799ba646">&#9670;&nbsp;</a></span>constant_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.constant_system </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a system for the constant solutions.

Explanation
===========

Given a differential field (K, D) with constant field C = Const(K), a Matrix
A, and a vector (Matrix) u with coefficients in K, returns the tuple
(B, v, s), where B is a Matrix with coefficients in C and v is a vector
(Matrix) such that either v has coefficients in C, in which case s is True
and the solutions in C of Ax == u are exactly all the solutions of Bx == v,
or v has a non-constant coefficient, in which case s is False Ax == u has no
constant solution.

This algorithm is used both in solving parametric problems and in
determining if an element a of K is a derivative of an element of K or the
logarithmic derivative of a K-radical using the structure theorem approach.

Because Poly does not play well with Matrix yet, this algorithm assumes that
all matrix entries are Basic expressions.
</pre> 
</div>
</div>
<a id="a8a1b667c41f350af695c16c240f22660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1b667c41f350af695c16c240f22660">&#9670;&nbsp;</a></span>is_deriv_k()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.is_deriv_k </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if Df/f is the derivative of an element of k(t).

Explanation
===========

a in k(t) is the derivative of an element of k(t) if there exists b in k(t)
such that a = Db.  Either returns (ans, u), such that Df/f == Du, or None,
which means that Df/f is not the derivative of an element of k(t).  ans is
a list of tuples such that Add(*[i*j for i, j in ans]) == u.  This is useful
for seeing exactly which elements of k(t) produce u.

This function uses the structure theorem approach, which says that for any
f in K, Df/f is the derivative of a element of K if and only if there are ri
in QQ such that::

        ---               ---       Dt
        \    r  * Dt   +  \    r  *   i      Df
        /     i     i     /     i   ---   =  --.
        ---               ---        t        f
     i in L            i in E         i
           K/C(x)            K/C(x)


Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is
transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i
in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic
monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i
is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some
a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of
hyperexponential monomials of K over C(x)).  If K is an elementary extension
over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the
transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==
Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and
deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)
and L_K/C(x) are disjoint.

The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed
recursively using this same function.  Therefore, it is required to pass
them as indices to D (or T).  E_args are the arguments of the
hyperexponentials indexed by E_K (i.e., if i is in E_K, then T[i] ==
exp(E_args[i])).  This is needed to compute the final answer u such that
Df/f == Du.

log(f) will be the same as u up to a additive constant.  This is because
they will both behave the same as monomials. For example, both log(x) and
log(2*x) == log(x) + log(2) satisfy Dt == 1/x, because log(2) is constant.
Therefore, the term const is returned.  const is such that
log(const) + f == u.  This is calculated by dividing the arguments of one
logarithm from the other.  Therefore, it is necessary to pass the arguments
of the logarithmic terms in L_args.

To handle the case where we are given Df/f, not f, use is_deriv_k_in_field().

See also
========
is_log_deriv_k_t_radical_in_field, is_log_deriv_k_t_radical</pre> 
</div>
</div>
<a id="aeb4cbaa41537cd5309e4a08a32cb959d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4cbaa41537cd5309e4a08a32cb959d">&#9670;&nbsp;</a></span>is_log_deriv_k_t_radical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.is_log_deriv_k_t_radical </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Df</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if Df is the logarithmic derivative of a k(t)-radical.

Explanation
===========

b in k(t) can be written as the logarithmic derivative of a k(t) radical if
there exist n in ZZ and u in k(t) with n, u != 0 such that n*b == Du/u.
Either returns (ans, u, n, const) or None, which means that Df cannot be
written as the logarithmic derivative of a k(t)-radical.  ans is a list of
tuples such that Mul(*[i**j for i, j in ans]) == u.  This is useful for
seeing exactly what elements of k(t) produce u.

This function uses the structure theorem approach, which says that for any
f in K, Df is the logarithmic derivative of a K-radical if and only if there
are ri in QQ such that::

        ---               ---       Dt
        \    r  * Dt   +  \    r  *   i
        /     i     i     /     i   ---   =  Df.
        ---               ---        t
     i in L            i in E         i
           K/C(x)            K/C(x)


Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is
transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i
in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic
monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i
is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some
a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of
hyperexponential monomials of K over C(x)).  If K is an elementary extension
over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the
transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==
Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and
deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)
and L_K/C(x) are disjoint.

The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed
recursively using this same function.  Therefore, it is required to pass
them as indices to D (or T).  L_args are the arguments of the logarithms
indexed by L_K (i.e., if i is in L_K, then T[i] == log(L_args[i])).  This is
needed to compute the final answer u such that n*f == Du/u.

exp(f) will be the same as u up to a multiplicative constant.  This is
because they will both behave the same as monomials.  For example, both
exp(x) and exp(x + 1) == E*exp(x) satisfy Dt == t. Therefore, the term const
is returned.  const is such that exp(const)*f == u.  This is calculated by
subtracting the arguments of one exponential from the other.  Therefore, it
is necessary to pass the arguments of the exponential terms in E_args.

To handle the case where we are given Df, not f, use
is_log_deriv_k_t_radical_in_field().

See also
========

is_log_deriv_k_t_radical_in_field, is_deriv_k</pre> 
</div>
</div>
<a id="a8731e851cf0ceb097bf1aea40a1c8d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8731e851cf0ceb097bf1aea40a1c8d0e">&#9670;&nbsp;</a></span>is_log_deriv_k_t_radical_in_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.is_log_deriv_k_t_radical_in_field </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>case</em> = <code>'auto'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if f can be written as the logarithmic derivative of a k(t)-radical.

Explanation
===========

It differs from is_log_deriv_k_t_radical(fa, fd, DE, Df=False)
for any given fa, fd, DE in that it finds the solution in the
given field not in some (possibly unspecified extension) and
"in_field" with the function name is used to indicate that.

f in k(t) can be written as the logarithmic derivative of a k(t) radical if
there exist n in ZZ and u in k(t) with n, u != 0 such that n*f == Du/u.
Either returns (n, u) or None, which means that f cannot be written as the
logarithmic derivative of a k(t)-radical.

case is one of {'primitive', 'exp', 'tan', 'auto'} for the primitive,
hyperexponential, and hypertangent cases, respectively.  If case is 'auto',
it will attempt to determine the type of the derivation automatically.

See also
========
is_log_deriv_k_t_radical, is_deriv_k</pre> 
</div>
</div>
<a id="a592cbaf284fa84ce655673d98948d8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592cbaf284fa84ce655673d98948d8ca">&#9670;&nbsp;</a></span>limited_integrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.limited_integrate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the limited integration problem:  f = Dv + Sum(ci*wi, (i, 1, n))
</pre> 
</div>
</div>
<a id="aaf56efc4b0ce5e00cf206d01f996444a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf56efc4b0ce5e00cf206d01f996444a">&#9670;&nbsp;</a></span>limited_integrate_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.limited_integrate_reduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simpler version of step 1 &amp; 2 for the limited integration problem.

Explanation
===========

Given a derivation D on k(t) and f, g1, ..., gn in k(t), return
(a, b, h, N, g, V) such that a, b, h in k[t], N is a non-negative integer,
g in k(t), V == [v1, ..., vm] in k(t)^m, and for any solution v in k(t),
c1, ..., cm in C of f == Dv + Sum(ci*wi, (i, 1, m)), p = v*h is in k&lt;t&gt;, and
p and the ci satisfy a*Dp + b*p == g + Sum(ci*vi, (i, 1, m)).  Furthermore,
if S1irr == Sirr, then p is in k[t], and if t is nonlinear or Liouvillian
over k, then deg(p) &lt;= N.

So that the special part is always computed, this function calls the more
general prde_special_denom() automatically if it cannot determine that
S1irr == Sirr.  Furthermore, it will automatically call bound_degree() when
t is linear and non-Liouvillian, which for the transcendental case, implies
that Dt == a*t + b with for some a, b in k*.
</pre> 
</div>
</div>
<a id="ab76307ef9bffa143174e16fc22948ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76307ef9bffa143174e16fc22948ef6">&#9670;&nbsp;</a></span>param_poly_rischDE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.param_poly_rischDE </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Polynomial solutions of a parametric Risch differential equation.

Explanation
===========

Given a derivation D in k[t], a, b in k[t] relatively prime, and q
= [q1, ..., qm] in k[t]^m, return h = [h1, ..., hr] in k[t]^r and
a matrix A with m + r columns and entries in Const(k) such that
a*Dp + b*p = Sum(ci*qi, (i, 1, m)) has a solution p of degree &lt;= n
in k[t] with c1, ..., cm in Const(k) if and only if p = Sum(dj*hj,
(j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,
d1, ..., dr) is a solution of Ax == 0.
</pre> 
</div>
</div>
<a id="a7e16e7249af0ec570047300a861f12ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e16e7249af0ec570047300a861f12ef">&#9670;&nbsp;</a></span>param_rischDE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.param_rischDE </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a Parametric Risch Differential Equation: Dy + f*y == Sum(ci*Gi, (i, 1, m)).

Explanation
===========

Given a derivation D in k(t), f in k(t), and G
= [G1, ..., Gm] in k(t)^m, return h = [h1, ..., hr] in k(t)^r and
a matrix A with m + r columns and entries in Const(k) such that
Dy + f*y = Sum(ci*Gi, (i, 1, m)) has a solution y
in k(t) with c1, ..., cm in Const(k) if and only if y = Sum(dj*hj,
(j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,
d1, ..., dr) is a solution of Ax == 0.

Elements of k(t) are tuples (a, d) with a and d in k[t].
</pre> 
</div>
</div>
<a id="a3f2e36b7395701b89aa24aa6ea9739aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2e36b7395701b89aa24aa6ea9739aa">&#9670;&nbsp;</a></span>parametric_log_deriv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.parametric_log_deriv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadb1eab09a178e89c750b3fb6c0bdbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb1eab09a178e89c750b3fb6c0bdbb4">&#9670;&nbsp;</a></span>parametric_log_deriv_heu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.parametric_log_deriv_heu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parametric logarithmic derivative heuristic.

Explanation
===========

Given a derivation D on k[t], f in k(t), and a hyperexponential monomial
theta over k(t), raises either NotImplementedError, in which case the
heuristic failed, or returns None, in which case it has proven that no
solution exists, or returns a solution (n, m, v) of the equation
n*f == Dv/v + m*Dtheta/theta, with v in k(t)* and n, m in ZZ with n != 0.

If this heuristic fails, the structure theorem approach will need to be
used.

The argument w == Dtheta/theta
</pre> 
</div>
</div>
<a id="a0a3cd42e78731d9109c5b33f265121b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3cd42e78731d9109c5b33f265121b8">&#9670;&nbsp;</a></span>poly_linear_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.poly_linear_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given p = [p1, ..., pm] in k[t]^m and d in k[t], return
q = [q1, ..., qm] in k[t]^m and a matrix M with entries in k such
that Sum(ci*pi, (i, 1, m)), for c1, ..., cm in k, is divisible
by d if and only if (c1, ..., cm) is a solution of Mx = 0, in
which case the quotient is Sum(ci*qi, (i, 1, m)).
</pre> 
</div>
</div>
<a id="a18c35881d144dc9ac603bd71bea3337a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c35881d144dc9ac603bd71bea3337a">&#9670;&nbsp;</a></span>prde_cancel_liouvillian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.prde_cancel_liouvillian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pg, 237.
</pre> 
</div>
</div>
<a id="a87f44263116ce69ee9c07bc597b39f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f44263116ce69ee9c07bc597b39f63">&#9670;&nbsp;</a></span>prde_linear_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.prde_linear_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parametric Risch Differential Equation - Generate linear constraints on the constants.

Explanation
===========

Given a derivation D on k[t], a, b, in k[t] with gcd(a, b) == 1, and
G = [g1, ..., gm] in k(t)^m, return Q = [q1, ..., qm] in k[t]^m and a
matrix M with entries in k(t) such that for any solution c1, ..., cm in
Const(k) and p in k[t] of a*Dp + b*p == Sum(ci*gi, (i, 1, m)),
(c1, ..., cm) is a solution of Mx == 0, and p and the ci satisfy
a*Dp + b*p == Sum(ci*qi, (i, 1, m)).

Because M has entries in k(t), and because Matrix does not play well with
Poly, M will be a Matrix of Basic expressions.
</pre> 
</div>
</div>
<a id="a6b0e9d995775beb8bc0f851f14251525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0e9d995775beb8bc0f851f14251525">&#9670;&nbsp;</a></span>prde_no_cancel_b_large()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.prde_no_cancel_b_large </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parametric Poly Risch Differential Equation - No cancellation: deg(b) large enough.

Explanation
===========

Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with
b != 0 and either D == d/dt or deg(b) &gt; max(0, deg(D) - 1), returns
h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that
if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) &lt;= n and
Dq + b*q == Sum(ci*qi, (i, 1, m)), then q = Sum(dj*hj, (j, 1, r)), where
d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.
</pre> 
</div>
</div>
<a id="ac63dbca53e26bdf8e430f4f2aca8fd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63dbca53e26bdf8e430f4f2aca8fd98">&#9670;&nbsp;</a></span>prde_no_cancel_b_small()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.prde_no_cancel_b_small </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parametric Poly Risch Differential Equation - No cancellation: deg(b) small enough.

Explanation
===========

Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with
deg(b) &lt; deg(D) - 1 and either D == d/dt or deg(D) &gt;= 2, returns
h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that
if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) &lt;= n and
Dq + b*q == Sum(ci*qi, (i, 1, m)) then q = Sum(dj*hj, (j, 1, r)) where
d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.
</pre> 
</div>
</div>
<a id="a05feffae3cf3808701c1addacc336a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05feffae3cf3808701c1addacc336a22">&#9670;&nbsp;</a></span>prde_normal_denom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.prde_normal_denom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parametric Risch Differential Equation - Normal part of the denominator.

Explanation
===========

Given a derivation D on k[t] and f, g1, ..., gm in k(t) with f weakly
normalized with respect to t, return the tuple (a, b, G, h) such that
a, h in k[t], b in k&lt;t&gt;, G = [g1, ..., gm] in k(t)^m, and for any solution
c1, ..., cm in Const(k) and y in k(t) of Dy + f*y == Sum(ci*gi, (i, 1, m)),
q == y*h in k&lt;t&gt; satisfies a*Dq + b*q == Sum(ci*Gi, (i, 1, m)).
</pre> 
</div>
</div>
<a id="a89a195c6d6e9ccbd7f35e39076c3b7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a195c6d6e9ccbd7f35e39076c3b7bb">&#9670;&nbsp;</a></span>prde_spde()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.prde_spde </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Special Polynomial Differential Equation algorithm: Parametric Version.

Explanation
===========

Given a derivation D on k[t], an integer n, and a, b, q1, ..., qm in k[t]
with deg(a) &gt; 0 and gcd(a, b) == 1, return (A, B, Q, R, n1), with
Qq = [q1, ..., qm] and R = [r1, ..., rm], such that for any solution
c1, ..., cm in Const(k) and q in k[t] of degree at most n of
a*Dq + b*q == Sum(ci*gi, (i, 1, m)), p = (q - Sum(ci*ri, (i, 1, m)))/a has
degree at most n1 and satisfies A*Dp + B*p == Sum(ci*qi, (i, 1, m))
</pre> 
</div>
</div>
<a id="aa620d52c789afb5ac1a1e56c124fafb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa620d52c789afb5ac1a1e56c124fafb1">&#9670;&nbsp;</a></span>prde_special_denom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.prde_special_denom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>case</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parametric Risch Differential Equation - Special part of the denominator.

Explanation
===========

Case is one of {'exp', 'tan', 'primitive'} for the hyperexponential,
hypertangent, and primitive cases, respectively.  For the hyperexponential
(resp. hypertangent) case, given a derivation D on k[t] and a in k[t],
b in k&lt;t&gt;, and g1, ..., gm in k(t) with Dt/t in k (resp. Dt/(t**2 + 1) in
k, sqrt(-1) not in k), a != 0, and gcd(a, t) == 1 (resp.
gcd(a, t**2 + 1) == 1), return the tuple (A, B, GG, h) such that A, B, h in
k[t], GG = [gg1, ..., ggm] in k(t)^m, and for any solution c1, ..., cm in
Const(k) and q in k&lt;t&gt; of a*Dq + b*q == Sum(ci*gi, (i, 1, m)), r == q*h in
k[t] satisfies A*Dr + B*r == Sum(ci*ggi, (i, 1, m)).

For case == 'primitive', k&lt;t&gt; == k[t], so it returns (a, b, G, 1) in this
case.
</pre> 
</div>
</div>
<a id="a5c02bbbf56dba572c1b3f5cd72681a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c02bbbf56dba572c1b3f5cd72681a3a">&#9670;&nbsp;</a></span>real_imag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.prde.real_imag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function, to get the real and imaginary part of a rational function
evaluated at sqrt(-1) without actually evaluating it at sqrt(-1).

Explanation
===========

Separates the even and odd power terms by checking the degree of terms wrt
mod 4. Returns a tuple (ba[0], ba[1], bd) where ba[0] is real part
of the numerator ba[1] is the imaginary part and bd is the denominator
of the rational function.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a856495f73d9492387eb10aa9e8cf2e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856495f73d9492387eb10aa9e8cf2e53">&#9670;&nbsp;</a></span>eye</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.integrals.prde.eye = Matrix.eye</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18d67b2e673da585ecca61cbbdb09e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d67b2e673da585ecca61cbbdb09e56">&#9670;&nbsp;</a></span>zeros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.integrals.prde.zeros = Matrix.zeros</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
