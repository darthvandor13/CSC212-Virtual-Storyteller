<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: huggingface_hub.file_download Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehuggingface__hub.html">huggingface_hub</a></li><li class="navelem"><a class="el" href="namespacehuggingface__hub_1_1file__download.html">file_download</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">huggingface_hub.file_download Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhuggingface__hub_1_1file__download_1_1HfFileMetadata.html">HfFileMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac257a13168623d6fe052eadb4c654b36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#ac257a13168623d6fe052eadb4c654b36">are_symlinks_supported</a> (Union[str, Path, None] cache_dir=None)</td></tr>
<tr class="separator:ac257a13168623d6fe052eadb4c654b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52813f5672770529246732142cccb7c"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#ae52813f5672770529246732142cccb7c">hf_hub_url</a> (str repo_id, str filename, *Optional[str] subfolder=None, Optional[str] repo_type=None, Optional[str] revision=None, Optional[str] endpoint=None)</td></tr>
<tr class="separator:ae52813f5672770529246732142cccb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea49f7655d00aa05f10190a9f4f09422"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#aea49f7655d00aa05f10190a9f4f09422">http_get</a> (str url, BinaryIO temp_file, *Optional[Dict] proxies=None, int resume_size=0, Optional[Dict[str, Any]] headers=None, Optional[int] expected_size=None, Optional[str] displayed_filename=None, int _nb_retries=5, Optional[tqdm] _tqdm_bar=None)</td></tr>
<tr class="separator:aea49f7655d00aa05f10190a9f4f09422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02fab9618d14d8ba92b5de8a86d6f40"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#af02fab9618d14d8ba92b5de8a86d6f40">xet_get</a> (*Path incomplete_path, XetFileData xet_file_data, Dict[str, str] headers, Optional[int] expected_size=None, Optional[str] displayed_filename=None, Optional[tqdm] _tqdm_bar=None)</td></tr>
<tr class="separator:af02fab9618d14d8ba92b5de8a86d6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a7fa362cf37b22fae32f0d88b6b6bc"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#ac0a7fa362cf37b22fae32f0d88b6b6bc">repo_folder_name</a> (*str repo_id, str repo_type)</td></tr>
<tr class="separator:ac0a7fa362cf37b22fae32f0d88b6b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b50f4a5e84124869327e4b3e2925a8"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#ad0b50f4a5e84124869327e4b3e2925a8">hf_hub_download</a> (str repo_id, str filename, *Optional[str] subfolder=None, Optional[str] repo_type=None, Optional[str] revision=None, Optional[str] library_name=None, Optional[str] library_version=None, Union[str, Path, None] cache_dir=None, Union[str, Path, None] local_dir=None, Union[Dict, str, None] user_agent=None, bool force_download=False, Optional[Dict] proxies=None, float etag_timeout=<a class="el" href="namespacehuggingface__hub_1_1constants.html#a5239c40e4d6ae41d1765e01d83546e59">constants.DEFAULT_ETAG_TIMEOUT</a>, Union[bool, str, None] token=None, bool local_files_only=False, Optional[Dict[str, str]] headers=None, Optional[str] endpoint=None, Optional[bool] resume_download=None, Optional[str] force_filename=None, Union[bool, Literal[&quot;auto&quot;]] local_dir_use_symlinks=&quot;auto&quot;)</td></tr>
<tr class="separator:ad0b50f4a5e84124869327e4b3e2925a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0242f2840a349e1bacb7426d00091a9f"><td class="memItemLeft" align="right" valign="top">Union[str, _CACHED_NO_EXIST_T, None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#a0242f2840a349e1bacb7426d00091a9f">try_to_load_from_cache</a> (str repo_id, str filename, Union[str, Path, None] cache_dir=None, Optional[str] revision=None, Optional[str] repo_type=None)</td></tr>
<tr class="separator:a0242f2840a349e1bacb7426d00091a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc3687dafc6e8be7c7cd3e7e91a66f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhuggingface__hub_1_1file__download_1_1HfFileMetadata.html">HfFileMetadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#a7cc3687dafc6e8be7c7cd3e7e91a66f8">get_hf_file_metadata</a> (str url, Union[bool, str, None] token=None, Optional[Dict] proxies=None, Optional[float] timeout=<a class="el" href="namespacehuggingface__hub_1_1constants.html#a2fd816963d28f0a6d7aa06c3cbbe642c">constants.DEFAULT_REQUEST_TIMEOUT</a>, Optional[str] library_name=None, Optional[str] library_version=None, Union[Dict, str, None] user_agent=None, Optional[Dict[str, str]] headers=None)</td></tr>
<tr class="separator:a7cc3687dafc6e8be7c7cd3e7e91a66f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a98e0033bd7e49b02336ee345b073945f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#a98e0033bd7e49b02336ee345b073945f">HEADER_FILENAME_PATTERN</a></td></tr>
<tr class="separator:a98e0033bd7e49b02336ee345b073945f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c29b004069999ab6945c6461aa892a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#a7c29b004069999ab6945c6461aa892a8">REGEX_COMMIT_HASH</a></td></tr>
<tr class="separator:a7c29b004069999ab6945c6461aa892a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64b9928d5b7aa42f8bb65a9393c7235"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehuggingface__hub_1_1file__download.html#ab64b9928d5b7aa42f8bb65a9393c7235">REGEX_SHA256</a></td></tr>
<tr class="separator:ab64b9928d5b7aa42f8bb65a9393c7235"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac257a13168623d6fe052eadb4c654b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac257a13168623d6fe052eadb4c654b36">&#9670;&nbsp;</a></span>are_symlinks_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool huggingface_hub.file_download.are_symlinks_supported </td>
          <td>(</td>
          <td class="paramtype">Union[str, Path, None] &#160;</td>
          <td class="paramname"><em>cache_dir</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the symlinks are supported on the machine.

Since symlinks support can change depending on the mounted disk, we need to check
on the precise cache folder. By default, the default HF cache directory is checked.

Args:
    cache_dir (`str`, `Path`, *optional*):
        Path to the folder where cached files are stored.

Returns: [bool] Whether symlinks are supported in the directory.
</pre> 
</div>
</div>
<a id="a7cc3687dafc6e8be7c7cd3e7e91a66f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc3687dafc6e8be7c7cd3e7e91a66f8">&#9670;&nbsp;</a></span>get_hf_file_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhuggingface__hub_1_1file__download_1_1HfFileMetadata.html">HfFileMetadata</a> huggingface_hub.file_download.get_hf_file_metadata </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[bool, str, None] &#160;</td>
          <td class="paramname"><em>token</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Dict] &#160;</td>
          <td class="paramname"><em>proxies</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[float] &#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="namespacehuggingface__hub_1_1constants.html#a2fd816963d28f0a6d7aa06c3cbbe642c">constants.DEFAULT_REQUEST_TIMEOUT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>library_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>library_version</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[Dict, str, None] &#160;</td>
          <td class="paramname"><em>user_agent</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Dict[str, str]] &#160;</td>
          <td class="paramname"><em>headers</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fetch metadata of a file versioned on the Hub for a given url.

Args:
    url (`str`):
        File url, for example returned by [`hf_hub_url`].
    token (`str` or `bool`, *optional*):
        A token to be used for the download.
            - If `True`, the token is read from the HuggingFace config
              folder.
            - If `False` or `None`, no token is provided.
            - If a string, it's used as the authentication token.
    proxies (`dict`, *optional*):
        Dictionary mapping protocol to the URL of the proxy passed to
        `requests.request`.
    timeout (`float`, *optional*, defaults to 10):
        How many seconds to wait for the server to send metadata before giving up.
    library_name (`str`, *optional*):
        The name of the library to which the object corresponds.
    library_version (`str`, *optional*):
        The version of the library.
    user_agent (`dict`, `str`, *optional*):
        The user-agent info in the form of a dictionary or a string.
    headers (`dict`, *optional*):
        Additional headers to be sent with the request.

Returns:
    A [`HfFileMetadata`] object containing metadata such as location, etag, size and
    commit_hash.
</pre> 
</div>
</div>
<a id="ad0b50f4a5e84124869327e4b3e2925a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b50f4a5e84124869327e4b3e2925a8">&#9670;&nbsp;</a></span>hf_hub_download()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str huggingface_hub.file_download.hf_hub_download </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>repo_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[str] &#160;</td>
          <td class="paramname"><em>subfolder</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>repo_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>revision</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>library_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>library_version</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, Path, None] &#160;</td>
          <td class="paramname"><em>cache_dir</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, Path, None] &#160;</td>
          <td class="paramname"><em>local_dir</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[Dict, str, None] &#160;</td>
          <td class="paramname"><em>user_agent</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>force_download</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Dict] &#160;</td>
          <td class="paramname"><em>proxies</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &#160;</td>
          <td class="paramname"><em>etag_timeout</em> = <code><a class="el" href="namespacehuggingface__hub_1_1constants.html#a5239c40e4d6ae41d1765e01d83546e59">constants.DEFAULT_ETAG_TIMEOUT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[bool, str, None] &#160;</td>
          <td class="paramname"><em>token</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>local_files_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Dict[str, str]] &#160;</td>
          <td class="paramname"><em>headers</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>endpoint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>resume_download</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>force_filename</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[bool, Literal[&quot;auto&quot;]] &#160;</td>
          <td class="paramname"><em>local_dir_use_symlinks</em> = <code>&quot;auto&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Download a given file if it's not already present in the local cache.

The new cache file layout looks like this:
- The cache directory contains one subfolder per repo_id (namespaced by repo type)
- inside each repo folder:
    - refs is a list of the latest known revision =&gt; commit_hash pairs
    - blobs contains the actual file blobs (identified by their git-sha or sha256, depending on
      whether they're LFS files or not)
    - snapshots contains one subfolder per commit, each "commit" contains the subset of the files
      that have been resolved at that particular commit. Each filename is a symlink to the blob
      at that particular commit.

```
[  96]  .
└── [ 160]  models--julien-c--EsperBERTo-small
    ├── [ 160]  blobs
    │   ├── [321M]  403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
    │   ├── [ 398]  7cb18dc9bafbfcf74629a4b760af1b160957a83e
    │   └── [1.4K]  d7edf6bd2a681fb0175f7735299831ee1b22b812
    ├── [  96]  refs
    │   └── [  40]  main
    └── [ 128]  snapshots
        ├── [ 128]  2439f60ef33a0d46d85da5001d52aeda5b00ce9f
        │   ├── [  52]  README.md -&gt; ../../blobs/d7edf6bd2a681fb0175f7735299831ee1b22b812
        │   └── [  76]  pytorch_model.bin -&gt; ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
        └── [ 128]  bbc77c8132af1cc5cf678da3f1ddf2de43606d48
            ├── [  52]  README.md -&gt; ../../blobs/7cb18dc9bafbfcf74629a4b760af1b160957a83e
            └── [  76]  pytorch_model.bin -&gt; ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
```

If `local_dir` is provided, the file structure from the repo will be replicated in this location. When using this
option, the `cache_dir` will not be used and a `.cache/huggingface/` folder will be created at the root of `local_dir`
to store some metadata related to the downloaded files. While this mechanism is not as robust as the main
cache-system, it's optimized for regularly pulling the latest version of a repository.

Args:
    repo_id (`str`):
        A user or an organization name and a repo name separated by a `/`.
    filename (`str`):
        The name of the file in the repo.
    subfolder (`str`, *optional*):
        An optional value corresponding to a folder inside the model repo.
    repo_type (`str`, *optional*):
        Set to `"dataset"` or `"space"` if downloading from a dataset or space,
        `None` or `"model"` if downloading from a model. Default is `None`.
    revision (`str`, *optional*):
        An optional Git revision id which can be a branch name, a tag, or a
        commit hash.
    library_name (`str`, *optional*):
        The name of the library to which the object corresponds.
    library_version (`str`, *optional*):
        The version of the library.
    cache_dir (`str`, `Path`, *optional*):
        Path to the folder where cached files are stored.
    local_dir (`str` or `Path`, *optional*):
        If provided, the downloaded file will be placed under this directory.
    user_agent (`dict`, `str`, *optional*):
        The user-agent info in the form of a dictionary or a string.
    force_download (`bool`, *optional*, defaults to `False`):
        Whether the file should be downloaded even if it already exists in
        the local cache.
    proxies (`dict`, *optional*):
        Dictionary mapping protocol to the URL of the proxy passed to
        `requests.request`.
    etag_timeout (`float`, *optional*, defaults to `10`):
        When fetching ETag, how many seconds to wait for the server to send
        data before giving up which is passed to `requests.request`.
    token (`str`, `bool`, *optional*):
        A token to be used for the download.
            - If `True`, the token is read from the HuggingFace config
              folder.
            - If a string, it's used as the authentication token.
    local_files_only (`bool`, *optional*, defaults to `False`):
        If `True`, avoid downloading the file and return the path to the
        local cached file if it exists.
    headers (`dict`, *optional*):
        Additional headers to be sent with the request.

Returns:
    `str`: Local path of file or if networking is off, last version of file cached on disk.

Raises:
    [`~utils.RepositoryNotFoundError`]
        If the repository to download from cannot be found. This may be because it doesn't exist,
        or because it is set to `private` and you do not have access.
    [`~utils.RevisionNotFoundError`]
        If the revision to download from cannot be found.
    [`~utils.EntryNotFoundError`]
        If the file to download cannot be found.
    [`~utils.LocalEntryNotFoundError`]
        If network is disabled or unavailable and file is not found in cache.
    [`EnvironmentError`](https://docs.python.org/3/library/exceptions.html#EnvironmentError)
        If `token=True` but the token cannot be found.
    [`OSError`](https://docs.python.org/3/library/exceptions.html#OSError)
        If ETag cannot be determined.
    [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError)
        If some parameter value is invalid.</pre> 
</div>
</div>
<a id="ae52813f5672770529246732142cccb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52813f5672770529246732142cccb7c">&#9670;&nbsp;</a></span>hf_hub_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str huggingface_hub.file_download.hf_hub_url </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>repo_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[str] &#160;</td>
          <td class="paramname"><em>subfolder</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>repo_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>revision</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>endpoint</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct the URL of a file from the given information.

The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.

Args:
    repo_id (`str`):
        A namespace (user or an organization) name and a repo name separated
        by a `/`.
    filename (`str`):
        The name of the file in the repo.
    subfolder (`str`, *optional*):
        An optional value corresponding to a folder inside the repo.
    repo_type (`str`, *optional*):
        Set to `"dataset"` or `"space"` if downloading from a dataset or space,
        `None` or `"model"` if downloading from a model. Default is `None`.
    revision (`str`, *optional*):
        An optional Git revision id which can be a branch name, a tag, or a
        commit hash.

Example:

```python
&gt;&gt;&gt; from huggingface_hub import hf_hub_url

&gt;&gt;&gt; hf_hub_url(
...     repo_id="julien-c/EsperBERTo-small", filename="pytorch_model.bin"
... )
'https://huggingface.co/julien-c/EsperBERTo-small/resolve/main/pytorch_model.bin'
```

&lt;Tip&gt;

Notes:

    Cloudfront is replicated over the globe so downloads are way faster for
    the end user (and it also lowers our bandwidth costs).

    Cloudfront aggressively caches files by default (default TTL is 24
    hours), however this is not an issue here because we implement a
    git-based versioning system on huggingface.co, which means that we store
    the files on S3/Cloudfront in a content-addressable way (i.e., the file
    name is its hash). Using content-addressable filenames means cache can't
    ever be stale.

    In terms of client-side caching from this library, we base our caching
    on the objects' entity tag (`ETag`), which is an identifier of a
    specific version of a resource [1]_. An object's ETag is: its git-sha1
    if stored in git, or its sha256 if stored in git-lfs.

&lt;/Tip&gt;

References:

-  [1] https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag
</pre> 
</div>
</div>
<a id="aea49f7655d00aa05f10190a9f4f09422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea49f7655d00aa05f10190a9f4f09422">&#9670;&nbsp;</a></span>http_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None huggingface_hub.file_download.http_get </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryIO&#160;</td>
          <td class="paramname"><em>temp_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[Dict] &#160;</td>
          <td class="paramname"><em>proxies</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>resume_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Dict[str, Any]] &#160;</td>
          <td class="paramname"><em>headers</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int] &#160;</td>
          <td class="paramname"><em>expected_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>displayed_filename</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_nb_retries</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[tqdm] &#160;</td>
          <td class="paramname"><em>_tqdm_bar</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Download a remote file. Do not gobble up errors, and will return errors tailored to the Hugging Face Hub.

If ConnectionError (SSLError) or ReadTimeout happen while streaming data from the server, it is most likely a
transient error (network outage?). We log a warning message and try to resume the download a few times before
giving up. The method gives up after 5 attempts if no new data has being received from the server.

Args:
    url (`str`):
        The URL of the file to download.
    temp_file (`BinaryIO`):
        The file-like object where to save the file.
    proxies (`dict`, *optional*):
        Dictionary mapping protocol to the URL of the proxy passed to `requests.request`.
    resume_size (`int`, *optional*):
        The number of bytes already downloaded. If set to 0 (default), the whole file is download. If set to a
        positive number, the download will resume at the given position.
    headers (`dict`, *optional*):
        Dictionary of HTTP Headers to send with the request.
    expected_size (`int`, *optional*):
        The expected size of the file to download. If set, the download will raise an error if the size of the
        received content is different from the expected one.
    displayed_filename (`str`, *optional*):
        The filename of the file that is being downloaded. Value is used only to display a nice progress bar. If
        not set, the filename is guessed from the URL or the `Content-Disposition` header.
</pre> 
</div>
</div>
<a id="ac0a7fa362cf37b22fae32f0d88b6b6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a7fa362cf37b22fae32f0d88b6b6bc">&#9670;&nbsp;</a></span>repo_folder_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str huggingface_hub.file_download.repo_folder_name </td>
          <td>(</td>
          <td class="paramtype">*str&#160;</td>
          <td class="paramname"><em>repo_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>repo_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a serialized version of a hf.co repo name and type, safe for disk storage
as a single non-nested folder.

Example: models--julien-c--EsperBERTo-small
</pre> 
</div>
</div>
<a id="a0242f2840a349e1bacb7426d00091a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0242f2840a349e1bacb7426d00091a9f">&#9670;&nbsp;</a></span>try_to_load_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[str, _CACHED_NO_EXIST_T, None] huggingface_hub.file_download.try_to_load_from_cache </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>repo_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, Path, None] &#160;</td>
          <td class="paramname"><em>cache_dir</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>revision</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>repo_type</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Explores the cache to return the latest cached file for a given revision if found.

This function will not raise any exception if the file in not cached.

Args:
    cache_dir (`str` or `os.PathLike`):
        The folder where the cached files lie.
    repo_id (`str`):
        The ID of the repo on huggingface.co.
    filename (`str`):
        The filename to look for inside `repo_id`.
    revision (`str`, *optional*):
        The specific model version to use. Will default to `"main"` if it's not provided and no `commit_hash` is
        provided either.
    repo_type (`str`, *optional*):
        The type of the repository. Will default to `"model"`.

Returns:
    `Optional[str]` or `_CACHED_NO_EXIST`:
        Will return `None` if the file was not cached. Otherwise:
        - The exact path to the cached file if it's found in the cache
        - A special value `_CACHED_NO_EXIST` if the file does not exist at the given commit hash and this fact was
          cached.

Example:

```python
from huggingface_hub import try_to_load_from_cache, _CACHED_NO_EXIST

filepath = try_to_load_from_cache()
if isinstance(filepath, str):
    # file exists and is cached
    ...
elif filepath is _CACHED_NO_EXIST:
    # non-existence of file is cached
    ...
else:
    # file is not cached
    ...
```
</pre> 
</div>
</div>
<a id="af02fab9618d14d8ba92b5de8a86d6f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02fab9618d14d8ba92b5de8a86d6f40">&#9670;&nbsp;</a></span>xet_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None huggingface_hub.file_download.xet_get </td>
          <td>(</td>
          <td class="paramtype">*Path&#160;</td>
          <td class="paramname"><em>incomplete_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XetFileData&#160;</td>
          <td class="paramname"><em>xet_file_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, str]&#160;</td>
          <td class="paramname"><em>headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int] &#160;</td>
          <td class="paramname"><em>expected_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>displayed_filename</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[tqdm] &#160;</td>
          <td class="paramname"><em>_tqdm_bar</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Download a file using Xet storage service.

Args:
    incomplete_path (`Path`):
        The path to the file to download.
    xet_file_data (`XetFileData`):
        The file metadata needed to make the request to the xet storage service.
    headers (`Dict[str, str]`):
        The headers to send to the xet storage service.
    expected_size (`int`, *optional*):
        The expected size of the file to download. If set, the download will raise an error if the size of the
        received content is different from the expected one.
    displayed_filename (`str`, *optional*):
        The filename of the file that is being downloaded. Value is used only to display a nice progress bar. If
        not set, the filename is guessed from the URL or the `Content-Disposition` header.

**How it works:**
    The file download system uses Xet storage, which is a content-addressable storage system that breaks files into chunks
    for efficient storage and transfer.

    `hf_xet.download_files` manages downloading files by:
    - Taking a list of files to download (each with its unique content hash)
    - Connecting to a storage server (CAS server) that knows how files are chunked
    - Using authentication to ensure secure access
    - Providing progress updates during download

    Authentication works by regularly refreshing access tokens through `refresh_xet_connection_info` to maintain a valid
    connection to the storage server.

    The download process works like this:
    1. Create a local cache folder at `~/.cache/huggingface/xet/chunk-cache` to store reusable file chunks
    2. Download files in parallel:
        2.1. Prepare to write the file to disk
        2.2. Ask the server "how is this file split into chunks?" using the file's unique hash
            The server responds with:
            - Which chunks make up the complete file
            - Where each chunk can be downloaded from
        2.3. For each needed chunk:
            - Checks if we already have it in our local cache
            - If not, download it from cloud storage (S3)
            - Save it to cache for future use
            - Assemble the chunks in order to recreate the original file</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a98e0033bd7e49b02336ee345b073945f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e0033bd7e49b02336ee345b073945f">&#9670;&nbsp;</a></span>HEADER_FILENAME_PATTERN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">huggingface_hub.file_download.HEADER_FILENAME_PATTERN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c29b004069999ab6945c6461aa892a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c29b004069999ab6945c6461aa892a8">&#9670;&nbsp;</a></span>REGEX_COMMIT_HASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">huggingface_hub.file_download.REGEX_COMMIT_HASH</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab64b9928d5b7aa42f8bb65a9393c7235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64b9928d5b7aa42f8bb65a9393c7235">&#9670;&nbsp;</a></span>REGEX_SHA256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">huggingface_hub.file_download.REGEX_SHA256</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
