<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: pydantic.type_adapter.TypeAdapter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepydantic.html">pydantic</a></li><li class="navelem"><a class="el" href="namespacepydantic_1_1type__adapter.html">type_adapter</a></li><li class="navelem"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html">TypeAdapter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classpydantic_1_1type__adapter_1_1TypeAdapter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pydantic.type_adapter.TypeAdapter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>!! abstract "Usage Documentation" ../concepts/type_adapter.md "`TypeAdapter`"  
 <a href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pydantic.type_adapter.TypeAdapter:</div>
<div class="dyncontent">
<div class="center"><img src="classpydantic_1_1type__adapter_1_1TypeAdapter__inherit__graph.png" border="0" usemap="#apydantic_8type__adapter_8TypeAdapter_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for pydantic.type_adapter.TypeAdapter:</div>
<div class="dyncontent">
<div class="center"><img src="classpydantic_1_1type__adapter_1_1TypeAdapter__coll__graph.png" border="0" usemap="#apydantic_8type__adapter_8TypeAdapter_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4e7ae2796f6a2c332007e006519c42a9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a4e7ae2796f6a2c332007e006519c42a9">__init__</a> (self, type[<a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>] type, *<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a>|None config=..., int _parent_depth=..., str|None module=...)</td></tr>
<tr class="separator:a4e7ae2796f6a2c332007e006519c42a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7001c271781191c7069c6bb372eed99d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a7001c271781191c7069c6bb372eed99d">__init__</a> (self, Any type, *<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a>|None config=..., int _parent_depth=..., str|None module=...)</td></tr>
<tr class="separator:a7001c271781191c7069c6bb372eed99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bcaf9855c7affd8b0f8029f258328d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a99bcaf9855c7affd8b0f8029f258328d">__init__</a> (self, Any type, *<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a>|None config=None, int _parent_depth=2, str|None module=None)</td></tr>
<tr class="separator:a99bcaf9855c7affd8b0f8029f258328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594d93ddf6566b9e509dfde5bcd2a34"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a7594d93ddf6566b9e509dfde5bcd2a34">__repr__</a> (self)</td></tr>
<tr class="separator:a7594d93ddf6566b9e509dfde5bcd2a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc975675d334b73b9f09135513713dfe"><td class="memItemLeft" align="right" valign="top">bool|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#afc975675d334b73b9f09135513713dfe">rebuild</a> (self, *bool force=False, bool raise_errors=True, int _parent_namespace_depth=2, _namespace_utils.MappingNamespace|None _types_namespace=None)</td></tr>
<tr class="separator:afc975675d334b73b9f09135513713dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d36c33f67e132b3b2f48aea1bc1464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#ae0d36c33f67e132b3b2f48aea1bc1464">validate_python</a> (self, Any object, *bool|None strict=None, bool|None from_attributes=None, dict[str, Any]|None context=None, bool|Literal['off', 'on', 'trailing-strings'] experimental_allow_partial=False, bool|None by_alias=None, bool|None by_name=None)</td></tr>
<tr class="separator:ae0d36c33f67e132b3b2f48aea1bc1464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb64bd9559e4130b7050044e4c09dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#aeeb64bd9559e4130b7050044e4c09dde">validate_json</a> (self, str|bytes|bytearray data, *bool|None strict=None, dict[str, Any]|None context=None, bool|Literal['off', 'on', 'trailing-strings'] experimental_allow_partial=False, bool|None by_alias=None, bool|None by_name=None)</td></tr>
<tr class="memdesc:aeeb64bd9559e4130b7050044e4c09dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">!! abstract "Usage Documentation" <a href="../concepts/json.md#json-parsing">JSON Parsing</a>  <a href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#aeeb64bd9559e4130b7050044e4c09dde">More...</a><br /></td></tr>
<tr class="separator:aeeb64bd9559e4130b7050044e4c09dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5953449ce605b3b54d4876f94c4a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a6d5953449ce605b3b54d4876f94c4a90">validate_strings</a> (self, Any obj, *bool|None strict=None, dict[str, Any]|None context=None, bool|Literal['off', 'on', 'trailing-strings'] experimental_allow_partial=False, bool|None by_alias=None, bool|None by_name=None)</td></tr>
<tr class="separator:a6d5953449ce605b3b54d4876f94c4a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862d5bb7a757f40aa2aff0206eb16d02"><td class="memItemLeft" align="right" valign="top">Some[<a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a862d5bb7a757f40aa2aff0206eb16d02">get_default_value</a> (self, *bool|None strict=None, dict[str, Any]|None context=None)</td></tr>
<tr class="separator:a862d5bb7a757f40aa2aff0206eb16d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8dca63948188cdfa48432b666e106a"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a6f8dca63948188cdfa48432b666e106a">dump_python</a> (self, <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> instance, *Literal['json', 'python'] mode='python', IncEx|None include=None, IncEx|None exclude=None, bool|None by_alias=None, bool exclude_unset=False, bool exclude_defaults=False, bool exclude_none=False, bool round_trip=False, bool|Literal['none', 'warn', 'error'] warnings=True, Callable[[Any], Any]|None fallback=None, bool serialize_as_any=False, dict[str, Any]|None context=None)</td></tr>
<tr class="separator:a6f8dca63948188cdfa48432b666e106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbea677c706bec6ea7359a2553d8177"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a0bbea677c706bec6ea7359a2553d8177">dump_json</a> (self, <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> instance, *int|None indent=None, IncEx|None include=None, IncEx|None exclude=None, bool|None by_alias=None, bool exclude_unset=False, bool exclude_defaults=False, bool exclude_none=False, bool round_trip=False, bool|Literal['none', 'warn', 'error'] warnings=True, Callable[[Any], Any]|None fallback=None, bool serialize_as_any=False, dict[str, Any]|None context=None)</td></tr>
<tr class="memdesc:a0bbea677c706bec6ea7359a2553d8177"><td class="mdescLeft">&#160;</td><td class="mdescRight">!! abstract "Usage Documentation" <a href="../concepts/json.md#json-serialization">JSON Serialization</a>  <a href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a0bbea677c706bec6ea7359a2553d8177">More...</a><br /></td></tr>
<tr class="separator:a0bbea677c706bec6ea7359a2553d8177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83425c7fb7bf744036846bcf8f7ba680"><td class="memItemLeft" align="right" valign="top">dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a83425c7fb7bf744036846bcf8f7ba680">json_schema</a> (self, *bool by_alias=True, str ref_template=DEFAULT_REF_TEMPLATE, type[<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>] schema_generator=<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>, JsonSchemaMode mode='validation')</td></tr>
<tr class="separator:a83425c7fb7bf744036846bcf8f7ba680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7ae2796f6a2c332007e006519c42a9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a4e7ae2796f6a2c332007e006519c42a9">__init__</a> (self, type[<a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>] type, *<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a>|None config=..., int _parent_depth=..., str|None module=...)</td></tr>
<tr class="separator:a4e7ae2796f6a2c332007e006519c42a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7001c271781191c7069c6bb372eed99d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a7001c271781191c7069c6bb372eed99d">__init__</a> (self, Any type, *<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a>|None config=..., int _parent_depth=..., str|None module=...)</td></tr>
<tr class="separator:a7001c271781191c7069c6bb372eed99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bcaf9855c7affd8b0f8029f258328d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a99bcaf9855c7affd8b0f8029f258328d">__init__</a> (self, Any type, *<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a>|None config=None, int _parent_depth=2, str|None module=None)</td></tr>
<tr class="separator:a99bcaf9855c7affd8b0f8029f258328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594d93ddf6566b9e509dfde5bcd2a34"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a7594d93ddf6566b9e509dfde5bcd2a34">__repr__</a> (self)</td></tr>
<tr class="separator:a7594d93ddf6566b9e509dfde5bcd2a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc975675d334b73b9f09135513713dfe"><td class="memItemLeft" align="right" valign="top">bool|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#afc975675d334b73b9f09135513713dfe">rebuild</a> (self, *bool force=False, bool raise_errors=True, int _parent_namespace_depth=2, _namespace_utils.MappingNamespace|None _types_namespace=None)</td></tr>
<tr class="separator:afc975675d334b73b9f09135513713dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8395706ca857bab6d3cad7e1b92c870d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a8395706ca857bab6d3cad7e1b92c870d">validate_python</a> (self, Any object, *bool|None strict=None, bool|None from_attributes=None, dict[str, Any]|None context=None, bool|Literal['off', 'on', 'trailing-strings'] experimental_allow_partial=False)</td></tr>
<tr class="separator:a8395706ca857bab6d3cad7e1b92c870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b3c3b720c1d09438c227c79c7ef41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a46b3c3b720c1d09438c227c79c7ef41e">validate_json</a> (self, str|bytes|bytearray data, *bool|None strict=None, dict[str, Any]|None context=None, bool|Literal['off', 'on', 'trailing-strings'] experimental_allow_partial=False)</td></tr>
<tr class="separator:a46b3c3b720c1d09438c227c79c7ef41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf3a5759d75056d680d36508e17c1b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#abcf3a5759d75056d680d36508e17c1b9">validate_strings</a> (self, Any obj, *bool|None strict=None, dict[str, Any]|None context=None, bool|Literal['off', 'on', 'trailing-strings'] experimental_allow_partial=False)</td></tr>
<tr class="separator:abcf3a5759d75056d680d36508e17c1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862d5bb7a757f40aa2aff0206eb16d02"><td class="memItemLeft" align="right" valign="top">Some[<a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a862d5bb7a757f40aa2aff0206eb16d02">get_default_value</a> (self, *bool|None strict=None, dict[str, Any]|None context=None)</td></tr>
<tr class="separator:a862d5bb7a757f40aa2aff0206eb16d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8796f1c21371c725915502a56e211b3c"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a8796f1c21371c725915502a56e211b3c">dump_python</a> (self, <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> instance, *Literal['json', 'python'] mode='python', IncEx|None include=None, IncEx|None exclude=None, bool by_alias=False, bool exclude_unset=False, bool exclude_defaults=False, bool exclude_none=False, bool round_trip=False, bool|Literal['none', 'warn', 'error'] warnings=True, bool serialize_as_any=False, dict[str, Any]|None context=None)</td></tr>
<tr class="separator:a8796f1c21371c725915502a56e211b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a20ce47367f296ccc96d1c967accdc1"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a8a20ce47367f296ccc96d1c967accdc1">dump_json</a> (self, <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> instance, *int|None indent=None, IncEx|None include=None, IncEx|None exclude=None, bool by_alias=False, bool exclude_unset=False, bool exclude_defaults=False, bool exclude_none=False, bool round_trip=False, bool|Literal['none', 'warn', 'error'] warnings=True, bool serialize_as_any=False, dict[str, Any]|None context=None)</td></tr>
<tr class="separator:a8a20ce47367f296ccc96d1c967accdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83425c7fb7bf744036846bcf8f7ba680"><td class="memItemLeft" align="right" valign="top">dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a83425c7fb7bf744036846bcf8f7ba680">json_schema</a> (self, *bool by_alias=True, str ref_template=DEFAULT_REF_TEMPLATE, type[<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>] schema_generator=<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>, JsonSchemaMode mode='validation')</td></tr>
<tr class="separator:a83425c7fb7bf744036846bcf8f7ba680"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8d2df0132b12af0e42e5585149a21391"><td class="memItemLeft" align="right" valign="top">tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a8d2df0132b12af0e42e5585149a21391">json_schemas</a> (Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, <a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html">TypeAdapter</a>[Any]]] inputs, *bool by_alias=True, str|None title=None, str|None description=None, str ref_template=DEFAULT_REF_TEMPLATE, type[<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>] schema_generator=<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>)</td></tr>
<tr class="separator:a8d2df0132b12af0e42e5585149a21391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2df0132b12af0e42e5585149a21391"><td class="memItemLeft" align="right" valign="top">tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a8d2df0132b12af0e42e5585149a21391">json_schemas</a> (Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, <a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html">TypeAdapter</a>[Any]]] inputs, *bool by_alias=True, str|None title=None, str|None description=None, str ref_template=DEFAULT_REF_TEMPLATE, type[<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>] schema_generator=<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>)</td></tr>
<tr class="separator:a8d2df0132b12af0e42e5585149a21391"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad4e0a33d66e62a21b1d26c8e2820152f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#ad4e0a33d66e62a21b1d26c8e2820152f">pydantic_complete</a></td></tr>
<tr class="separator:ad4e0a33d66e62a21b1d26c8e2820152f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b8394a1a927e8baab8b5a0746597cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#aa7b8394a1a927e8baab8b5a0746597cc">core_schema</a></td></tr>
<tr class="separator:aa7b8394a1a927e8baab8b5a0746597cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b196f39add757ba438d54a51c653d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a55b196f39add757ba438d54a51c653d5">validator</a></td></tr>
<tr class="separator:a55b196f39add757ba438d54a51c653d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7a71c29e7009570da9c4651b6aaf46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html#a8e7a71c29e7009570da9c4651b6aaf46">serializer</a></td></tr>
<tr class="separator:a8e7a71c29e7009570da9c4651b6aaf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>!! abstract "Usage Documentation" ../concepts/type_adapter.md "`TypeAdapter`" </p>
<p>Type adapters provide a flexible way to perform validation and serialization based on a Python type.</p>
<p>A <code><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></code> instance exposes some of the functionality from <code>BaseModel</code> instance methods for types that do not have such methods (such as dataclasses, primitive types, and more).</p>
<p><b>Note:</b> <code><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></code> instances are not types, and cannot be used as type annotations for fields.</p>
<p>Args: type: The type associated with the <code><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></code>. config: Configuration for the <code><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></code>, should be a dictionary conforming to [<code>ConfigDict</code>][<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">pydantic.config.ConfigDict</a>].</p>
<p>!!! note You cannot provide a configuration when instantiating a <code><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></code> if the type you're using has its own config that cannot be overridden (ex: <code>BaseModel</code>, <code>TypedDict</code>, and <code>dataclass</code>). A <a href="../errors/usage_errors.md#type-adapter-config-unused"><code>type-adapter-config-unused</code></a> error will be raised in this case. _parent_depth: Depth at which to search for the [parent frame][frame-objects]. This frame is used when resolving forward annotations during schema building, by looking for the globals and locals of this frame. Defaults to 2, which will result in the frame where the <code><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></code> was instantiated.</p>
<p>!!! note This parameter is named with an underscore to suggest its private nature and discourage use. It may be deprecated in a minor version, so we only recommend using it if you're comfortable with potential change in behavior/support. It's default value is 2 because internally, the <code><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></code> class makes another call to fetch the frame. module: The module that passes to plugin if provided.</p>
<p>Attributes: core_schema: The core schema for the type. validator: The schema validator for the type. serializer: The schema serializer for the type. pydantic_complete: Whether the core schema for the type is successfully built.</p>
<p>??? tip "Compatibility with `mypy`" Depending on the type used, <code>mypy</code> might raise an error when instantiating a <code><a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></code>. As a workaround, you can explicitly annotate your variable:</p>
<p>```py from typing import Union</p>
<p>from pydantic import <a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a></p>
<p>ta: <a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html" title="!! abstract &quot;Usage Documentation&quot; ../concepts/type_adapter.md &quot;`TypeAdapter`&quot;">TypeAdapter</a>[Union[str, int]] = TypeAdapter(Union[str, int]) # type: ignore[arg-type] ```</p>
<p>??? info "Namespace management nuances and implementation details" </p><pre class="fragment">Here, we collect some notes on namespace management, and subtle differences from `BaseModel`:

`BaseModel` uses its own `__module__` to find out where it was defined
and then looks for symbols to resolve forward references in those globals.
On the other hand, `TypeAdapter` can be initialized with arbitrary objects,
which may not be types and thus do not have a `__module__` available.
So instead we look at the globals in our parent stack frame.

It is expected that the `ns_resolver` passed to this function will have the correct
namespace for the type we're adapting. See the source code for `TypeAdapter.__init__`
and `TypeAdapter.rebuild` for various ways to construct this namespace.

This works for the case where this function is called in a module that
has the target of forward references in its scope, but
does not always work for more complex cases.

For example, take the following:

```python {title="a.py"}
IntList = list[int]
OuterDict = dict[str, 'IntList']
```

```python {test="skip" title="b.py"}
from a import OuterDict

from pydantic import TypeAdapter

IntList = int  # replaces the symbol the forward reference is looking for
v = TypeAdapter(OuterDict)
v({'x': 1})  # should fail but doesn't
```

If `OuterDict` were a `BaseModel`, this would work because it would resolve
the forward reference within the `a.py` namespace.
But `TypeAdapter(OuterDict)` can't determine what module `OuterDict` came from.

In other words, the assumption that _all_ forward references exist in the
module we are being called from is not technically always true.
Although most of the time it is and it works fine for recursive models and such,
`BaseModel`'s behavior isn't perfect either and _can_ break in similar ways,
so there is no right or wrong between the two.

But at the very least this behavior is _subtly_ different from `BaseModel`'s.
</pre><pre class="fragment">Usage docs: https://docs.pydantic.dev/2.10/concepts/type_adapter/

Type adapters provide a flexible way to perform validation and serialization based on a Python type.

A `TypeAdapter` instance exposes some of the functionality from `BaseModel` instance methods
for types that do not have such methods (such as dataclasses, primitive types, and more).

**Note:** `TypeAdapter` instances are not types, and cannot be used as type annotations for fields.

Args:
    type: The type associated with the `TypeAdapter`.
    config: Configuration for the `TypeAdapter`, should be a dictionary conforming to
        [`ConfigDict`][pydantic.config.ConfigDict].

        !!! note
            You cannot provide a configuration when instantiating a `TypeAdapter` if the type you're using
            has its own config that cannot be overridden (ex: `BaseModel`, `TypedDict`, and `dataclass`). A
            [`type-adapter-config-unused`](../errors/usage_errors.md#type-adapter-config-unused) error will
            be raised in this case.
    _parent_depth: Depth at which to search for the [parent frame][frame-objects]. This frame is used when
        resolving forward annotations during schema building, by looking for the globals and locals of this
        frame. Defaults to 2, which will result in the frame where the `TypeAdapter` was instantiated.

        !!! note
            This parameter is named with an underscore to suggest its private nature and discourage use.
            It may be deprecated in a minor version, so we only recommend using it if you're comfortable
            with potential change in behavior/support. It's default value is 2 because internally,
            the `TypeAdapter` class makes another call to fetch the frame.
    module: The module that passes to plugin if provided.

Attributes:
    core_schema: The core schema for the type.
    validator: The schema validator for the type.
    serializer: The schema serializer for the type.
    pydantic_complete: Whether the core schema for the type is successfully built.

??? tip "Compatibility with `mypy`"
    Depending on the type used, `mypy` might raise an error when instantiating a `TypeAdapter`. As a workaround, you can explicitly
    annotate your variable:

    ```py
    from typing import Union

    from pydantic import TypeAdapter

    ta: TypeAdapter[Union[str, int]] = TypeAdapter(Union[str, int])  # type: ignore[arg-type]
    ```

??? info "Namespace management nuances and implementation details"

    Here, we collect some notes on namespace management, and subtle differences from `BaseModel`:

    `BaseModel` uses its own `__module__` to find out where it was defined
    and then looks for symbols to resolve forward references in those globals.
    On the other hand, `TypeAdapter` can be initialized with arbitrary objects,
    which may not be types and thus do not have a `__module__` available.
    So instead we look at the globals in our parent stack frame.

    It is expected that the `ns_resolver` passed to this function will have the correct
    namespace for the type we're adapting. See the source code for `TypeAdapter.__init__`
    and `TypeAdapter.rebuild` for various ways to construct this namespace.

    This works for the case where this function is called in a module that
    has the target of forward references in its scope, but
    does not always work for more complex cases.

    For example, take the following:

    ```python {title="a.py"}
    from typing import Dict, List

    IntList = List[int]
    OuterDict = Dict[str, 'IntList']
    ```

    ```python {test="skip" title="b.py"}
    from a import OuterDict

    from pydantic import TypeAdapter

    IntList = int  # replaces the symbol the forward reference is looking for
    v = TypeAdapter(OuterDict)
    v({'x': 1})  # should fail but doesn't
    ```

    If `OuterDict` were a `BaseModel`, this would work because it would resolve
    the forward reference within the `a.py` namespace.
    But `TypeAdapter(OuterDict)` can't determine what module `OuterDict` came from.

    In other words, the assumption that _all_ forward references exist in the
    module we are being called from is not technically always true.
    Although most of the time it is and it works fine for recursive models and such,
    `BaseModel`'s behavior isn't perfect either and _can_ break in similar ways,
    so there is no right or wrong between the two.

    But at the very least this behavior is _subtly_ different from `BaseModel`'s.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4e7ae2796f6a2c332007e006519c42a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7ae2796f6a2c332007e006519c42a9">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic.type_adapter.TypeAdapter.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>]&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_parent_depth</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>module</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7001c271781191c7069c6bb372eed99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7001c271781191c7069c6bb372eed99d">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic.type_adapter.TypeAdapter.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_parent_depth</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>module</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99bcaf9855c7affd8b0f8029f258328d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bcaf9855c7affd8b0f8029f258328d">&#9670;&nbsp;</a></span>__init__() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic.type_adapter.TypeAdapter.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_parent_depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>module</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e7ae2796f6a2c332007e006519c42a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7ae2796f6a2c332007e006519c42a9">&#9670;&nbsp;</a></span>__init__() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic.type_adapter.TypeAdapter.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>]&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_parent_depth</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>module</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7001c271781191c7069c6bb372eed99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7001c271781191c7069c6bb372eed99d">&#9670;&nbsp;</a></span>__init__() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic.type_adapter.TypeAdapter.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_parent_depth</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>module</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99bcaf9855c7affd8b0f8029f258328d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bcaf9855c7affd8b0f8029f258328d">&#9670;&nbsp;</a></span>__init__() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic.type_adapter.TypeAdapter.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classpydantic_1_1config_1_1ConfigDict.html">ConfigDict</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_parent_depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>module</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7594d93ddf6566b9e509dfde5bcd2a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7594d93ddf6566b9e509dfde5bcd2a34">&#9670;&nbsp;</a></span>__repr__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str pydantic.type_adapter.TypeAdapter.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7594d93ddf6566b9e509dfde5bcd2a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7594d93ddf6566b9e509dfde5bcd2a34">&#9670;&nbsp;</a></span>__repr__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str pydantic.type_adapter.TypeAdapter.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a20ce47367f296ccc96d1c967accdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a20ce47367f296ccc96d1c967accdc1">&#9670;&nbsp;</a></span>dump_json() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bytes pydantic.type_adapter.TypeAdapter.dump_json </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>indent</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncEx | None &#160;</td>
          <td class="paramname"><em>include</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncEx | None &#160;</td>
          <td class="paramname"><em>exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_unset</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_defaults</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_none</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>round_trip</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['none', 'warn', 'error'] &#160;</td>
          <td class="paramname"><em>warnings</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>serialize_as_any</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-serialization

Serialize an instance of the adapted type to JSON.

Args:
    instance: The instance to be serialized.
    indent: Number of spaces for JSON indentation.
    include: Fields to include.
    exclude: Fields to exclude.
    by_alias: Whether to use alias names for field names.
    exclude_unset: Whether to exclude unset fields.
    exclude_defaults: Whether to exclude fields with default values.
    exclude_none: Whether to exclude fields with a value of `None`.
    round_trip: Whether to serialize and deserialize the instance to ensure round-tripping.
    warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
        "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
    context: Additional context to pass to the serializer.

Returns:
    The JSON representation of the given instance as bytes.
</pre> 
</div>
</div>
<a id="a0bbea677c706bec6ea7359a2553d8177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbea677c706bec6ea7359a2553d8177">&#9670;&nbsp;</a></span>dump_json() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bytes pydantic.type_adapter.TypeAdapter.dump_json </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>indent</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncEx | None &#160;</td>
          <td class="paramname"><em>include</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncEx | None &#160;</td>
          <td class="paramname"><em>exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_unset</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_defaults</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_none</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>round_trip</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['none', 'warn', 'error'] &#160;</td>
          <td class="paramname"><em>warnings</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[Any], Any] | None &#160;</td>
          <td class="paramname"><em>fallback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>serialize_as_any</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!! abstract "Usage Documentation" <a href="../concepts/json.md#json-serialization">JSON Serialization</a> </p>
<p>Serialize an instance of the adapted type to JSON.</p>
<p>Args: instance: The instance to be serialized. indent: Number of spaces for JSON indentation. include: Fields to include. exclude: Fields to exclude. by_alias: Whether to use alias names for field names. exclude_unset: Whether to exclude unset fields. exclude_defaults: Whether to exclude fields with default values. exclude_none: Whether to exclude fields with a value of <code>None</code>. round_trip: Whether to serialize and deserialize the instance to ensure round-tripping. warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. fallback: A function to call when an unknown value is encountered. If not provided, a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError] error is raised. serialize_as_any: Whether to serialize fields with duck-typing serialization behavior. context: Additional context to pass to the serializer.</p>
<p>Returns: The JSON representation of the given instance as bytes. </p>

</div>
</div>
<a id="a8796f1c21371c725915502a56e211b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8796f1c21371c725915502a56e211b3c">&#9670;&nbsp;</a></span>dump_python() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic.type_adapter.TypeAdapter.dump_python </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal['json', 'python'] &#160;</td>
          <td class="paramname"><em>mode</em> = <code>'python'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncEx | None &#160;</td>
          <td class="paramname"><em>include</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncEx | None &#160;</td>
          <td class="paramname"><em>exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_unset</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_defaults</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_none</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>round_trip</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['none', 'warn', 'error'] &#160;</td>
          <td class="paramname"><em>warnings</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>serialize_as_any</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dump an instance of the adapted type to a Python object.

Args:
    instance: The Python object to serialize.
    mode: The output format.
    include: Fields to include in the output.
    exclude: Fields to exclude from the output.
    by_alias: Whether to use alias names for field names.
    exclude_unset: Whether to exclude unset fields.
    exclude_defaults: Whether to exclude fields with default values.
    exclude_none: Whether to exclude fields with None values.
    round_trip: Whether to output the serialized data in a way that is compatible with deserialization.
    warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
        "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
    context: Additional context to pass to the serializer.

Returns:
    The serialized object.
</pre> 
</div>
</div>
<a id="a6f8dca63948188cdfa48432b666e106a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8dca63948188cdfa48432b666e106a">&#9670;&nbsp;</a></span>dump_python() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic.type_adapter.TypeAdapter.dump_python </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal['json', 'python'] &#160;</td>
          <td class="paramname"><em>mode</em> = <code>'python'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncEx | None &#160;</td>
          <td class="paramname"><em>include</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncEx | None &#160;</td>
          <td class="paramname"><em>exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_unset</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_defaults</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exclude_none</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>round_trip</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['none', 'warn', 'error'] &#160;</td>
          <td class="paramname"><em>warnings</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[Any], Any] | None &#160;</td>
          <td class="paramname"><em>fallback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>serialize_as_any</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dump an instance of the adapted type to a Python object.

Args:
    instance: The Python object to serialize.
    mode: The output format.
    include: Fields to include in the output.
    exclude: Fields to exclude from the output.
    by_alias: Whether to use alias names for field names.
    exclude_unset: Whether to exclude unset fields.
    exclude_defaults: Whether to exclude fields with default values.
    exclude_none: Whether to exclude fields with None values.
    round_trip: Whether to output the serialized data in a way that is compatible with deserialization.
    warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
        "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
    fallback: A function to call when an unknown value is encountered. If not provided,
        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
    context: Additional context to pass to the serializer.

Returns:
    The serialized object.
</pre> 
</div>
</div>
<a id="a862d5bb7a757f40aa2aff0206eb16d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862d5bb7a757f40aa2aff0206eb16d02">&#9670;&nbsp;</a></span>get_default_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Some[<a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>] | None pydantic.type_adapter.TypeAdapter.get_default_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the default value for the wrapped type.

Args:
    strict: Whether to strictly check types.
    context: Additional context to pass to the validator.

Returns:
    The default value wrapped in a `Some` if there is one or None if not.
</pre> 
</div>
</div>
<a id="a862d5bb7a757f40aa2aff0206eb16d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862d5bb7a757f40aa2aff0206eb16d02">&#9670;&nbsp;</a></span>get_default_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Some[<a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a>] | None pydantic.type_adapter.TypeAdapter.get_default_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the default value for the wrapped type.

Args:
    strict: Whether to strictly check types.
    context: Additional context to pass to the validator.

Returns:
    The default value wrapped in a `Some` if there is one or None if not.
</pre> 
</div>
</div>
<a id="a83425c7fb7bf744036846bcf8f7ba680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83425c7fb7bf744036846bcf8f7ba680">&#9670;&nbsp;</a></span>json_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, Any] pydantic.type_adapter.TypeAdapter.json_schema </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>ref_template</em> = <code>DEFAULT_REF_TEMPLATE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>] &#160;</td>
          <td class="paramname"><em>schema_generator</em> = <code><a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JsonSchemaMode &#160;</td>
          <td class="paramname"><em>mode</em> = <code>'validation'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a JSON schema for the adapted type.

Args:
    by_alias: Whether to use alias names for field names.
    ref_template: The format string used for generating $ref strings.
    schema_generator: The generator class used for creating the schema.
    mode: The mode to use for schema generation.

Returns:
    The JSON schema for the model as a dictionary.
</pre> 
</div>
</div>
<a id="a83425c7fb7bf744036846bcf8f7ba680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83425c7fb7bf744036846bcf8f7ba680">&#9670;&nbsp;</a></span>json_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, Any] pydantic.type_adapter.TypeAdapter.json_schema </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>ref_template</em> = <code>DEFAULT_REF_TEMPLATE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>] &#160;</td>
          <td class="paramname"><em>schema_generator</em> = <code><a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JsonSchemaMode &#160;</td>
          <td class="paramname"><em>mode</em> = <code>'validation'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a JSON schema for the adapted type.

Args:
    by_alias: Whether to use alias names for field names.
    ref_template: The format string used for generating $ref strings.
    schema_generator: The generator class used for creating the schema.
    mode: The mode to use for schema generation.

Returns:
    The JSON schema for the model as a dictionary.
</pre> 
</div>
</div>
<a id="a8d2df0132b12af0e42e5585149a21391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2df0132b12af0e42e5585149a21391">&#9670;&nbsp;</a></span>json_schemas() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue] pydantic.type_adapter.TypeAdapter.json_schemas </td>
          <td>(</td>
          <td class="paramtype">Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, <a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html">TypeAdapter</a>[Any]]]&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>title</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>description</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>ref_template</em> = <code>DEFAULT_REF_TEMPLATE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>] &#160;</td>
          <td class="paramname"><em>schema_generator</em> = <code><a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generate a JSON schema including definitions from multiple type adapters.

Args:
    inputs: Inputs to schema generation. The first two items will form the keys of the (first)
        output mapping; the type adapters will provide the core schemas that get converted into
        definitions in the output JSON schema.
    by_alias: Whether to use alias names.
    title: The title for the schema.
    description: The description for the schema.
    ref_template: The format string used for generating $ref strings.
    schema_generator: The generator class used for creating the schema.

Returns:
    A tuple where:

        - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and
            whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have
            JsonRef references to definitions that are defined in the second returned element.)
        - The second element is a JSON schema containing all definitions referenced in the first returned
            element, along with the optional title and description keys.</pre> 
</div>
</div>
<a id="a8d2df0132b12af0e42e5585149a21391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2df0132b12af0e42e5585149a21391">&#9670;&nbsp;</a></span>json_schemas() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue] pydantic.type_adapter.TypeAdapter.json_schemas </td>
          <td>(</td>
          <td class="paramtype">Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, <a class="el" href="classpydantic_1_1type__adapter_1_1TypeAdapter.html">TypeAdapter</a>[Any]]]&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>title</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>description</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>ref_template</em> = <code>DEFAULT_REF_TEMPLATE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a>] &#160;</td>
          <td class="paramname"><em>schema_generator</em> = <code><a class="el" href="classpydantic_1_1json__schema_1_1GenerateJsonSchema.html">GenerateJsonSchema</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generate a JSON schema including definitions from multiple type adapters.

Args:
    inputs: Inputs to schema generation. The first two items will form the keys of the (first)
        output mapping; the type adapters will provide the core schemas that get converted into
        definitions in the output JSON schema.
    by_alias: Whether to use alias names.
    title: The title for the schema.
    description: The description for the schema.
    ref_template: The format string used for generating $ref strings.
    schema_generator: The generator class used for creating the schema.

Returns:
    A tuple where:

        - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and
            whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have
            JsonRef references to definitions that are defined in the second returned element.)
        - The second element is a JSON schema containing all definitions referenced in the first returned
            element, along with the optional title and description keys.</pre> 
</div>
</div>
<a id="afc975675d334b73b9f09135513713dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc975675d334b73b9f09135513713dfe">&#9670;&nbsp;</a></span>rebuild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool | None pydantic.type_adapter.TypeAdapter.rebuild </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raise_errors</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_parent_namespace_depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_namespace_utils.MappingNamespace | None &#160;</td>
          <td class="paramname"><em>_types_namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to rebuild the pydantic-core schema for the adapter's type.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

Args:
    force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.
    raise_errors: Whether to raise errors, defaults to `True`.
    _parent_namespace_depth: Depth at which to search for the [parent frame][frame-objects]. This
        frame is used when resolving forward annotations during schema rebuilding, by looking for
        the locals of this frame. Defaults to 2, which will result in the frame where the method
        was called.
    _types_namespace: An explicit types namespace to use, instead of using the local namespace
        from the parent frame. Defaults to `None`.

Returns:
    Returns `None` if the schema is already "complete" and rebuilding was not required.
    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
</pre> 
</div>
</div>
<a id="afc975675d334b73b9f09135513713dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc975675d334b73b9f09135513713dfe">&#9670;&nbsp;</a></span>rebuild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool | None pydantic.type_adapter.TypeAdapter.rebuild </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raise_errors</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>_parent_namespace_depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_namespace_utils.MappingNamespace | None &#160;</td>
          <td class="paramname"><em>_types_namespace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to rebuild the pydantic-core schema for the adapter's type.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

Args:
    force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.
    raise_errors: Whether to raise errors, defaults to `True`.
    _parent_namespace_depth: Depth at which to search for the [parent frame][frame-objects]. This
        frame is used when resolving forward annotations during schema rebuilding, by looking for
        the locals of this frame. Defaults to 2, which will result in the frame where the method
        was called.
    _types_namespace: An explicit types namespace to use, instead of using the local namespace
        from the parent frame. Defaults to `None`.

Returns:
    Returns `None` if the schema is already "complete" and rebuilding was not required.
    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
</pre> 
</div>
</div>
<a id="a46b3c3b720c1d09438c227c79c7ef41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b3c3b720c1d09438c227c79c7ef41e">&#9670;&nbsp;</a></span>validate_json() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> pydantic.type_adapter.TypeAdapter.validate_json </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | bytes | bytearray&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['off', 'on', 'trailing-strings'] &#160;</td>
          <td class="paramname"><em>experimental_allow_partial</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing

Validate a JSON string or bytes against the model.

Args:
    data: The JSON data to validate against the model.
    strict: Whether to strictly check types.
    context: Additional context to use during validation.
    experimental_allow_partial: **Experimental** whether to enable
        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.
        * False / 'off': Default behavior, no partial validation.
        * True / 'on': Enable partial validation.
        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.

Returns:
    The validated object.
</pre> 
</div>
</div>
<a id="aeeb64bd9559e4130b7050044e4c09dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb64bd9559e4130b7050044e4c09dde">&#9670;&nbsp;</a></span>validate_json() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> pydantic.type_adapter.TypeAdapter.validate_json </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | bytes | bytearray&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['off', 'on', 'trailing-strings'] &#160;</td>
          <td class="paramname"><em>experimental_allow_partial</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>by_name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!! abstract "Usage Documentation" <a href="../concepts/json.md#json-parsing">JSON Parsing</a> </p>
<p>Validate a JSON string or bytes against the model.</p>
<p>Args: data: The JSON data to validate against the model. strict: Whether to strictly check types. context: Additional context to use during validation. experimental_allow_partial: <b>Experimental</b> whether to enable <a href="../concepts/experimental.md#partial-validation">partial validation</a>, e.g. to process streams.</p><ul>
<li>False / 'off': Default behavior, no partial validation.</li>
<li>True / 'on': Enable partial validation.</li>
<li>'trailing-strings': Enable partial validation and allow trailing strings in the input. by_alias: Whether to use the field's alias when validating against the provided input data. by_name: Whether to use the field's name when validating against the provided input data.</li>
</ul>
<p>Returns: The validated object. </p>

</div>
</div>
<a id="a8395706ca857bab6d3cad7e1b92c870d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8395706ca857bab6d3cad7e1b92c870d">&#9670;&nbsp;</a></span>validate_python() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> pydantic.type_adapter.TypeAdapter.validate_python </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>from_attributes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['off', 'on', 'trailing-strings'] &#160;</td>
          <td class="paramname"><em>experimental_allow_partial</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validate a Python object against the model.

Args:
    object: The Python object to validate against the model.
    strict: Whether to strictly check types.
    from_attributes: Whether to extract data from object attributes.
    context: Additional context to pass to the validator.
    experimental_allow_partial: **Experimental** whether to enable
        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.
        * False / 'off': Default behavior, no partial validation.
        * True / 'on': Enable partial validation.
        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.

!!! note
    When using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`
    argument is not supported.

Returns:
    The validated object.
</pre> 
</div>
</div>
<a id="ae0d36c33f67e132b3b2f48aea1bc1464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d36c33f67e132b3b2f48aea1bc1464">&#9670;&nbsp;</a></span>validate_python() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> pydantic.type_adapter.TypeAdapter.validate_python </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>from_attributes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['off', 'on', 'trailing-strings'] &#160;</td>
          <td class="paramname"><em>experimental_allow_partial</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>by_name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validate a Python object against the model.

Args:
    object: The Python object to validate against the model.
    strict: Whether to strictly check types.
    from_attributes: Whether to extract data from object attributes.
    context: Additional context to pass to the validator.
    experimental_allow_partial: **Experimental** whether to enable
        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.
        * False / 'off': Default behavior, no partial validation.
        * True / 'on': Enable partial validation.
        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.
    by_alias: Whether to use the field's alias when validating against the provided input data.
    by_name: Whether to use the field's name when validating against the provided input data.

!!! note
    When using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`
    argument is not supported.

Returns:
    The validated object.
</pre> 
</div>
</div>
<a id="abcf3a5759d75056d680d36508e17c1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf3a5759d75056d680d36508e17c1b9">&#9670;&nbsp;</a></span>validate_strings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> pydantic.type_adapter.TypeAdapter.validate_strings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['off', 'on', 'trailing-strings'] &#160;</td>
          <td class="paramname"><em>experimental_allow_partial</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validate object contains string data against the model.

Args:
    obj: The object contains string data to validate.
    strict: Whether to strictly check types.
    context: Additional context to use during validation.
    experimental_allow_partial: **Experimental** whether to enable
        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.
        * False / 'off': Default behavior, no partial validation.
        * True / 'on': Enable partial validation.
        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.

Returns:
    The validated object.
</pre> 
</div>
</div>
<a id="a6d5953449ce605b3b54d4876f94c4a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5953449ce605b3b54d4876f94c4a90">&#9670;&nbsp;</a></span>validate_strings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepydantic_1_1type__adapter.html#a863692c7dc2dacec2a9f9c54558691a0">T</a> pydantic.type_adapter.TypeAdapter.validate_strings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | Literal['off', 'on', 'trailing-strings'] &#160;</td>
          <td class="paramname"><em>experimental_allow_partial</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>by_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>by_name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validate object contains string data against the model.

Args:
    obj: The object contains string data to validate.
    strict: Whether to strictly check types.
    context: Additional context to use during validation.
    experimental_allow_partial: **Experimental** whether to enable
        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.
        * False / 'off': Default behavior, no partial validation.
        * True / 'on': Enable partial validation.
        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.
    by_alias: Whether to use the field's alias when validating against the provided input data.
    by_name: Whether to use the field's name when validating against the provided input data.

Returns:
    The validated object.
</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa7b8394a1a927e8baab8b5a0746597cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b8394a1a927e8baab8b5a0746597cc">&#9670;&nbsp;</a></span>core_schema</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic.type_adapter.TypeAdapter.core_schema</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4e0a33d66e62a21b1d26c8e2820152f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e0a33d66e62a21b1d26c8e2820152f">&#9670;&nbsp;</a></span>pydantic_complete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic.type_adapter.TypeAdapter.pydantic_complete</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e7a71c29e7009570da9c4651b6aaf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7a71c29e7009570da9c4651b6aaf46">&#9670;&nbsp;</a></span>serializer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic.type_adapter.TypeAdapter.serializer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55b196f39add757ba438d54a51c653d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b196f39add757ba438d54a51c653d5">&#9670;&nbsp;</a></span>validator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic.type_adapter.TypeAdapter.validator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/pydantic/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2pydantic_2type__adapter_8py.html">type_adapter.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
