<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: numpy._core.defchararray Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>numpy</b></li><li class="navelem"><a class="el" href="namespacenumpy_1_1__core.html">_core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html">defchararray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">numpy._core.defchararray Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1__core_1_1defchararray_1_1chararray.html">chararray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaf737deaa1cc77f23616d59031fd972b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#aaf737deaa1cc77f23616d59031fd972b">equal</a> (x1, x2)</td></tr>
<tr class="separator:aaf737deaa1cc77f23616d59031fd972b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23275872707dc024de9f20f8d436b9fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#a23275872707dc024de9f20f8d436b9fe">not_equal</a> (x1, x2)</td></tr>
<tr class="separator:a23275872707dc024de9f20f8d436b9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9148363d93185c6f3c398189d53233e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#a9148363d93185c6f3c398189d53233e4">greater_equal</a> (x1, x2)</td></tr>
<tr class="separator:a9148363d93185c6f3c398189d53233e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4476cb11f29c84c3a46d176443a3daa9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#a4476cb11f29c84c3a46d176443a3daa9">less_equal</a> (x1, x2)</td></tr>
<tr class="separator:a4476cb11f29c84c3a46d176443a3daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ba62746bcb59d7da92d0560880e8a1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#a67ba62746bcb59d7da92d0560880e8a1">greater</a> (x1, x2)</td></tr>
<tr class="separator:a67ba62746bcb59d7da92d0560880e8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbdd45dea2f901a65e6ea3ab0c221bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#a4bbdd45dea2f901a65e6ea3ab0c221bb">less</a> (x1, x2)</td></tr>
<tr class="separator:a4bbdd45dea2f901a65e6ea3ab0c221bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eb9735b1da666dacb20a00e35ffe32"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#ab5eb9735b1da666dacb20a00e35ffe32">multiply</a> (a, i)</td></tr>
<tr class="separator:ab5eb9735b1da666dacb20a00e35ffe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c7c4d1565f50f2f9486c3eae610179"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#a03c7c4d1565f50f2f9486c3eae610179">partition</a> (a, sep)</td></tr>
<tr class="separator:a03c7c4d1565f50f2f9486c3eae610179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab97c3a4be1bcd17b96a2157bb6685a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#abab97c3a4be1bcd17b96a2157bb6685a">rpartition</a> (a, sep)</td></tr>
<tr class="separator:abab97c3a4be1bcd17b96a2157bb6685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7e9f07337b6dad61c7cf6e5cd1d65d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#a6f7e9f07337b6dad61c7cf6e5cd1d65d">array</a> (obj, itemsize=None, copy=True, unicode=None, order=None)</td></tr>
<tr class="separator:a6f7e9f07337b6dad61c7cf6e5cd1d65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb702f428542716d190f3272c1fa9b42"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#aeb702f428542716d190f3272c1fa9b42">asarray</a> (obj, itemsize=None, unicode=None, order=None)</td></tr>
<tr class="separator:aeb702f428542716d190f3272c1fa9b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a162b64fb9eaed4ca75c7dac3bb69626d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1defchararray.html#a162b64fb9eaed4ca75c7dac3bb69626d">array_function_dispatch</a></td></tr>
<tr class="separator:a162b64fb9eaed4ca75c7dac3bb69626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module contains a set of functions for vectorized string
operations and methods.

.. note::
   The `chararray` class exists for backwards compatibility with
   Numarray, it is not recommended for new development. Starting from numpy
   1.4, if one needs arrays of strings, it is recommended to use arrays of
   `dtype` `object_`, `bytes_` or `str_`, and use the free functions
   in the `numpy.char` module for fast vectorized string operations.

Some methods will only be available if the corresponding string method is
available in your version of Python.

The preferred alias for `defchararray` is `numpy.char`.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6f7e9f07337b6dad61c7cf6e5cd1d65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7e9f07337b6dad61c7cf6e5cd1d65d">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>itemsize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unicode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a `~numpy.char.chararray`.

.. note::
   This class is provided for numarray backward-compatibility.
   New code (not concerned with numarray compatibility) should use
   arrays of type `bytes_` or `str_` and use the free functions
   in :mod:`numpy.char` for fast vectorized string operations instead.

Versus a NumPy array of dtype `bytes_` or `str_`, this
class adds the following functionality:

1) values automatically have whitespace removed from the end
   when indexed

2) comparison operators automatically remove whitespace from the
   end when comparing values

3) vectorized string operations are provided as methods
   (e.g. `chararray.endswith &lt;numpy.char.chararray.endswith&gt;`)
   and infix operators (e.g. ``+, *, %``)

Parameters
----------
obj : array of str or unicode-like

itemsize : int, optional
    `itemsize` is the number of characters per scalar in the
    resulting array.  If `itemsize` is None, and `obj` is an
    object array or a Python list, the `itemsize` will be
    automatically determined.  If `itemsize` is provided and `obj`
    is of type str or unicode, then the `obj` string will be
    chunked into `itemsize` pieces.

copy : bool, optional
    If true (default), then the object is copied.  Otherwise, a copy
    will only be made if ``__array__`` returns a copy, if obj is a
    nested sequence, or if a copy is needed to satisfy any of the other
    requirements (`itemsize`, unicode, `order`, etc.).

unicode : bool, optional
    When true, the resulting `~numpy.char.chararray` can contain Unicode
    characters, when false only 8-bit characters.  If unicode is
    None and `obj` is one of the following:

    - a `~numpy.char.chararray`,
    - an ndarray of type :class:`str_` or :class:`bytes_`
    - a Python :class:`str` or :class:`bytes` object,

    then the unicode setting of the output array will be
    automatically determined.

order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C' (default), then the
    array will be in C-contiguous order (last-index varies the
    fastest).  If order is 'F', then the returned array
    will be in Fortran-contiguous order (first-index varies the
    fastest).  If order is 'A', then the returned array may
    be in any order (either C-, Fortran-contiguous, or even
    discontiguous).

Examples
--------

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; char_array = np.char.array(['hello', 'world', 'numpy','array'])
&gt;&gt;&gt; char_array
chararray(['hello', 'world', 'numpy', 'array'], dtype='&lt;U5')</pre> 
</div>
</div>
<a id="aeb702f428542716d190f3272c1fa9b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb702f428542716d190f3272c1fa9b42">&#9670;&nbsp;</a></span>asarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.asarray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>itemsize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unicode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the input to a `~numpy.char.chararray`, copying the data only if
necessary.

Versus a NumPy array of dtype `bytes_` or `str_`, this
class adds the following functionality:

1) values automatically have whitespace removed from the end
   when indexed

2) comparison operators automatically remove whitespace from the
   end when comparing values

3) vectorized string operations are provided as methods
   (e.g. `chararray.endswith &lt;numpy.char.chararray.endswith&gt;`)
   and infix operators (e.g. ``+``, ``*``, ``%``)

Parameters
----------
obj : array of str or unicode-like

itemsize : int, optional
    `itemsize` is the number of characters per scalar in the
    resulting array.  If `itemsize` is None, and `obj` is an
    object array or a Python list, the `itemsize` will be
    automatically determined.  If `itemsize` is provided and `obj`
    is of type str or unicode, then the `obj` string will be
    chunked into `itemsize` pieces.

unicode : bool, optional
    When true, the resulting `~numpy.char.chararray` can contain Unicode
    characters, when false only 8-bit characters.  If unicode is
    None and `obj` is one of the following:

    - a `~numpy.char.chararray`,
    - an ndarray of type `str_` or `unicode_`
    - a Python str or unicode object,

    then the unicode setting of the output array will be
    automatically determined.

order : {'C', 'F'}, optional
    Specify the order of the array.  If order is 'C' (default), then the
    array will be in C-contiguous order (last-index varies the
    fastest).  If order is 'F', then the returned array
    will be in Fortran-contiguous order (first-index varies the
    fastest).

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.char.asarray(['hello', 'world'])
chararray(['hello', 'world'], dtype='&lt;U5')</pre> 
</div>
</div>
<a id="aaf737deaa1cc77f23616d59031fd972b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf737deaa1cc77f23616d59031fd972b">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (x1 == x2) element-wise.

Unlike `numpy.equal`, this comparison is performed by first
stripping whitespace characters from the end of the string.  This
behavior is provided for backward-compatibility with numarray.

Parameters
----------
x1, x2 : array_like of str or unicode
    Input arrays of the same shape.

Returns
-------
out : ndarray
    Output array of bools.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; y = "aa "
&gt;&gt;&gt; x = "aa"
&gt;&gt;&gt; np.char.equal(x, y)
array(True)

See Also
--------
not_equal, greater_equal, less_equal, greater, less
</pre> 
</div>
</div>
<a id="a67ba62746bcb59d7da92d0560880e8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ba62746bcb59d7da92d0560880e8a1">&#9670;&nbsp;</a></span>greater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.greater </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (x1 &gt; x2) element-wise.

Unlike `numpy.greater`, this comparison is performed by first
stripping whitespace characters from the end of the string.  This
behavior is provided for backward-compatibility with numarray.

Parameters
----------
x1, x2 : array_like of str or unicode
    Input arrays of the same shape.

Returns
-------
out : ndarray
    Output array of bools.

See Also
--------
equal, not_equal, greater_equal, less_equal, less

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x1 = np.array(['a', 'b', 'c'])
&gt;&gt;&gt; np.char.greater(x1, 'b')
array([False, False,  True])</pre> 
</div>
</div>
<a id="a9148363d93185c6f3c398189d53233e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9148363d93185c6f3c398189d53233e4">&#9670;&nbsp;</a></span>greater_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.greater_equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (x1 &gt;= x2) element-wise.

Unlike `numpy.greater_equal`, this comparison is performed by
first stripping whitespace characters from the end of the string.
This behavior is provided for backward-compatibility with
numarray.

Parameters
----------
x1, x2 : array_like of str or unicode
    Input arrays of the same shape.

Returns
-------
out : ndarray
    Output array of bools.

See Also
--------
equal, not_equal, less_equal, greater, less

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x1 = np.array(['a', 'b', 'c'])
&gt;&gt;&gt; np.char.greater_equal(x1, 'b')
array([False,  True,  True])</pre> 
</div>
</div>
<a id="a4bbdd45dea2f901a65e6ea3ab0c221bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbdd45dea2f901a65e6ea3ab0c221bb">&#9670;&nbsp;</a></span>less()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.less </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (x1 &lt; x2) element-wise.

Unlike `numpy.greater`, this comparison is performed by first
stripping whitespace characters from the end of the string.  This
behavior is provided for backward-compatibility with numarray.

Parameters
----------
x1, x2 : array_like of str or unicode
    Input arrays of the same shape.

Returns
-------
out : ndarray
    Output array of bools.

See Also
--------
equal, not_equal, greater_equal, less_equal, greater

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x1 = np.array(['a', 'b', 'c'])
&gt;&gt;&gt; np.char.less(x1, 'b')
array([True, False, False])</pre> 
</div>
</div>
<a id="a4476cb11f29c84c3a46d176443a3daa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4476cb11f29c84c3a46d176443a3daa9">&#9670;&nbsp;</a></span>less_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.less_equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (x1 &lt;= x2) element-wise.

Unlike `numpy.less_equal`, this comparison is performed by first
stripping whitespace characters from the end of the string.  This
behavior is provided for backward-compatibility with numarray.

Parameters
----------
x1, x2 : array_like of str or unicode
    Input arrays of the same shape.

Returns
-------
out : ndarray
    Output array of bools.

See Also
--------
equal, not_equal, greater_equal, greater, less

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x1 = np.array(['a', 'b', 'c'])
&gt;&gt;&gt; np.char.less_equal(x1, 'b')
array([ True,  True, False])</pre> 
</div>
</div>
<a id="ab5eb9735b1da666dacb20a00e35ffe32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eb9735b1da666dacb20a00e35ffe32">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.multiply </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (a * i), that is string multiple concatenation,
element-wise.

Values in ``i`` of less than 0 are treated as 0 (which yields an
empty string).

Parameters
----------
a : array_like, with `np.bytes_` or `np.str_` dtype

i : array_like, with any integer dtype

Returns
-------
out : ndarray
    Output array of str or unicode, depending on input types

Notes
-----
This is a thin wrapper around np.strings.multiply that raises
`ValueError` when ``i`` is not an integer. It only
exists for backwards-compatibility.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(["a", "b", "c"])
&gt;&gt;&gt; np.strings.multiply(a, 3)
array(['aaa', 'bbb', 'ccc'], dtype='&lt;U3')
&gt;&gt;&gt; i = np.array([1, 2, 3])
&gt;&gt;&gt; np.strings.multiply(a, i)
array(['a', 'bb', 'ccc'], dtype='&lt;U3')
&gt;&gt;&gt; np.strings.multiply(np.array(['a']), i)
array(['a', 'aa', 'aaa'], dtype='&lt;U3')
&gt;&gt;&gt; a = np.array(['a', 'b', 'c', 'd', 'e', 'f']).reshape((2, 3))
&gt;&gt;&gt; np.strings.multiply(a, 3)
array([['aaa', 'bbb', 'ccc'],
       ['ddd', 'eee', 'fff']], dtype='&lt;U3')
&gt;&gt;&gt; np.strings.multiply(a, i)
array([['a', 'bb', 'ccc'],
       ['d', 'ee', 'fff']], dtype='&lt;U3')</pre> 
</div>
</div>
<a id="a23275872707dc024de9f20f8d436b9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23275872707dc024de9f20f8d436b9fe">&#9670;&nbsp;</a></span>not_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.not_equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (x1 != x2) element-wise.

Unlike `numpy.not_equal`, this comparison is performed by first
stripping whitespace characters from the end of the string.  This
behavior is provided for backward-compatibility with numarray.

Parameters
----------
x1, x2 : array_like of str or unicode
    Input arrays of the same shape.

Returns
-------
out : ndarray
    Output array of bools.

See Also
--------
equal, greater_equal, less_equal, greater, less

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x1 = np.array(['a', 'b', 'c'])
&gt;&gt;&gt; np.char.not_equal(x1, 'b')
array([ True, False,  True])</pre> 
</div>
</div>
<a id="a03c7c4d1565f50f2f9486c3eae610179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c7c4d1565f50f2f9486c3eae610179">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.partition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Partition each element in `a` around `sep`.

Calls :meth:`str.partition` element-wise.

For each element in `a`, split the element as the first
occurrence of `sep`, and return 3 strings containing the part
before the separator, the separator itself, and the part after
the separator. If the separator is not found, return 3 strings
containing the string itself, followed by two empty strings.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array
sep : {str, unicode}
    Separator to split each string element in `a`.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types. The output array will have an extra
    dimension with 3 elements per input element.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.array(["Numpy is nice!"])
&gt;&gt;&gt; np.char.partition(x, " ")
array([['Numpy', ' ', 'is nice!']], dtype='&lt;U8')

See Also
--------
str.partition</pre> 
</div>
</div>
<a id="abab97c3a4be1bcd17b96a2157bb6685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab97c3a4be1bcd17b96a2157bb6685a">&#9670;&nbsp;</a></span>rpartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.defchararray.rpartition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Partition (split) each element around the right-most separator.

Calls :meth:`str.rpartition` element-wise.

For each element in `a`, split the element as the last
occurrence of `sep`, and return 3 strings containing the part
before the separator, the separator itself, and the part after
the separator. If the separator is not found, return 3 strings
containing the string itself, followed by two empty strings.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array
sep : str or unicode
    Right-most separator to split each element in array.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types. The output array will have an extra
    dimension with 3 elements per input element.

See Also
--------
str.rpartition

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
&gt;&gt;&gt; np.char.rpartition(a, 'A')
array([['aAaAa', 'A', ''],
   ['  a', 'A', '  '],
   ['abB', 'A', 'Bba']], dtype='&lt;U5')</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a162b64fb9eaed4ca75c7dac3bb69626d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162b64fb9eaed4ca75c7dac3bb69626d">&#9670;&nbsp;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy._core.defchararray.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  functools.partial(</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy.char&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
