<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.utilities.enumerative Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1utilities.html">utilities</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1utilities_1_1enumerative.html">enumerative</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.utilities.enumerative Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1PartComponent.html">PartComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1enumerative_1_1MultisetPartitionTraverser.html">MultisetPartitionTraverser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad6d1da1f9c8e5001ea33f9341b0bded2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1enumerative.html#ad6d1da1f9c8e5001ea33f9341b0bded2">multiset_partitions_taocp</a> (multiplicities)</td></tr>
<tr class="separator:ad6d1da1f9c8e5001ea33f9341b0bded2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c592892c15cc774669bc193ba579552"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1enumerative.html#a1c592892c15cc774669bc193ba579552">factoring_visitor</a> (state, primes)</td></tr>
<tr class="separator:a1c592892c15cc774669bc193ba579552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bb7279286a257e9f97a818b3bbd2ca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1enumerative.html#a47bb7279286a257e9f97a818b3bbd2ca">list_visitor</a> (state, components)</td></tr>
<tr class="separator:a47bb7279286a257e9f97a818b3bbd2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fc71d19aff980635889c7fd8afee1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1enumerative.html#af5fc71d19aff980635889c7fd8afee1c">part_key</a> (part)</td></tr>
<tr class="separator:af5fc71d19aff980635889c7fd8afee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Algorithms and classes to support enumerative combinatorics.

Currently just multiset partitions, but more could be added.

Terminology (following Knuth, algorithm 7.1.2.5M TAOCP)
*multiset* aaabbcccc has a *partition* aaabc | bccc

The submultisets, aaabc and bccc of the partition are called
*parts*, or sometimes *vectors*.  (Knuth notes that multiset
partitions can be thought of as partitions of vectors of integers,
where the ith element of the vector gives the multiplicity of
element i.)

The values a, b and c are *components* of the multiset.  These
correspond to elements of a set, but in a multiset can be present
with a multiplicity greater than 1.

The algorithm deserves some explanation.

Think of the part aaabc from the multiset above.  If we impose an
ordering on the components of the multiset, we can represent a part
with a vector, in which the value of the first element of the vector
corresponds to the multiplicity of the first component in that
part. Thus, aaabc can be represented by the vector [3, 1, 1].  We
can also define an ordering on parts, based on the lexicographic
ordering of the vector (leftmost vector element, i.e., the element
with the smallest component number, is the most significant), so
that [3, 1, 1] &gt; [3, 1, 0] and [3, 1, 1] &gt; [2, 1, 4].  The ordering
on parts can be extended to an ordering on partitions: First, sort
the parts in each partition, left-to-right in decreasing order. Then
partition A is greater than partition B if A's leftmost/greatest
part is greater than B's leftmost part.  If the leftmost parts are
equal, compare the second parts, and so on.

In this ordering, the greatest partition of a given multiset has only
one part.  The least partition is the one in which the components
are spread out, one per part.

The enumeration algorithms in this file yield the partitions of the
argument multiset in decreasing order.  The main data structure is a
stack of parts, corresponding to the current partition.  An
important invariant is that the parts on the stack are themselves in
decreasing order.  This data structure is decremented to find the
next smaller partition.  Most often, decrementing the partition will
only involve adjustments to the smallest parts at the top of the
stack, much as adjacent integers *usually* differ only in their last
few digits.

Knuth's algorithm uses two main operations on parts:

Decrement - change the part so that it is smaller in the
  (vector) lexicographic order, but reduced by the smallest amount possible.
  For example, if the multiset has vector [5,
  3, 1], and the bottom/greatest part is [4, 2, 1], this part would
  decrement to [4, 2, 0], while [4, 0, 0] would decrement to [3, 3,
  1].  A singleton part is never decremented -- [1, 0, 0] is not
  decremented to [0, 3, 1].  Instead, the decrement operator needs
  to fail for this case.  In Knuth's pseudocode, the decrement
  operator is step m5.

Spread unallocated multiplicity - Once a part has been decremented,
  it cannot be the rightmost part in the partition.  There is some
  multiplicity that has not been allocated, and new parts must be
  created above it in the stack to use up this multiplicity.  To
  maintain the invariant that the parts on the stack are in
  decreasing order, these new parts must be less than or equal to
  the decremented part.
  For example, if the multiset is [5, 3, 1], and its most
  significant part has just been decremented to [5, 3, 0], the
  spread operation will add a new part so that the stack becomes
  [[5, 3, 0], [0, 0, 1]].  If the most significant part (for the
  same multiset) has been decremented to [2, 0, 0] the stack becomes
  [[2, 0, 0], [2, 0, 0], [1, 3, 1]].  In the pseudocode, the spread
  operation for one part is step m2.  The complete spread operation
  is a loop of steps m2 and m3.

In order to facilitate the spread operation, Knuth stores, for each
component of each part, not just the multiplicity of that component
in the part, but also the total multiplicity available for this
component in this part or any lesser part above it on the stack.

One added twist is that Knuth does not represent the part vectors as
arrays. Instead, he uses a sparse representation, in which a
component of a part is represented as a component number (c), plus
the multiplicity of the component in that part (v) as well as the
total multiplicity available for that component (u).  This saves
time that would be spent skipping over zeros.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a1c592892c15cc774669bc193ba579552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c592892c15cc774669bc193ba579552">&#9670;&nbsp;</a></span>factoring_visitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.factoring_visitor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Use with multiset_partitions_taocp to enumerate the ways a
number can be expressed as a product of factors.  For this usage,
the exponents of the prime factors of a number are arguments to
the partition enumerator, while the corresponding prime factors
are input here.

Examples
========

To enumerate the factorings of a number we can think of the elements of the
partition as being the prime factors and the multiplicities as being their
exponents.

&gt;&gt;&gt; from sympy.utilities.enumerative import factoring_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import multiset_partitions_taocp
&gt;&gt;&gt; from sympy import factorint
&gt;&gt;&gt; primes, multiplicities = zip(*factorint(24).items())
&gt;&gt;&gt; primes
(2, 3)
&gt;&gt;&gt; multiplicities
(3, 1)
&gt;&gt;&gt; states = multiset_partitions_taocp(multiplicities)
&gt;&gt;&gt; list(factoring_visitor(state, primes) for state in states)
[[24], [8, 3], [12, 2], [4, 6], [4, 2, 3], [6, 2, 2], [2, 2, 2, 3]]
</pre> 
</div>
</div>
<a id="a47bb7279286a257e9f97a818b3bbd2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bb7279286a257e9f97a818b3bbd2ca">&#9670;&nbsp;</a></span>list_visitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.list_visitor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of lists to represent the partition.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import multiset_partitions_taocp
&gt;&gt;&gt; states = multiset_partitions_taocp([1, 2, 1])
&gt;&gt;&gt; s = next(states)
&gt;&gt;&gt; list_visitor(s, 'abc')  # for multiset 'a b b c'
[['a', 'b', 'b', 'c']]
&gt;&gt;&gt; s = next(states)
&gt;&gt;&gt; list_visitor(s, [1, 2, 3])  # for multiset '1 2 2 3
[[1, 2, 2], [3]]
</pre> 
</div>
</div>
<a id="ad6d1da1f9c8e5001ea33f9341b0bded2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d1da1f9c8e5001ea33f9341b0bded2">&#9670;&nbsp;</a></span>multiset_partitions_taocp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.multiset_partitions_taocp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enumerates partitions of a multiset.

Parameters
==========

multiplicities
     list of integer multiplicities of the components of the multiset.

Yields
======

state
    Internal data structure which encodes a particular partition.
    This output is then usually processed by a visitor function
    which combines the information from this data structure with
    the components themselves to produce an actual partition.

    Unless they wish to create their own visitor function, users will
    have little need to look inside this data structure.  But, for
    reference, it is a 3-element list with components:

    f
        is a frame array, which is used to divide pstack into parts.

    lpart
        points to the base of the topmost part.

    pstack
        is an array of PartComponent objects.

    The ``state`` output offers a peek into the internal data
    structures of the enumeration function.  The client should
    treat this as read-only; any modification of the data
    structure will cause unpredictable (and almost certainly
    incorrect) results.  Also, the components of ``state`` are
    modified in place at each iteration.  Hence, the visitor must
    be called at each loop iteration.  Accumulating the ``state``
    instances and processing them later will not work.

Examples
========

&gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor
&gt;&gt;&gt; from sympy.utilities.enumerative import multiset_partitions_taocp
&gt;&gt;&gt; # variables components and multiplicities represent the multiset 'abb'
&gt;&gt;&gt; components = 'ab'
&gt;&gt;&gt; multiplicities = [1, 2]
&gt;&gt;&gt; states = multiset_partitions_taocp(multiplicities)
&gt;&gt;&gt; list(list_visitor(state, components) for state in states)
[[['a', 'b', 'b']],
[['a', 'b'], ['b']],
[['a'], ['b', 'b']],
[['a'], ['b'], ['b']]]

See Also
========

sympy.utilities.iterables.multiset_partitions: Takes a multiset
    as input and directly yields multiset partitions.  It
    dispatches to a number of functions, including this one, for
    implementation.  Most users will find it more convenient to
    use than multiset_partitions_taocp.</pre> 
</div>
</div>
<a id="af5fc71d19aff980635889c7fd8afee1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fc71d19aff980635889c7fd8afee1c">&#9670;&nbsp;</a></span>part_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.enumerative.part_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper for MultisetPartitionTraverser.count_partitions that
creates a key for ``part``, that only includes information which can
affect the count for that part.  (Any irrelevant information just
reduces the effectiveness of dynamic programming.)

Notes
=====

This member function is a candidate for future exploration. There
are likely symmetries that can be exploited to coalesce some
``part_key`` values, and thereby save space and improve
performance.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
