<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.matrices.eigen_symmetric Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1matrices.html">matrices</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html">eigen_symmetric</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.matrices.eigen_symmetric Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0415faaa19fcd0d26633798700c1ebe9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#a0415faaa19fcd0d26633798700c1ebe9">r_sy_tridiag</a> (ctx, A, D, E, calc_ev=True)</td></tr>
<tr class="separator:a0415faaa19fcd0d26633798700c1ebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade623c952e0aa6d2a66b452fcfe8ec19"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#ade623c952e0aa6d2a66b452fcfe8ec19">c_he_tridiag_0</a> (ctx, A, D, E, T)</td></tr>
<tr class="separator:ade623c952e0aa6d2a66b452fcfe8ec19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07aa67704ed0d50293a499a0a4f13e56"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#a07aa67704ed0d50293a499a0a4f13e56">c_he_tridiag_1</a> (ctx, A, T)</td></tr>
<tr class="separator:a07aa67704ed0d50293a499a0a4f13e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484fbd83d0ef86895b35f0e1c43f7c67"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#a484fbd83d0ef86895b35f0e1c43f7c67">c_he_tridiag_2</a> (ctx, A, T, B)</td></tr>
<tr class="separator:a484fbd83d0ef86895b35f0e1c43f7c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa666ec4e51210f2071f50d7f7048965f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#aa666ec4e51210f2071f50d7f7048965f">tridiag_eigen</a> (ctx, d, <a class="el" href="namespacempmath.html#ae338175834529dd23bb24ed01183c717">e</a>, z=False)</td></tr>
<tr class="separator:aa666ec4e51210f2071f50d7f7048965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4147fbd99a23fa40254538e8138f83c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#ab4147fbd99a23fa40254538e8138f83c">eigsy</a> (ctx, A, eigvals_only=False, overwrite_a=False)</td></tr>
<tr class="separator:ab4147fbd99a23fa40254538e8138f83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396dbe0c05a55b7f49fd76d6d86198ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#a396dbe0c05a55b7f49fd76d6d86198ff">eighe</a> (ctx, A, eigvals_only=False, overwrite_a=False)</td></tr>
<tr class="separator:a396dbe0c05a55b7f49fd76d6d86198ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594502fee4f42dcefca0b3622cc39f93"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#a594502fee4f42dcefca0b3622cc39f93">eigh</a> (ctx, A, eigvals_only=False, overwrite_a=False)</td></tr>
<tr class="separator:a594502fee4f42dcefca0b3622cc39f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f5bfe59a6ff943ef1a447adbe9f7fa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#a45f5bfe59a6ff943ef1a447adbe9f7fa">gauss_quadrature</a> (ctx, n, qtype=&quot;legendre&quot;, alpha=0, <a class="el" href="namespacempmath.html#a83f8c2fdb151a2c8d807916611852281">beta</a>=0)</td></tr>
<tr class="separator:a45f5bfe59a6ff943ef1a447adbe9f7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fe0a5208a36bfdc13d6d726147e9fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#ae8fe0a5208a36bfdc13d6d726147e9fc">svd_r_raw</a> (ctx, A, V=False, calc_u=False)</td></tr>
<tr class="separator:ae8fe0a5208a36bfdc13d6d726147e9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8612a43984c4a06be68c4c8fba43db40"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#a8612a43984c4a06be68c4c8fba43db40">svd_c_raw</a> (ctx, A, V=False, calc_u=False)</td></tr>
<tr class="separator:a8612a43984c4a06be68c4c8fba43db40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc000a7c63a07771f5dbf0058ef62be1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#abc000a7c63a07771f5dbf0058ef62be1">svd_r</a> (ctx, A, full_matrices=False, compute_uv=True, overwrite_a=False)</td></tr>
<tr class="separator:abc000a7c63a07771f5dbf0058ef62be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90e9dc9a45219d690a7a04ec790082a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#ac90e9dc9a45219d690a7a04ec790082a">svd_c</a> (ctx, A, full_matrices=False, compute_uv=True, overwrite_a=False)</td></tr>
<tr class="separator:ac90e9dc9a45219d690a7a04ec790082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e57f1c257112d6591942af0904d0a7b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen__symmetric.html#a2e57f1c257112d6591942af0904d0a7b">svd</a> (ctx, A, full_matrices=False, compute_uv=True, overwrite_a=False)</td></tr>
<tr class="separator:a2e57f1c257112d6591942af0904d0a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ade623c952e0aa6d2a66b452fcfe8ec19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade623c952e0aa6d2a66b452fcfe8ec19">&#9670;&nbsp;</a></span>c_he_tridiag_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.c_he_tridiag_0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine transforms a complex hermitian matrix A to a real symmetric
tridiagonal matrix T using an unitary similarity transformation:
      Q' * A * Q = T     (here ' denotes the hermitian matrix transpose,
                          i.e. transposition und conjugation).
The unitary matrix Q is build up from Householder reflectors and
an unitary diagonal matrix.

parameters:
  A         (input/output) On input, A contains the complex hermitian matrix
            of dimension (n,n). On output, A contains the unitary matrix Q
            in compressed form.

  D         (output) real array of length n, contains the diagonal elements
            of the tridiagonal matrix.

  E         (output) real array of length n, contains the offdiagonal elements
            of the tridiagonal matrix in E[0:(n-1)] where is the dimension of
            the matrix A. E[n-1] is undefined.

  T         (output) complex array of length n, contains a unitary diagonal
            matrix.

This routine is a python translation (in slightly modified form) of the fortran
routine htridi.f in the software library EISPACK (see netlib.org) which itself
is a complex version of the algol procedure tred1 described in:
  - Num. Math. 11, p.181-195 (1968) by Martin, Reinsch and Wilkonson
  - Handbook for auto. comp., Vol II, Linear Algebra, p.212-226 (1971)

For a good introduction to Householder reflections, see also
  Stoer, Bulirsch - Introduction to Numerical Analysis.
</pre> 
</div>
</div>
<a id="a07aa67704ed0d50293a499a0a4f13e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07aa67704ed0d50293a499a0a4f13e56">&#9670;&nbsp;</a></span>c_he_tridiag_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.c_he_tridiag_1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine forms the unitary matrix Q described in c_he_tridiag_0.

parameters:
  A    (input/output) On input, A is the same matrix as delivered by
       c_he_tridiag_0. On output, A is set to Q.

  T    (input) On input, T is the same array as delivered by c_he_tridiag_0.</pre> 
</div>
</div>
<a id="a484fbd83d0ef86895b35f0e1c43f7c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484fbd83d0ef86895b35f0e1c43f7c67">&#9670;&nbsp;</a></span>c_he_tridiag_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.c_he_tridiag_2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine applied the unitary matrix Q described in c_he_tridiag_0
onto the the matrix B, i.e. it forms Q*B.

parameters:
  A    (input) On input, A is the same matrix as delivered by c_he_tridiag_0.

  T    (input) On input, T is the same array as delivered by c_he_tridiag_0.

  B    (input/output) On input, B is a complex matrix. On output B is replaced
       by Q*B.

This routine is a python translation of the fortran routine htribk.f in the
software library EISPACK (see netlib.org). See c_he_tridiag_0 for more
references.
</pre> 
</div>
</div>
<a id="a594502fee4f42dcefca0b3622cc39f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594502fee4f42dcefca0b3622cc39f93">&#9670;&nbsp;</a></span>eigh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.eigh </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eigvals_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">"eigh" is a unified interface for "eigsy" and "eighe". Depending on
whether A is real or complex the appropriate function is called.

This routine solves the (ordinary) eigenvalue problem for a real symmetric
or complex hermitian square matrix A. Given A, an orthogonal (A real) or
unitary (A complex) matrix Q is calculated which diagonalizes A:

    Q' A Q = diag(E)               and                Q Q' = Q' Q = 1

Here diag(E) a is diagonal matrix whose diagonal is E.
' denotes the hermitian transpose (i.e. ordinary transposition and
complex conjugation).

The columns of Q are the eigenvectors of A and E contains the eigenvalues:

    A Q[:,i] = E[i] Q[:,i]

input:

  A: a real or complex square matrix of format (n,n) which is symmetric
     (i.e. A[i,j]=A[j,i]) or hermitian (i.e. A[i,j]=conj(A[j,i])).

  eigvals_only: if true, calculates only the eigenvalues E.
                if false, calculates both eigenvectors and eigenvalues.

  overwrite_a: if true, allows modification of A which may improve
               performance. if false, A is not modified.

output:

  E: vector of format (n). contains the eigenvalues of A in ascending order.

  Q: an orthogonal or unitary matrix of format (n,n). contains the
     eigenvectors of A as columns.

return value:

      E         if eigvals_only is true
     (E, Q)     if eigvals_only is false

example:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; A = mp.matrix([[3, 2], [2, 0]])
  &gt;&gt;&gt; E = mp.eigh(A, eigvals_only = True)
  &gt;&gt;&gt; print(E)
  [-1.0]
  [ 4.0]

  &gt;&gt;&gt; A = mp.matrix([[1, 2], [2, 3]])
  &gt;&gt;&gt; E, Q = mp.eigh(A)
  &gt;&gt;&gt; print(mp.chop(A * Q[:,0] - E[0] * Q[:,0]))
  [0.0]
  [0.0]

  &gt;&gt;&gt; A = mp.matrix([[1, 2 + 5j], [2 - 5j, 3]])
  &gt;&gt;&gt; E, Q = mp.eigh(A)
  &gt;&gt;&gt; print(mp.chop(A * Q[:,0] - E[0] * Q[:,0]))
  [0.0]
  [0.0]

see also: eigsy, eighe, eig
</pre> 
</div>
</div>
<a id="a396dbe0c05a55b7f49fd76d6d86198ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396dbe0c05a55b7f49fd76d6d86198ff">&#9670;&nbsp;</a></span>eighe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.eighe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eigvals_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine solves the (ordinary) eigenvalue problem for a complex
hermitian square matrix A. Given A, an unitary matrix Q is calculated which
diagonalizes A:

    Q' A Q = diag(E)               and                Q Q' = Q' Q = 1

Here diag(E) a is diagonal matrix whose diagonal is E.
' denotes the hermitian transpose (i.e. ordinary transposition and
complex conjugation).

The columns of Q are the eigenvectors of A and E contains the eigenvalues:

    A Q[:,i] = E[i] Q[:,i]


input:

  A: complex matrix of format (n,n) which is hermitian
     (i.e. A=A' or A[i,j]=conj(A[j,i]))

  eigvals_only: if true, calculates only the eigenvalues E.
                if false, calculates both eigenvectors and eigenvalues.

  overwrite_a: if true, allows modification of A which may improve
               performance. if false, A is not modified.

output:

  E: vector of format (n). contains the eigenvalues of A in ascending order.

  Q: unitary matrix of format (n,n). contains the eigenvectors
     of A as columns.

return value:

       E         if eigvals_only is true
      (E, Q)     if eigvals_only is false

example:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; A = mp.matrix([[1, -3 - 1j], [-3 + 1j, -2]])
  &gt;&gt;&gt; E = mp.eighe(A, eigvals_only = True)
  &gt;&gt;&gt; print(E)
  [-4.0]
  [ 3.0]

  &gt;&gt;&gt; A = mp.matrix([[1, 2 + 5j], [2 - 5j, 3]])
  &gt;&gt;&gt; E, Q = mp.eighe(A)
  &gt;&gt;&gt; print(mp.chop(A * Q[:,0] - E[0] * Q[:,0]))
  [0.0]
  [0.0]

see also: eigsy, eigh, eig
</pre> 
</div>
</div>
<a id="ab4147fbd99a23fa40254538e8138f83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4147fbd99a23fa40254538e8138f83c">&#9670;&nbsp;</a></span>eigsy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.eigsy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eigvals_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine solves the (ordinary) eigenvalue problem for a real symmetric
square matrix A. Given A, an orthogonal matrix Q is calculated which
diagonalizes A:

      Q' A Q = diag(E)               and                Q Q' = Q' Q = 1

Here diag(E) is a diagonal matrix whose diagonal is E.
' denotes the transpose.

The columns of Q are the eigenvectors of A and E contains the eigenvalues:

      A Q[:,i] = E[i] Q[:,i]


input:

  A: real matrix of format (n,n) which is symmetric
     (i.e. A=A' or A[i,j]=A[j,i])

  eigvals_only: if true, calculates only the eigenvalues E.
                if false, calculates both eigenvectors and eigenvalues.

  overwrite_a: if true, allows modification of A which may improve
               performance. if false, A is not modified.

output:

  E: vector of format (n). contains the eigenvalues of A in ascending order.

  Q: orthogonal matrix of format (n,n). contains the eigenvectors
     of A as columns.

return value:

      E          if eigvals_only is true
     (E, Q)      if eigvals_only is false

example:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; A = mp.matrix([[3, 2], [2, 0]])
  &gt;&gt;&gt; E = mp.eigsy(A, eigvals_only = True)
  &gt;&gt;&gt; print(E)
  [-1.0]
  [ 4.0]

  &gt;&gt;&gt; A = mp.matrix([[1, 2], [2, 3]])
  &gt;&gt;&gt; E, Q = mp.eigsy(A)
  &gt;&gt;&gt; print(mp.chop(A * Q[:,0] - E[0] * Q[:,0]))
  [0.0]
  [0.0]

see also: eighe, eigh, eig
</pre> 
</div>
</div>
<a id="a45f5bfe59a6ff943ef1a447adbe9f7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f5bfe59a6ff943ef1a447adbe9f7fa">&#9670;&nbsp;</a></span>gauss_quadrature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.gauss_quadrature </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>qtype</em> = <code>&quot;legendre&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine calulates gaussian quadrature rules for different
families of orthogonal polynomials. Let (a, b) be an interval,
W(x) a positive weight function and n a positive integer.
Then the purpose of this routine is to calculate pairs (x_k, w_k)
for k=0, 1, 2, ... (n-1) which give

  int(W(x) * F(x), x = a..b) = sum(w_k * F(x_k),k = 0..(n-1))

exact for all polynomials F(x) of degree (strictly) less than 2*n. For all
integrable functions F(x) the sum is a (more or less) good approximation to
the integral. The x_k are called nodes (which are the zeros of the
related orthogonal polynomials) and the w_k are called the weights.

parameters
   n        (input) The degree of the quadrature rule, i.e. its number of
            nodes.

   qtype    (input) The family of orthogonal polynmomials for which to
            compute the quadrature rule. See the list below.

   alpha    (input) real number, used as parameter for some orthogonal
            polynomials

   beta     (input) real number, used as parameter for some orthogonal
            polynomials.

return value

  (X, W)    a pair of two real arrays where x_k = X[k] and w_k = W[k].


orthogonal polynomials:

  qtype           polynomial
  -----           ----------

  "legendre"      Legendre polynomials, W(x)=1 on the interval (-1, +1)
  "legendre01"    shifted Legendre polynomials, W(x)=1 on the interval (0, +1)
  "hermite"       Hermite polynomials, W(x)=exp(-x*x) on (-infinity,+infinity)
  "laguerre"      Laguerre polynomials, W(x)=exp(-x) on (0,+infinity)
  "glaguerre"     generalized Laguerre polynomials, W(x)=exp(-x)*x**alpha
                  on (0, +infinity)
  "chebyshev1"    Chebyshev polynomials of the first kind, W(x)=1/sqrt(1-x*x)
                  on (-1, +1)
  "chebyshev2"    Chebyshev polynomials of the second kind, W(x)=sqrt(1-x*x)
                  on (-1, +1)
  "jacobi"        Jacobi polynomials, W(x)=(1-x)**alpha * (1+x)**beta on (-1, +1)
                  with alpha&gt;-1 and beta&gt;-1

examples:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; f = lambda x: x**8 + 2 * x**6 - 3 * x**4 + 5 * x**2 - 7
  &gt;&gt;&gt; X, W = mp.gauss_quadrature(5, "hermite")
  &gt;&gt;&gt; A = mp.fdot([(f(x), w) for x, w in zip(X, W)])
  &gt;&gt;&gt; B = mp.sqrt(mp.pi) * 57 / 16
  &gt;&gt;&gt; C = mp.quad(lambda x: mp.exp(- x * x) * f(x), [-mp.inf, +mp.inf])
  &gt;&gt;&gt; mp.nprint((mp.chop(A-B, tol = 1e-10), mp.chop(A-C, tol = 1e-10)))
  (0.0, 0.0)

  &gt;&gt;&gt; f = lambda x: x**5 - 2 * x**4 + 3 * x**3 - 5 * x**2 + 7 * x - 11
  &gt;&gt;&gt; X, W = mp.gauss_quadrature(3, "laguerre")
  &gt;&gt;&gt; A = mp.fdot([(f(x), w) for x, w in zip(X, W)])
  &gt;&gt;&gt; B = 76
  &gt;&gt;&gt; C = mp.quad(lambda x: mp.exp(-x) * f(x), [0, +mp.inf])
  &gt;&gt;&gt; mp.nprint(mp.chop(A-B, tol = 1e-10), mp.chop(A-C, tol = 1e-10))
  .0

  # orthogonality of the chebyshev polynomials:
  &gt;&gt;&gt; f = lambda x: mp.chebyt(3, x) * mp.chebyt(2, x)
  &gt;&gt;&gt; X, W = mp.gauss_quadrature(3, "chebyshev1")
  &gt;&gt;&gt; A = mp.fdot([(f(x), w) for x, w in zip(X, W)])
  &gt;&gt;&gt; print(mp.chop(A, tol = 1e-10))
  0.0

references:
  - golub and welsch, "calculations of gaussian quadrature rules", mathematics of
    computation 23, p. 221-230 (1969)
  - golub, "some modified matrix eigenvalue problems", siam review 15, p. 318-334 (1973)
  - stroud and secrest, "gaussian quadrature formulas", prentice-hall (1966)

See also the routine gaussq.f in netlog.org or ACM Transactions on
Mathematical Software algorithm 726.
</pre> 
</div>
</div>
<a id="a0415faaa19fcd0d26633798700c1ebe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0415faaa19fcd0d26633798700c1ebe9">&#9670;&nbsp;</a></span>r_sy_tridiag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.r_sy_tridiag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>calc_ev</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine transforms a real symmetric matrix A to a real symmetric
tridiagonal matrix T using an orthogonal similarity transformation:
      Q' * A * Q = T     (here ' denotes the matrix transpose).
The orthogonal matrix Q is build up from Householder reflectors.

parameters:
  A         (input/output) On input, A contains the real symmetric matrix of
            dimension (n,n). On output, if calc_ev is true, A contains the
            orthogonal matrix Q, otherwise A is destroyed.

  D         (output) real array of length n, contains the diagonal elements
            of the tridiagonal matrix

  E         (output) real array of length n, contains the offdiagonal elements
            of the tridiagonal matrix in E[0:(n-1)] where is the dimension of
            the matrix A. E[n-1] is undefined.

  calc_ev   (input) If calc_ev is true, this routine explicitly calculates the
            orthogonal matrix Q which is then returned in A. If calc_ev is
            false, Q is not explicitly calculated resulting in a shorter run time.

This routine is a python translation of the fortran routine tred2.f in the
software library EISPACK (see netlib.org) which itself is based on the algol
procedure tred2 described in:
  - Num. Math. 11, p.181-195 (1968) by Martin, Reinsch and Wilkonson
  - Handbook for auto. comp., Vol II, Linear Algebra, p.212-226 (1971)

For a good introduction to Householder reflections, see also
  Stoer, Bulirsch - Introduction to Numerical Analysis.
</pre> 
</div>
</div>
<a id="a2e57f1c257112d6591942af0904d0a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e57f1c257112d6591942af0904d0a7b">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_matrices</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_uv</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">"svd" is a unified interface for "svd_r" and "svd_c". Depending on
whether A is real or complex the appropriate function is called.

This routine computes the singular value decomposition of a matrix A.
Given A, two orthogonal (A real) or unitary (A complex) matrices U and V
are calculated such that

       A = U S V        and        U' U = 1         and         V V' = 1

where S is a suitable shaped matrix whose off-diagonal elements are zero.
Here ' denotes the hermitian transpose (i.e. transposition and complex
conjugation). The diagonal elements of S are the singular values of A,
i.e. the squareroots of the eigenvalues of A' A or A A'.

input:
  A             : a real or complex matrix of shape (m, n)
  full_matrices : if true, U and V are of shape (m, m) and (n, n).
                  if false, U and V are of shape (m, min(m, n)) and (min(m, n), n).
  compute_uv    : if true, U and V are calculated. if false, only S is calculated.
  overwrite_a   : if true, allows modification of A which may improve
                  performance. if false, A is not modified.

output:
  U : an orthogonal or unitary matrix: U' U = 1. if full_matrices is true, U is of
      shape (m, m). ortherwise it is of shape (m, min(m, n)).

  S : an array of length min(m, n) containing the singular values of A sorted by
      decreasing magnitude.

  V : an orthogonal or unitary matrix: V V' = 1. if full_matrices is true, V is of
      shape (n, n). ortherwise it is of shape (min(m, n), n).

return value:

       S          if compute_uv is false
   (U, S, V)      if compute_uv is true

overview of the matrices:

  full_matrices true:
    A           : m*n
    U           : m*m     U' U  = 1
    S as matrix : m*n
    V           : n*n     V  V' = 1

 full_matrices false:
    A           : m*n
    U           : m*min(n,m)             U' U  = 1
    S as matrix : min(m,n)*min(m,n)
    V           : min(m,n)*n             V  V' = 1

examples:

   &gt;&gt;&gt; from mpmath import mp
   &gt;&gt;&gt; A = mp.matrix([[2, -2, -1], [3, 4, -2], [-2, -2, 0]])
   &gt;&gt;&gt; S = mp.svd(A, compute_uv = False)
   &gt;&gt;&gt; print(S)
   [6.0]
   [3.0]
   [1.0]

   &gt;&gt;&gt; U, S, V = mp.svd(A)
   &gt;&gt;&gt; print(mp.chop(A - U * mp.diag(S) * V))
   [0.0  0.0  0.0]
   [0.0  0.0  0.0]
   [0.0  0.0  0.0]

see also: svd_r, svd_c
</pre> 
</div>
</div>
<a id="ac90e9dc9a45219d690a7a04ec790082a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90e9dc9a45219d690a7a04ec790082a">&#9670;&nbsp;</a></span>svd_c()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.svd_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_matrices</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_uv</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the singular value decomposition of a matrix A.
Given A, two unitary matrices U and V are calculated such that

       A = U S V        and        U' U = 1         and         V V' = 1

where S is a suitable shaped matrix whose off-diagonal elements are zero.
Here ' denotes the hermitian transpose (i.e. transposition and complex
conjugation). The diagonal elements of S are the singular values of A,
i.e. the squareroots of the eigenvalues of A' A or A A'.

input:
  A             : a complex matrix of shape (m, n)
  full_matrices : if true, U and V are of shape (m, m) and (n, n).
                  if false, U and V are of shape (m, min(m, n)) and (min(m, n), n).
  compute_uv    : if true, U and V are calculated. if false, only S is calculated.
  overwrite_a   : if true, allows modification of A which may improve
                  performance. if false, A is not modified.

output:
  U : an unitary matrix: U' U = 1. if full_matrices is true, U is of
      shape (m, m). ortherwise it is of shape (m, min(m, n)).

  S : an array of length min(m, n) containing the singular values of A sorted by
      decreasing magnitude.

  V : an unitary matrix: V V' = 1. if full_matrices is true, V is of
      shape (n, n). ortherwise it is of shape (min(m, n), n).

return value:

       S          if compute_uv is false
   (U, S, V)      if compute_uv is true

overview of the matrices:

  full_matrices true:
    A           : m*n
    U           : m*m     U' U  = 1
    S as matrix : m*n
    V           : n*n     V  V' = 1

 full_matrices false:
    A           : m*n
    U           : m*min(n,m)             U' U  = 1
    S as matrix : min(m,n)*min(m,n)
    V           : min(m,n)*n             V  V' = 1

example:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; A = mp.matrix([[-2j, -1-3j, -2+2j], [2-2j, -1-3j, 1], [-3+1j,-2j,0]])
  &gt;&gt;&gt; S = mp.svd_c(A, compute_uv = False)
  &gt;&gt;&gt; print(mp.chop(S - mp.matrix([mp.sqrt(34), mp.sqrt(15), mp.sqrt(6)])))
  [0.0]
  [0.0]
  [0.0]

  &gt;&gt;&gt; U, S, V = mp.svd_c(A)
  &gt;&gt;&gt; print(mp.chop(A - U * mp.diag(S) * V))
  [0.0  0.0  0.0]
  [0.0  0.0  0.0]
  [0.0  0.0  0.0]

see also: svd, svd_r
</pre> 
</div>
</div>
<a id="a8612a43984c4a06be68c4c8fba43db40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8612a43984c4a06be68c4c8fba43db40">&#9670;&nbsp;</a></span>svd_c_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.svd_c_raw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>V</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>calc_u</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the singular value decomposition of a matrix A.
Given A, two unitary matrices U and V are calculated such that

                A = U S V

where S is a suitable shaped matrix whose off-diagonal elements are zero.
The diagonal elements of S are the singular values of A, i.e. the
squareroots of the eigenvalues of A' A or A A'. Here ' denotes the hermitian
transpose (i.e. transposition and conjugation). Householder bidiagonalization
and a variant of the QR algorithm is used.

overview of the matrices :

  A : m*n       A gets replaced by U
  U : m*n       U replaces A. If n&gt;m then only the first m*m block of U is
                non-zero. column-unitary: U' U = B
                here B is a n*n matrix whose first min(m,n) diagonal
                elements are 1 and all other elements are zero.
  S : n*n       diagonal matrix, only the diagonal elements are stored in
                the array S. only the first min(m,n) diagonal elements are non-zero.
  V : n*n       unitary: V V' = V' V = 1

parameters:
  A        (input/output) On input, A contains a complex matrix of shape m*n.
           On output, if calc_u is true A contains the column-unitary
           matrix U; otherwise A is simply used as workspace and thus destroyed.

  V        (input/output) if false, the matrix V is not calculated. otherwise
           V must be a matrix of shape n*n.

  calc_u   (input) If true, the matrix U is calculated and replaces A.
           if false, U is not calculated and A is simply destroyed

return value:
  S        an array of length n containing the singular values of A sorted by
           decreasing magnitude. only the first min(m,n) elements are non-zero.

This routine is a python translation of the fortran routine svd.f in the
software library EISPACK (see netlib.org) which itself is based on the
algol procedure svd described in:
  - num. math. 14, 403-420(1970) by golub and reinsch.
  - wilkinson/reinsch: handbook for auto. comp., vol ii-linear algebra, 134-151(1971).</pre> 
</div>
</div>
<a id="abc000a7c63a07771f5dbf0058ef62be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc000a7c63a07771f5dbf0058ef62be1">&#9670;&nbsp;</a></span>svd_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.svd_r </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_matrices</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_uv</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the singular value decomposition of a matrix A.
Given A, two orthogonal matrices U and V are calculated such that

       A = U S V        and        U' U = 1         and         V V' = 1

where S is a suitable shaped matrix whose off-diagonal elements are zero.
Here ' denotes the transpose. The diagonal elements of S are the singular
values of A, i.e. the squareroots of the eigenvalues of A' A or A A'.

input:
  A             : a real matrix of shape (m, n)
  full_matrices : if true, U and V are of shape (m, m) and (n, n).
                  if false, U and V are of shape (m, min(m, n)) and (min(m, n), n).
  compute_uv    : if true, U and V are calculated. if false, only S is calculated.
  overwrite_a   : if true, allows modification of A which may improve
                  performance. if false, A is not modified.

output:
  U : an orthogonal matrix: U' U = 1. if full_matrices is true, U is of
      shape (m, m). ortherwise it is of shape (m, min(m, n)).

  S : an array of length min(m, n) containing the singular values of A sorted by
      decreasing magnitude.

  V : an orthogonal matrix: V V' = 1. if full_matrices is true, V is of
      shape (n, n). ortherwise it is of shape (min(m, n), n).

return value:

       S          if compute_uv is false
   (U, S, V)      if compute_uv is true

overview of the matrices:

  full_matrices true:
    A           : m*n
    U           : m*m     U' U  = 1
    S as matrix : m*n
    V           : n*n     V  V' = 1

 full_matrices false:
    A           : m*n
    U           : m*min(n,m)             U' U  = 1
    S as matrix : min(m,n)*min(m,n)
    V           : min(m,n)*n             V  V' = 1

examples:

   &gt;&gt;&gt; from mpmath import mp
   &gt;&gt;&gt; A = mp.matrix([[2, -2, -1], [3, 4, -2], [-2, -2, 0]])
   &gt;&gt;&gt; S = mp.svd_r(A, compute_uv = False)
   &gt;&gt;&gt; print(S)
   [6.0]
   [3.0]
   [1.0]

   &gt;&gt;&gt; U, S, V = mp.svd_r(A)
   &gt;&gt;&gt; print(mp.chop(A - U * mp.diag(S) * V))
   [0.0  0.0  0.0]
   [0.0  0.0  0.0]
   [0.0  0.0  0.0]


see also: svd, svd_c
</pre> 
</div>
</div>
<a id="ae8fe0a5208a36bfdc13d6d726147e9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fe0a5208a36bfdc13d6d726147e9fc">&#9670;&nbsp;</a></span>svd_r_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.svd_r_raw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>V</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>calc_u</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the singular value decomposition of a matrix A.
Given A, two orthogonal matrices U and V are calculated such that

                A = U S V

where S is a suitable shaped matrix whose off-diagonal elements are zero.
The diagonal elements of S are the singular values of A, i.e. the
squareroots of the eigenvalues of A' A or A A'. Here ' denotes the transpose.
Householder bidiagonalization and a variant of the QR algorithm is used.

overview of the matrices :

  A : m*n       A gets replaced by U
  U : m*n       U replaces A. If n&gt;m then only the first m*m block of U is
                non-zero. column-orthogonal: U' U = B
                here B is a n*n matrix whose first min(m,n) diagonal
                elements are 1 and all other elements are zero.
  S : n*n       diagonal matrix, only the diagonal elements are stored in
                the array S. only the first min(m,n) diagonal elements are non-zero.
  V : n*n       orthogonal: V V' = V' V = 1

parameters:
  A        (input/output) On input, A contains a real matrix of shape m*n.
           On output, if calc_u is true A contains the column-orthogonal
           matrix U; otherwise A is simply used as workspace and thus destroyed.

  V        (input/output) if false, the matrix V is not calculated. otherwise
           V must be a matrix of shape n*n.

  calc_u   (input) If true, the matrix U is calculated and replaces A.
           if false, U is not calculated and A is simply destroyed

return value:
  S        an array of length n containing the singular values of A sorted by
           decreasing magnitude. only the first min(m,n) elements are non-zero.

This routine is a python translation of the fortran routine svd.f in the
software library EISPACK (see netlib.org) which itself is based on the
algol procedure svd described in:
  - num. math. 14, 403-420(1970) by golub and reinsch.
  - wilkinson/reinsch: handbook for auto. comp., vol ii-linear algebra, 134-151(1971).</pre> 
</div>
</div>
<a id="aa666ec4e51210f2071f50d7f7048965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa666ec4e51210f2071f50d7f7048965f">&#9670;&nbsp;</a></span>tridiag_eigen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen_symmetric.tridiag_eigen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This subroutine find the eigenvalues and the first components of the
eigenvectors of a real symmetric tridiagonal matrix using the implicit
QL method.

parameters:

  d (input/output) real array of length n. on input, d contains the diagonal
    elements of the input matrix. on output, d contains the eigenvalues in
    ascending order.

  e (input) real array of length n. on input, e contains the offdiagonal
    elements of the input matrix in e[0:(n-1)]. On output, e has been
    destroyed.

  z (input/output) If z is equal to False, no eigenvectors will be computed.
    Otherwise on input z should have the format z[0:m,0:n] (i.e. a real or
    complex matrix of dimension (m,n) ). On output this matrix will be
    multiplied by the matrix of the eigenvectors (i.e. the columns of this
    matrix are the eigenvectors): z --&gt; z*EV
    That means if z[i,j]={1 if j==j; 0 otherwise} on input, then on output
    z will contain the first m components of the eigenvectors. That means
    if m is equal to n, the i-th eigenvector will be z[:,i].

This routine is a python translation (in slightly modified form) of the
fortran routine imtql2.f in the software library EISPACK (see netlib.org)
which itself is based on the algol procudure imtql2 desribed in:
 - num. math. 12, p. 377-383(1968) by matrin and wilkinson
 - modified in num. math. 15, p. 450(1970) by dubrulle
 - handbook for auto. comp., vol. II-linear algebra, p. 241-248 (1971)
See also the routine gaussq.f in netlog.org or acm algorithm 726.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
