<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: fsspec.utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefsspec.html">fsspec</a></li><li class="navelem"><a class="el" href="namespacefsspec_1_1utils.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fsspec.utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5b4af170cd4759ab9d28e3a510628d73"><td class="memItemLeft" align="right" valign="top">dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a5b4af170cd4759ab9d28e3a510628d73">infer_storage_options</a> (str urlpath, dict[str, Any]|None inherit_storage_options=None)</td></tr>
<tr class="separator:a5b4af170cd4759ab9d28e3a510628d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa39e182341e99f33c850adfddb74281"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#afa39e182341e99f33c850adfddb74281">update_storage_options</a> (dict[str, Any] options, dict[str, Any]|None inherited=None)</td></tr>
<tr class="separator:afa39e182341e99f33c850adfddb74281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1d6bfa94cb047e5b70e6e8215eb2a7"><td class="memItemLeft" align="right" valign="top">str|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a9c1d6bfa94cb047e5b70e6e8215eb2a7">infer_compression</a> (str filename)</td></tr>
<tr class="separator:a9c1d6bfa94cb047e5b70e6e8215eb2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7172da0bea0daf5f5ce758613b7b582"><td class="memItemLeft" align="right" valign="top">Callable[[int], str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#ae7172da0bea0daf5f5ce758613b7b582">build_name_function</a> (float max_int)</td></tr>
<tr class="separator:ae7172da0bea0daf5f5ce758613b7b582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e4df5f4746c50e41f217c6e326f07b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#ac4e4df5f4746c50e41f217c6e326f07b">seek_delimiter</a> (IO[bytes] file, bytes delimiter, int blocksize)</td></tr>
<tr class="separator:ac4e4df5f4746c50e41f217c6e326f07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537b0507f8c02de97cc989d9baff88cb"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a537b0507f8c02de97cc989d9baff88cb">read_block</a> (IO[bytes] f, int offset, int|None length, bytes|None delimiter=None, bool split_before=False)</td></tr>
<tr class="separator:a537b0507f8c02de97cc989d9baff88cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e209bd45e2bd4bac7d7d28009bb227"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a79e209bd45e2bd4bac7d7d28009bb227">tokenize</a> (*Any args, **Any kwargs)</td></tr>
<tr class="separator:a79e209bd45e2bd4bac7d7d28009bb227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80161f7d986c933c45a6a3f6b2359d3c"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a80161f7d986c933c45a6a3f6b2359d3c">stringify_path</a> (str|os.PathLike[str]|pathlib.Path filepath)</td></tr>
<tr class="separator:a80161f7d986c933c45a6a3f6b2359d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec38c4f68722a1ce669e80b5e7815e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a8ec38c4f68722a1ce669e80b5e7815e2">make_instance</a> (Callable[..., <a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>] cls, Sequence[Any] args, dict[str, Any] kwargs)</td></tr>
<tr class="separator:a8ec38c4f68722a1ce669e80b5e7815e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d55ba22c34a150ea4778677778b111a"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a5d55ba22c34a150ea4778677778b111a">common_prefix</a> (Iterable[str] paths)</td></tr>
<tr class="separator:a5d55ba22c34a150ea4778677778b111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccaac79211669541c1d6ac9b9a18fad"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a1ccaac79211669541c1d6ac9b9a18fad">other_paths</a> (list[str] paths, str|list[str] path2, bool exists=False, bool flatten=False)</td></tr>
<tr class="separator:a1ccaac79211669541c1d6ac9b9a18fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89f4a28c50142c45a14f7f07fd8551c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#ae89f4a28c50142c45a14f7f07fd8551c">is_exception</a> (Any obj)</td></tr>
<tr class="separator:ae89f4a28c50142c45a14f7f07fd8551c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb521db0bde4611fb05e626e4ef45c1"><td class="memItemLeft" align="right" valign="top">TypeGuard[IO[bytes]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#adeb521db0bde4611fb05e626e4ef45c1">isfilelike</a> (Any f)</td></tr>
<tr class="separator:adeb521db0bde4611fb05e626e4ef45c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327f3d84397bb1b3db6d0cbe6945ecf7"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a327f3d84397bb1b3db6d0cbe6945ecf7">get_protocol</a> (str url)</td></tr>
<tr class="separator:a327f3d84397bb1b3db6d0cbe6945ecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30537ee9f0ce8d2b054da6702548a84c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a30537ee9f0ce8d2b054da6702548a84c">can_be_local</a> (str path)</td></tr>
<tr class="separator:a30537ee9f0ce8d2b054da6702548a84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf15e66012c66958cac76563c46c693a"><td class="memItemLeft" align="right" valign="top">str|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#acf15e66012c66958cac76563c46c693a">get_package_version_without_import</a> (str name)</td></tr>
<tr class="separator:acf15e66012c66958cac76563c46c693a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40121c5e01825156164255e679ad8ac"><td class="memItemLeft" align="right" valign="top">logging.Logger&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#ae40121c5e01825156164255e679ad8ac">setup_logging</a> (logging.Logger|None logger=None, str|None logger_name=None, str level=&quot;DEBUG&quot;, bool clear=True)</td></tr>
<tr class="separator:ae40121c5e01825156164255e679ad8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7772933a9b4b91c0a34934620aa1f735"><td class="memItemLeft" align="right" valign="top">Callable[[type[<a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>]], type[<a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a7772933a9b4b91c0a34934620aa1f735">mirror_from</a> (str origin_name, Iterable[str] methods)</td></tr>
<tr class="separator:a7772933a9b4b91c0a34934620aa1f735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280323d430deabc5955589fb21d94cae"><td class="memItemLeft" align="right" valign="top">Iterator[<a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a280323d430deabc5955589fb21d94cae">nullcontext</a> (<a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a> obj)</td></tr>
<tr class="separator:a280323d430deabc5955589fb21d94cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab660b587490f3949abeb317c44ff4b30"><td class="memItemLeft" align="right" valign="top">tuple[list[str], list[int], list[int]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#ab660b587490f3949abeb317c44ff4b30">merge_offset_ranges</a> (list[str] paths, list[int]|int starts, list[int]|int ends, int max_gap=0, int|None max_block=None, bool sort=True)</td></tr>
<tr class="separator:ab660b587490f3949abeb317c44ff4b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaa9c8ec2ea37d08774046d556bea2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#afdaa9c8ec2ea37d08774046d556bea2f">file_size</a> (IO[bytes] filelike)</td></tr>
<tr class="separator:afdaa9c8ec2ea37d08774046d556bea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac118f8a1cb74bdc0ce7af7af46a49192"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#ac118f8a1cb74bdc0ce7af7af46a49192">atomic_write</a> (str path, str mode=&quot;wb&quot;)</td></tr>
<tr class="separator:ac118f8a1cb74bdc0ce7af7af46a49192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62892a0c0762107a0e742311987c1c70"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#a62892a0c0762107a0e742311987c1c70">glob_translate</a> (pat)</td></tr>
<tr class="separator:a62892a0c0762107a0e742311987c1c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aec3f5ac4ef0c708d33959c1e2975f534"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#aec3f5ac4ef0c708d33959c1e2975f534">DEFAULT_BLOCK_SIZE</a> = 5 * 2**20</td></tr>
<tr class="separator:aec3f5ac4ef0c708d33959c1e2975f534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe79bae9f9f68362fbae5f59b39bdc55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a> = TypeVar(&quot;T&quot;)</td></tr>
<tr class="separator:abe79bae9f9f68362fbae5f59b39bdc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac118f8a1cb74bdc0ce7af7af46a49192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac118f8a1cb74bdc0ce7af7af46a49192">&#9670;&nbsp;</a></span>atomic_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def fsspec.utils.atomic_write </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;wb&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A context manager that opens a temporary file next to `path` and, on exit,
replaces `path` with the temporary file, thereby updating `path`
atomically.
</pre> 
</div>
</div>
<a id="ae7172da0bea0daf5f5ce758613b7b582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7172da0bea0daf5f5ce758613b7b582">&#9670;&nbsp;</a></span>build_name_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Callable[[int], str] fsspec.utils.build_name_function </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a function that receives a single integer
and returns it as a string padded by enough zero characters
to align with maximum possible integer

&gt;&gt;&gt; name_f = build_name_function(57)

&gt;&gt;&gt; name_f(7)
'07'
&gt;&gt;&gt; name_f(31)
'31'
&gt;&gt;&gt; build_name_function(1000)(42)
'0042'
&gt;&gt;&gt; build_name_function(999)(42)
'042'
&gt;&gt;&gt; build_name_function(0)(0)
'0'
</pre> 
</div>
</div>
<a id="a30537ee9f0ce8d2b054da6702548a84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30537ee9f0ce8d2b054da6702548a84c">&#9670;&nbsp;</a></span>can_be_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fsspec.utils.can_be_local </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Can the given URL be used with open_local?</pre> 
</div>
</div>
<a id="a5d55ba22c34a150ea4778677778b111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d55ba22c34a150ea4778677778b111a">&#9670;&nbsp;</a></span>common_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str fsspec.utils.common_prefix </td>
          <td>(</td>
          <td class="paramtype">Iterable[str]&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a list of paths, find the shortest prefix common to all</pre> 
</div>
</div>
<a id="afdaa9c8ec2ea37d08774046d556bea2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaa9c8ec2ea37d08774046d556bea2f">&#9670;&nbsp;</a></span>file_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fsspec.utils.file_size </td>
          <td>(</td>
          <td class="paramtype">IO[bytes]&#160;</td>
          <td class="paramname"><em>filelike</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find length of any open read-mode file-like</pre> 
</div>
</div>
<a id="acf15e66012c66958cac76563c46c693a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf15e66012c66958cac76563c46c693a">&#9670;&nbsp;</a></span>get_package_version_without_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str None fsspec.utils.get_package_version_without_import </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For given package name, try to find the version without importing it

Import and package.__version__ is still the backup here, so an import
*might* happen.

Returns either the version string, or None if the package
or the version was not readily  found.
</pre> 
</div>
</div>
<a id="a327f3d84397bb1b3db6d0cbe6945ecf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327f3d84397bb1b3db6d0cbe6945ecf7">&#9670;&nbsp;</a></span>get_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str fsspec.utils.get_protocol </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62892a0c0762107a0e742311987c1c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62892a0c0762107a0e742311987c1c70">&#9670;&nbsp;</a></span>glob_translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def fsspec.utils.glob_translate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Translate a pathname with shell wildcards to a regular expression.</pre> 
</div>
</div>
<a id="a9c1d6bfa94cb047e5b70e6e8215eb2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1d6bfa94cb047e5b70e6e8215eb2a7">&#9670;&nbsp;</a></span>infer_compression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str None fsspec.utils.infer_compression </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Infer compression, if available, from filename.

Infer a named compression type, if registered and available, from filename
extension. This includes builtin (gz, bz2, zip) compressions, as well as
optional compressions. See fsspec.compression.register_compression.
</pre> 
</div>
</div>
<a id="a5b4af170cd4759ab9d28e3a510628d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4af170cd4759ab9d28e3a510628d73">&#9670;&nbsp;</a></span>infer_storage_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, Any] fsspec.utils.infer_storage_options </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>urlpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>inherit_storage_options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Infer storage options from URL path and merge it with existing storage
options.

Parameters
----------
urlpath: str or unicode
    Either local absolute file path or URL (hdfs://namenode:8020/file.csv)
inherit_storage_options: dict (optional)
    Its contents will get merged with the inferred information from the
    given path

Returns
-------
Storage options dict.

Examples
--------
&gt;&gt;&gt; infer_storage_options('/mnt/datasets/test.csv')  # doctest: +SKIP
{"protocol": "file", "path", "/mnt/datasets/test.csv"}
&gt;&gt;&gt; infer_storage_options(
...     'hdfs://username:pwd@node:123/mnt/datasets/test.csv?q=1',
...     inherit_storage_options={'extra': 'value'},
... )  # doctest: +SKIP
{"protocol": "hdfs", "username": "username", "password": "pwd",
"host": "node", "port": 123, "path": "/mnt/datasets/test.csv",
"url_query": "q=1", "extra": "value"}
</pre> 
</div>
</div>
<a id="ae89f4a28c50142c45a14f7f07fd8551c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89f4a28c50142c45a14f7f07fd8551c">&#9670;&nbsp;</a></span>is_exception()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fsspec.utils.is_exception </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adeb521db0bde4611fb05e626e4ef45c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb521db0bde4611fb05e626e4ef45c1">&#9670;&nbsp;</a></span>isfilelike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> TypeGuard[IO[bytes]] fsspec.utils.isfilelike </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ec38c4f68722a1ce669e80b5e7815e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec38c4f68722a1ce669e80b5e7815e2">&#9670;&nbsp;</a></span>make_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a> fsspec.utils.make_instance </td>
          <td>(</td>
          <td class="paramtype">Callable[..., <a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Any]&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any]
&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab660b587490f3949abeb317c44ff4b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab660b587490f3949abeb317c44ff4b30">&#9670;&nbsp;</a></span>merge_offset_ranges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[list[str], list[int], list[int]] fsspec.utils.merge_offset_ranges </td>
          <td>(</td>
          <td class="paramtype">list[str]&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int] | int&#160;</td>
          <td class="paramname"><em>starts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int] | int&#160;</td>
          <td class="paramname"><em>ends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>max_gap</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_block</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Merge adjacent byte-offset ranges when the inter-range
gap is &lt;= `max_gap`, and when the merged byte range does not
exceed `max_block` (if specified). By default, this function
will re-order the input paths and byte ranges to ensure sorted
order. If the user can guarantee that the inputs are already
sorted, passing `sort=False` will skip the re-ordering.
</pre> 
</div>
</div>
<a id="a7772933a9b4b91c0a34934620aa1f735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7772933a9b4b91c0a34934620aa1f735">&#9670;&nbsp;</a></span>mirror_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Callable[[type[<a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>]], type[<a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>]] fsspec.utils.mirror_from </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>origin_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[str]
&#160;</td>
          <td class="paramname"><em>methods</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Mirror attributes and methods from the given
origin_name attribute of the instance to the
decorated class</pre> 
</div>
</div>
<a id="a280323d430deabc5955589fb21d94cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280323d430deabc5955589fb21d94cae">&#9670;&nbsp;</a></span>nullcontext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[<a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>] fsspec.utils.nullcontext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefsspec_1_1utils.html#abe79bae9f9f68362fbae5f59b39bdc55">T</a>&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ccaac79211669541c1d6ac9b9a18fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccaac79211669541c1d6ac9b9a18fad">&#9670;&nbsp;</a></span>other_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[str] fsspec.utils.other_paths </td>
          <td>(</td>
          <td class="paramtype">list[str]&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str]&#160;</td>
          <td class="paramname"><em>path2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exists</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>flatten</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">In bulk file operations, construct a new file tree from a list of files

Parameters
----------
paths: list of str
    The input file tree
path2: str or list of str
    Root to construct the new list in. If this is already a list of str, we just
    assert it has the right number of elements.
exists: bool (optional)
    For a str destination, it is already exists (and is a dir), files should
    end up inside.
flatten: bool (optional)
    Whether to flatten the input directory tree structure so that the output files
    are in the same directory.

Returns
-------
list of str
</pre> 
</div>
</div>
<a id="a537b0507f8c02de97cc989d9baff88cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537b0507f8c02de97cc989d9baff88cb">&#9670;&nbsp;</a></span>read_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bytes fsspec.utils.read_block </td>
          <td>(</td>
          <td class="paramtype">IO[bytes]&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes | None &#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>split_before</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a block of bytes from a file

Parameters
----------
f: File
    Open file
offset: int
    Byte offset to start read
length: int
    Number of bytes to read, read through end of file if None
delimiter: bytes (optional)
    Ensure reading starts and stops at delimiter bytestring
split_before: bool (optional)
    Start/stop read *before* delimiter bytestring.


If using the ``delimiter=`` keyword argument we ensure that the read
starts and stops at delimiter boundaries that follow the locations
``offset`` and ``offset + length``.  If ``offset`` is zero then we
start at zero, regardless of delimiter.  The bytestring returned WILL
include the terminating delimiter string.

Examples
--------

&gt;&gt;&gt; from io import BytesIO  # doctest: +SKIP
&gt;&gt;&gt; f = BytesIO(b'Alice, 100\\nBob, 200\\nCharlie, 300')  # doctest: +SKIP
&gt;&gt;&gt; read_block(f, 0, 13)  # doctest: +SKIP
b'Alice, 100\\nBo'

&gt;&gt;&gt; read_block(f, 0, 13, delimiter=b'\\n')  # doctest: +SKIP
b'Alice, 100\\nBob, 200\\n'

&gt;&gt;&gt; read_block(f, 10, 10, delimiter=b'\\n')  # doctest: +SKIP
b'Bob, 200\\nCharlie, 300'
</pre> 
</div>
</div>
<a id="ac4e4df5f4746c50e41f217c6e326f07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e4df5f4746c50e41f217c6e326f07b">&#9670;&nbsp;</a></span>seek_delimiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fsspec.utils.seek_delimiter </td>
          <td>(</td>
          <td class="paramtype">IO[bytes]&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Seek current file to file start, file end, or byte after delimiter seq.

Seeks file to next chunk delimiter, where chunks are defined on file start,
a delimiting sequence, and file end. Use file.tell() to see location afterwards.
Note that file start is a valid split, so must be at offset &gt; 0 to seek for
delimiter.

Parameters
----------
file: a file
delimiter: bytes
    a delimiter like ``b'\n'`` or message sentinel, matching file .read() type
blocksize: int
    Number of bytes to read from the file at once.


Returns
-------
Returns True if a delimiter was found, False if at file start or end.</pre> 
</div>
</div>
<a id="ae40121c5e01825156164255e679ad8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40121c5e01825156164255e679ad8ac">&#9670;&nbsp;</a></span>setup_logging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logging Logger fsspec.utils.setup_logging </td>
          <td>(</td>
          <td class="paramtype">logging.Logger | None &#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>logger_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>level</em> = <code>&quot;DEBUG&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>clear</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80161f7d986c933c45a6a3f6b2359d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80161f7d986c933c45a6a3f6b2359d3c">&#9670;&nbsp;</a></span>stringify_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str fsspec.utils.stringify_path </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str] | pathlib.Path&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Attempt to convert a path-like object to a string.

Parameters
----------
filepath: object to be converted

Returns
-------
filepath_str: maybe a string version of the object

Notes
-----
Objects supporting the fspath protocol are coerced according to its
__fspath__ method.

For backwards compatibility with older Python version, pathlib.Path
objects are specially coerced.

Any other object is passed through unchanged, which includes bytes,
strings, buffers, or anything else that's not even path-like.
</pre> 
</div>
</div>
<a id="a79e209bd45e2bd4bac7d7d28009bb227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e209bd45e2bd4bac7d7d28009bb227">&#9670;&nbsp;</a></span>tokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str fsspec.utils.tokenize </td>
          <td>(</td>
          <td class="paramtype">*Any&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Deterministic token

(modified from dask.base)

&gt;&gt;&gt; tokenize([1, 2, '3'])
'9d71491b50023b06fc76928e6eddb952'

&gt;&gt;&gt; tokenize('Hello') == tokenize('Hello')
True
</pre> 
</div>
</div>
<a id="afa39e182341e99f33c850adfddb74281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa39e182341e99f33c850adfddb74281">&#9670;&nbsp;</a></span>update_storage_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">None fsspec.utils.update_storage_options </td>
          <td>(</td>
          <td class="paramtype">dict[str, Any]&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>inherited</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aec3f5ac4ef0c708d33959c1e2975f534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3f5ac4ef0c708d33959c1e2975f534">&#9670;&nbsp;</a></span>DEFAULT_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fsspec.utils.DEFAULT_BLOCK_SIZE = 5 * 2**20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe79bae9f9f68362fbae5f59b39bdc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe79bae9f9f68362fbae5f59b39bdc55">&#9670;&nbsp;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fsspec.utils.T = TypeVar(&quot;T&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
