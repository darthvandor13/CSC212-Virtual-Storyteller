<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sqlalchemy.orm._orm_constructors Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesqlalchemy.html">sqlalchemy</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1orm.html">orm</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html">_orm_constructors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sqlalchemy.orm._orm_constructors Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad1d514ada9c1a0b010497fa90aee322d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1AliasOption.html">AliasOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ad1d514ada9c1a0b010497fa90aee322d">contains_alias</a> (Union[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1Alias.html">Alias</a>, <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1Subquery.html">Subquery</a>] alias)</td></tr>
<tr class="separator:ad1d514ada9c1a0b010497fa90aee322d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06d736e3469df4a972803d5f45bd0bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedColumn.html">MappedColumn</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ad06d736e3469df4a972803d5f45bd0bd">mapped_column</a> (Optional[Union[str, _TypeEngineArgument[Any], <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1SchemaEventTarget.html">SchemaEventTarget</a>]] __name_pos=None, Optional[Union[_TypeEngineArgument[Any], <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1SchemaEventTarget.html">SchemaEventTarget</a>]] __type_pos=None, *<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1SchemaEventTarget.html">SchemaEventTarget</a> args, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[Any] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[Union[bool, Literal[<a class="el" href="classsqlalchemy_1_1sql_1_1schema_1_1SchemaConst.html#a726e8e28db556a8aea2ad20dd4de4ce0">SchemaConst.NULL_UNSPECIFIED</a>]]] nullable=<a class="el" href="classsqlalchemy_1_1sql_1_1schema_1_1SchemaConst.html#a726e8e28db556a8aea2ad20dd4de4ce0">SchemaConst.NULL_UNSPECIFIED</a>, Optional[bool] primary_key=False, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a51b156dffa9e6f82416c4875bde3977c">deferred</a>=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[str] deferred_group=None, Optional[bool] deferred_raiseload=None, bool use_existing_column=False, Optional[str] name=None, Optional[_TypeEngineArgument[Any]] type_=None, _AutoIncrementType autoincrement=&quot;auto&quot;, Optional[str] doc=None, Optional[str] key=None, Optional[bool] index=None, Optional[bool] unique=None, Optional[_InfoType] info=None, Optional[Any] onupdate=None, Optional[Any] insert_default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[_ServerDefaultArgument] server_default=None, Optional[_ServerOnUpdateArgument] server_onupdate=None, bool active_history=False, Optional[bool] quote=None, bool system=False, Optional[str] comment=None, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, int] sort_order=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, **Any kw)</td></tr>
<tr class="separator:ad06d736e3469df4a972803d5f45bd0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1284f9ca40054aad9a49e8caaf34b42d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedColumn.html">MappedColumn</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a1284f9ca40054aad9a49e8caaf34b42d">orm_insert_sentinel</a> (Optional[str] name=None, Optional[_TypeEngineArgument[Any]] type_=None, *Optional[Any] default=None, bool omit_from_statements=True)</td></tr>
<tr class="separator:a1284f9ca40054aad9a49e8caaf34b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc114aa7894fc8b60e0d740596f425a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedSQLExpression.html">MappedSQLExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#abc114aa7894fc8b60e0d740596f425a3">column_property</a> (_ORMColumnExprArgument[_T] column, *_ORMColumnExprArgument[Any] additional_columns, Optional[str] group=None, bool <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a51b156dffa9e6f82416c4875bde3977c">deferred</a>=False, bool raiseload=False, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1PropComparator.html">PropComparator</a>[_T]]] comparator_factory=None, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[Any] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, bool active_history=False, bool expire_on_flush=True, Optional[_InfoType] info=None, Optional[str] doc=None)</td></tr>
<tr class="separator:abc114aa7894fc8b60e0d740596f425a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91efe75efc14c1826ed2b9463c049915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Composite.html">Composite</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a91efe75efc14c1826ed2b9463c049915">composite</a> (_CompositeAttrType[Any] _class_or_attr, *_CompositeAttrType[Any] attrs, Optional[str] group=None, bool <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a51b156dffa9e6f82416c4875bde3977c">deferred</a>=False, bool raiseload=False, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1CompositeProperty_1_1Comparator.html">Composite.Comparator</a>[_T]]] comparator_factory=None, bool active_history=False, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[Any] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[_InfoType] info=None, Optional[str] doc=None, **Any __kw)</td></tr>
<tr class="separator:a91efe75efc14c1826ed2b9463c049915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b31b56dc5ae7b6d95263bed4067d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Composite.html">Composite</a>[_CC]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#aa1b31b56dc5ae7b6d95263bed4067d8d">composite</a> (Type[_CC] _class_or_attr, *_CompositeAttrType[Any] attrs, Optional[str] group=None, bool <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a51b156dffa9e6f82416c4875bde3977c">deferred</a>=False, bool raiseload=False, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1CompositeProperty_1_1Comparator.html">Composite.Comparator</a>[_T]]] comparator_factory=None, bool active_history=False, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[Any] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[_InfoType] info=None, Optional[str] doc=None, **Any __kw)</td></tr>
<tr class="separator:aa1b31b56dc5ae7b6d95263bed4067d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5283c8c612d33111f6429efd66a3a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Composite.html">Composite</a>[_CC]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ab5283c8c612d33111f6429efd66a3a46">composite</a> (Callable[..., _CC] _class_or_attr, *_CompositeAttrType[Any] attrs, Optional[str] group=None, bool <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a51b156dffa9e6f82416c4875bde3977c">deferred</a>=False, bool raiseload=False, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1CompositeProperty_1_1Comparator.html">Composite.Comparator</a>[_T]]] comparator_factory=None, bool active_history=False, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[Any] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[_InfoType] info=None, Optional[str] doc=None, **Any __kw)</td></tr>
<tr class="separator:ab5283c8c612d33111f6429efd66a3a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3184179da4bc2f8aab2c734a887641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Composite.html">Composite</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#aea3184179da4bc2f8aab2c734a887641">composite</a> (Union[None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]] _class_or_attr=None, *_CompositeAttrType[Any] attrs, Optional[str] group=None, bool <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a51b156dffa9e6f82416c4875bde3977c">deferred</a>=False, bool raiseload=False, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1CompositeProperty_1_1Comparator.html">Composite.Comparator</a>[_T]]] comparator_factory=None, bool active_history=False, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[Any] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[_InfoType] info=None, Optional[str] doc=None, **Any __kw)</td></tr>
<tr class="separator:aea3184179da4bc2f8aab2c734a887641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844ec63166b6cb911076548c6c1bd563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1LoaderCriteriaOption.html">LoaderCriteriaOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a844ec63166b6cb911076548c6c1bd563">with_loader_criteria</a> (_EntityType[Any] entity_or_base, Union[_ColumnExpressionArgument[bool], Callable[[Any], _ColumnExpressionArgument[bool]],] where_criteria, bool loader_only=False, bool include_aliases=False, bool propagate_to_loaders=True, bool track_closure_variables=True)</td></tr>
<tr class="separator:a844ec63166b6cb911076548c6c1bd563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1e03f024110629aa290b7515eaec18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1relationships_1_1__RelationshipDeclared.html">_RelationshipDeclared</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#aeb1e03f024110629aa290b7515eaec18">relationship</a> (Optional[_RelationshipArgumentType[Any]] argument=None, Optional[_RelationshipSecondaryArgument] secondary=None, *Optional[bool] uselist=None, Optional[Union[Type[Collection[Any]], Callable[[], Collection[Any]]]] collection_class=None, Optional[_RelationshipJoinConditionArgument] primaryjoin=None, Optional[_RelationshipJoinConditionArgument] secondaryjoin=None, Optional[str] back_populates=None, _ORMOrderByArgument order_by=False, Optional[ORMBackrefArgument] <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ae6199e745a98edbb9d26cff940673e85">backref</a>=None, Optional[str] overlaps=None, bool post_update=False, str cascade=&quot;save-update, merge&quot;, bool viewonly=False, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, _T] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, _LazyLoadArgumentType lazy=&quot;select&quot;, Union[Literal[&quot;all&quot;], bool] passive_deletes=False, bool passive_updates=True, bool active_history=False, bool enable_typechecks=True, Optional[_ORMColCollectionArgument] foreign_keys=None, Optional[_ORMColCollectionArgument] remote_side=None, Optional[int] join_depth=None, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1relationships_1_1RelationshipProperty_1_1Comparator.html">RelationshipProperty.Comparator</a>[Any]]] comparator_factory=None, bool single_parent=False, bool innerjoin=False, Optional[bool] distinct_target_key=None, bool load_on_pending=False, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[Any]]] query_class=None, Optional[_InfoType] info=None, Literal[None, False] omit_join=None, Optional[bool] sync_backref=None, **Any kw)</td></tr>
<tr class="separator:aeb1e03f024110629aa290b7515eaec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada754a884b9775b9fd00bb3d9eb4ae89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Synonym.html">Synonym</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ada754a884b9775b9fd00bb3d9eb4ae89">synonym</a> (str name, *Optional[bool] map_column=None, Optional[Any] descriptor=None, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1PropComparator.html">PropComparator</a>[_T]]] comparator_factory=None, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, _T] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[_InfoType] info=None, Optional[str] doc=None)</td></tr>
<tr class="separator:ada754a884b9775b9fd00bb3d9eb4ae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04660aafacd42a4f4d766d31021422dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html">Session</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a04660aafacd42a4f4d766d31021422dc">create_session</a> (Optional[_SessionBind] bind=None, **Any kwargs)</td></tr>
<tr class="separator:a04660aafacd42a4f4d766d31021422dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0650f5502e471c488b855c873725eb61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1relationships_1_1RelationshipProperty.html">RelationshipProperty</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a0650f5502e471c488b855c873725eb61">dynamic_loader</a> (Optional[_RelationshipArgumentType[Any]] argument=None, **Any kw)</td></tr>
<tr class="separator:a0650f5502e471c488b855c873725eb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6199e745a98edbb9d26cff940673e85"><td class="memItemLeft" align="right" valign="top">ORMBackrefArgument&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ae6199e745a98edbb9d26cff940673e85">backref</a> (str name, **Any kwargs)</td></tr>
<tr class="separator:ae6199e745a98edbb9d26cff940673e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b156dffa9e6f82416c4875bde3977c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedSQLExpression.html">MappedSQLExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a51b156dffa9e6f82416c4875bde3977c">deferred</a> (_ORMColumnExprArgument[_T] column, *_ORMColumnExprArgument[Any] additional_columns, Optional[str] group=None, bool raiseload=False, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1PropComparator.html">PropComparator</a>[_T]]] comparator_factory=None, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] init=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[Any] default=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] default_factory=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] kw_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] hash=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, bool active_history=False, bool expire_on_flush=True, Optional[_InfoType] info=None, Optional[str] doc=None)</td></tr>
<tr class="separator:a51b156dffa9e6f82416c4875bde3977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193704eaff17d55ba6b0f02f18f9b45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedSQLExpression.html">MappedSQLExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a193704eaff17d55ba6b0f02f18f9b45f">query_expression</a> (_ORMColumnExprArgument[_T] default_expr=sql.null(), *Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] repr=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] compare=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, bool expire_on_flush=True, Optional[_InfoType] info=None, Optional[str] doc=None)</td></tr>
<tr class="separator:a193704eaff17d55ba6b0f02f18f9b45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ebfcd4f36d14e8a890e560e0dce0b2"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a13ebfcd4f36d14e8a890e560e0dce0b2">clear_mappers</a> ()</td></tr>
<tr class="separator:a13ebfcd4f36d14e8a890e560e0dce0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023345d0873f8b6c8a3cd7ba8b72edeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ac76550a22f01b55621db8ae7e75da735">AliasedType</a>[_O]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a023345d0873f8b6c8a3cd7ba8b72edeb">aliased</a> (Type[_O] element, Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] alias=None, Optional[str] name=None, bool flat=False, bool adapt_on_names=False)</td></tr>
<tr class="separator:a023345d0873f8b6c8a3cd7ba8b72edeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad613e0961f1fccaa3de1ccc28884b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedClass.html">AliasedClass</a>[_O]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#aad613e0961f1fccaa3de1ccc28884b9e">aliased</a> (Union[<a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedClass.html">AliasedClass</a>[_O], <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O], <a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedInsp.html">AliasedInsp</a>[_O]] element, Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] alias=None, Optional[str] name=None, bool flat=False, bool adapt_on_names=False)</td></tr>
<tr class="separator:aad613e0961f1fccaa3de1ccc28884b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7988b4fba467e642cd36c7e5fad5c06b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a7988b4fba467e642cd36c7e5fad5c06b">aliased</a> (<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a> element, None alias=None, Optional[str] name=None, bool flat=False, bool adapt_on_names=False)</td></tr>
<tr class="separator:a7988b4fba467e642cd36c7e5fad5c06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77206a6b0410cfa3dc668ad1b21e4f52"><td class="memItemLeft" align="right" valign="top">Union[<a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedClass.html">AliasedClass</a>[_O], <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>, <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ac76550a22f01b55621db8ae7e75da735">AliasedType</a>[_O]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a77206a6b0410cfa3dc668ad1b21e4f52">aliased</a> (Union[_EntityType[_O], <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] element, Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] alias=None, Optional[str] name=None, bool flat=False, bool adapt_on_names=False)</td></tr>
<tr class="separator:a77206a6b0410cfa3dc668ad1b21e4f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c44c0abcfce7170dd5ce56690b91c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedClass.html">AliasedClass</a>[_O]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a9c44c0abcfce7170dd5ce56690b91c7b">with_polymorphic</a> (Union[Type[_O], <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]] base, Union[Literal[&quot;*&quot;], Iterable[Type[Any]]] classes, Union[Literal[False, None], <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] selectable=False, bool flat=False, Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnElement.html">ColumnElement</a>[Any]] polymorphic_on=None, bool <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a023345d0873f8b6c8a3cd7ba8b72edeb">aliased</a>=False, bool innerjoin=False, bool adapt_on_names=False, Optional[str] name=None, bool _use_mapper_path=False)</td></tr>
<tr class="separator:a9c44c0abcfce7170dd5ce56690b91c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3151cb4ae47932f01e6dca83036e0fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1__ORMJoin.html">_ORMJoin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a3151cb4ae47932f01e6dca83036e0fb8">join</a> (_FromClauseArgument left, _FromClauseArgument right, Optional[_OnClauseArgument] onclause=None, bool isouter=False, bool full=False)</td></tr>
<tr class="separator:a3151cb4ae47932f01e6dca83036e0fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4692d21971056197a32b1f7aed42d5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1__ORMJoin.html">_ORMJoin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#a4692d21971056197a32b1f7aed42d5fc">outerjoin</a> (_FromClauseArgument left, _FromClauseArgument right, Optional[_OnClauseArgument] onclause=None, bool full=False)</td></tr>
<tr class="separator:a4692d21971056197a32b1f7aed42d5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac76550a22f01b55621db8ae7e75da735"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ac76550a22f01b55621db8ae7e75da735">AliasedType</a> = Annotated[Type[_O], &quot;aliased&quot;]</td></tr>
<tr class="separator:ac76550a22f01b55621db8ae7e75da735"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7988b4fba467e642cd36c7e5fad5c06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7988b4fba467e642cd36c7e5fad5c06b">&#9670;&nbsp;</a></span>aliased() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a> sqlalchemy.orm._orm_constructors.aliased </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>flat</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>adapt_on_names</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a023345d0873f8b6c8a3cd7ba8b72edeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023345d0873f8b6c8a3cd7ba8b72edeb">&#9670;&nbsp;</a></span>aliased() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ac76550a22f01b55621db8ae7e75da735">AliasedType</a>[_O] sqlalchemy.orm._orm_constructors.aliased </td>
          <td>(</td>
          <td class="paramtype">Type[_O]&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>flat</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>adapt_on_names</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77206a6b0410cfa3dc668ad1b21e4f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77206a6b0410cfa3dc668ad1b21e4f52">&#9670;&nbsp;</a></span>aliased() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[<a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedClass.html">AliasedClass</a>[_O], <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>, <a class="el" href="namespacesqlalchemy_1_1orm_1_1__orm__constructors.html#ac76550a22f01b55621db8ae7e75da735">AliasedType</a>[_O]] sqlalchemy.orm._orm_constructors.aliased </td>
          <td>(</td>
          <td class="paramtype">Union[_EntityType[_O], <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>]&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>flat</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>adapt_on_names</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce an alias of the given element, usually an :class:`.AliasedClass`
instance.

E.g.::

    my_alias = aliased(MyClass)

    stmt = select(MyClass, my_alias).filter(MyClass.id &gt; my_alias.id)
    result = session.execute(stmt)

The :func:`.aliased` function is used to create an ad-hoc mapping of a
mapped class to a new selectable.  By default, a selectable is generated
from the normally mapped selectable (typically a :class:`_schema.Table`
) using the
:meth:`_expression.FromClause.alias` method. However, :func:`.aliased`
can also be
used to link the class to a new :func:`_expression.select` statement.
Also, the :func:`.with_polymorphic` function is a variant of
:func:`.aliased` that is intended to specify a so-called "polymorphic
selectable", that corresponds to the union of several joined-inheritance
subclasses at once.

For convenience, the :func:`.aliased` function also accepts plain
:class:`_expression.FromClause` constructs, such as a
:class:`_schema.Table` or
:func:`_expression.select` construct.   In those cases, the
:meth:`_expression.FromClause.alias`
method is called on the object and the new
:class:`_expression.Alias` object returned.  The returned
:class:`_expression.Alias` is not
ORM-mapped in this case.

.. seealso::

    :ref:`tutorial_orm_entity_aliases` - in the :ref:`unified_tutorial`

    :ref:`orm_queryguide_orm_aliases` - in the :ref:`queryguide_toplevel`

:param element: element to be aliased.  Is normally a mapped class,
 but for convenience can also be a :class:`_expression.FromClause`
 element.

:param alias: Optional selectable unit to map the element to.  This is
 usually used to link the object to a subquery, and should be an aliased
 select construct as one would produce from the
 :meth:`_query.Query.subquery` method or
 the :meth:`_expression.Select.subquery` or
 :meth:`_expression.Select.alias` methods of the :func:`_expression.select`
 construct.

:param name: optional string name to use for the alias, if not specified
 by the ``alias`` parameter.  The name, among other things, forms the
 attribute name that will be accessible via tuples returned by a
 :class:`_query.Query` object.  Not supported when creating aliases
 of :class:`_sql.Join` objects.

:param flat: Boolean, will be passed through to the
 :meth:`_expression.FromClause.alias` call so that aliases of
 :class:`_expression.Join` objects will alias the individual tables
 inside the join, rather than creating a subquery.  This is generally
 supported by all modern databases with regards to right-nested joins
 and generally produces more efficient queries.

 When :paramref:`_orm.aliased.flat` is combined with
 :paramref:`_orm.aliased.name`, the resulting joins will alias individual
 tables using a naming scheme similar to ``&lt;prefix&gt;_&lt;tablename&gt;``.  This
 naming scheme is for visibility / debugging purposes only and the
 specific scheme is subject to change without notice.

 .. versionadded:: 2.0.32 added support for combining
    :paramref:`_orm.aliased.name` with :paramref:`_orm.aliased.flat`.
    Previously, this would raise ``NotImplementedError``.

:param adapt_on_names: if True, more liberal "matching" will be used when
 mapping the mapped columns of the ORM entity to those of the
 given selectable - a name-based match will be performed if the
 given selectable doesn't otherwise have a column that corresponds
 to one on the entity.  The use case for this is when associating
 an entity with some derived selectable such as one that uses
 aggregate functions::

    class UnitPrice(Base):
        __tablename__ = "unit_price"
        ...
        unit_id = Column(Integer)
        price = Column(Numeric)


    aggregated_unit_price = (
        Session.query(func.sum(UnitPrice.price).label("price"))
        .group_by(UnitPrice.unit_id)
        .subquery()
    )

    aggregated_unit_price = aliased(
        UnitPrice, alias=aggregated_unit_price, adapt_on_names=True
    )

 Above, functions on ``aggregated_unit_price`` which refer to
 ``.price`` will return the
 ``func.sum(UnitPrice.price).label('price')`` column, as it is
 matched on the name "price".  Ordinarily, the "price" function
 wouldn't have any "column correspondence" to the actual
 ``UnitPrice.price`` column as it is not a proxy of the original.</pre> 
</div>
</div>
<a id="aad613e0961f1fccaa3de1ccc28884b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad613e0961f1fccaa3de1ccc28884b9e">&#9670;&nbsp;</a></span>aliased() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedClass.html">AliasedClass</a>[_O] sqlalchemy.orm._orm_constructors.aliased </td>
          <td>(</td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedClass.html">AliasedClass</a>[_O], <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O], <a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedInsp.html">AliasedInsp</a>[_O]]&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>flat</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>adapt_on_names</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6199e745a98edbb9d26cff940673e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6199e745a98edbb9d26cff940673e85">&#9670;&nbsp;</a></span>backref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ORMBackrefArgument sqlalchemy.orm._orm_constructors.backref </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">When using the :paramref:`_orm.relationship.backref` parameter,
provides specific parameters to be used when the new
:func:`_orm.relationship` is generated.

E.g.::

    "items": relationship(SomeItem, backref=backref("parent", lazy="subquery"))

The :paramref:`_orm.relationship.backref` parameter is generally
considered to be legacy; for modern applications, using
explicit :func:`_orm.relationship` constructs linked together using
the :paramref:`_orm.relationship.back_populates` parameter should be
preferred.

.. seealso::

    :ref:`relationships_backref` - background on backrefs</pre> 
</div>
</div>
<a id="a13ebfcd4f36d14e8a890e560e0dce0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ebfcd4f36d14e8a890e560e0dce0b2">&#9670;&nbsp;</a></span>clear_mappers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm._orm_constructors.clear_mappers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove all mappers from all classes.

.. versionchanged:: 1.4  This function now locates all
   :class:`_orm.registry` objects and calls upon the
   :meth:`_orm.registry.dispose` method of each.

This function removes all instrumentation from classes and disposes
of their associated mappers.  Once called, the classes are unmapped
and can be later re-mapped with new mappers.

:func:`.clear_mappers` is *not* for normal use, as there is literally no
valid usage for it outside of very specific testing scenarios. Normally,
mappers are permanent structural components of user-defined classes, and
are never discarded independently of their class.  If a mapped class
itself is garbage collected, its mapper is automatically disposed of as
well. As such, :func:`.clear_mappers` is only for usage in test suites
that re-use the same classes with different mappings, which is itself an
extremely rare use case - the only such use case is in fact SQLAlchemy's
own test suite, and possibly the test suites of other ORM extension
libraries which intend to test various combinations of mapper construction
upon a fixed set of classes.</pre> 
</div>
</div>
<a id="abc114aa7894fc8b60e0d740596f425a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc114aa7894fc8b60e0d740596f425a3">&#9670;&nbsp;</a></span>column_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedSQLExpression.html">MappedSQLExpression</a>[_T] sqlalchemy.orm._orm_constructors.column_property </td>
          <td>(</td>
          <td class="paramtype">_ORMColumnExprArgument[_T]&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_ORMColumnExprArgument[Any]&#160;</td>
          <td class="paramname"><em>additional_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>group</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>deferred</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raiseload</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1PropComparator.html">PropComparator</a>[_T]]] &#160;</td>
          <td class="paramname"><em>comparator_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>active_history</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>expire_on_flush</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide a column-level property for use with a mapping.

With Declarative mappings, :func:`_orm.column_property` is used to
map read-only SQL expressions to a mapped class.

When using Imperative mappings, :func:`_orm.column_property` also
takes on the role of mapping table columns with additional features.
When using fully Declarative mappings, the :func:`_orm.mapped_column`
construct should be used for this purpose.

With Declarative Dataclass mappings, :func:`_orm.column_property`
is considered to be **read only**, and will not be included in the
Dataclass ``__init__()`` constructor.

The :func:`_orm.column_property` function returns an instance of
:class:`.ColumnProperty`.

.. seealso::

    :ref:`mapper_column_property_sql_expressions` - general use of
    :func:`_orm.column_property` to map SQL expressions

    :ref:`orm_imperative_table_column_options` - usage of
    :func:`_orm.column_property` with Imperative Table mappings to apply
    additional options to a plain :class:`_schema.Column` object

:param \*cols:
    list of Column objects to be mapped.

:param active_history=False:

    Used only for Imperative Table mappings, or legacy-style Declarative
    mappings (i.e. which have not been upgraded to
    :func:`_orm.mapped_column`), for column-based attributes that are
    expected to be writeable; use :func:`_orm.mapped_column` with
    :paramref:`_orm.mapped_column.active_history` for Declarative mappings.
    See that parameter for functional details.

:param comparator_factory: a class which extends
    :class:`.ColumnProperty.Comparator` which provides custom SQL
    clause generation for comparison operations.

:param group:
    a group name for this property when marked as deferred.

:param deferred:
    when True, the column property is "deferred", meaning that
    it does not load immediately, and is instead loaded when the
    attribute is first accessed on an instance.  See also
    :func:`~sqlalchemy.orm.deferred`.

:param doc:
    optional string that will be applied as the doc on the
    class-bound descriptor.

:param expire_on_flush=True:
    Disable expiry on flush.   A column_property() which refers
    to a SQL expression (and not a single table-bound column)
    is considered to be a "read only" property; populating it
    has no effect on the state of data, and it can only return
    database state.   For this reason a column_property()'s value
    is expired whenever the parent object is involved in a
    flush, that is, has any kind of "dirty" state within a flush.
    Setting this parameter to ``False`` will have the effect of
    leaving any existing value present after the flush proceeds.
    Note that the :class:`.Session` with default expiration
    settings still expires
    all attributes after a :meth:`.Session.commit` call, however.

:param info: Optional data dictionary which will be populated into the
    :attr:`.MapperProperty.info` attribute of this object.

:param raiseload: if True, indicates the column should raise an error
    when undeferred, rather than loading the value.  This can be
    altered at query time by using the :func:`.deferred` option with
    raiseload=False.

    .. versionadded:: 1.4

    .. seealso::

        :ref:`orm_queryguide_deferred_raiseload`

:param init: Specific to :ref:`orm_declarative_native_dataclasses`,
 specifies if the mapped attribute should be part of the ``__init__()``
 method as generated by the dataclass process.
:param repr: Specific to :ref:`orm_declarative_native_dataclasses`,
 specifies if the mapped attribute should be part of the ``__repr__()``
 method as generated by the dataclass process.
:param default_factory: Specific to
 :ref:`orm_declarative_native_dataclasses`,
 specifies a default-value generation function that will take place
 as part of the ``__init__()``
 method as generated by the dataclass process.

 .. seealso::

    :ref:`defaults_default_factory_insert_default`

    :paramref:`_orm.mapped_column.default`

    :paramref:`_orm.mapped_column.insert_default`

:param compare: Specific to
 :ref:`orm_declarative_native_dataclasses`, indicates if this field
 should be included in comparison operations when generating the
 ``__eq__()`` and ``__ne__()`` methods for the mapped class.

 .. versionadded:: 2.0.0b4

:param kw_only: Specific to
 :ref:`orm_declarative_native_dataclasses`, indicates if this field
 should be marked as keyword-only when generating the ``__init__()``.

:param hash: Specific to
 :ref:`orm_declarative_native_dataclasses`, controls if this field
 is included when generating the ``__hash__()`` method for the mapped
 class.

 .. versionadded:: 2.0.36</pre> 
</div>
</div>
<a id="a91efe75efc14c1826ed2b9463c049915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91efe75efc14c1826ed2b9463c049915">&#9670;&nbsp;</a></span>composite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Composite.html">Composite</a>[Any] sqlalchemy.orm._orm_constructors.composite </td>
          <td>(</td>
          <td class="paramtype">_CompositeAttrType[Any]&#160;</td>
          <td class="paramname"><em>_class_or_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_CompositeAttrType[Any]&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>group</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>deferred</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raiseload</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1CompositeProperty_1_1Comparator.html">Composite.Comparator</a>[_T]]] &#160;</td>
          <td class="paramname"><em>comparator_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>active_history</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>__kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5283c8c612d33111f6429efd66a3a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5283c8c612d33111f6429efd66a3a46">&#9670;&nbsp;</a></span>composite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Composite.html">Composite</a>[_CC] sqlalchemy.orm._orm_constructors.composite </td>
          <td>(</td>
          <td class="paramtype">Callable[..., _CC]&#160;</td>
          <td class="paramname"><em>_class_or_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_CompositeAttrType[Any]&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>group</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>deferred</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raiseload</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1CompositeProperty_1_1Comparator.html">Composite.Comparator</a>[_T]]] &#160;</td>
          <td class="paramname"><em>comparator_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>active_history</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>__kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1b31b56dc5ae7b6d95263bed4067d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b31b56dc5ae7b6d95263bed4067d8d">&#9670;&nbsp;</a></span>composite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Composite.html">Composite</a>[_CC] sqlalchemy.orm._orm_constructors.composite </td>
          <td>(</td>
          <td class="paramtype">Type[_CC]&#160;</td>
          <td class="paramname"><em>_class_or_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_CompositeAttrType[Any]&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>group</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>deferred</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raiseload</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1CompositeProperty_1_1Comparator.html">Composite.Comparator</a>[_T]]] &#160;</td>
          <td class="paramname"><em>comparator_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>active_history</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>__kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea3184179da4bc2f8aab2c734a887641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3184179da4bc2f8aab2c734a887641">&#9670;&nbsp;</a></span>composite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Composite.html">Composite</a>[Any] sqlalchemy.orm._orm_constructors.composite </td>
          <td>(</td>
          <td class="paramtype">Union[
        None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]
    ] &#160;</td>
          <td class="paramname"><em>_class_or_attr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_CompositeAttrType[Any]&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>group</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>deferred</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raiseload</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1CompositeProperty_1_1Comparator.html">Composite.Comparator</a>[_T]]] &#160;</td>
          <td class="paramname"><em>comparator_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>active_history</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>__kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a composite column-based property for use with a Mapper.

See the mapping documentation section :ref:`mapper_composite` for a
full usage example.

The :class:`.MapperProperty` returned by :func:`.composite`
is the :class:`.Composite`.

:param class\_:
  The "composite type" class, or any classmethod or callable which
  will produce a new instance of the composite object given the
  column values in order.

:param \*attrs:
  List of elements to be mapped, which may include:

  * :class:`_schema.Column` objects
  * :func:`_orm.mapped_column` constructs
  * string names of other attributes on the mapped class, which may be
    any other SQL or object-mapped attribute.  This can for
    example allow a composite that refers to a many-to-one relationship

:param active_history=False:
  When ``True``, indicates that the "previous" value for a
  scalar attribute should be loaded when replaced, if not
  already loaded.  See the same flag on :func:`.column_property`.

:param group:
  A group name for this property when marked as deferred.

:param deferred:
  When True, the column property is "deferred", meaning that it does
  not load immediately, and is instead loaded when the attribute is
  first accessed on an instance.  See also
  :func:`~sqlalchemy.orm.deferred`.

:param comparator_factory:  a class which extends
  :class:`.Composite.Comparator` which provides custom SQL
  clause generation for comparison operations.

:param doc:
  optional string that will be applied as the doc on the
  class-bound descriptor.

:param info: Optional data dictionary which will be populated into the
    :attr:`.MapperProperty.info` attribute of this object.

:param init: Specific to :ref:`orm_declarative_native_dataclasses`,
 specifies if the mapped attribute should be part of the ``__init__()``
 method as generated by the dataclass process.
:param repr: Specific to :ref:`orm_declarative_native_dataclasses`,
 specifies if the mapped attribute should be part of the ``__repr__()``
 method as generated by the dataclass process.
:param default_factory: Specific to
 :ref:`orm_declarative_native_dataclasses`,
 specifies a default-value generation function that will take place
 as part of the ``__init__()``
 method as generated by the dataclass process.

:param compare: Specific to
 :ref:`orm_declarative_native_dataclasses`, indicates if this field
 should be included in comparison operations when generating the
 ``__eq__()`` and ``__ne__()`` methods for the mapped class.

 .. versionadded:: 2.0.0b4

:param kw_only: Specific to
 :ref:`orm_declarative_native_dataclasses`, indicates if this field
 should be marked as keyword-only when generating the ``__init__()``.

:param hash: Specific to
 :ref:`orm_declarative_native_dataclasses`, controls if this field
 is included when generating the ``__hash__()`` method for the mapped
 class.

 .. versionadded:: 2.0.36
</pre> 
</div>
</div>
<a id="ad1d514ada9c1a0b010497fa90aee322d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d514ada9c1a0b010497fa90aee322d">&#9670;&nbsp;</a></span>contains_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1AliasOption.html">AliasOption</a> sqlalchemy.orm._orm_constructors.contains_alias </td>
          <td>(</td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1Alias.html">Alias</a>, <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1Subquery.html">Subquery</a>]&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`.MapperOption` that will indicate to the
:class:`_query.Query`
that the main table has been aliased.</pre> 
</div>
</div>
<a id="a04660aafacd42a4f4d766d31021422dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04660aafacd42a4f4d766d31021422dc">&#9670;&nbsp;</a></span>create_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html">Session</a> sqlalchemy.orm._orm_constructors.create_session </td>
          <td>(</td>
          <td class="paramtype">Optional[_SessionBind] &#160;</td>
          <td class="paramname"><em>bind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new :class:`.Session`
with no automation enabled by default.

This function is used primarily for testing.   The usual
route to :class:`.Session` creation is via its constructor
or the :func:`.sessionmaker` function.

:param bind: optional, a single Connectable to use for all
  database access in the created
  :class:`~sqlalchemy.orm.session.Session`.

:param \*\*kwargs: optional, passed through to the
  :class:`.Session` constructor.

:returns: an :class:`~sqlalchemy.orm.session.Session` instance

The defaults of create_session() are the opposite of that of
:func:`sessionmaker`; ``autoflush`` and ``expire_on_commit`` are
False.

Usage::

  &gt;&gt;&gt; from sqlalchemy.orm import create_session
  &gt;&gt;&gt; session = create_session()

It is recommended to use :func:`sessionmaker` instead of
create_session().</pre> 
</div>
</div>
<a id="a51b156dffa9e6f82416c4875bde3977c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b156dffa9e6f82416c4875bde3977c">&#9670;&nbsp;</a></span>deferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedSQLExpression.html">MappedSQLExpression</a>[_T] sqlalchemy.orm._orm_constructors.deferred </td>
          <td>(</td>
          <td class="paramtype">_ORMColumnExprArgument[_T]&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_ORMColumnExprArgument[Any]&#160;</td>
          <td class="paramname"><em>additional_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>group</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raiseload</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1PropComparator.html">PropComparator</a>[_T]]] &#160;</td>
          <td class="paramname"><em>comparator_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>active_history</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>expire_on_flush</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate a column-based mapped attribute that by default will
not load unless accessed.

When using :func:`_orm.mapped_column`, the same functionality as
that of :func:`_orm.deferred` construct is provided by using the
:paramref:`_orm.mapped_column.deferred` parameter.

:param \*columns: columns to be mapped.  This is typically a single
 :class:`_schema.Column` object,
 however a collection is supported in order
 to support multiple columns mapped under the same attribute.

:param raiseload: boolean, if True, indicates an exception should be raised
 if the load operation is to take place.

 .. versionadded:: 1.4


Additional arguments are the same as that of :func:`_orm.column_property`.

.. seealso::

    :ref:`orm_queryguide_deferred_imperative`</pre> 
</div>
</div>
<a id="a0650f5502e471c488b855c873725eb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0650f5502e471c488b855c873725eb61">&#9670;&nbsp;</a></span>dynamic_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1relationships_1_1RelationshipProperty.html">RelationshipProperty</a>[Any] sqlalchemy.orm._orm_constructors.dynamic_loader </td>
          <td>(</td>
          <td class="paramtype">Optional[_RelationshipArgumentType[Any]] &#160;</td>
          <td class="paramname"><em>argument</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a dynamically-loading mapper property.

This is essentially the same as
using the ``lazy='dynamic'`` argument with :func:`relationship`::

    dynamic_loader(SomeClass)

    # is the same as

    relationship(SomeClass, lazy="dynamic")

See the section :ref:`dynamic_relationship` for more details
on dynamic loading.</pre> 
</div>
</div>
<a id="a3151cb4ae47932f01e6dca83036e0fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3151cb4ae47932f01e6dca83036e0fb8">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1__ORMJoin.html">_ORMJoin</a> sqlalchemy.orm._orm_constructors.join </td>
          <td>(</td>
          <td class="paramtype">_FromClauseArgument&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_FromClauseArgument&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_OnClauseArgument] &#160;</td>
          <td class="paramname"><em>onclause</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>isouter</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>full</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce an inner join between left and right clauses.

:func:`_orm.join` is an extension to the core join interface
provided by :func:`_expression.join()`, where the
left and right selectable may be not only core selectable
objects such as :class:`_schema.Table`, but also mapped classes or
:class:`.AliasedClass` instances.   The "on" clause can
be a SQL expression or an ORM mapped attribute
referencing a configured :func:`_orm.relationship`.

:func:`_orm.join` is not commonly needed in modern usage,
as its functionality is encapsulated within that of the
:meth:`_sql.Select.join` and :meth:`_query.Query.join`
methods. which feature a
significant amount of automation beyond :func:`_orm.join`
by itself.  Explicit use of :func:`_orm.join`
with ORM-enabled SELECT statements involves use of the
:meth:`_sql.Select.select_from` method, as in::

    from sqlalchemy.orm import join

    stmt = (
        select(User)
        .select_from(join(User, Address, User.addresses))
        .filter(Address.email_address == "foo@bar.com")
    )

In modern SQLAlchemy the above join can be written more
succinctly as::

    stmt = (
        select(User)
        .join(User.addresses)
        .filter(Address.email_address == "foo@bar.com")
    )

.. warning:: using :func:`_orm.join` directly may not work properly
   with modern ORM options such as :func:`_orm.with_loader_criteria`.
   It is strongly recommended to use the idiomatic join patterns
   provided by methods such as :meth:`.Select.join` and
   :meth:`.Select.join_from` when creating ORM joins.

.. seealso::

    :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` for
    background on idiomatic ORM join patterns</pre> 
</div>
</div>
<a id="ad06d736e3469df4a972803d5f45bd0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06d736e3469df4a972803d5f45bd0bd">&#9670;&nbsp;</a></span>mapped_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedColumn.html">MappedColumn</a>[Any] sqlalchemy.orm._orm_constructors.mapped_column </td>
          <td>(</td>
          <td class="paramtype">Optional[
        Union[str, _TypeEngineArgument[Any], <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1SchemaEventTarget.html">SchemaEventTarget</a>]
    ] &#160;</td>
          <td class="paramname"><em>__name_pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[
        Union[_TypeEngineArgument[Any], <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1SchemaEventTarget.html">SchemaEventTarget</a>]
    ] &#160;</td>
          <td class="paramname"><em>__type_pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1SchemaEventTarget.html">SchemaEventTarget</a>&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[
        Union[bool, Literal[<a class="el" href="classsqlalchemy_1_1sql_1_1schema_1_1SchemaConst.html#a726e8e28db556a8aea2ad20dd4de4ce0">SchemaConst.NULL_UNSPECIFIED</a>]]
    ] &#160;</td>
          <td class="paramname"><em>nullable</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1schema_1_1SchemaConst.html#a726e8e28db556a8aea2ad20dd4de4ce0">SchemaConst.NULL_UNSPECIFIED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>primary_key</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>deferred</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>deferred_group</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>deferred_raiseload</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>use_existing_column</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_TypeEngineArgument[Any]] &#160;</td>
          <td class="paramname"><em>type_</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AutoIncrementType &#160;</td>
          <td class="paramname"><em>autoincrement</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>unique</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>onupdate</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>insert_default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_ServerDefaultArgument] &#160;</td>
          <td class="paramname"><em>server_default</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_ServerOnUpdateArgument] &#160;</td>
          <td class="paramname"><em>server_onupdate</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>active_history</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>quote</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>system</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>comment</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, int] &#160;</td>
          <td class="paramname"><em>sort_order</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">declare a new ORM-mapped :class:`_schema.Column` construct
for use within :ref:`Declarative Table &lt;orm_declarative_table&gt;`
configuration.

The :func:`_orm.mapped_column` function provides an ORM-aware and
Python-typing-compatible construct which is used with
:ref:`declarative &lt;orm_declarative_mapping&gt;` mappings to indicate an
attribute that's mapped to a Core :class:`_schema.Column` object.  It
provides the equivalent feature as mapping an attribute to a
:class:`_schema.Column` object directly when using Declarative,
specifically when using :ref:`Declarative Table &lt;orm_declarative_table&gt;`
configuration.

.. versionadded:: 2.0

:func:`_orm.mapped_column` is normally used with explicit typing along with
the :class:`_orm.Mapped` annotation type, where it can derive the SQL
type and nullability for the column based on what's present within the
:class:`_orm.Mapped` annotation.   It also may be used without annotations
as a drop-in replacement for how :class:`_schema.Column` is used in
Declarative mappings in SQLAlchemy 1.x style.

For usage examples of :func:`_orm.mapped_column`, see the documentation
at :ref:`orm_declarative_table`.

.. seealso::

    :ref:`orm_declarative_table` - complete documentation

    :ref:`whatsnew_20_orm_declarative_typing` - migration notes for
    Declarative mappings using 1.x style mappings

:param __name: String name to give to the :class:`_schema.Column`.  This
 is an optional, positional only argument that if present must be the
 first positional argument passed.  If omitted, the attribute name to
 which the :func:`_orm.mapped_column`  is mapped will be used as the SQL
 column name.
:param __type: :class:`_types.TypeEngine` type or instance which will
 indicate the datatype to be associated with the :class:`_schema.Column`.
 This is an optional, positional-only argument that if present must
 immediately follow the ``__name`` parameter if present also, or otherwise
 be the first positional parameter.  If omitted, the ultimate type for
 the column may be derived either from the annotated type, or if a
 :class:`_schema.ForeignKey` is present, from the datatype of the
 referenced column.
:param \*args: Additional positional arguments include constructs such
 as :class:`_schema.ForeignKey`, :class:`_schema.CheckConstraint`,
 and :class:`_schema.Identity`, which are passed through to the constructed
 :class:`_schema.Column`.
:param nullable: Optional bool, whether the column should be "NULL" or
 "NOT NULL". If omitted, the nullability is derived from the type
 annotation based on whether or not ``typing.Optional`` is present.
 ``nullable`` defaults to ``True`` otherwise for non-primary key columns,
 and ``False`` for primary key columns.
:param primary_key: optional bool, indicates the :class:`_schema.Column`
 would be part of the table's primary key or not.
:param deferred: Optional bool - this keyword argument is consumed by the
 ORM declarative process, and is not part of the :class:`_schema.Column`
 itself; instead, it indicates that this column should be "deferred" for
 loading as though mapped by :func:`_orm.deferred`.

 .. seealso::

    :ref:`orm_queryguide_deferred_declarative`

:param deferred_group: Implies :paramref:`_orm.mapped_column.deferred`
 to ``True``, and set the :paramref:`_orm.deferred.group` parameter.

 .. seealso::

    :ref:`orm_queryguide_deferred_group`

:param deferred_raiseload: Implies :paramref:`_orm.mapped_column.deferred`
 to ``True``, and set the :paramref:`_orm.deferred.raiseload` parameter.

 .. seealso::

    :ref:`orm_queryguide_deferred_raiseload`

:param use_existing_column: if True, will attempt to locate the given
 column name on an inherited superclass (typically single inheriting
 superclass), and if present, will not produce a new column, mapping
 to the superclass column as though it were omitted from this class.
 This is used for mixins that add new columns to an inherited superclass.

 .. seealso::

    :ref:`orm_inheritance_column_conflicts`

 .. versionadded:: 2.0.0b4

:param default: Passed directly to the
 :paramref:`_schema.Column.default` parameter if the
 :paramref:`_orm.mapped_column.insert_default` parameter is not present.
 Additionally, when used with :ref:`orm_declarative_native_dataclasses`,
 indicates a default Python value that should be applied to the keyword
 constructor within the generated ``__init__()`` method.

 Note that in the case of dataclass generation when
 :paramref:`_orm.mapped_column.insert_default` is not present, this means
 the :paramref:`_orm.mapped_column.default` value is used in **two**
 places, both the ``__init__()`` method as well as the
 :paramref:`_schema.Column.default` parameter. While this behavior may
 change in a future release, for the moment this tends to "work out"; a
 default of ``None`` will mean that the :class:`_schema.Column` gets no
 default generator, whereas a default that refers to a non-``None`` Python
 or SQL expression value will be assigned up front on the object when
 ``__init__()`` is called, which is the same value that the Core
 :class:`_sql.Insert` construct would use in any case, leading to the same
 end result.

 .. note:: When using Core level column defaults that are callables to
    be interpreted by the underlying :class:`_schema.Column` in conjunction
    with :ref:`ORM-mapped dataclasses
    &lt;orm_declarative_native_dataclasses&gt;`, especially those that are
    :ref:`context-aware default functions &lt;context_default_functions&gt;`,
    **the** :paramref:`_orm.mapped_column.insert_default` **parameter must
    be used instead**.  This is necessary to disambiguate the callable from
    being interpreted as a dataclass level default.

 .. seealso::

    :ref:`defaults_default_factory_insert_default`

    :paramref:`_orm.mapped_column.insert_default`

    :paramref:`_orm.mapped_column.default_factory`

:param insert_default: Passed directly to the
 :paramref:`_schema.Column.default` parameter; will supersede the value
 of :paramref:`_orm.mapped_column.default` when present, however
 :paramref:`_orm.mapped_column.default` will always apply to the
 constructor default for a dataclasses mapping.

 .. seealso::

    :ref:`defaults_default_factory_insert_default`

    :paramref:`_orm.mapped_column.default`

    :paramref:`_orm.mapped_column.default_factory`

:param sort_order: An integer that indicates how this mapped column
 should be sorted compared to the others when the ORM is creating a
 :class:`_schema.Table`. Among mapped columns that have the same
 value the default ordering is used, placing first the mapped columns
 defined in the main class, then the ones in the super classes.
 Defaults to 0. The sort is ascending.

 .. versionadded:: 2.0.4

:param active_history=False:

    When ``True``, indicates that the "previous" value for a
    scalar attribute should be loaded when replaced, if not
    already loaded. Normally, history tracking logic for
    simple non-primary-key scalar values only needs to be
    aware of the "new" value in order to perform a flush. This
    flag is available for applications that make use of
    :func:`.attributes.get_history` or :meth:`.Session.is_modified`
    which also need to know the "previous" value of the attribute.

    .. versionadded:: 2.0.10


:param init: Specific to :ref:`orm_declarative_native_dataclasses`,
 specifies if the mapped attribute should be part of the ``__init__()``
 method as generated by the dataclass process.
:param repr: Specific to :ref:`orm_declarative_native_dataclasses`,
 specifies if the mapped attribute should be part of the ``__repr__()``
 method as generated by the dataclass process.
:param default_factory: Specific to
 :ref:`orm_declarative_native_dataclasses`,
 specifies a default-value generation function that will take place
 as part of the ``__init__()``
 method as generated by the dataclass process.

 .. seealso::

    :ref:`defaults_default_factory_insert_default`

    :paramref:`_orm.mapped_column.default`

    :paramref:`_orm.mapped_column.insert_default`

:param compare: Specific to
 :ref:`orm_declarative_native_dataclasses`, indicates if this field
 should be included in comparison operations when generating the
 ``__eq__()`` and ``__ne__()`` methods for the mapped class.

 .. versionadded:: 2.0.0b4

:param kw_only: Specific to
 :ref:`orm_declarative_native_dataclasses`, indicates if this field
 should be marked as keyword-only when generating the ``__init__()``.

:param hash: Specific to
 :ref:`orm_declarative_native_dataclasses`, controls if this field
 is included when generating the ``__hash__()`` method for the mapped
 class.

 .. versionadded:: 2.0.36

:param \**kw: All remaining keyword arguments are passed through to the
 constructor for the :class:`_schema.Column`.</pre> 
</div>
</div>
<a id="a1284f9ca40054aad9a49e8caaf34b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1284f9ca40054aad9a49e8caaf34b42d">&#9670;&nbsp;</a></span>orm_insert_sentinel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedColumn.html">MappedColumn</a>[Any] sqlalchemy.orm._orm_constructors.orm_insert_sentinel </td>
          <td>(</td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_TypeEngineArgument[Any]] &#160;</td>
          <td class="paramname"><em>type_</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[Any] &#160;</td>
          <td class="paramname"><em>default</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>omit_from_statements</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provides a surrogate :func:`_orm.mapped_column` that generates
a so-called :term:`sentinel` column, allowing efficient bulk
inserts with deterministic RETURNING sorting for tables that don't
otherwise have qualifying primary key configurations.

Use of :func:`_orm.orm_insert_sentinel` is analogous to the use of the
:func:`_schema.insert_sentinel` construct within a Core
:class:`_schema.Table` construct.

Guidelines for adding this construct to a Declarative mapped class
are the same as that of the :func:`_schema.insert_sentinel` construct;
the database table itself also needs to have a column with this name
present.

For background on how this object is used, see the section
:ref:`engine_insertmanyvalues_sentinel_columns` as part of the
section :ref:`engine_insertmanyvalues`.

.. seealso::

    :func:`_schema.insert_sentinel`

    :ref:`engine_insertmanyvalues`

    :ref:`engine_insertmanyvalues_sentinel_columns`


.. versionadded:: 2.0.10</pre> 
</div>
</div>
<a id="a4692d21971056197a32b1f7aed42d5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4692d21971056197a32b1f7aed42d5fc">&#9670;&nbsp;</a></span>outerjoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1__ORMJoin.html">_ORMJoin</a> sqlalchemy.orm._orm_constructors.outerjoin </td>
          <td>(</td>
          <td class="paramtype">_FromClauseArgument&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_FromClauseArgument&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_OnClauseArgument] &#160;</td>
          <td class="paramname"><em>onclause</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>full</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a left outer join between left and right clauses.

This is the "outer join" version of the :func:`_orm.join` function,
featuring the same behavior except that an OUTER JOIN is generated.
See that function's documentation for other usage details.</pre> 
</div>
</div>
<a id="a193704eaff17d55ba6b0f02f18f9b45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193704eaff17d55ba6b0f02f18f9b45f">&#9670;&nbsp;</a></span>query_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1properties_1_1MappedSQLExpression.html">MappedSQLExpression</a>[_T] sqlalchemy.orm._orm_constructors.query_expression </td>
          <td>(</td>
          <td class="paramtype">_ORMColumnExprArgument[_T] &#160;</td>
          <td class="paramname"><em>default_expr</em> = <code>sql.null()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>expire_on_flush</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate an attribute that populates from a query-time SQL expression.

:param default_expr: Optional SQL expression object that will be used in
    all cases if not assigned later with :func:`_orm.with_expression`.

.. versionadded:: 1.2

.. seealso::

    :ref:`orm_queryguide_with_expression` - background and usage examples</pre> 
</div>
</div>
<a id="aeb1e03f024110629aa290b7515eaec18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1e03f024110629aa290b7515eaec18">&#9670;&nbsp;</a></span>relationship()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1relationships_1_1__RelationshipDeclared.html">_RelationshipDeclared</a>[Any] sqlalchemy.orm._orm_constructors.relationship </td>
          <td>(</td>
          <td class="paramtype">Optional[_RelationshipArgumentType[Any]] &#160;</td>
          <td class="paramname"><em>argument</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_RelationshipSecondaryArgument] &#160;</td>
          <td class="paramname"><em>secondary</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[bool] &#160;</td>
          <td class="paramname"><em>uselist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[
        Union[Type[Collection[Any]], Callable[[], Collection[Any]]]
    ] &#160;</td>
          <td class="paramname"><em>collection_class</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_RelationshipJoinConditionArgument] &#160;</td>
          <td class="paramname"><em>primaryjoin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_RelationshipJoinConditionArgument] &#160;</td>
          <td class="paramname"><em>secondaryjoin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>back_populates</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ORMOrderByArgument &#160;</td>
          <td class="paramname"><em>order_by</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[ORMBackrefArgument] &#160;</td>
          <td class="paramname"><em>backref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>overlaps</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>post_update</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>cascade</em> = <code>&quot;save-update,&#160;merge&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>viewonly</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, _T] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_LazyLoadArgumentType &#160;</td>
          <td class="paramname"><em>lazy</em> = <code>&quot;select&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[Literal[&quot;all&quot;], bool] &#160;</td>
          <td class="paramname"><em>passive_deletes</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>passive_updates</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>active_history</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>enable_typechecks</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_ORMColCollectionArgument] &#160;</td>
          <td class="paramname"><em>foreign_keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_ORMColCollectionArgument] &#160;</td>
          <td class="paramname"><em>remote_side</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int] &#160;</td>
          <td class="paramname"><em>join_depth</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[
        Type[<a class="el" href="classsqlalchemy_1_1orm_1_1relationships_1_1RelationshipProperty_1_1Comparator.html">RelationshipProperty.Comparator</a>[Any]]
    ] &#160;</td>
          <td class="paramname"><em>comparator_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>single_parent</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>innerjoin</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>distinct_target_key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>load_on_pending</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[Any]]] &#160;</td>
          <td class="paramname"><em>query_class</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[None, False] &#160;</td>
          <td class="paramname"><em>omit_join</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>sync_backref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide a relationship between two mapped classes.

This corresponds to a parent-child or associative table relationship.
The constructed class is an instance of :class:`.Relationship`.

.. seealso::

    :ref:`tutorial_orm_related_objects` - tutorial introduction
    to :func:`_orm.relationship` in the :ref:`unified_tutorial`

    :ref:`relationship_config_toplevel` - narrative documentation

:param argument:
  This parameter refers to the class that is to be related.   It
  accepts several forms, including a direct reference to the target
  class itself, the :class:`_orm.Mapper` instance for the target class,
  a Python callable / lambda that will return a reference to the
  class or :class:`_orm.Mapper` when called, and finally a string
  name for the class, which will be resolved from the
  :class:`_orm.registry` in use in order to locate the class, e.g.::

        class SomeClass(Base):
            # ...

            related = relationship("RelatedClass")

  The :paramref:`_orm.relationship.argument` may also be omitted from the
  :func:`_orm.relationship` construct entirely, and instead placed inside
  a :class:`_orm.Mapped` annotation on the left side, which should
  include a Python collection type if the relationship is expected
  to be a collection, such as::

        class SomeClass(Base):
            # ...

            related_items: Mapped[List["RelatedItem"]] = relationship()

  Or for a many-to-one or one-to-one relationship::

        class SomeClass(Base):
            # ...

            related_item: Mapped["RelatedItem"] = relationship()

  .. seealso::

    :ref:`orm_declarative_properties` - further detail
    on relationship configuration when using Declarative.

:param secondary:
  For a many-to-many relationship, specifies the intermediary
  table, and is typically an instance of :class:`_schema.Table`.
  In less common circumstances, the argument may also be specified
  as an :class:`_expression.Alias` construct, or even a
  :class:`_expression.Join` construct.

  :paramref:`_orm.relationship.secondary` may
  also be passed as a callable function which is evaluated at
  mapper initialization time.  When using Declarative, it may also
  be a string argument noting the name of a :class:`_schema.Table`
  that is
  present in the :class:`_schema.MetaData`
  collection associated with the
  parent-mapped :class:`_schema.Table`.

  .. warning:: When passed as a Python-evaluable string, the
     argument is interpreted using Python's ``eval()`` function.
     **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
     See :ref:`declarative_relationship_eval` for details on
     declarative evaluation of :func:`_orm.relationship` arguments.

  The :paramref:`_orm.relationship.secondary` keyword argument is
  typically applied in the case where the intermediary
  :class:`_schema.Table`
  is not otherwise expressed in any direct class mapping. If the
  "secondary" table is also explicitly mapped elsewhere (e.g. as in
  :ref:`association_pattern`), one should consider applying the
  :paramref:`_orm.relationship.viewonly` flag so that this
  :func:`_orm.relationship`
  is not used for persistence operations which
  may conflict with those of the association object pattern.

  .. seealso::

      :ref:`relationships_many_to_many` - Reference example of "many
      to many".

      :ref:`self_referential_many_to_many` - Specifics on using
      many-to-many in a self-referential case.

      :ref:`declarative_many_to_many` - Additional options when using
      Declarative.

      :ref:`association_pattern` - an alternative to
      :paramref:`_orm.relationship.secondary`
      when composing association
      table relationships, allowing additional attributes to be
      specified on the association table.

      :ref:`composite_secondary_join` - a lesser-used pattern which
      in some cases can enable complex :func:`_orm.relationship` SQL
      conditions to be used.

:param active_history=False:
  When ``True``, indicates that the "previous" value for a
  many-to-one reference should be loaded when replaced, if
  not already loaded. Normally, history tracking logic for
  simple many-to-ones only needs to be aware of the "new"
  value in order to perform a flush. This flag is available
  for applications that make use of
  :func:`.attributes.get_history` which also need to know
  the "previous" value of the attribute.

:param backref:
  A reference to a string relationship name, or a :func:`_orm.backref`
  construct, which will be used to automatically generate a new
  :func:`_orm.relationship` on the related class, which then refers to this
  one using a bi-directional :paramref:`_orm.relationship.back_populates`
  configuration.

  In modern Python, explicit use of :func:`_orm.relationship`
  with :paramref:`_orm.relationship.back_populates` should be preferred,
  as it is more robust in terms of mapper configuration as well as
  more conceptually straightforward.  It also integrates with
  new :pep:`484` typing features introduced in SQLAlchemy 2.0 which
  is not possible with dynamically generated attributes.

  .. seealso::

    :ref:`relationships_backref` - notes on using
    :paramref:`_orm.relationship.backref`

    :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,
    presents an overview of bi-directional relationship configuration
    and behaviors using :paramref:`_orm.relationship.back_populates`

    :func:`.backref` - allows control over :func:`_orm.relationship`
    configuration when using :paramref:`_orm.relationship.backref`.


:param back_populates:
  Indicates the name of a :func:`_orm.relationship` on the related
  class that will be synchronized with this one.   It is usually
  expected that the :func:`_orm.relationship` on the related class
  also refer to this one.  This allows objects on both sides of
  each :func:`_orm.relationship` to synchronize in-Python state
  changes and also provides directives to the :term:`unit of work`
  flush process how changes along these relationships should
  be persisted.

  .. seealso::

    :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,
    presents an overview of bi-directional relationship configuration
    and behaviors.

    :ref:`relationship_patterns` - includes many examples of
    :paramref:`_orm.relationship.back_populates`.

    :paramref:`_orm.relationship.backref` - legacy form which allows
    more succinct configuration, but does not support explicit typing

:param overlaps:
   A string name or comma-delimited set of names of other relationships
   on either this mapper, a descendant mapper, or a target mapper with
   which this relationship may write to the same foreign keys upon
   persistence.   The only effect this has is to eliminate the
   warning that this relationship will conflict with another upon
   persistence.   This is used for such relationships that are truly
   capable of conflicting with each other on write, but the application
   will ensure that no such conflicts occur.

   .. versionadded:: 1.4

   .. seealso::

        :ref:`error_qzyx` - usage example

:param cascade:
  A comma-separated list of cascade rules which determines how
  Session operations should be "cascaded" from parent to child.
  This defaults to ``False``, which means the default cascade
  should be used - this default cascade is ``"save-update, merge"``.

  The available cascades are ``save-update``, ``merge``,
  ``expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.
  An additional option, ``all`` indicates shorthand for
  ``"save-update, merge, refresh-expire,
  expunge, delete"``, and is often used as in ``"all, delete-orphan"``
  to indicate that related objects should follow along with the
  parent object in all cases, and be deleted when de-associated.

  .. seealso::

    :ref:`unitofwork_cascades` - Full detail on each of the available
    cascade options.

:param cascade_backrefs=False:
  Legacy; this flag is always False.

  .. versionchanged:: 2.0 "cascade_backrefs" functionality has been
     removed.

:param collection_class:
  A class or callable that returns a new list-holding object. will
  be used in place of a plain list for storing elements.

  .. seealso::

    :ref:`custom_collections` - Introductory documentation and
    examples.

:param comparator_factory:
  A class which extends :class:`.Relationship.Comparator`
  which provides custom SQL clause generation for comparison
  operations.

  .. seealso::

    :class:`.PropComparator` - some detail on redefining comparators
    at this level.

    :ref:`custom_comparators` - Brief intro to this feature.


:param distinct_target_key=None:
  Indicate if a "subquery" eager load should apply the DISTINCT
  keyword to the innermost SELECT statement.  When left as ``None``,
  the DISTINCT keyword will be applied in those cases when the target
  columns do not comprise the full primary key of the target table.
  When set to ``True``, the DISTINCT keyword is applied to the
  innermost SELECT unconditionally.

  It may be desirable to set this flag to False when the DISTINCT is
  reducing performance of the innermost subquery beyond that of what
  duplicate innermost rows may be causing.

  .. seealso::

    :ref:`loading_toplevel` - includes an introduction to subquery
    eager loading.

:param doc:
  Docstring which will be applied to the resulting descriptor.

:param foreign_keys:

  A list of columns which are to be used as "foreign key"
  columns, or columns which refer to the value in a remote
  column, within the context of this :func:`_orm.relationship`
  object's :paramref:`_orm.relationship.primaryjoin` condition.
  That is, if the :paramref:`_orm.relationship.primaryjoin`
  condition of this :func:`_orm.relationship` is ``a.id ==
  b.a_id``, and the values in ``b.a_id`` are required to be
  present in ``a.id``, then the "foreign key" column of this
  :func:`_orm.relationship` is ``b.a_id``.

  In normal cases, the :paramref:`_orm.relationship.foreign_keys`
  parameter is **not required.** :func:`_orm.relationship` will
  automatically determine which columns in the
  :paramref:`_orm.relationship.primaryjoin` condition are to be
  considered "foreign key" columns based on those
  :class:`_schema.Column` objects that specify
  :class:`_schema.ForeignKey`,
  or are otherwise listed as referencing columns in a
  :class:`_schema.ForeignKeyConstraint` construct.
  :paramref:`_orm.relationship.foreign_keys` is only needed when:

    1. There is more than one way to construct a join from the local
       table to the remote table, as there are multiple foreign key
       references present.  Setting ``foreign_keys`` will limit the
       :func:`_orm.relationship`
       to consider just those columns specified
       here as "foreign".

    2. The :class:`_schema.Table` being mapped does not actually have
       :class:`_schema.ForeignKey` or
       :class:`_schema.ForeignKeyConstraint`
       constructs present, often because the table
       was reflected from a database that does not support foreign key
       reflection (MySQL MyISAM).

    3. The :paramref:`_orm.relationship.primaryjoin`
       argument is used to
       construct a non-standard join condition, which makes use of
       columns or expressions that do not normally refer to their
       "parent" column, such as a join condition expressed by a
       complex comparison using a SQL function.

  The :func:`_orm.relationship` construct will raise informative
  error messages that suggest the use of the
  :paramref:`_orm.relationship.foreign_keys` parameter when
  presented with an ambiguous condition.   In typical cases,
  if :func:`_orm.relationship` doesn't raise any exceptions, the
  :paramref:`_orm.relationship.foreign_keys` parameter is usually
  not needed.

  :paramref:`_orm.relationship.foreign_keys` may also be passed as a
  callable function which is evaluated at mapper initialization time,
  and may be passed as a Python-evaluable string when using
  Declarative.

  .. warning:: When passed as a Python-evaluable string, the
     argument is interpreted using Python's ``eval()`` function.
     **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
     See :ref:`declarative_relationship_eval` for details on
     declarative evaluation of :func:`_orm.relationship` arguments.

  .. seealso::

    :ref:`relationship_foreign_keys`

    :ref:`relationship_custom_foreign`

    :func:`.foreign` - allows direct annotation of the "foreign"
    columns within a :paramref:`_orm.relationship.primaryjoin`
    condition.

:param info: Optional data dictionary which will be populated into the
    :attr:`.MapperProperty.info` attribute of this object.

:param innerjoin=False:
  When ``True``, joined eager loads will use an inner join to join
  against related tables instead of an outer join.  The purpose
  of this option is generally one of performance, as inner joins
  generally perform better than outer joins.

  This flag can be set to ``True`` when the relationship references an
  object via many-to-one using local foreign keys that are not
  nullable, or when the reference is one-to-one or a collection that
  is guaranteed to have one or at least one entry.

  The option supports the same "nested" and "unnested" options as
  that of :paramref:`_orm.joinedload.innerjoin`.  See that flag
  for details on nested / unnested behaviors.

  .. seealso::

    :paramref:`_orm.joinedload.innerjoin` - the option as specified by
    loader option, including detail on nesting behavior.

    :ref:`what_kind_of_loading` - Discussion of some details of
    various loader options.


:param join_depth:
  When non-``None``, an integer value indicating how many levels
  deep "eager" loaders should join on a self-referring or cyclical
  relationship.  The number counts how many times the same Mapper
  shall be present in the loading condition along a particular join
  branch.  When left at its default of ``None``, eager loaders
  will stop chaining when they encounter a the same target mapper
  which is already higher up in the chain.  This option applies
  both to joined- and subquery- eager loaders.

  .. seealso::

    :ref:`self_referential_eager_loading` - Introductory documentation
    and examples.

:param lazy='select': specifies
  How the related items should be loaded.  Default value is
  ``select``.  Values include:

  * ``select`` - items should be loaded lazily when the property is
    first accessed, using a separate SELECT statement, or identity map
    fetch for simple many-to-one references.

  * ``immediate`` - items should be loaded as the parents are loaded,
    using a separate SELECT statement, or identity map fetch for
    simple many-to-one references.

  * ``joined`` - items should be loaded "eagerly" in the same query as
    that of the parent, using a JOIN or LEFT OUTER JOIN.  Whether
    the join is "outer" or not is determined by the
    :paramref:`_orm.relationship.innerjoin` parameter.

  * ``subquery`` - items should be loaded "eagerly" as the parents are
    loaded, using one additional SQL statement, which issues a JOIN to
    a subquery of the original statement, for each collection
    requested.

  * ``selectin`` - items should be loaded "eagerly" as the parents
    are loaded, using one or more additional SQL statements, which
    issues a JOIN to the immediate parent object, specifying primary
    key identifiers using an IN clause.

  * ``noload`` - no loading should occur at any time.  The related
    collection will remain empty.   The ``noload`` strategy is not
    recommended for general use.  For a general use "never load"
    approach, see :ref:`write_only_relationship`

  * ``raise`` - lazy loading is disallowed; accessing
    the attribute, if its value were not already loaded via eager
    loading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.
    This strategy can be used when objects are to be detached from
    their attached :class:`.Session` after they are loaded.

  * ``raise_on_sql`` - lazy loading that emits SQL is disallowed;
    accessing the attribute, if its value were not already loaded via
    eager loading, will raise an
    :exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load
    needs to emit SQL**.  If the lazy load can pull the related value
    from the identity map or determine that it should be None, the
    value is loaded.  This strategy can be used when objects will
    remain associated with the attached :class:`.Session`, however
    additional SELECT statements should be blocked.

  * ``write_only`` - the attribute will be configured with a special
    "virtual collection" that may receive
    :meth:`_orm.WriteOnlyCollection.add` and
    :meth:`_orm.WriteOnlyCollection.remove` commands to add or remove
    individual objects, but will not under any circumstances load or
    iterate the full set of objects from the database directly. Instead,
    methods such as :meth:`_orm.WriteOnlyCollection.select`,
    :meth:`_orm.WriteOnlyCollection.insert`,
    :meth:`_orm.WriteOnlyCollection.update` and
    :meth:`_orm.WriteOnlyCollection.delete` are provided which generate SQL
    constructs that may be used to load and modify rows in bulk. Used for
    large collections that are never appropriate to load at once into
    memory.

    The ``write_only`` loader style is configured automatically when
    the :class:`_orm.WriteOnlyMapped` annotation is provided on the
    left hand side within a Declarative mapping.  See the section
    :ref:`write_only_relationship` for examples.

    .. versionadded:: 2.0

    .. seealso::

        :ref:`write_only_relationship` - in the :ref:`queryguide_toplevel`

  * ``dynamic`` - the attribute will return a pre-configured
    :class:`_query.Query` object for all read
    operations, onto which further filtering operations can be
    applied before iterating the results.

    The ``dynamic`` loader style is configured automatically when
    the :class:`_orm.DynamicMapped` annotation is provided on the
    left hand side within a Declarative mapping.  See the section
    :ref:`dynamic_relationship` for examples.

    .. legacy::  The "dynamic" lazy loader strategy is the legacy form of
       what is now the "write_only" strategy described in the section
       :ref:`write_only_relationship`.

    .. seealso::

        :ref:`dynamic_relationship` - in the :ref:`queryguide_toplevel`

        :ref:`write_only_relationship` - more generally useful approach
        for large collections that should not fully load into memory

  * True - a synonym for 'select'

  * False - a synonym for 'joined'

  * None - a synonym for 'noload'

  .. seealso::

    :ref:`orm_queryguide_relationship_loaders` - Full documentation on
    relationship loader configuration in the :ref:`queryguide_toplevel`.


:param load_on_pending=False:
  Indicates loading behavior for transient or pending parent objects.

  When set to ``True``, causes the lazy-loader to
  issue a query for a parent object that is not persistent, meaning it
  has never been flushed.  This may take effect for a pending object
  when autoflush is disabled, or for a transient object that has been
  "attached" to a :class:`.Session` but is not part of its pending
  collection.

  The :paramref:`_orm.relationship.load_on_pending`
  flag does not improve
  behavior when the ORM is used normally - object references should be
  constructed at the object level, not at the foreign key level, so
  that they are present in an ordinary way before a flush proceeds.
  This flag is not not intended for general use.

  .. seealso::

      :meth:`.Session.enable_relationship_loading` - this method
      establishes "load on pending" behavior for the whole object, and
      also allows loading on objects that remain transient or
      detached.

:param order_by:
  Indicates the ordering that should be applied when loading these
  items.  :paramref:`_orm.relationship.order_by`
  is expected to refer to
  one of the :class:`_schema.Column`
  objects to which the target class is
  mapped, or the attribute itself bound to the target class which
  refers to the column.

  :paramref:`_orm.relationship.order_by`
  may also be passed as a callable
  function which is evaluated at mapper initialization time, and may
  be passed as a Python-evaluable string when using Declarative.

  .. warning:: When passed as a Python-evaluable string, the
     argument is interpreted using Python's ``eval()`` function.
     **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
     See :ref:`declarative_relationship_eval` for details on
     declarative evaluation of :func:`_orm.relationship` arguments.

:param passive_deletes=False:
   Indicates loading behavior during delete operations.

   A value of True indicates that unloaded child items should not
   be loaded during a delete operation on the parent.  Normally,
   when a parent item is deleted, all child items are loaded so
   that they can either be marked as deleted, or have their
   foreign key to the parent set to NULL.  Marking this flag as
   True usually implies an ON DELETE &lt;CASCADE|SET NULL&gt; rule is in
   place which will handle updating/deleting child rows on the
   database side.

   Additionally, setting the flag to the string value 'all' will
   disable the "nulling out" of the child foreign keys, when the parent
   object is deleted and there is no delete or delete-orphan cascade
   enabled.  This is typically used when a triggering or error raise
   scenario is in place on the database side.  Note that the foreign
   key attributes on in-session child objects will not be changed after
   a flush occurs so this is a very special use-case setting.
   Additionally, the "nulling out" will still occur if the child
   object is de-associated with the parent.

   .. seealso::

        :ref:`passive_deletes` - Introductory documentation
        and examples.

:param passive_updates=True:
  Indicates the persistence behavior to take when a referenced
  primary key value changes in place, indicating that the referencing
  foreign key columns will also need their value changed.

  When True, it is assumed that ``ON UPDATE CASCADE`` is configured on
  the foreign key in the database, and that the database will
  handle propagation of an UPDATE from a source column to
  dependent rows.  When False, the SQLAlchemy
  :func:`_orm.relationship`
  construct will attempt to emit its own UPDATE statements to
  modify related targets.  However note that SQLAlchemy **cannot**
  emit an UPDATE for more than one level of cascade.  Also,
  setting this flag to False is not compatible in the case where
  the database is in fact enforcing referential integrity, unless
  those constraints are explicitly "deferred", if the target backend
  supports it.

  It is highly advised that an application which is employing
  mutable primary keys keeps ``passive_updates`` set to True,
  and instead uses the referential integrity features of the database
  itself in order to handle the change efficiently and fully.

  .. seealso::

      :ref:`passive_updates` - Introductory documentation and
      examples.

      :paramref:`.mapper.passive_updates` - a similar flag which
      takes effect for joined-table inheritance mappings.

:param post_update:
  This indicates that the relationship should be handled by a
  second UPDATE statement after an INSERT or before a
  DELETE. This flag is used to handle saving bi-directional
  dependencies between two individual rows (i.e. each row
  references the other), where it would otherwise be impossible to
  INSERT or DELETE both rows fully since one row exists before the
  other. Use this flag when a particular mapping arrangement will
  incur two rows that are dependent on each other, such as a table
  that has a one-to-many relationship to a set of child rows, and
  also has a column that references a single child row within that
  list (i.e. both tables contain a foreign key to each other). If
  a flush operation returns an error that a "cyclical
  dependency" was detected, this is a cue that you might want to
  use :paramref:`_orm.relationship.post_update` to "break" the cycle.

  .. seealso::

      :ref:`post_update` - Introductory documentation and examples.

:param primaryjoin:
  A SQL expression that will be used as the primary
  join of the child object against the parent object, or in a
  many-to-many relationship the join of the parent object to the
  association table. By default, this value is computed based on the
  foreign key relationships of the parent and child tables (or
  association table).

  :paramref:`_orm.relationship.primaryjoin` may also be passed as a
  callable function which is evaluated at mapper initialization time,
  and may be passed as a Python-evaluable string when using
  Declarative.

  .. warning:: When passed as a Python-evaluable string, the
     argument is interpreted using Python's ``eval()`` function.
     **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
     See :ref:`declarative_relationship_eval` for details on
     declarative evaluation of :func:`_orm.relationship` arguments.

  .. seealso::

      :ref:`relationship_primaryjoin`

:param remote_side:
  Used for self-referential relationships, indicates the column or
  list of columns that form the "remote side" of the relationship.

  :paramref:`_orm.relationship.remote_side` may also be passed as a
  callable function which is evaluated at mapper initialization time,
  and may be passed as a Python-evaluable string when using
  Declarative.

  .. warning:: When passed as a Python-evaluable string, the
     argument is interpreted using Python's ``eval()`` function.
     **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
     See :ref:`declarative_relationship_eval` for details on
     declarative evaluation of :func:`_orm.relationship` arguments.

  .. seealso::

    :ref:`self_referential` - in-depth explanation of how
    :paramref:`_orm.relationship.remote_side`
    is used to configure self-referential relationships.

    :func:`.remote` - an annotation function that accomplishes the
    same purpose as :paramref:`_orm.relationship.remote_side`,
    typically
    when a custom :paramref:`_orm.relationship.primaryjoin` condition
    is used.

:param query_class:
  A :class:`_query.Query`
  subclass that will be used internally by the
  ``AppenderQuery`` returned by a "dynamic" relationship, that
  is, a relationship that specifies ``lazy="dynamic"`` or was
  otherwise constructed using the :func:`_orm.dynamic_loader`
  function.

  .. seealso::

    :ref:`dynamic_relationship` - Introduction to "dynamic"
    relationship loaders.

:param secondaryjoin:
  A SQL expression that will be used as the join of
  an association table to the child object. By default, this value is
  computed based on the foreign key relationships of the association
  and child tables.

  :paramref:`_orm.relationship.secondaryjoin` may also be passed as a
  callable function which is evaluated at mapper initialization time,
  and may be passed as a Python-evaluable string when using
  Declarative.

  .. warning:: When passed as a Python-evaluable string, the
     argument is interpreted using Python's ``eval()`` function.
     **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
     See :ref:`declarative_relationship_eval` for details on
     declarative evaluation of :func:`_orm.relationship` arguments.

  .. seealso::

      :ref:`relationship_primaryjoin`

:param single_parent:
  When True, installs a validator which will prevent objects
  from being associated with more than one parent at a time.
  This is used for many-to-one or many-to-many relationships that
  should be treated either as one-to-one or one-to-many.  Its usage
  is optional, except for :func:`_orm.relationship` constructs which
  are many-to-one or many-to-many and also
  specify the ``delete-orphan`` cascade option.  The
  :func:`_orm.relationship` construct itself will raise an error
  instructing when this option is required.

  .. seealso::

    :ref:`unitofwork_cascades` - includes detail on when the
    :paramref:`_orm.relationship.single_parent`
    flag may be appropriate.

:param uselist:
  A boolean that indicates if this property should be loaded as a
  list or a scalar. In most cases, this value is determined
  automatically by :func:`_orm.relationship` at mapper configuration
  time.  When using explicit :class:`_orm.Mapped` annotations,
  :paramref:`_orm.relationship.uselist` may be derived from the
  whether or not the annotation within :class:`_orm.Mapped` contains
  a collection class.
  Otherwise, :paramref:`_orm.relationship.uselist` may be derived from
  the type and direction
  of the relationship - one to many forms a list, many to one
  forms a scalar, many to many is a list. If a scalar is desired
  where normally a list would be present, such as a bi-directional
  one-to-one relationship, use an appropriate :class:`_orm.Mapped`
  annotation or set :paramref:`_orm.relationship.uselist` to False.

  The :paramref:`_orm.relationship.uselist`
  flag is also available on an
  existing :func:`_orm.relationship`
  construct as a read-only attribute,
  which can be used to determine if this :func:`_orm.relationship`
  deals
  with collections or scalar attributes::

      &gt;&gt;&gt; User.addresses.property.uselist
      True

  .. seealso::

      :ref:`relationships_one_to_one` - Introduction to the "one to
      one" relationship pattern, which is typically when an alternate
      setting for :paramref:`_orm.relationship.uselist` is involved.

:param viewonly=False:
  When set to ``True``, the relationship is used only for loading
  objects, and not for any persistence operation.  A
  :func:`_orm.relationship` which specifies
  :paramref:`_orm.relationship.viewonly` can work
  with a wider range of SQL operations within the
  :paramref:`_orm.relationship.primaryjoin` condition, including
  operations that feature the use of a variety of comparison operators
  as well as SQL functions such as :func:`_expression.cast`.  The
  :paramref:`_orm.relationship.viewonly`
  flag is also of general use when defining any kind of
  :func:`_orm.relationship` that doesn't represent
  the full set of related objects, to prevent modifications of the
  collection from resulting in persistence operations.

  .. seealso::

    :ref:`relationship_viewonly_notes` - more details on best practices
    when using :paramref:`_orm.relationship.viewonly`.

:param sync_backref:
  A boolean that enables the events used to synchronize the in-Python
  attributes when this relationship is target of either
  :paramref:`_orm.relationship.backref` or
  :paramref:`_orm.relationship.back_populates`.

  Defaults to ``None``, which indicates that an automatic value should
  be selected based on the value of the
  :paramref:`_orm.relationship.viewonly` flag.  When left at its
  default, changes in state will be back-populated only if neither
  sides of a relationship is viewonly.

  .. versionadded:: 1.3.17

  .. versionchanged:: 1.4 - A relationship that specifies
     :paramref:`_orm.relationship.viewonly` automatically implies
     that :paramref:`_orm.relationship.sync_backref` is ``False``.

  .. seealso::

    :paramref:`_orm.relationship.viewonly`

:param omit_join:
  Allows manual control over the "selectin" automatic join
  optimization.  Set to ``False`` to disable the "omit join" feature
  added in SQLAlchemy 1.3; or leave as ``None`` to leave automatic
  optimization in place.

  .. note:: This flag may only be set to ``False``.   It is not
     necessary to set it to ``True`` as the "omit_join" optimization is
     automatically detected; if it is not detected, then the
     optimization is not supported.

     .. versionchanged:: 1.3.11  setting ``omit_join`` to True will now
        emit a warning as this was not the intended use of this flag.

  .. versionadded:: 1.3

:param init: Specific to :ref:`orm_declarative_native_dataclasses`,
 specifies if the mapped attribute should be part of the ``__init__()``
 method as generated by the dataclass process.
:param repr: Specific to :ref:`orm_declarative_native_dataclasses`,
 specifies if the mapped attribute should be part of the ``__repr__()``
 method as generated by the dataclass process.
:param default_factory: Specific to
 :ref:`orm_declarative_native_dataclasses`,
 specifies a default-value generation function that will take place
 as part of the ``__init__()``
 method as generated by the dataclass process.
:param compare: Specific to
 :ref:`orm_declarative_native_dataclasses`, indicates if this field
 should be included in comparison operations when generating the
 ``__eq__()`` and ``__ne__()`` methods for the mapped class.

 .. versionadded:: 2.0.0b4

:param kw_only: Specific to
 :ref:`orm_declarative_native_dataclasses`, indicates if this field
 should be marked as keyword-only when generating the ``__init__()``.

:param hash: Specific to
 :ref:`orm_declarative_native_dataclasses`, controls if this field
 is included when generating the ``__hash__()`` method for the mapped
 class.

 .. versionadded:: 2.0.36
</pre> 
</div>
</div>
<a id="ada754a884b9775b9fd00bb3d9eb4ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada754a884b9775b9fd00bb3d9eb4ae89">&#9670;&nbsp;</a></span>synonym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1descriptor__props_1_1Synonym.html">Synonym</a>[Any] sqlalchemy.orm._orm_constructors.synonym </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[bool] &#160;</td>
          <td class="paramname"><em>map_column</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>descriptor</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1PropComparator.html">PropComparator</a>[_T]]] &#160;</td>
          <td class="paramname"><em>comparator_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>init</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>repr</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, _T] &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, Callable[[], _T]] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>compare</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool] &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>, bool, None] &#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>doc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Denote an attribute name as a synonym to a mapped property,
in that the attribute will mirror the value and expression behavior
of another attribute.

e.g.::

    class MyClass(Base):
        __tablename__ = "my_table"

        id = Column(Integer, primary_key=True)
        job_status = Column(String(50))

        status = synonym("job_status")

:param name: the name of the existing mapped property.  This
  can refer to the string name ORM-mapped attribute
  configured on the class, including column-bound attributes
  and relationships.

:param descriptor: a Python :term:`descriptor` that will be used
  as a getter (and potentially a setter) when this attribute is
  accessed at the instance level.

:param map_column: **For classical mappings and mappings against
  an existing Table object only**.  if ``True``, the :func:`.synonym`
  construct will locate the :class:`_schema.Column`
  object upon the mapped
  table that would normally be associated with the attribute name of
  this synonym, and produce a new :class:`.ColumnProperty` that instead
  maps this :class:`_schema.Column`
  to the alternate name given as the "name"
  argument of the synonym; in this way, the usual step of redefining
  the mapping of the :class:`_schema.Column`
  to be under a different name is
  unnecessary. This is usually intended to be used when a
  :class:`_schema.Column`
  is to be replaced with an attribute that also uses a
  descriptor, that is, in conjunction with the
  :paramref:`.synonym.descriptor` parameter::

    my_table = Table(
        "my_table",
        metadata,
        Column("id", Integer, primary_key=True),
        Column("job_status", String(50)),
    )


    class MyClass:
        @property
        def _job_status_descriptor(self):
            return "Status: %s" % self._job_status


    mapper(
        MyClass,
        my_table,
        properties={
            "job_status": synonym(
                "_job_status",
                map_column=True,
                descriptor=MyClass._job_status_descriptor,
            )
        },
    )

  Above, the attribute named ``_job_status`` is automatically
  mapped to the ``job_status`` column::

    &gt;&gt;&gt; j1 = MyClass()
    &gt;&gt;&gt; j1._job_status = "employed"
    &gt;&gt;&gt; j1.job_status
    Status: employed

  When using Declarative, in order to provide a descriptor in
  conjunction with a synonym, use the
  :func:`sqlalchemy.ext.declarative.synonym_for` helper.  However,
  note that the :ref:`hybrid properties &lt;mapper_hybrids&gt;` feature
  should usually be preferred, particularly when redefining attribute
  behavior.

:param info: Optional data dictionary which will be populated into the
    :attr:`.InspectionAttr.info` attribute of this object.

:param comparator_factory: A subclass of :class:`.PropComparator`
  that will provide custom comparison behavior at the SQL expression
  level.

  .. note::

    For the use case of providing an attribute which redefines both
    Python-level and SQL-expression level behavior of an attribute,
    please refer to the Hybrid attribute introduced at
    :ref:`mapper_hybrids` for a more effective technique.

.. seealso::

    :ref:`synonyms` - Overview of synonyms

    :func:`.synonym_for` - a helper oriented towards Declarative

    :ref:`mapper_hybrids` - The Hybrid Attribute extension provides an
    updated approach to augmenting attribute behavior more flexibly
    than can be achieved with synonyms.</pre> 
</div>
</div>
<a id="a844ec63166b6cb911076548c6c1bd563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844ec63166b6cb911076548c6c1bd563">&#9670;&nbsp;</a></span>with_loader_criteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1LoaderCriteriaOption.html">LoaderCriteriaOption</a> sqlalchemy.orm._orm_constructors.with_loader_criteria </td>
          <td>(</td>
          <td class="paramtype">_EntityType[Any]&#160;</td>
          <td class="paramname"><em>entity_or_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[
        _ColumnExpressionArgument[bool],
        Callable[[Any], _ColumnExpressionArgument[bool]],
    ]&#160;</td>
          <td class="paramname"><em>where_criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>loader_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>include_aliases</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>propagate_to_loaders</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>track_closure_variables</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add additional WHERE criteria to the load for all occurrences of
a particular entity.

.. versionadded:: 1.4

The :func:`_orm.with_loader_criteria` option is intended to add
limiting criteria to a particular kind of entity in a query,
**globally**, meaning it will apply to the entity as it appears
in the SELECT query as well as within any subqueries, join
conditions, and relationship loads, including both eager and lazy
loaders, without the need for it to be specified in any particular
part of the query.    The rendering logic uses the same system used by
single table inheritance to ensure a certain discriminator is applied
to a table.

E.g., using :term:`2.0-style` queries, we can limit the way the
``User.addresses`` collection is loaded, regardless of the kind
of loading used::

    from sqlalchemy.orm import with_loader_criteria

    stmt = select(User).options(
        selectinload(User.addresses),
        with_loader_criteria(Address, Address.email_address != "foo"),
    )

Above, the "selectinload" for ``User.addresses`` will apply the
given filtering criteria to the WHERE clause.

Another example, where the filtering will be applied to the
ON clause of the join, in this example using :term:`1.x style`
queries::

    q = (
        session.query(User)
        .outerjoin(User.addresses)
        .options(with_loader_criteria(Address, Address.email_address != "foo"))
    )

The primary purpose of :func:`_orm.with_loader_criteria` is to use
it in the :meth:`_orm.SessionEvents.do_orm_execute` event handler
to ensure that all occurrences of a particular entity are filtered
in a certain way, such as filtering for access control roles.    It
also can be used to apply criteria to relationship loads.  In the
example below, we can apply a certain set of rules to all queries
emitted by a particular :class:`_orm.Session`::

    session = Session(bind=engine)


    @event.listens_for("do_orm_execute", session)
    def _add_filtering_criteria(execute_state):

        if (
            execute_state.is_select
            and not execute_state.is_column_load
            and not execute_state.is_relationship_load
        ):
            execute_state.statement = execute_state.statement.options(
                with_loader_criteria(
                    SecurityRole,
                    lambda cls: cls.role.in_(["some_role"]),
                    include_aliases=True,
                )
            )

In the above example, the :meth:`_orm.SessionEvents.do_orm_execute`
event will intercept all queries emitted using the
:class:`_orm.Session`. For those queries which are SELECT statements
and are not attribute or relationship loads a custom
:func:`_orm.with_loader_criteria` option is added to the query.    The
:func:`_orm.with_loader_criteria` option will be used in the given
statement and will also be automatically propagated to all relationship
loads that descend from this query.

The criteria argument given is a ``lambda`` that accepts a ``cls``
argument.  The given class will expand to include all mapped subclass
and need not itself be a mapped class.

.. tip::

   When using :func:`_orm.with_loader_criteria` option in
   conjunction with the :func:`_orm.contains_eager` loader option,
   it's important to note that :func:`_orm.with_loader_criteria` only
   affects the part of the query that determines what SQL is rendered
   in terms of the WHERE and FROM clauses. The
   :func:`_orm.contains_eager` option does not affect the rendering of
   the SELECT statement outside of the columns clause, so does not have
   any interaction with the :func:`_orm.with_loader_criteria` option.
   However, the way things "work" is that :func:`_orm.contains_eager`
   is meant to be used with a query that is already selecting from the
   additional entities in some way, where
   :func:`_orm.with_loader_criteria` can apply it's additional
   criteria.

   In the example below, assuming a mapping relationship as
   ``A -&gt; A.bs -&gt; B``, the given :func:`_orm.with_loader_criteria`
   option will affect the way in which the JOIN is rendered::

        stmt = (
            select(A)
            .join(A.bs)
            .options(contains_eager(A.bs), with_loader_criteria(B, B.flag == 1))
        )

   Above, the given :func:`_orm.with_loader_criteria` option will
   affect the ON clause of the JOIN that is specified by
   ``.join(A.bs)``, so is applied as expected. The
   :func:`_orm.contains_eager` option has the effect that columns from
   ``B`` are added to the columns clause:

   .. sourcecode:: sql

        SELECT
            b.id, b.a_id, b.data, b.flag,
            a.id AS id_1,
            a.data AS data_1
        FROM a JOIN b ON a.id = b.a_id AND b.flag = :flag_1


   The use of the :func:`_orm.contains_eager` option within the above
   statement has no effect on the behavior of the
   :func:`_orm.with_loader_criteria` option. If the
   :func:`_orm.contains_eager` option were omitted, the SQL would be
   the same as regards the FROM and WHERE clauses, where
   :func:`_orm.with_loader_criteria` continues to add its criteria to
   the ON clause of the JOIN. The addition of
   :func:`_orm.contains_eager` only affects the columns clause, in that
   additional columns against ``b`` are added which are then consumed
   by the ORM to produce ``B`` instances.

.. warning:: The use of a lambda inside of the call to
  :func:`_orm.with_loader_criteria` is only invoked **once per unique
  class**. Custom functions should not be invoked within this lambda.
  See :ref:`engine_lambda_caching` for an overview of the "lambda SQL"
  feature, which is for advanced use only.

:param entity_or_base: a mapped class, or a class that is a super
 class of a particular set of mapped classes, to which the rule
 will apply.

:param where_criteria: a Core SQL expression that applies limiting
 criteria.   This may also be a "lambda:" or Python function that
 accepts a target class as an argument, when the given class is
 a base with many different mapped subclasses.

 .. note:: To support pickling, use a module-level Python function to
    produce the SQL expression instead of a lambda or a fixed SQL
    expression, which tend to not be picklable.

:param include_aliases: if True, apply the rule to :func:`_orm.aliased`
 constructs as well.

:param propagate_to_loaders: defaults to True, apply to relationship
 loaders such as lazy loaders.   This indicates that the
 option object itself including SQL expression is carried along with
 each loaded instance.  Set to ``False`` to prevent the object from
 being assigned to individual instances.


 .. seealso::

    :ref:`examples_session_orm_events` - includes examples of using
    :func:`_orm.with_loader_criteria`.

    :ref:`do_orm_execute_global_criteria` - basic example on how to
    combine :func:`_orm.with_loader_criteria` with the
    :meth:`_orm.SessionEvents.do_orm_execute` event.

:param track_closure_variables: when False, closure variables inside
 of a lambda expression will not be used as part of
 any cache key.    This allows more complex expressions to be used
 inside of a lambda expression but requires that the lambda ensures
 it returns the identical SQL every time given a particular class.

 .. versionadded:: 1.4.0b2</pre> 
</div>
</div>
<a id="a9c44c0abcfce7170dd5ce56690b91c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c44c0abcfce7170dd5ce56690b91c7b">&#9670;&nbsp;</a></span>with_polymorphic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1util_1_1AliasedClass.html">AliasedClass</a>[_O] sqlalchemy.orm._orm_constructors.with_polymorphic </td>
          <td>(</td>
          <td class="paramtype">Union[Type[_O], <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]]&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[Literal[&quot;*&quot;], Iterable[Type[Any]]]&#160;</td>
          <td class="paramname"><em>classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[Literal[False, None], <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] &#160;</td>
          <td class="paramname"><em>selectable</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>flat</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnElement.html">ColumnElement</a>[Any]] &#160;</td>
          <td class="paramname"><em>polymorphic_on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>aliased</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>innerjoin</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>adapt_on_names</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>_use_mapper_path</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce an :class:`.AliasedClass` construct which specifies
columns for descendant mappers of the given base.

Using this method will ensure that each descendant mapper's
tables are included in the FROM clause, and will allow filter()
criterion to be used against those tables.  The resulting
instances will also have those columns already loaded so that
no "post fetch" of those columns will be required.

.. seealso::

    :ref:`with_polymorphic` - full discussion of
    :func:`_orm.with_polymorphic`.

:param base: Base class to be aliased.

:param classes: a single class or mapper, or list of
    class/mappers, which inherit from the base class.
    Alternatively, it may also be the string ``'*'``, in which case
    all descending mapped classes will be added to the FROM clause.

:param aliased: when True, the selectable will be aliased.   For a
    JOIN, this means the JOIN will be SELECTed from inside of a subquery
    unless the :paramref:`_orm.with_polymorphic.flat` flag is set to
    True, which is recommended for simpler use cases.

:param flat: Boolean, will be passed through to the
 :meth:`_expression.FromClause.alias` call so that aliases of
 :class:`_expression.Join` objects will alias the individual tables
 inside the join, rather than creating a subquery.  This is generally
 supported by all modern databases with regards to right-nested joins
 and generally produces more efficient queries.  Setting this flag is
 recommended as long as the resulting SQL is functional.

:param selectable: a table or subquery that will
    be used in place of the generated FROM clause. This argument is
    required if any of the desired classes use concrete table
    inheritance, since SQLAlchemy currently cannot generate UNIONs
    among tables automatically. If used, the ``selectable`` argument
    must represent the full set of tables and columns mapped by every
    mapped class. Otherwise, the unaccounted mapped columns will
    result in their table being appended directly to the FROM clause
    which will usually lead to incorrect results.

    When left at its default value of ``False``, the polymorphic
    selectable assigned to the base mapper is used for selecting rows.
    However, it may also be passed as ``None``, which will bypass the
    configured polymorphic selectable and instead construct an ad-hoc
    selectable for the target classes given; for joined table inheritance
    this will be a join that includes all target mappers and their
    subclasses.

:param polymorphic_on: a column to be used as the "discriminator"
    column for the given selectable. If not given, the polymorphic_on
    attribute of the base classes' mapper will be used, if any. This
    is useful for mappings that don't have polymorphic loading
    behavior by default.

:param innerjoin: if True, an INNER JOIN will be used.  This should
   only be specified if querying for one specific subtype only

:param adapt_on_names: Passes through the
  :paramref:`_orm.aliased.adapt_on_names`
  parameter to the aliased object.  This may be useful in situations where
  the given selectable is not directly related to the existing mapped
  selectable.

  .. versionadded:: 1.4.33

:param name: Name given to the generated :class:`.AliasedClass`.

  .. versionadded:: 2.0.31</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac76550a22f01b55621db8ae7e75da735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76550a22f01b55621db8ae7e75da735">&#9670;&nbsp;</a></span>AliasedType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm._orm_constructors.AliasedType = Annotated[Type[_O], &quot;aliased&quot;]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
