<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.integrals.risch Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1integrals.html">integrals</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html">risch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.integrals.risch Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1integrals_1_1risch_1_1DifferentialExtension.html">DifferentialExtension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1integrals_1_1risch_1_1DecrementLevel.html">DecrementLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1integrals_1_1risch_1_1NonElementaryIntegralException.html">NonElementaryIntegralException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1integrals_1_1risch_1_1NonElementaryIntegral.html">NonElementaryIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3165188f9f01ab5ccb853f32df97c23f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a3165188f9f01ab5ccb853f32df97c23f">integer_powers</a> (exprs)</td></tr>
<tr class="separator:a3165188f9f01ab5ccb853f32df97c23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dcee923d75bf59db5cd4d7d402de6f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a62dcee923d75bf59db5cd4d7d402de6f">update_sets</a> (seq, atoms, func)</td></tr>
<tr class="separator:a62dcee923d75bf59db5cd4d7d402de6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418072b0732f791a68454787cc97359c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a418072b0732f791a68454787cc97359c">gcdex_diophantine</a> (a, b, c)</td></tr>
<tr class="separator:a418072b0732f791a68454787cc97359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015822ec04d302f068dd7373263413e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a015822ec04d302f068dd7373263413e7">frac_in</a> (f, t, *cancel=False, **kwargs)</td></tr>
<tr class="separator:a015822ec04d302f068dd7373263413e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161c2e7c89e9930c1458b65d4eed7a5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a161c2e7c89e9930c1458b65d4eed7a5f">as_poly_1t</a> (p, t, z)</td></tr>
<tr class="separator:a161c2e7c89e9930c1458b65d4eed7a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e80287b420af6d661f78406537c73e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a0e80287b420af6d661f78406537c73e2">derivation</a> (p, DE, coefficientD=False, basic=False)</td></tr>
<tr class="separator:a0e80287b420af6d661f78406537c73e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83c695615b779c045ed659d1dec7ba7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#ad83c695615b779c045ed659d1dec7ba7">get_case</a> (d, t)</td></tr>
<tr class="separator:ad83c695615b779c045ed659d1dec7ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93769358f8f9ea2742d3b3068b1ca64c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a93769358f8f9ea2742d3b3068b1ca64c">splitfactor</a> (p, DE, coefficientD=False, z=None)</td></tr>
<tr class="separator:a93769358f8f9ea2742d3b3068b1ca64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144d090581227df3c00b74ab528c8adf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a144d090581227df3c00b74ab528c8adf">splitfactor_sqf</a> (p, DE, coefficientD=False, z=None, basic=False)</td></tr>
<tr class="separator:a144d090581227df3c00b74ab528c8adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7930e2a57a36d77e6b25b7768809ee80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a7930e2a57a36d77e6b25b7768809ee80">canonical_representation</a> (a, d, DE)</td></tr>
<tr class="separator:a7930e2a57a36d77e6b25b7768809ee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9680c38dfc79014fb4b1d63d712856b8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a9680c38dfc79014fb4b1d63d712856b8">hermite_reduce</a> (a, d, DE)</td></tr>
<tr class="separator:a9680c38dfc79014fb4b1d63d712856b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480aed7193fc62d871539e22ed84467c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a480aed7193fc62d871539e22ed84467c">polynomial_reduce</a> (p, DE)</td></tr>
<tr class="separator:a480aed7193fc62d871539e22ed84467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4506171ceafcccd98ee757af589329cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a4506171ceafcccd98ee757af589329cb">laurent_series</a> (a, d, F, n, DE)</td></tr>
<tr class="separator:a4506171ceafcccd98ee757af589329cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b04d6e437baea48407b82a093d86902"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a9b04d6e437baea48407b82a093d86902">recognize_derivative</a> (a, d, DE, z=None)</td></tr>
<tr class="separator:a9b04d6e437baea48407b82a093d86902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76fad17ee9e961943f01bec720f8054"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#ab76fad17ee9e961943f01bec720f8054">recognize_log_derivative</a> (a, d, DE, z=None)</td></tr>
<tr class="separator:ab76fad17ee9e961943f01bec720f8054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5ad6ca62e43e1f42dccc6c41c51f30"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a9c5ad6ca62e43e1f42dccc6c41c51f30">residue_reduce</a> (a, d, DE, z=None, invert=True)</td></tr>
<tr class="separator:a9c5ad6ca62e43e1f42dccc6c41c51f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e1c5dc91c1fc61754eac2c1fe752bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#ae3e1c5dc91c1fc61754eac2c1fe752bc">residue_reduce_to_basic</a> (H, DE, z)</td></tr>
<tr class="separator:ae3e1c5dc91c1fc61754eac2c1fe752bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdafb73f6220fbbfa46564bb5258258"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a5cdafb73f6220fbbfa46564bb5258258">residue_reduce_derivation</a> (H, DE, z)</td></tr>
<tr class="separator:a5cdafb73f6220fbbfa46564bb5258258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe30916b86bbd9c142021bceed9731fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#afe30916b86bbd9c142021bceed9731fc">integrate_primitive_polynomial</a> (p, DE)</td></tr>
<tr class="separator:afe30916b86bbd9c142021bceed9731fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a8cef287a9044c9185a78d33975b4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a64a8cef287a9044c9185a78d33975b4f">integrate_primitive</a> (a, d, DE, z=None)</td></tr>
<tr class="separator:a64a8cef287a9044c9185a78d33975b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e2710df931f7b595ef1ac09cffdb63"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#af4e2710df931f7b595ef1ac09cffdb63">integrate_hyperexponential_polynomial</a> (p, DE, z)</td></tr>
<tr class="separator:af4e2710df931f7b595ef1ac09cffdb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176895a0a18f56e53927b058850687a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a176895a0a18f56e53927b058850687a7">integrate_hyperexponential</a> (a, d, DE, z=None, conds='piecewise')</td></tr>
<tr class="separator:a176895a0a18f56e53927b058850687a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea36b91ac74131bcad841ffbfeb067e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#aea36b91ac74131bcad841ffbfeb067e1">integrate_hypertangent_polynomial</a> (p, DE)</td></tr>
<tr class="separator:aea36b91ac74131bcad841ffbfeb067e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54c909a3332a65f5515c4ad47b30356"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#ad54c909a3332a65f5515c4ad47b30356">integrate_nonlinear_no_specials</a> (a, d, DE, z=None)</td></tr>
<tr class="separator:ad54c909a3332a65f5515c4ad47b30356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50604fe5f1d294112431385b6d12f151"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1risch.html#a50604fe5f1d294112431385b6d12f151">risch_integrate</a> (f, x, extension=None, handle_first='<a class="el" href="classsympy_1_1functions_1_1elementary_1_1exponential_1_1log.html">log</a>', separate_integral=False, rewrite_complex=None, conds='piecewise')</td></tr>
<tr class="separator:a50604fe5f1d294112431385b6d12f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The Risch Algorithm for transcendental function integration.

The core algorithms for the Risch algorithm are here.  The subproblem
algorithms are in the rde.py and prde.py files for the Risch
Differential Equation solver and the parametric problems solvers,
respectively.  All important information concerning the differential extension
for an integrand is stored in a DifferentialExtension object, which in the code
is usually called DE.  Throughout the code and Inside the DifferentialExtension
object, the conventions/attribute names are that the base domain is QQ and each
differential extension is x, t0, t1, ..., tn-1 = DE.t. DE.x is the variable of
integration (Dx == 1), DE.D is a list of the derivatives of
x, t1, t2, ..., tn-1 = t, DE.T is the list [x, t1, t2, ..., tn-1], DE.t is the
outer-most variable of the differential extension at the given level (the level
can be adjusted using DE.increment_level() and DE.decrement_level()),
k is the field C(x, t0, ..., tn-2), where C is the constant field.  The
numerator of a fraction is denoted by a and the denominator by
d.  If the fraction is named f, fa == numer(f) and fd == denom(f).
Fractions are returned as tuples (fa, fd).  DE.d and DE.t are used to
represent the topmost derivation and extension variable, respectively.
The docstring of a function signifies whether an argument is in k[t], in
which case it will just return a Poly in t, or in k(t), in which case it
will return the fraction (fa, fd). Other variable names probably come
from the names used in Bronstein's book.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a161c2e7c89e9930c1458b65d4eed7a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161c2e7c89e9930c1458b65d4eed7a5f">&#9670;&nbsp;</a></span>as_poly_1t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.as_poly_1t </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">(Hackish) way to convert an element ``p`` of K[t, 1/t] to K[t, z].

In other words, ``z == 1/t`` will be a dummy variable that Poly can handle
better.

See issue 5131.

Examples
========

&gt;&gt;&gt; from sympy import random_poly
&gt;&gt;&gt; from sympy.integrals.risch import as_poly_1t
&gt;&gt;&gt; from sympy.abc import x, z

&gt;&gt;&gt; p1 = random_poly(x, 10, -10, 10)
&gt;&gt;&gt; p2 = random_poly(x, 10, -10, 10)
&gt;&gt;&gt; p = p1 + p2.subs(x, 1/x)
&gt;&gt;&gt; as_poly_1t(p, x, z).as_expr().subs(z, 1/x) == p
True
</pre> 
</div>
</div>
<a id="a7930e2a57a36d77e6b25b7768809ee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7930e2a57a36d77e6b25b7768809ee80">&#9670;&nbsp;</a></span>canonical_representation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.canonical_representation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Canonical Representation.

Explanation
===========

Given a derivation D on k[t] and f = a/d in k(t), return (f_p, f_s,
f_n) in k[t] x k(t) x k(t) such that f = f_p + f_s + f_n is the
canonical representation of f (f_p is a polynomial, f_s is reduced
(has a special denominator), and f_n is simple (has a normal
denominator).
</pre> 
</div>
</div>
<a id="a0e80287b420af6d661f78406537c73e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e80287b420af6d661f78406537c73e2">&#9670;&nbsp;</a></span>derivation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.derivation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coefficientD</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basic</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes Dp.

Explanation
===========

Given the derivation D with D = d/dx and p is a polynomial in t over
K(x), return Dp.

If coefficientD is True, it computes the derivation kD
(kappaD), which is defined as kD(sum(ai*Xi**i, (i, 0, n))) ==
sum(Dai*Xi**i, (i, 1, n)) (Definition 3.2.2, page 80).  X in this case is
T[-1], so coefficientD computes the derivative just with respect to T[:-1],
with T[-1] treated as a constant.

If ``basic=True``, the returns a Basic expression.  Elements of D can still be
instances of Poly.
</pre> 
</div>
</div>
<a id="a015822ec04d302f068dd7373263413e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015822ec04d302f068dd7373263413e7">&#9670;&nbsp;</a></span>frac_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.frac_in </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>cancel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the tuple (fa, fd), where fa and fd are Polys in t.

Explanation
===========

This is a common idiom in the Risch Algorithm functions, so we abstract
it out here. ``f`` should be a basic expression, a Poly, or a tuple (fa, fd),
where fa and fd are either basic expressions or Polys, and f == fa/fd.
**kwargs are applied to Poly.
</pre> 
</div>
</div>
<a id="a418072b0732f791a68454787cc97359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418072b0732f791a68454787cc97359c">&#9670;&nbsp;</a></span>gcdex_diophantine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.gcdex_diophantine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extended Euclidean Algorithm, Diophantine version.

Explanation
===========

Given ``a``, ``b`` in K[x] and ``c`` in (a, b), the ideal generated by ``a`` and
``b``, return (s, t) such that s*a + t*b == c and either s == 0 or s.degree()
&lt; b.degree().
</pre> 
</div>
</div>
<a id="ad83c695615b779c045ed659d1dec7ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83c695615b779c045ed659d1dec7ba7">&#9670;&nbsp;</a></span>get_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.get_case </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the type of the derivation d.

Returns one of {'exp', 'tan', 'base', 'primitive', 'other_linear',
'other_nonlinear'}.
</pre> 
</div>
</div>
<a id="a9680c38dfc79014fb4b1d63d712856b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9680c38dfc79014fb4b1d63d712856b8">&#9670;&nbsp;</a></span>hermite_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.hermite_reduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Hermite Reduction - Mack's Linear Version.

Given a derivation D on k(t) and f = a/d in k(t), returns g, h, r in
k(t) such that f = Dg + h + r, h is simple, and r is reduced.</pre> 
</div>
</div>
<a id="a3165188f9f01ab5ccb853f32df97c23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3165188f9f01ab5ccb853f32df97c23f">&#9670;&nbsp;</a></span>integer_powers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.integer_powers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exprs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rewrites a list of expressions as integer multiples of each other.

Explanation
===========

For example, if you have [x, x/2, x**2 + 1, 2*x/3], then you can rewrite
this as [(x/6) * 6, (x/6) * 3, (x**2 + 1) * 1, (x/6) * 4]. This is useful
in the Risch integration algorithm, where we must write exp(x) + exp(x/2)
as (exp(x/2))**2 + exp(x/2), but not as exp(x) + sqrt(exp(x)) (this is
because only the transcendental case is implemented and we therefore cannot
integrate algebraic extensions). The integer multiples returned by this
function for each term are the smallest possible (their content equals 1).

Returns a list of tuples where the first element is the base term and the
second element is a list of `(item, factor)` terms, where `factor` is the
integer multiplicative factor that must multiply the base term to obtain
the original item.

The easiest way to understand this is to look at an example:

&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; from sympy.integrals.risch import integer_powers
&gt;&gt;&gt; integer_powers([x, x/2, x**2 + 1, 2*x/3])
[(x/6, [(x, 6), (x/2, 3), (2*x/3, 4)]), (x**2 + 1, [(x**2 + 1, 1)])]

We can see how this relates to the example at the beginning of the
docstring.  It chose x/6 as the first base term.  Then, x can be written as
(x/2) * 2, so we get (0, 2), and so on. Now only element (x**2 + 1)
remains, and there are no other terms that can be written as a rational
multiple of that, so we get that it can be written as (x**2 + 1) * 1.</pre> 
</div>
</div>
<a id="a176895a0a18f56e53927b058850687a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176895a0a18f56e53927b058850687a7">&#9670;&nbsp;</a></span>integrate_hyperexponential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.integrate_hyperexponential </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>conds</em> = <code>'piecewise'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integration of hyperexponential functions.

Explanation
===========

Given a hyperexponential monomial t over k and f in k(t), return g
elementary over k(t), i in k(t), and a bool b in {True, False} such that
i = f - Dg is in k if b is True or i = f - Dg does not have an elementary
integral over k(t) if b is False.

This function returns a Basic expression for the first argument.  If b is
True, the second argument is Basic expression in k to recursively integrate.
If b is False, the second argument is an unevaluated Integral, which has
been proven to be nonelementary.
</pre> 
</div>
</div>
<a id="af4e2710df931f7b595ef1ac09cffdb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e2710df931f7b595ef1ac09cffdb63">&#9670;&nbsp;</a></span>integrate_hyperexponential_polynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.integrate_hyperexponential_polynomial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integration of hyperexponential polynomials.

Explanation
===========

Given a hyperexponential monomial t over k and ``p`` in k[t, 1/t], return q in
k[t, 1/t] and a bool b in {True, False} such that p - Dq in k if b is True,
or p - Dq does not have an elementary integral over k(t) if b is False.
</pre> 
</div>
</div>
<a id="aea36b91ac74131bcad841ffbfeb067e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea36b91ac74131bcad841ffbfeb067e1">&#9670;&nbsp;</a></span>integrate_hypertangent_polynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.integrate_hypertangent_polynomial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integration of hypertangent polynomials.

Explanation
===========

Given a differential field k such that sqrt(-1) is not in k, a
hypertangent monomial t over k, and p in k[t], return q in k[t] and
c in k such that p - Dq - c*D(t**2 + 1)/(t**1 + 1) is in k and p -
Dq does not have an elementary integral over k(t) if Dc != 0.
</pre> 
</div>
</div>
<a id="ad54c909a3332a65f5515c4ad47b30356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54c909a3332a65f5515c4ad47b30356">&#9670;&nbsp;</a></span>integrate_nonlinear_no_specials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.integrate_nonlinear_no_specials </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integration of nonlinear monomials with no specials.

Explanation
===========

Given a nonlinear monomial t over k such that Sirr ({p in k[t] | p is
special, monic, and irreducible}) is empty, and f in k(t), returns g
elementary over k(t) and a Boolean b in {True, False} such that f - Dg is
in k if b == True, or f - Dg does not have an elementary integral over k(t)
if b == False.

This function is applicable to all nonlinear extensions, but in the case
where it returns b == False, it will only have proven that the integral of
f - Dg is nonelementary if Sirr is empty.

This function returns a Basic expression.
</pre> 
</div>
</div>
<a id="a64a8cef287a9044c9185a78d33975b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a8cef287a9044c9185a78d33975b4f">&#9670;&nbsp;</a></span>integrate_primitive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.integrate_primitive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integration of primitive functions.

Explanation
===========

Given a primitive monomial t over k and f in k(t), return g elementary over
k(t), i in k(t), and b in {True, False} such that i = f - Dg is in k if b
is True or i = f - Dg does not have an elementary integral over k(t) if b
is False.

This function returns a Basic expression for the first argument.  If b is
True, the second argument is Basic expression in k to recursively integrate.
If b is False, the second argument is an unevaluated Integral, which has
been proven to be nonelementary.
</pre> 
</div>
</div>
<a id="afe30916b86bbd9c142021bceed9731fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe30916b86bbd9c142021bceed9731fc">&#9670;&nbsp;</a></span>integrate_primitive_polynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.integrate_primitive_polynomial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integration of primitive polynomials.

Explanation
===========

Given a primitive monomial t over k, and ``p`` in k[t], return q in k[t],
r in k, and a bool b in {True, False} such that r = p - Dq is in k if b is
True, or r = p - Dq does not have an elementary integral over k(t) if b is
False.
</pre> 
</div>
</div>
<a id="a4506171ceafcccd98ee757af589329cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4506171ceafcccd98ee757af589329cb">&#9670;&nbsp;</a></span>laurent_series()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.laurent_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Contribution of ``F`` to the full partial fraction decomposition of A/D.

Explanation
===========

Given a field K of characteristic 0 and ``A``,``D``,``F`` in K[x] with D monic,
nonzero, coprime with A, and ``F`` the factor of multiplicity n in the square-
free factorization of D, return the principal parts of the Laurent series of
A/D at all the zeros of ``F``.
</pre> 
</div>
</div>
<a id="a480aed7193fc62d871539e22ed84467c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480aed7193fc62d871539e22ed84467c">&#9670;&nbsp;</a></span>polynomial_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.polynomial_reduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Polynomial Reduction.

Explanation
===========

Given a derivation D on k(t) and p in k[t] where t is a nonlinear
monomial over k, return q, r in k[t] such that p = Dq  + r, and
deg(r) &lt; deg_t(Dt).
</pre> 
</div>
</div>
<a id="a9b04d6e437baea48407b82a093d86902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b04d6e437baea48407b82a093d86902">&#9670;&nbsp;</a></span>recognize_derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.recognize_derivative </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the squarefree factorization of the denominator of f
and for each Di the polynomial H in K[x] (see Theorem 2.7.1), using the
LaurentSeries algorithm. Write Di = GiEi where Gj = gcd(Hn, Di) and
gcd(Ei,Hn) = 1. Since the residues of f at the roots of Gj are all 0, and
the residue of f at a root alpha of Ei is Hi(a) != 0, f is the derivative of a
rational function if and only if Ei = 1 for each i, which is equivalent to
Di | H[-1] for each i.
</pre> 
</div>
</div>
<a id="ab76fad17ee9e961943f01bec720f8054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76fad17ee9e961943f01bec720f8054">&#9670;&nbsp;</a></span>recognize_log_derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.recognize_log_derivative </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">There exists a v in K(x)* such that f = dv/v
where f a rational function if and only if f can be written as f = A/D
where D is squarefree,deg(A) &lt; deg(D), gcd(A, D) = 1,
and all the roots of the Rothstein-Trager resultant are integers. In that case,
any of the Rothstein-Trager, Lazard-Rioboo-Trager or Czichowski algorithm
produces u in K(x) such that du/dx = uf.
</pre> 
</div>
</div>
<a id="a9c5ad6ca62e43e1f42dccc6c41c51f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5ad6ca62e43e1f42dccc6c41c51f30">&#9670;&nbsp;</a></span>residue_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.residue_reduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invert</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Lazard-Rioboo-Rothstein-Trager resultant reduction.

Explanation
===========

Given a derivation ``D`` on k(t) and f in k(t) simple, return g
elementary over k(t) and a Boolean b in {True, False} such that f -
Dg in k[t] if b == True or f + h and f + h - Dg do not have an
elementary integral over k(t) for any h in k&lt;t&gt; (reduced) if b ==
False.

Returns (G, b), where G is a tuple of tuples of the form (s_i, S_i),
such that g = Add(*[RootSum(s_i, lambda z: z*log(S_i(z, t))) for
S_i, s_i in G]). f - Dg is the remaining integral, which is elementary
only if b == True, and hence the integral of f is elementary only if
b == True.

f - Dg is not calculated in this function because that would require
explicitly calculating the RootSum.  Use residue_reduce_derivation().
</pre> 
</div>
</div>
<a id="a5cdafb73f6220fbbfa46564bb5258258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdafb73f6220fbbfa46564bb5258258">&#9670;&nbsp;</a></span>residue_reduce_derivation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.residue_reduce_derivation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the derivation of an expression returned by residue_reduce().

In general, this is a rational function in t, so this returns an
as_expr() result.
</pre> 
</div>
</div>
<a id="ae3e1c5dc91c1fc61754eac2c1fe752bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e1c5dc91c1fc61754eac2c1fe752bc">&#9670;&nbsp;</a></span>residue_reduce_to_basic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.residue_reduce_to_basic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts the tuple returned by residue_reduce() into a Basic expression.
</pre> 
</div>
</div>
<a id="a50604fe5f1d294112431385b6d12f151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50604fe5f1d294112431385b6d12f151">&#9670;&nbsp;</a></span>risch_integrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.risch_integrate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extension</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>handle_first</em> = <code>'<a class="el" href="classsympy_1_1functions_1_1elementary_1_1exponential_1_1log.html">log</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>separate_integral</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rewrite_complex</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>conds</em> = <code>'piecewise'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The Risch Integration Algorithm.

Explanation
===========

Only transcendental functions are supported.  Currently, only exponentials
and logarithms are supported, but support for trigonometric functions is
forthcoming.

If this function returns an unevaluated Integral in the result, it means
that it has proven that integral to be nonelementary.  Any errors will
result in raising NotImplementedError.  The unevaluated Integral will be
an instance of NonElementaryIntegral, a subclass of Integral.

handle_first may be either 'exp' or 'log'.  This changes the order in
which the extension is built, and may result in a different (but
equivalent) solution (for an example of this, see issue 5109).  It is also
possible that the integral may be computed with one but not the other,
because not all cases have been implemented yet.  It defaults to 'log' so
that the outer extension is exponential when possible, because more of the
exponential case has been implemented.

If ``separate_integral`` is ``True``, the result is returned as a tuple (ans, i),
where the integral is ans + i, ans is elementary, and i is either a
NonElementaryIntegral or 0.  This useful if you want to try further
integrating the NonElementaryIntegral part using other algorithms to
possibly get a solution in terms of special functions.  It is False by
default.

Examples
========

&gt;&gt;&gt; from sympy.integrals.risch import risch_integrate
&gt;&gt;&gt; from sympy import exp, log, pprint
&gt;&gt;&gt; from sympy.abc import x

First, we try integrating exp(-x**2). Except for a constant factor of
2/sqrt(pi), this is the famous error function.

&gt;&gt;&gt; pprint(risch_integrate(exp(-x**2), x))
  /
 |
 |    2
 |  -x
 | e    dx
 |
/

The unevaluated Integral in the result means that risch_integrate() has
proven that exp(-x**2) does not have an elementary anti-derivative.

In many cases, risch_integrate() can split out the elementary
anti-derivative part from the nonelementary anti-derivative part.
For example,

&gt;&gt;&gt; pprint(risch_integrate((2*log(x)**2 - log(x) - x**2)/(log(x)**3 -
... x**2*log(x)), x))
                                         /
                                        |
  log(-x + log(x))   log(x + log(x))    |   1
- ---------------- + --------------- +  | ------ dx
         2                  2           | log(x)
                                        |
                                       /

This means that it has proven that the integral of 1/log(x) is
nonelementary.  This function is also known as the logarithmic integral,
and is often denoted as Li(x).

risch_integrate() currently only accepts purely transcendental functions
with exponentials and logarithms, though note that this can include
nested exponentials and logarithms, as well as exponentials with bases
other than E.

&gt;&gt;&gt; pprint(risch_integrate(exp(x)*exp(exp(x)), x))
 / x\
 \e /
e
&gt;&gt;&gt; pprint(risch_integrate(exp(exp(x)), x))
  /
 |
 |  / x\
 |  \e /
 | e     dx
 |
/

&gt;&gt;&gt; pprint(risch_integrate(x*x**x*log(x) + x**x + x*x**x, x))
   x
x*x
&gt;&gt;&gt; pprint(risch_integrate(x**x, x))
  /
 |
 |  x
 | x  dx
 |
/

&gt;&gt;&gt; pprint(risch_integrate(-1/(x*log(x)*log(log(x))**2), x))
     1
-----------
log(log(x))</pre> 
</div>
</div>
<a id="a93769358f8f9ea2742d3b3068b1ca64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93769358f8f9ea2742d3b3068b1ca64c">&#9670;&nbsp;</a></span>splitfactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.splitfactor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coefficientD</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Splitting factorization.

Explanation
===========

Given a derivation D on k[t] and ``p`` in k[t], return (p_n, p_s) in
k[t] x k[t] such that p = p_n*p_s, p_s is special, and each square
factor of p_n is normal.

Page. 100
</pre> 
</div>
</div>
<a id="a144d090581227df3c00b74ab528c8adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144d090581227df3c00b74ab528c8adf">&#9670;&nbsp;</a></span>splitfactor_sqf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.splitfactor_sqf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>DE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coefficientD</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basic</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Splitting Square-free Factorization.

Explanation
===========

Given a derivation D on k[t] and ``p`` in k[t], returns (N1, ..., Nm)
and (S1, ..., Sm) in k[t]^m such that p =
(N1*N2**2*...*Nm**m)*(S1*S2**2*...*Sm**m) is a splitting
factorization of ``p`` and the Ni and Si are square-free and coprime.
</pre> 
</div>
</div>
<a id="a62dcee923d75bf59db5cd4d7d402de6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62dcee923d75bf59db5cd4d7d402de6f">&#9670;&nbsp;</a></span>update_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.risch.update_sets </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
