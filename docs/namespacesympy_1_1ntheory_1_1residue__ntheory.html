<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.ntheory.residue_ntheory Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1ntheory.html">ntheory</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html">residue_ntheory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.ntheory.residue_ntheory Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac090a41e404ed54eabd139d64312c6c8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#ac090a41e404ed54eabd139d64312c6c8">n_order</a> (a, n)</td></tr>
<tr class="separator:ac090a41e404ed54eabd139d64312c6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6a3b6f8451e482bf0c7b7e3855067f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a1d6a3b6f8451e482bf0c7b7e3855067f">primitive_root</a> (p, smallest=True)</td></tr>
<tr class="separator:a1d6a3b6f8451e482bf0c7b7e3855067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d30eb1bb079a6478e021294f07fb78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#ae9d30eb1bb079a6478e021294f07fb78">is_primitive_root</a> (a, p)</td></tr>
<tr class="separator:ae9d30eb1bb079a6478e021294f07fb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e0c72f2b73cbb8b7421d6de1e0fd7c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a93e0c72f2b73cbb8b7421d6de1e0fd7c">sqrt_mod</a> (a, p, all_roots=False)</td></tr>
<tr class="separator:a93e0c72f2b73cbb8b7421d6de1e0fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f18ece81d0b2cf63fc220ef57c10f99"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a9f18ece81d0b2cf63fc220ef57c10f99">sqrt_mod_iter</a> (a, p, domain=int)</td></tr>
<tr class="separator:a9f18ece81d0b2cf63fc220ef57c10f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc152edb7e13f3bb98cb5075b84d60b4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#acc152edb7e13f3bb98cb5075b84d60b4">is_quad_residue</a> (a, p)</td></tr>
<tr class="separator:acc152edb7e13f3bb98cb5075b84d60b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb781429dedd0f86f748fba130a37d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a9eb781429dedd0f86f748fba130a37d8">is_nthpow_residue</a> (a, n, m)</td></tr>
<tr class="separator:a9eb781429dedd0f86f748fba130a37d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ed2e085d45fd8761df8e0292b211c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a86ed2e085d45fd8761df8e0292b211c7">nthroot_mod</a> (a, n, p, all_roots=False)</td></tr>
<tr class="separator:a86ed2e085d45fd8761df8e0292b211c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3477080752fcace1627ee4c77dfde6"><td class="memItemLeft" align="right" valign="top">list[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a4f3477080752fcace1627ee4c77dfde6">quadratic_residues</a> (p)</td></tr>
<tr class="separator:a4f3477080752fcace1627ee4c77dfde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb16b6b1c6ebe8baa6af7d2e29a09ff1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#acb16b6b1c6ebe8baa6af7d2e29a09ff1">legendre_symbol</a> (a, p)</td></tr>
<tr class="separator:acb16b6b1c6ebe8baa6af7d2e29a09ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a1d8d1680439d825e2ab66f75d39fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a96a1d8d1680439d825e2ab66f75d39fe">jacobi_symbol</a> (m, n)</td></tr>
<tr class="separator:a96a1d8d1680439d825e2ab66f75d39fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b31ce6b3e5306521a1ac550fde7c8a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a39b31ce6b3e5306521a1ac550fde7c8a">mobius</a> (n)</td></tr>
<tr class="separator:a39b31ce6b3e5306521a1ac550fde7c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcd3fec801057fe00649577b5188c41"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#acfcd3fec801057fe00649577b5188c41">discrete_log</a> (n, a, b, order=None, prime_order=None)</td></tr>
<tr class="separator:acfcd3fec801057fe00649577b5188c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4e4fd3e67634aae8ba751d26a3c4b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#aff4e4fd3e67634aae8ba751d26a3c4b7">quadratic_congruence</a> (a, b, c, n)</td></tr>
<tr class="separator:aff4e4fd3e67634aae8ba751d26a3c4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236d759d944d61110bc385a47472b3d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a236d759d944d61110bc385a47472b3d6">polynomial_congruence</a> (expr, m)</td></tr>
<tr class="separator:a236d759d944d61110bc385a47472b3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4ddefdb9cb2fe7a9c93bd4f08554e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1residue__ntheory.html#a0b4ddefdb9cb2fe7a9c93bd4f08554e5">binomial_mod</a> (n, m, k)</td></tr>
<tr class="separator:a0b4ddefdb9cb2fe7a9c93bd4f08554e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0b4ddefdb9cb2fe7a9c93bd4f08554e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4ddefdb9cb2fe7a9c93bd4f08554e5">&#9670;&nbsp;</a></span>binomial_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.binomial_mod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ``binomial(n, m) % k``.

Explanation
===========

Returns ``binomial(n, m) % k`` using a generalization of Lucas'
Theorem for prime powers given by Granville [1]_, in conjunction with
the Chinese Remainder Theorem.  The residue for each prime power
is calculated in time O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p)).

Parameters
==========

n : an integer
m : an integer
k : a positive integer

Examples
========

&gt;&gt;&gt; from sympy.ntheory.residue_ntheory import binomial_mod
&gt;&gt;&gt; binomial_mod(10, 2, 6)  # binomial(10, 2) = 45
3
&gt;&gt;&gt; binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310
0

References
==========

.. [1] Binomial coefficients modulo prime powers, Andrew Granville,
    Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf
</pre> 
</div>
</div>
<a id="acfcd3fec801057fe00649577b5188c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcd3fec801057fe00649577b5188c41">&#9670;&nbsp;</a></span>discrete_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.discrete_log </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prime_order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.

This is a recursive function to reduce the discrete logarithm problem in
cyclic groups of composite order to the problem in cyclic groups of prime
order.

It employs different algorithms depending on the problem (subgroup order
size, prime order or not):

    * Trial multiplication
    * Baby-step giant-step
    * Pollard's Rho
    * Index Calculus
    * Pohlig-Hellman

Examples
========

&gt;&gt;&gt; from sympy.ntheory import discrete_log
&gt;&gt;&gt; discrete_log(41, 15, 7)
3

References
==========

.. [1] https://mathworld.wolfram.com/DiscreteLogarithm.html
.. [2] "Handbook of applied cryptography", Menezes, A. J., Van, O. P. C., &amp;
    Vanstone, S. A. (1997).</pre> 
</div>
</div>
<a id="a9eb781429dedd0f86f748fba130a37d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb781429dedd0f86f748fba130a37d8">&#9670;&nbsp;</a></span>is_nthpow_residue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.is_nthpow_residue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if ``x**n == a (mod m)`` has solutions.

References
==========

.. [1] P. Hackman "Elementary Number Theory" (2009), page 76</pre> 
</div>
</div>
<a id="ae9d30eb1bb079a6478e021294f07fb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d30eb1bb079a6478e021294f07fb78">&#9670;&nbsp;</a></span>is_primitive_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.is_primitive_root </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns True if ``a`` is a primitive root of ``p``.

Explanation
===========

``a`` is said to be the primitive root of ``p`` if `\gcd(a, p) = 1` and
`\phi(p)` is the smallest positive number s.t.

    `a^{\phi(p)} \equiv 1 \pmod{p}`.

where `\phi(p)` is Euler's totient function.

The primitive root of ``p`` exist only for
`p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).
Hence, if it is not such a ``p``, it returns False.
To determine the primitive root, we need to know
the prime factorization of ``q-1``.
The hardness of the determination depends on this complexity.

Parameters
==========

a : integer
p : integer, ``p`` &gt; 1. ``a`` and ``p`` should be relatively prime

Returns
=======

bool : If True, ``a`` is the primitive root of ``p``.

Raises
======

ValueError
    If `p \le 1` or `\gcd(a, p) \neq 1`.
    If ``a`` or ``p`` is not an integer.

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import totient
&gt;&gt;&gt; from sympy.ntheory import is_primitive_root, n_order
&gt;&gt;&gt; is_primitive_root(3, 10)
True
&gt;&gt;&gt; is_primitive_root(9, 10)
False
&gt;&gt;&gt; n_order(3, 10) == totient(10)
True
&gt;&gt;&gt; n_order(9, 10) == totient(10)
False

See Also
========

primitive_root</pre> 
</div>
</div>
<a id="acc152edb7e13f3bb98cb5075b84d60b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc152edb7e13f3bb98cb5075b84d60b4">&#9670;&nbsp;</a></span>is_quad_residue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.is_quad_residue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,
i.e a % p in set([i**2 % p for i in range(p)]).

Parameters
==========

a : integer
p : positive integer

Returns
=======

bool : If True, ``x**2 == a (mod p)`` has solution.

Raises
======

ValueError
    If ``a``, ``p`` is not integer.
    If ``p`` is not positive.

Examples
========

&gt;&gt;&gt; from sympy.ntheory import is_quad_residue
&gt;&gt;&gt; is_quad_residue(21, 100)
True

Indeed, ``pow(39, 2, 100)`` would be 21.

&gt;&gt;&gt; is_quad_residue(21, 120)
False

That is, for any integer ``x``, ``pow(x, 2, 120)`` is not 21.

If ``p`` is an odd
prime, an iterative method is used to make the determination:

&gt;&gt;&gt; from sympy.ntheory import is_quad_residue
&gt;&gt;&gt; sorted(set([i**2 % 7 for i in range(7)]))
[0, 1, 2, 4]
&gt;&gt;&gt; [j for j in range(7) if is_quad_residue(j, 7)]
[0, 1, 2, 4]

See Also
========

legendre_symbol, jacobi_symbol, sqrt_mod
</pre> 
</div>
</div>
<a id="a96a1d8d1680439d825e2ab66f75d39fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a1d8d1680439d825e2ab66f75d39fe">&#9670;&nbsp;</a></span>jacobi_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.jacobi_symbol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Jacobi symbol `(m / n)`.

.. deprecated:: 1.13

    The ``jacobi_symbol`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.jacobi_symbol`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol
is defined as the product of the Legendre symbols corresponding to the
prime factors of ``n``:

.. math ::
    \genfrac(){}{}{m}{n} =
        \genfrac(){}{}{m}{p^{1}}^{\alpha_1}
        \genfrac(){}{}{m}{p^{2}}^{\alpha_2}
        ...
        \genfrac(){}{}{m}{p^{k}}^{\alpha_k}
        \text{ where } n =
            p_1^{\alpha_1}
            p_2^{\alpha_2}
            ...
            p_k^{\alpha_k}

Like the Legendre symbol, if the Jacobi symbol `\genfrac(){}{}{m}{n} = -1`
then ``m`` is a quadratic nonresidue modulo ``n``.

But, unlike the Legendre symbol, if the Jacobi symbol
`\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue
modulo ``n``.

Parameters
==========

m : integer
n : odd positive integer

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import jacobi_symbol, legendre_symbol
&gt;&gt;&gt; from sympy import S
&gt;&gt;&gt; jacobi_symbol(45, 77)
-1
&gt;&gt;&gt; jacobi_symbol(60, 121)
1

The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can
be demonstrated as follows:

&gt;&gt;&gt; L = legendre_symbol
&gt;&gt;&gt; S(45).factors()
{3: 2, 5: 1}
&gt;&gt;&gt; jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1
True

See Also
========

is_quad_residue, legendre_symbol
</pre> 
</div>
</div>
<a id="acb16b6b1c6ebe8baa6af7d2e29a09ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb16b6b1c6ebe8baa6af7d2e29a09ff1">&#9670;&nbsp;</a></span>legendre_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.legendre_symbol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Legendre symbol `(a / p)`.

.. deprecated:: 1.13

    The ``legendre_symbol`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.legendre_symbol`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

For an integer ``a`` and an odd prime ``p``, the Legendre symbol is
defined as

.. math ::
    \genfrac(){}{}{a}{p} = \begin{cases}
         0 &amp; \text{if } p \text{ divides } a\\
         1 &amp; \text{if } a \text{ is a quadratic residue modulo } p\\
        -1 &amp; \text{if } a \text{ is a quadratic nonresidue modulo } p
    \end{cases}

Parameters
==========

a : integer
p : odd prime

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import legendre_symbol
&gt;&gt;&gt; [legendre_symbol(i, 7) for i in range(7)]
[0, 1, 1, -1, 1, -1, -1]
&gt;&gt;&gt; sorted(set([i**2 % 7 for i in range(7)]))
[0, 1, 2, 4]

See Also
========

is_quad_residue, jacobi_symbol</pre> 
</div>
</div>
<a id="a39b31ce6b3e5306521a1ac550fde7c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b31ce6b3e5306521a1ac550fde7c8a">&#9670;&nbsp;</a></span>mobius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.mobius </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Mobius function maps natural number to {-1, 0, 1}

.. deprecated:: 1.13

    The ``mobius`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.mobius`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

It is defined as follows:
    1) `1` if `n = 1`.
    2) `0` if `n` has a squared prime factor.
    3) `(-1)^k` if `n` is a square-free positive integer with `k`
       number of prime factors.

It is an important multiplicative function in number theory
and combinatorics.  It has applications in mathematical series,
algebraic number theory and also physics (Fermion operator has very
concrete realization with Mobius Function model).

Parameters
==========

n : positive integer

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import mobius
&gt;&gt;&gt; mobius(13*7)
1
&gt;&gt;&gt; mobius(1)
1
&gt;&gt;&gt; mobius(13*7*5)
-1
&gt;&gt;&gt; mobius(13**2)
0

References
==========

.. [1] https://en.wikipedia.org/wiki/M%C3%B6bius_function
.. [2] Thomas Koshy "Elementary Number Theory with Applications"</pre> 
</div>
</div>
<a id="ac090a41e404ed54eabd139d64312c6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac090a41e404ed54eabd139d64312c6c8">&#9670;&nbsp;</a></span>n_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.n_order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns the order of ``a`` modulo ``n``.

Explanation
===========

The order of ``a`` modulo ``n`` is the smallest integer
``k`` such that `a^k` leaves a remainder of 1 with ``n``.

Parameters
==========

a : integer
n : integer, n &gt; 1. a and n should be relatively prime

Returns
=======

int : the order of ``a`` modulo ``n``

Raises
======

ValueError
    If `n \le 1` or `\gcd(a, n) \neq 1`.
    If ``a`` or ``n`` is not an integer.

Examples
========

&gt;&gt;&gt; from sympy.ntheory import n_order
&gt;&gt;&gt; n_order(3, 7)
6
&gt;&gt;&gt; n_order(4, 7)
3

See Also
========

is_primitive_root
    We say that ``a`` is a primitive root of ``n``
    when the order of ``a`` modulo ``n`` equals ``totient(n)``</pre> 
</div>
</div>
<a id="a86ed2e085d45fd8761df8e0292b211c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ed2e085d45fd8761df8e0292b211c7">&#9670;&nbsp;</a></span>nthroot_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.nthroot_mod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all_roots</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the solutions to ``x**n = a mod p``.

Parameters
==========

a : integer
n : positive integer
p : positive integer
all_roots : if False returns the smallest root, else the list of roots

Returns
=======

    list[int] | int | None :
        solutions to ``x**n = a mod p``.
        The table of the output type is:

        ========== ========== ==========
        all_roots  has roots  Returns
        ========== ========== ==========
        True       Yes        list[int]
        True       No         []
        False      Yes        int
        False      No         None
        ========== ========== ==========

Raises
======

    ValueError
        If ``a``, ``n`` or ``p`` is not integer.
        If ``n`` or ``p`` is not positive.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.residue_ntheory import nthroot_mod
&gt;&gt;&gt; nthroot_mod(11, 4, 19)
8
&gt;&gt;&gt; nthroot_mod(11, 4, 19, True)
[8, 11]
&gt;&gt;&gt; nthroot_mod(68, 3, 109)
23

References
==========

.. [1] P. Hackman "Elementary Number Theory" (2009), page 76</pre> 
</div>
</div>
<a id="a236d759d944d61110bc385a47472b3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236d759d944d61110bc385a47472b3d6">&#9670;&nbsp;</a></span>polynomial_congruence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.polynomial_congruence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the solutions to a polynomial congruence equation modulo m.

Parameters
==========

expr : integer coefficient polynomial
m : positive integer

Examples
========

&gt;&gt;&gt; from sympy.ntheory import polynomial_congruence
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; expr = x**6 - 2*x**5 -35
&gt;&gt;&gt; polynomial_congruence(expr, 6125)
[3257]

See Also
========

sympy.polys.galoistools.gf_csolve : low level solving routine used by this routine</pre> 
</div>
</div>
<a id="a1d6a3b6f8451e482bf0c7b7e3855067f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6a3b6f8451e482bf0c7b7e3855067f">&#9670;&nbsp;</a></span>primitive_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.primitive_root </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>smallest</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns a primitive root of ``p`` or None.

Explanation
===========

For the definition of primitive root,
see the explanation of ``is_primitive_root``.

The primitive root of ``p`` exist only for
`p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).
Now, if we know the primitive root of ``q``,
we can calculate the primitive root of `q^e`,
and if we know the primitive root of `q^e`,
we can calculate the primitive root of `2q^e`.
When there is no need to find the smallest primitive root,
this property can be used to obtain a fast primitive root.
On the other hand, when we want the smallest primitive root,
we naively determine whether it is a primitive root or not.

Parameters
==========

p : integer, p &gt; 1
smallest : if True the smallest primitive root is returned or None

Returns
=======

int | None :
    If the primitive root exists, return the primitive root of ``p``.
    If not, return None.

Raises
======

ValueError
    If `p \le 1` or ``p`` is not an integer.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.residue_ntheory import primitive_root
&gt;&gt;&gt; primitive_root(19)
2
&gt;&gt;&gt; primitive_root(21) is None
True
&gt;&gt;&gt; primitive_root(50, smallest=False)
27

See Also
========

is_primitive_root

References
==========

.. [1] W. Stein "Elementary Number Theory" (2011), page 44
.. [2] P. Hackman "Elementary Number Theory" (2009), Chapter C</pre> 
</div>
</div>
<a id="aff4e4fd3e67634aae8ba751d26a3c4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4e4fd3e67634aae8ba751d26a3c4b7">&#9670;&nbsp;</a></span>quadratic_congruence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.quadratic_congruence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the solutions to `a x^2 + b x + c \equiv 0 \pmod{n}`.

Parameters
==========

a : int
b : int
c : int
n : int
    A positive integer.

Returns
=======

list[int] :
    A sorted list of solutions. If no solution exists, ``[]``.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.residue_ntheory import quadratic_congruence
&gt;&gt;&gt; quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)
[2, 6]
&gt;&gt;&gt; quadratic_congruence(8, 6, 4, 15) # No solution
[]

See Also
========

polynomial_congruence : Solve the polynomial congruence</pre> 
</div>
</div>
<a id="a4f3477080752fcace1627ee4c77dfde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3477080752fcace1627ee4c77dfde6">&#9670;&nbsp;</a></span>quadratic_residues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[int] sympy.ntheory.residue_ntheory.quadratic_residues </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the list of quadratic residues.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.residue_ntheory import quadratic_residues
&gt;&gt;&gt; quadratic_residues(7)
[0, 1, 2, 4]
</pre> 
</div>
</div>
<a id="a93e0c72f2b73cbb8b7421d6de1e0fd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e0c72f2b73cbb8b7421d6de1e0fd7c">&#9670;&nbsp;</a></span>sqrt_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.sqrt_mod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all_roots</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a root of ``x**2 = a mod p``.

Parameters
==========

a : integer
p : positive integer
all_roots : if True the list of roots is returned or None

Notes
=====

If there is no root it is returned None; else the returned root
is less or equal to ``p // 2``; in general is not the smallest one.
It is returned ``p // 2`` only if it is the only root.

Use ``all_roots`` only when it is expected that all the roots fit
in memory; otherwise use ``sqrt_mod_iter``.

Examples
========

&gt;&gt;&gt; from sympy.ntheory import sqrt_mod
&gt;&gt;&gt; sqrt_mod(11, 43)
21
&gt;&gt;&gt; sqrt_mod(17, 32, True)
[7, 9, 23, 25]
</pre> 
</div>
</div>
<a id="a9f18ece81d0b2cf63fc220ef57c10f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f18ece81d0b2cf63fc220ef57c10f99">&#9670;&nbsp;</a></span>sqrt_mod_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.residue_ntheory.sqrt_mod_iter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>int</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate over solutions to ``x**2 = a mod p``.

Parameters
==========

a : integer
p : positive integer
domain : integer domain, ``int``, ``ZZ`` or ``Integer``

Examples
========

&gt;&gt;&gt; from sympy.ntheory.residue_ntheory import sqrt_mod_iter
&gt;&gt;&gt; list(sqrt_mod_iter(11, 43))
[21, 22]

See Also
========

sqrt_mod : Same functionality, but you want a sorted list or only one solution.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
