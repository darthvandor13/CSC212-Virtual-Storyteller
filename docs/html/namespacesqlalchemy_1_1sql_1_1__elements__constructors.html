<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sqlalchemy.sql._elements_constructors Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesqlalchemy.html">sqlalchemy</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1sql.html">sql</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html">_elements_constructors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sqlalchemy.sql._elements_constructors Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0e560f82c7de1bbdd7f541430fd12a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1CollectionAggregate.html">CollectionAggregate</a>[bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a0e560f82c7de1bbdd7f541430fd12a98">all_</a> (_ColumnExpressionArgument[_T] expr)</td></tr>
<tr class="separator:a0e560f82c7de1bbdd7f541430fd12a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c22dd968f861077e0bd03c3d05cf596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnElement.html">ColumnElement</a>[bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a0c22dd968f861077e0bd03c3d05cf596">and_</a> (Union[Literal[True], _ColumnExpressionArgument[bool]] initial_clause, *_ColumnExpressionArgument[bool] clauses)</td></tr>
<tr class="separator:a0c22dd968f861077e0bd03c3d05cf596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fa285a8531a1a40ff039363f97c6b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a09fa285a8531a1a40ff039363f97c6b0">and_</a> (*clauses)</td></tr>
<tr class="separator:a09fa285a8531a1a40ff039363f97c6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073fa701912c2e73890463a94e5476b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1CollectionAggregate.html">CollectionAggregate</a>[bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a073fa701912c2e73890463a94e5476b6">any_</a> (_ColumnExpressionArgument[_T] expr)</td></tr>
<tr class="separator:a073fa701912c2e73890463a94e5476b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dc02185e035dfe1609d4542d8b6f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a56dc02185e035dfe1609d4542d8b6f4e">asc</a> (_ColumnExpressionOrStrLabelArgument[_T] <a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ac7d864454edd3089f6d1639387765ba1">column</a>)</td></tr>
<tr class="separator:a56dc02185e035dfe1609d4542d8b6f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589cf94c78e30cc97200a4fd24a48863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BinaryExpression.html">BinaryExpression</a>[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a589cf94c78e30cc97200a4fd24a48863">collate</a> (_ColumnExpressionArgument[str] expression, str collation)</td></tr>
<tr class="separator:a589cf94c78e30cc97200a4fd24a48863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0021ff3a5817abf5a7d83df8518240b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BinaryExpression.html">BinaryExpression</a>[bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#aa0021ff3a5817abf5a7d83df8518240b">between</a> (_ColumnExpressionOrLiteralArgument[_T] expr, Any lower_bound, Any upper_bound, bool symmetric=False)</td></tr>
<tr class="separator:aa0021ff3a5817abf5a7d83df8518240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc91cf2b5548fc2e2affe93ba44c103b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BindParameter.html">BindParameter</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#afc91cf2b5548fc2e2affe93ba44c103b">outparam</a> (str key, Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1type__api_1_1TypeEngine.html">TypeEngine</a>[_T]] type_=None)</td></tr>
<tr class="separator:afc91cf2b5548fc2e2affe93ba44c103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310c79c224de678ef4a7a77818c14c0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BinaryExpression.html">BinaryExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a310c79c224de678ef4a7a77818c14c0c">not_</a> (<a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BinaryExpression.html">BinaryExpression</a>[_T] clause)</td></tr>
<tr class="separator:a310c79c224de678ef4a7a77818c14c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c501eb335f217057b608e5a10c767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnElement.html">ColumnElement</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#af12c501eb335f217057b608e5a10c767">not_</a> (_ColumnExpressionArgument[_T] clause)</td></tr>
<tr class="separator:af12c501eb335f217057b608e5a10c767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5a9a21c3a53499a77189dcd8ddb1db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BindParameter.html">BindParameter</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a6a5a9a21c3a53499a77189dcd8ddb1db">bindparam</a> (Optional[str] key, Any value=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[_TypeEngineArgument[_T]] type_=None, bool unique=False, Union[bool, Literal[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>]] required=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>, Optional[bool] quote=None, Optional[Callable[[], Any]] callable_=None, bool expanding=False, bool isoutparam=False, bool literal_execute=False)</td></tr>
<tr class="separator:a6a5a9a21c3a53499a77189dcd8ddb1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dab113342bf5f3aa74cd724f02451c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Case.html">Case</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a8dab113342bf5f3aa74cd724f02451c6">case</a> (*Union[typing_Tuple[_ColumnExpressionArgument[bool], Any], Mapping[Any, Any]] whens, Optional[Any] value=None, Optional[Any] else_=None)</td></tr>
<tr class="separator:a8dab113342bf5f3aa74cd724f02451c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493256cb5a8c31cea08dcc0ffb745be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Cast.html">Cast</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a493256cb5a8c31cea08dcc0ffb745be4">cast</a> (_ColumnExpressionOrLiteralArgument[Any] expression, _TypeEngineArgument[_T] type_)</td></tr>
<tr class="separator:a493256cb5a8c31cea08dcc0ffb745be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee7f3597cd154cc74f5235e5072a45c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1TryCast.html">TryCast</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a9ee7f3597cd154cc74f5235e5072a45c">try_cast</a> (_ColumnExpressionOrLiteralArgument[Any] expression, _TypeEngineArgument[_T] type_)</td></tr>
<tr class="separator:a9ee7f3597cd154cc74f5235e5072a45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d864454edd3089f6d1639387765ba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnClause.html">ColumnClause</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ac7d864454edd3089f6d1639387765ba1">column</a> (str <a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ae65c5d912dcc878ff909c44313e75487">text</a>, Optional[_TypeEngineArgument[_T]] type_=None, bool is_literal=False, Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] _selectable=None)</td></tr>
<tr class="separator:ac7d864454edd3089f6d1639387765ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9be10c597f3b2c014b0071787bdb1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a7c9be10c597f3b2c014b0071787bdb1c">desc</a> (_ColumnExpressionOrStrLabelArgument[_T] <a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ac7d864454edd3089f6d1639387765ba1">column</a>)</td></tr>
<tr class="separator:a7c9be10c597f3b2c014b0071787bdb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775d0828419ca96b70208fd8b783d718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a775d0828419ca96b70208fd8b783d718">distinct</a> (_ColumnExpressionArgument[_T] expr)</td></tr>
<tr class="separator:a775d0828419ca96b70208fd8b783d718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac069aa879e77d6d6f43ac41c9ecb2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a5ac069aa879e77d6d6f43ac41c9ecb2c">bitwise_not</a> (_ColumnExpressionArgument[_T] expr)</td></tr>
<tr class="separator:a5ac069aa879e77d6d6f43ac41c9ecb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3671954a393fee0207682afdf3adf5d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Extract.html">Extract</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a3671954a393fee0207682afdf3adf5d1">extract</a> (str field, _ColumnExpressionArgument[Any] expr)</td></tr>
<tr class="separator:a3671954a393fee0207682afdf3adf5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4351c18f5285c9fefaef2a756232222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1False__.html">False_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#af4351c18f5285c9fefaef2a756232222">false</a> ()</td></tr>
<tr class="separator:af4351c18f5285c9fefaef2a756232222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0adc175859ec766093cc93b89ff23c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1FunctionFilter.html">FunctionFilter</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ac0adc175859ec766093cc93b89ff23c9">funcfilter</a> (<a class="el" href="classsqlalchemy_1_1sql_1_1functions_1_1FunctionElement.html">FunctionElement</a>[_T] func, *_ColumnExpressionArgument[bool] criterion)</td></tr>
<tr class="separator:ac0adc175859ec766093cc93b89ff23c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517af110eca3e1f74dda782754f8b787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Label.html">Label</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a517af110eca3e1f74dda782754f8b787">label</a> (str name, _ColumnExpressionArgument[_T] element, Optional[_TypeEngineArgument[_T]] type_=None)</td></tr>
<tr class="separator:a517af110eca3e1f74dda782754f8b787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46be6ef0863028bc999503b5e1bc7d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Null.html">Null</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a46be6ef0863028bc999503b5e1bc7d57">null</a> ()</td></tr>
<tr class="separator:a46be6ef0863028bc999503b5e1bc7d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4927e66923176c22478540f14ea46f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a4927e66923176c22478540f14ea46f93">nulls_first</a> (_ColumnExpressionArgument[_T] <a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ac7d864454edd3089f6d1639387765ba1">column</a>)</td></tr>
<tr class="separator:a4927e66923176c22478540f14ea46f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bc92bbba4109c8978710fe7c07a280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a11bc92bbba4109c8978710fe7c07a280">nulls_last</a> (_ColumnExpressionArgument[_T] <a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ac7d864454edd3089f6d1639387765ba1">column</a>)</td></tr>
<tr class="separator:a11bc92bbba4109c8978710fe7c07a280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf755692bbb06712f49067b68589f75c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnElement.html">ColumnElement</a>[bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#acf755692bbb06712f49067b68589f75c">or_</a> (Union[Literal[False], _ColumnExpressionArgument[bool]] initial_clause, *_ColumnExpressionArgument[bool] clauses)</td></tr>
<tr class="separator:acf755692bbb06712f49067b68589f75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878e87a4dfd44e1b27111016ede7ab3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a878e87a4dfd44e1b27111016ede7ab3f">or_</a> (*clauses)</td></tr>
<tr class="separator:a878e87a4dfd44e1b27111016ede7ab3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5159bebe15b5444f90d42b346e7caa65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Over.html">Over</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a5159bebe15b5444f90d42b346e7caa65">over</a> (<a class="el" href="classsqlalchemy_1_1sql_1_1functions_1_1FunctionElement.html">FunctionElement</a>[_T] element, Optional[_ByArgument] partition_by=None, Optional[_ByArgument] order_by=None, Optional[typing_Tuple[Optional[int], Optional[int]]] range_=None, Optional[typing_Tuple[Optional[int], Optional[int]]] rows=None)</td></tr>
<tr class="separator:a5159bebe15b5444f90d42b346e7caa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65c5d912dcc878ff909c44313e75487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1TextClause.html">TextClause</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ae65c5d912dcc878ff909c44313e75487">text</a> (str text)</td></tr>
<tr class="separator:ae65c5d912dcc878ff909c44313e75487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909160b7374ca75cbc430b9c1cd5142e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1True__.html">True_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a909160b7374ca75cbc430b9c1cd5142e">true</a> ()</td></tr>
<tr class="separator:a909160b7374ca75cbc430b9c1cd5142e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bd982e8a54729096f132facda96dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#ab5bd982e8a54729096f132facda96dde">tuple_</a> (*_ColumnExpressionArgument[Any] clauses, Optional[Sequence[_TypeEngineArgument[Any]]] types=None)</td></tr>
<tr class="separator:ab5bd982e8a54729096f132facda96dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aa77fc566b5c1ffb074c95e2c6e6c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1TypeCoerce.html">TypeCoerce</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a71aa77fc566b5c1ffb074c95e2c6e6c1">type_coerce</a> (_ColumnExpressionOrLiteralArgument[Any] expression, _TypeEngineArgument[_T] type_)</td></tr>
<tr class="separator:a71aa77fc566b5c1ffb074c95e2c6e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8472d8714b43ca3823eed738c4584782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1WithinGroup.html">WithinGroup</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesqlalchemy_1_1sql_1_1__elements__constructors.html#a8472d8714b43ca3823eed738c4584782">within_group</a> (<a class="el" href="classsqlalchemy_1_1sql_1_1functions_1_1FunctionElement.html">FunctionElement</a>[_T] element, *_ColumnExpressionArgument[Any] order_by)</td></tr>
<tr class="separator:a8472d8714b43ca3823eed738c4584782"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0e560f82c7de1bbdd7f541430fd12a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e560f82c7de1bbdd7f541430fd12a98">&#9670;&nbsp;</a></span>all_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1CollectionAggregate.html">CollectionAggregate</a>[bool] sqlalchemy.sql._elements_constructors.all_ </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionArgument[_T]&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce an ALL expression.

For dialects such as that of PostgreSQL, this operator applies
to usage of the :class:`_types.ARRAY` datatype, for that of
MySQL, it may apply to a subquery.  e.g.::

    # renders on PostgreSQL:
    # '5 = ALL (somearray)'
    expr = 5 == all_(mytable.c.somearray)

    # renders on MySQL:
    # '5 = ALL (SELECT value FROM table)'
    expr = 5 == all_(select(table.c.value))

Comparison to NULL may work using ``None``::

    None == all_(mytable.c.somearray)

The any_() / all_() operators also feature a special "operand flipping"
behavior such that if any_() / all_() are used on the left side of a
comparison using a standalone operator such as ``==``, ``!=``, etc.
(not including operator methods such as
:meth:`_sql.ColumnOperators.is_`) the rendered expression is flipped::

    # would render '5 = ALL (column)`
    all_(mytable.c.column) == 5

Or with ``None``, which note will not perform
the usual step of rendering "IS" as is normally the case for NULL::

    # would render 'NULL = ALL(somearray)'
    all_(mytable.c.somearray) == None

.. versionchanged:: 1.4.26  repaired the use of any_() / all_()
   comparing to NULL on the right side to be flipped to the left.

The column-level :meth:`_sql.ColumnElement.all_` method (not to be
confused with :class:`_types.ARRAY` level
:meth:`_types.ARRAY.Comparator.all`) is shorthand for
``all_(col)``::

    5 == mytable.c.somearray.all_()

.. seealso::

    :meth:`_sql.ColumnOperators.all_`

    :func:`_expression.any_`</pre> 
</div>
</div>
<a id="a09fa285a8531a1a40ff039363f97c6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fa285a8531a1a40ff039363f97c6b0">&#9670;&nbsp;</a></span>and_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sqlalchemy.sql._elements_constructors.and_ </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>clauses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a conjunction of expressions joined by ``AND``.

E.g.::

    from sqlalchemy import and_

    stmt = select(users_table).where(
        and_(users_table.c.name == "wendy", users_table.c.enrolled == True)
    )

The :func:`.and_` conjunction is also available using the
Python ``&amp;`` operator (though note that compound expressions
need to be parenthesized in order to function with Python
operator precedence behavior)::

    stmt = select(users_table).where(
        (users_table.c.name == "wendy") &amp; (users_table.c.enrolled == True)
    )

The :func:`.and_` operation is also implicit in some cases;
the :meth:`_expression.Select.where`
method for example can be invoked multiple
times against a statement, which will have the effect of each
clause being combined using :func:`.and_`::

    stmt = (
        select(users_table)
        .where(users_table.c.name == "wendy")
        .where(users_table.c.enrolled == True)
    )

The :func:`.and_` construct must be given at least one positional
argument in order to be valid; a :func:`.and_` construct with no
arguments is ambiguous.   To produce an "empty" or dynamically
generated :func:`.and_`  expression, from a given list of expressions,
a "default" element of :func:`_sql.true` (or just ``True``) should be
specified::

    from sqlalchemy import true

    criteria = and_(true(), *expressions)

The above expression will compile to SQL as the expression ``true``
or ``1 = 1``, depending on backend, if no other expressions are
present.  If expressions are present, then the :func:`_sql.true` value
is ignored as it does not affect the outcome of an AND expression that
has other elements.

.. deprecated:: 1.4  The :func:`.and_` element now requires that at
  least one argument is passed; creating the :func:`.and_` construct
  with no arguments is deprecated, and will emit a deprecation warning
  while continuing to produce a blank SQL string.

.. seealso::

    :func:`.or_`</pre> 
</div>
</div>
<a id="a0c22dd968f861077e0bd03c3d05cf596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c22dd968f861077e0bd03c3d05cf596">&#9670;&nbsp;</a></span>and_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnElement.html">ColumnElement</a>[bool] sqlalchemy.sql._elements_constructors.and_ </td>
          <td>(</td>
          <td class="paramtype">Union[Literal[True], _ColumnExpressionArgument[bool]]&#160;</td>
          <td class="paramname"><em>initial_clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_ColumnExpressionArgument[bool]&#160;</td>
          <td class="paramname"><em>clauses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a conjunction of expressions joined by ``AND``.

E.g.::

    from sqlalchemy import and_

    stmt = select(users_table).where(
        and_(users_table.c.name == "wendy", users_table.c.enrolled == True)
    )

The :func:`.and_` conjunction is also available using the
Python ``&amp;`` operator (though note that compound expressions
need to be parenthesized in order to function with Python
operator precedence behavior)::

    stmt = select(users_table).where(
        (users_table.c.name == "wendy") &amp; (users_table.c.enrolled == True)
    )

The :func:`.and_` operation is also implicit in some cases;
the :meth:`_expression.Select.where`
method for example can be invoked multiple
times against a statement, which will have the effect of each
clause being combined using :func:`.and_`::

    stmt = (
        select(users_table)
        .where(users_table.c.name == "wendy")
        .where(users_table.c.enrolled == True)
    )

The :func:`.and_` construct must be given at least one positional
argument in order to be valid; a :func:`.and_` construct with no
arguments is ambiguous.   To produce an "empty" or dynamically
generated :func:`.and_`  expression, from a given list of expressions,
a "default" element of :func:`_sql.true` (or just ``True``) should be
specified::

    from sqlalchemy import true

    criteria = and_(true(), *expressions)

The above expression will compile to SQL as the expression ``true``
or ``1 = 1``, depending on backend, if no other expressions are
present.  If expressions are present, then the :func:`_sql.true` value is
ignored as it does not affect the outcome of an AND expression that
has other elements.

.. deprecated:: 1.4  The :func:`.and_` element now requires that at
   least one argument is passed; creating the :func:`.and_` construct
   with no arguments is deprecated, and will emit a deprecation warning
   while continuing to produce a blank SQL string.

.. seealso::

    :func:`.or_`</pre> 
</div>
</div>
<a id="a073fa701912c2e73890463a94e5476b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073fa701912c2e73890463a94e5476b6">&#9670;&nbsp;</a></span>any_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1CollectionAggregate.html">CollectionAggregate</a>[bool] sqlalchemy.sql._elements_constructors.any_ </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionArgument[_T]&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce an ANY expression.

For dialects such as that of PostgreSQL, this operator applies
to usage of the :class:`_types.ARRAY` datatype, for that of
MySQL, it may apply to a subquery.  e.g.::

    # renders on PostgreSQL:
    # '5 = ANY (somearray)'
    expr = 5 == any_(mytable.c.somearray)

    # renders on MySQL:
    # '5 = ANY (SELECT value FROM table)'
    expr = 5 == any_(select(table.c.value))

Comparison to NULL may work using ``None`` or :func:`_sql.null`::

    None == any_(mytable.c.somearray)

The any_() / all_() operators also feature a special "operand flipping"
behavior such that if any_() / all_() are used on the left side of a
comparison using a standalone operator such as ``==``, ``!=``, etc.
(not including operator methods such as
:meth:`_sql.ColumnOperators.is_`) the rendered expression is flipped::

    # would render '5 = ANY (column)`
    any_(mytable.c.column) == 5

Or with ``None``, which note will not perform
the usual step of rendering "IS" as is normally the case for NULL::

    # would render 'NULL = ANY(somearray)'
    any_(mytable.c.somearray) == None

.. versionchanged:: 1.4.26  repaired the use of any_() / all_()
   comparing to NULL on the right side to be flipped to the left.

The column-level :meth:`_sql.ColumnElement.any_` method (not to be
confused with :class:`_types.ARRAY` level
:meth:`_types.ARRAY.Comparator.any`) is shorthand for
``any_(col)``::

    5 = mytable.c.somearray.any_()

.. seealso::

    :meth:`_sql.ColumnOperators.any_`

    :func:`_expression.all_`</pre> 
</div>
</div>
<a id="a56dc02185e035dfe1609d4542d8b6f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dc02185e035dfe1609d4542d8b6f4e">&#9670;&nbsp;</a></span>asc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T] sqlalchemy.sql._elements_constructors.asc </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionOrStrLabelArgument[_T]&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce an ascending ``ORDER BY`` clause element.

e.g.::

    from sqlalchemy import asc

    stmt = select(users_table).order_by(asc(users_table.c.name))

will produce SQL as:

.. sourcecode:: sql

    SELECT id, name FROM user ORDER BY name ASC

The :func:`.asc` function is a standalone version of the
:meth:`_expression.ColumnElement.asc`
method available on all SQL expressions,
e.g.::


    stmt = select(users_table).order_by(users_table.c.name.asc())

:param column: A :class:`_expression.ColumnElement` (e.g.
 scalar SQL expression)
 with which to apply the :func:`.asc` operation.

.. seealso::

    :func:`.desc`

    :func:`.nulls_first`

    :func:`.nulls_last`

    :meth:`_expression.Select.order_by`</pre> 
</div>
</div>
<a id="aa0021ff3a5817abf5a7d83df8518240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0021ff3a5817abf5a7d83df8518240b">&#9670;&nbsp;</a></span>between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BinaryExpression.html">BinaryExpression</a>[bool] sqlalchemy.sql._elements_constructors.between </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionOrLiteralArgument[_T]&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a ``BETWEEN`` predicate clause.

E.g.::

    from sqlalchemy import between

    stmt = select(users_table).where(between(users_table.c.id, 5, 7))

Would produce SQL resembling:

.. sourcecode:: sql

    SELECT id, name FROM user WHERE id BETWEEN :id_1 AND :id_2

The :func:`.between` function is a standalone version of the
:meth:`_expression.ColumnElement.between` method available on all
SQL expressions, as in::

    stmt = select(users_table).where(users_table.c.id.between(5, 7))

All arguments passed to :func:`.between`, including the left side
column expression, are coerced from Python scalar values if a
the value is not a :class:`_expression.ColumnElement` subclass.
For example,
three fixed values can be compared as in::

    print(between(5, 3, 7))

Which would produce::

    :param_1 BETWEEN :param_2 AND :param_3

:param expr: a column expression, typically a
 :class:`_expression.ColumnElement`
 instance or alternatively a Python scalar expression to be coerced
 into a column expression, serving as the left side of the ``BETWEEN``
 expression.

:param lower_bound: a column or Python scalar expression serving as the
 lower bound of the right side of the ``BETWEEN`` expression.

:param upper_bound: a column or Python scalar expression serving as the
 upper bound of the right side of the ``BETWEEN`` expression.

:param symmetric: if True, will render " BETWEEN SYMMETRIC ". Note
 that not all databases support this syntax.

.. seealso::

    :meth:`_expression.ColumnElement.between`</pre> 
</div>
</div>
<a id="a6a5a9a21c3a53499a77189dcd8ddb1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5a9a21c3a53499a77189dcd8ddb1db">&#9670;&nbsp;</a></span>bindparam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BindParameter.html">BindParameter</a>[_T] sqlalchemy.sql._elements_constructors.bindparam </td>
          <td>(</td>
          <td class="paramtype">Optional[str]&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any &#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_TypeEngineArgument[_T]] &#160;</td>
          <td class="paramname"><em>type_</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>unique</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[bool, Literal[<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>]] &#160;</td>
          <td class="paramname"><em>required</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>quote</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Callable[[], Any]] &#160;</td>
          <td class="paramname"><em>callable_</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>expanding</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>isoutparam</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>literal_execute</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a "bound expression".

The return value is an instance of :class:`.BindParameter`; this
is a :class:`_expression.ColumnElement`
subclass which represents a so-called
"placeholder" value in a SQL expression, the value of which is
supplied at the point at which the statement in executed against a
database connection.

In SQLAlchemy, the :func:`.bindparam` construct has
the ability to carry along the actual value that will be ultimately
used at expression time.  In this way, it serves not just as
a "placeholder" for eventual population, but also as a means of
representing so-called "unsafe" values which should not be rendered
directly in a SQL statement, but rather should be passed along
to the :term:`DBAPI` as values which need to be correctly escaped
and potentially handled for type-safety.

When using :func:`.bindparam` explicitly, the use case is typically
one of traditional deferment of parameters; the :func:`.bindparam`
construct accepts a name which can then be referred to at execution
time::

    from sqlalchemy import bindparam

    stmt = select(users_table).where(
        users_table.c.name == bindparam("username")
    )

The above statement, when rendered, will produce SQL similar to:

.. sourcecode:: sql

    SELECT id, name FROM user WHERE name = :username

In order to populate the value of ``:username`` above, the value
would typically be applied at execution time to a method
like :meth:`_engine.Connection.execute`::

    result = connection.execute(stmt, {"username": "wendy"})

Explicit use of :func:`.bindparam` is also common when producing
UPDATE or DELETE statements that are to be invoked multiple times,
where the WHERE criterion of the statement is to change on each
invocation, such as::

    stmt = (
        users_table.update()
        .where(user_table.c.name == bindparam("username"))
        .values(fullname=bindparam("fullname"))
    )

    connection.execute(
        stmt,
        [
            {"username": "wendy", "fullname": "Wendy Smith"},
            {"username": "jack", "fullname": "Jack Jones"},
        ],
    )

SQLAlchemy's Core expression system makes wide use of
:func:`.bindparam` in an implicit sense.   It is typical that Python
literal values passed to virtually all SQL expression functions are
coerced into fixed :func:`.bindparam` constructs.  For example, given
a comparison operation such as::

    expr = users_table.c.name == "Wendy"

The above expression will produce a :class:`.BinaryExpression`
construct, where the left side is the :class:`_schema.Column` object
representing the ``name`` column, and the right side is a
:class:`.BindParameter` representing the literal value::

    print(repr(expr.right))
    BindParameter("%(4327771088 name)s", "Wendy", type_=String())

The expression above will render SQL such as:

.. sourcecode:: sql

    user.name = :name_1

Where the ``:name_1`` parameter name is an anonymous name.  The
actual string ``Wendy`` is not in the rendered string, but is carried
along where it is later used within statement execution.  If we
invoke a statement like the following::

    stmt = select(users_table).where(users_table.c.name == "Wendy")
    result = connection.execute(stmt)

We would see SQL logging output as:

.. sourcecode:: sql

    SELECT "user".id, "user".name
    FROM "user"
    WHERE "user".name = %(name_1)s
    {'name_1': 'Wendy'}

Above, we see that ``Wendy`` is passed as a parameter to the database,
while the placeholder ``:name_1`` is rendered in the appropriate form
for the target database, in this case the PostgreSQL database.

Similarly, :func:`.bindparam` is invoked automatically when working
with :term:`CRUD` statements as far as the "VALUES" portion is
concerned.   The :func:`_expression.insert` construct produces an
``INSERT`` expression which will, at statement execution time, generate
bound placeholders based on the arguments passed, as in::

    stmt = users_table.insert()
    result = connection.execute(stmt, {"name": "Wendy"})

The above will produce SQL output as:

.. sourcecode:: sql

    INSERT INTO "user" (name) VALUES (%(name)s)
    {'name': 'Wendy'}

The :class:`_expression.Insert` construct, at
compilation/execution time, rendered a single :func:`.bindparam`
mirroring the column name ``name`` as a result of the single ``name``
parameter we passed to the :meth:`_engine.Connection.execute` method.

:param key:
  the key (e.g. the name) for this bind param.
  Will be used in the generated
  SQL statement for dialects that use named parameters.  This
  value may be modified when part of a compilation operation,
  if other :class:`BindParameter` objects exist with the same
  key, or if its length is too long and truncation is
  required.

  If omitted, an "anonymous" name is generated for the bound parameter;
  when given a value to bind, the end result is equivalent to calling upon
  the :func:`.literal` function with a value to bind, particularly
  if the :paramref:`.bindparam.unique` parameter is also provided.

:param value:
  Initial value for this bind param.  Will be used at statement
  execution time as the value for this parameter passed to the
  DBAPI, if no other value is indicated to the statement execution
  method for this particular parameter name.  Defaults to ``None``.

:param callable\_:
  A callable function that takes the place of "value".  The function
  will be called at statement execution time to determine the
  ultimate value.   Used for scenarios where the actual bind
  value cannot be determined at the point at which the clause
  construct is created, but embedded bind values are still desirable.

:param type\_:
  A :class:`.TypeEngine` class or instance representing an optional
  datatype for this :func:`.bindparam`.  If not passed, a type
  may be determined automatically for the bind, based on the given
  value; for example, trivial Python types such as ``str``,
  ``int``, ``bool``
  may result in the :class:`.String`, :class:`.Integer` or
  :class:`.Boolean` types being automatically selected.

  The type of a :func:`.bindparam` is significant especially in that
  the type will apply pre-processing to the value before it is
  passed to the database.  For example, a :func:`.bindparam` which
  refers to a datetime value, and is specified as holding the
  :class:`.DateTime` type, may apply conversion needed to the
  value (such as stringification on SQLite) before passing the value
  to the database.

:param unique:
  if True, the key name of this :class:`.BindParameter` will be
  modified if another :class:`.BindParameter` of the same name
  already has been located within the containing
  expression.  This flag is used generally by the internals
  when producing so-called "anonymous" bound expressions, it
  isn't generally applicable to explicitly-named :func:`.bindparam`
  constructs.

:param required:
  If ``True``, a value is required at execution time.  If not passed,
  it defaults to ``True`` if neither :paramref:`.bindparam.value`
  or :paramref:`.bindparam.callable` were passed.  If either of these
  parameters are present, then :paramref:`.bindparam.required`
  defaults to ``False``.

:param quote:
  True if this parameter name requires quoting and is not
  currently known as a SQLAlchemy reserved word; this currently
  only applies to the Oracle Database backends, where bound names must
  sometimes be quoted.

:param isoutparam:
  if True, the parameter should be treated like a stored procedure
  "OUT" parameter.  This applies to backends such as Oracle Database which
  support OUT parameters.

:param expanding:
  if True, this parameter will be treated as an "expanding" parameter
  at execution time; the parameter value is expected to be a sequence,
  rather than a scalar value, and the string SQL statement will
  be transformed on a per-execution basis to accommodate the sequence
  with a variable number of parameter slots passed to the DBAPI.
  This is to allow statement caching to be used in conjunction with
  an IN clause.

  .. seealso::

    :meth:`.ColumnOperators.in_`

    :ref:`baked_in` - with baked queries

  .. note:: The "expanding" feature does not support "executemany"-
     style parameter sets.

  .. versionadded:: 1.2

  .. versionchanged:: 1.3 the "expanding" bound parameter feature now
     supports empty lists.

:param literal_execute:
  if True, the bound parameter will be rendered in the compile phase
  with a special "POSTCOMPILE" token, and the SQLAlchemy compiler will
  render the final value of the parameter into the SQL statement at
  statement execution time, omitting the value from the parameter
  dictionary / list passed to DBAPI ``cursor.execute()``.  This
  produces a similar effect as that of using the ``literal_binds``,
  compilation flag,  however takes place as the statement is sent to
  the DBAPI ``cursor.execute()`` method, rather than when the statement
  is compiled.   The primary use of this
  capability is for rendering LIMIT / OFFSET clauses for database
  drivers that can't accommodate for bound parameters in these
  contexts, while allowing SQL constructs to be cacheable at the
  compilation level.

  .. versionadded:: 1.4 Added "post compile" bound parameters

    .. seealso::

        :ref:`change_4808`.

.. seealso::

    :ref:`tutorial_sending_parameters` - in the
    :ref:`unified_tutorial`</pre> 
</div>
</div>
<a id="a5ac069aa879e77d6d6f43ac41c9ecb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac069aa879e77d6d6f43ac41c9ecb2c">&#9670;&nbsp;</a></span>bitwise_not()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T] sqlalchemy.sql._elements_constructors.bitwise_not </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionArgument[_T]&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a unary bitwise NOT clause, typically via the ``~`` operator.

Not to be confused with boolean negation :func:`_sql.not_`.

.. versionadded:: 2.0.2

.. seealso::

    :ref:`operators_bitwise`</pre> 
</div>
</div>
<a id="a8dab113342bf5f3aa74cd724f02451c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dab113342bf5f3aa74cd724f02451c6">&#9670;&nbsp;</a></span>case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Case.html">Case</a>[Any] sqlalchemy.sql._elements_constructors.case </td>
          <td>(</td>
          <td class="paramtype">*Union[
        typing_Tuple[_ColumnExpressionArgument[bool], Any], Mapping[Any, Any]
    ]&#160;</td>
          <td class="paramname"><em>whens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>else_</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a ``CASE`` expression.

The ``CASE`` construct in SQL is a conditional object that
acts somewhat analogously to an "if/then" construct in other
languages.  It returns an instance of :class:`.Case`.

:func:`.case` in its usual form is passed a series of "when"
constructs, that is, a list of conditions and results as tuples::

    from sqlalchemy import case

    stmt = select(users_table).where(
        case(
            (users_table.c.name == "wendy", "W"),
            (users_table.c.name == "jack", "J"),
            else_="E",
        )
    )

The above statement will produce SQL resembling:

.. sourcecode:: sql

    SELECT id, name FROM user
    WHERE CASE
        WHEN (name = :name_1) THEN :param_1
        WHEN (name = :name_2) THEN :param_2
        ELSE :param_3
    END

When simple equality expressions of several values against a single
parent column are needed, :func:`.case` also has a "shorthand" format
used via the
:paramref:`.case.value` parameter, which is passed a column
expression to be compared.  In this form, the :paramref:`.case.whens`
parameter is passed as a dictionary containing expressions to be
compared against keyed to result expressions.  The statement below is
equivalent to the preceding statement::

    stmt = select(users_table).where(
        case({"wendy": "W", "jack": "J"}, value=users_table.c.name, else_="E")
    )

The values which are accepted as result values in
:paramref:`.case.whens` as well as with :paramref:`.case.else_` are
coerced from Python literals into :func:`.bindparam` constructs.
SQL expressions, e.g. :class:`_expression.ColumnElement` constructs,
are accepted
as well.  To coerce a literal string expression into a constant
expression rendered inline, use the :func:`_expression.literal_column`
construct,
as in::

    from sqlalchemy import case, literal_column

    case(
        (orderline.c.qty &gt; 100, literal_column("'greaterthan100'")),
        (orderline.c.qty &gt; 10, literal_column("'greaterthan10'")),
        else_=literal_column("'lessthan10'"),
    )

The above will render the given constants without using bound
parameters for the result values (but still for the comparison
values), as in:

.. sourcecode:: sql

    CASE
        WHEN (orderline.qty &gt; :qty_1) THEN 'greaterthan100'
        WHEN (orderline.qty &gt; :qty_2) THEN 'greaterthan10'
        ELSE 'lessthan10'
    END

:param \*whens: The criteria to be compared against,
 :paramref:`.case.whens` accepts two different forms, based on
 whether or not :paramref:`.case.value` is used.

 .. versionchanged:: 1.4 the :func:`_sql.case`
    function now accepts the series of WHEN conditions positionally

 In the first form, it accepts multiple 2-tuples passed as positional
 arguments; each 2-tuple consists of ``(&lt;sql expression&gt;, &lt;value&gt;)``,
 where the SQL expression is a boolean expression and "value" is a
 resulting value, e.g.::

    case(
        (users_table.c.name == "wendy", "W"),
        (users_table.c.name == "jack", "J"),
    )

 In the second form, it accepts a Python dictionary of comparison
 values mapped to a resulting value; this form requires
 :paramref:`.case.value` to be present, and values will be compared
 using the ``==`` operator, e.g.::

    case({"wendy": "W", "jack": "J"}, value=users_table.c.name)

:param value: An optional SQL expression which will be used as a
  fixed "comparison point" for candidate values within a dictionary
  passed to :paramref:`.case.whens`.

:param else\_: An optional SQL expression which will be the evaluated
  result of the ``CASE`` construct if all expressions within
  :paramref:`.case.whens` evaluate to false.  When omitted, most
  databases will produce a result of NULL if none of the "when"
  expressions evaluate to true.</pre> 
</div>
</div>
<a id="a493256cb5a8c31cea08dcc0ffb745be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493256cb5a8c31cea08dcc0ffb745be4">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Cast.html">Cast</a>[_T] sqlalchemy.sql._elements_constructors.cast </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionOrLiteralArgument[Any]&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TypeEngineArgument[_T]&#160;</td>
          <td class="paramname"><em>type_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a ``CAST`` expression.

:func:`.cast` returns an instance of :class:`.Cast`.

E.g.::

    from sqlalchemy import cast, Numeric

    stmt = select(cast(product_table.c.unit_price, Numeric(10, 4)))

The above statement will produce SQL resembling:

.. sourcecode:: sql

    SELECT CAST(unit_price AS NUMERIC(10, 4)) FROM product

The :func:`.cast` function performs two distinct functions when
used.  The first is that it renders the ``CAST`` expression within
the resulting SQL string.  The second is that it associates the given
type (e.g. :class:`.TypeEngine` class or instance) with the column
expression on the Python side, which means the expression will take
on the expression operator behavior associated with that type,
as well as the bound-value handling and result-row-handling behavior
of the type.

An alternative to :func:`.cast` is the :func:`.type_coerce` function.
This function performs the second task of associating an expression
with a specific type, but does not render the ``CAST`` expression
in SQL.

:param expression: A SQL expression, such as a
 :class:`_expression.ColumnElement`
 expression or a Python string which will be coerced into a bound
 literal value.

:param type\_: A :class:`.TypeEngine` class or instance indicating
 the type to which the ``CAST`` should apply.

.. seealso::

    :ref:`tutorial_casts`

    :func:`.try_cast` - an alternative to CAST that results in
    NULLs when the cast fails, instead of raising an error.
    Only supported by some dialects.

    :func:`.type_coerce` - an alternative to CAST that coerces the type
    on the Python side only, which is often sufficient to generate the
    correct SQL and data coercion.</pre> 
</div>
</div>
<a id="a589cf94c78e30cc97200a4fd24a48863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589cf94c78e30cc97200a4fd24a48863">&#9670;&nbsp;</a></span>collate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BinaryExpression.html">BinaryExpression</a>[str] sqlalchemy.sql._elements_constructors.collate </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionArgument[str]&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str
&#160;</td>
          <td class="paramname"><em>collation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the clause ``expression COLLATE collation``.

e.g.::

    collate(mycolumn, "utf8_bin")

produces:

.. sourcecode:: sql

    mycolumn COLLATE utf8_bin

The collation expression is also quoted if it is a case sensitive
identifier, e.g. contains uppercase characters.

.. versionchanged:: 1.2 quoting is automatically applied to COLLATE
   expressions if they are case sensitive.</pre> 
</div>
</div>
<a id="ac7d864454edd3089f6d1639387765ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d864454edd3089f6d1639387765ba1">&#9670;&nbsp;</a></span>column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnClause.html">ColumnClause</a>[_T] sqlalchemy.sql._elements_constructors.column </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_TypeEngineArgument[_T]] &#160;</td>
          <td class="paramname"><em>type_</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>is_literal</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1FromClause.html">FromClause</a>] &#160;</td>
          <td class="paramname"><em>_selectable</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a :class:`.ColumnClause` object.

The :class:`.ColumnClause` is a lightweight analogue to the
:class:`_schema.Column` class.  The :func:`_expression.column`
function can
be invoked with just a name alone, as in::

    from sqlalchemy import column

    id, name = column("id"), column("name")
    stmt = select(id, name).select_from("user")

The above statement would produce SQL like:

.. sourcecode:: sql

    SELECT id, name FROM user

Once constructed, :func:`_expression.column`
may be used like any other SQL
expression element such as within :func:`_expression.select`
constructs::

    from sqlalchemy.sql import column

    id, name = column("id"), column("name")
    stmt = select(id, name).select_from("user")

The text handled by :func:`_expression.column`
is assumed to be handled
like the name of a database column; if the string contains mixed case,
special characters, or matches a known reserved word on the target
backend, the column expression will render using the quoting
behavior determined by the backend.  To produce a textual SQL
expression that is rendered exactly without any quoting,
use :func:`_expression.literal_column` instead,
or pass ``True`` as the
value of :paramref:`_expression.column.is_literal`.   Additionally,
full SQL
statements are best handled using the :func:`_expression.text`
construct.

:func:`_expression.column` can be used in a table-like
fashion by combining it with the :func:`.table` function
(which is the lightweight analogue to :class:`_schema.Table`
) to produce
a working table construct with minimal boilerplate::

    from sqlalchemy import table, column, select

    user = table(
        "user",
        column("id"),
        column("name"),
        column("description"),
    )

    stmt = select(user.c.description).where(user.c.name == "wendy")

A :func:`_expression.column` / :func:`.table`
construct like that illustrated
above can be created in an
ad-hoc fashion and is not associated with any
:class:`_schema.MetaData`, DDL, or events, unlike its
:class:`_schema.Table` counterpart.

:param text: the text of the element.

:param type: :class:`_types.TypeEngine` object which can associate
  this :class:`.ColumnClause` with a type.

:param is_literal: if True, the :class:`.ColumnClause` is assumed to
  be an exact expression that will be delivered to the output with no
  quoting rules applied regardless of case sensitive settings. the
  :func:`_expression.literal_column()` function essentially invokes
  :func:`_expression.column` while passing ``is_literal=True``.

.. seealso::

    :class:`_schema.Column`

    :func:`_expression.literal_column`

    :func:`.table`

    :func:`_expression.text`

    :ref:`tutorial_select_arbitrary_text`</pre> 
</div>
</div>
<a id="a7c9be10c597f3b2c014b0071787bdb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9be10c597f3b2c014b0071787bdb1c">&#9670;&nbsp;</a></span>desc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T] sqlalchemy.sql._elements_constructors.desc </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionOrStrLabelArgument[_T]&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a descending ``ORDER BY`` clause element.

e.g.::

    from sqlalchemy import desc

    stmt = select(users_table).order_by(desc(users_table.c.name))

will produce SQL as:

.. sourcecode:: sql

    SELECT id, name FROM user ORDER BY name DESC

The :func:`.desc` function is a standalone version of the
:meth:`_expression.ColumnElement.desc`
method available on all SQL expressions,
e.g.::


    stmt = select(users_table).order_by(users_table.c.name.desc())

:param column: A :class:`_expression.ColumnElement` (e.g.
 scalar SQL expression)
 with which to apply the :func:`.desc` operation.

.. seealso::

    :func:`.asc`

    :func:`.nulls_first`

    :func:`.nulls_last`

    :meth:`_expression.Select.order_by`</pre> 
</div>
</div>
<a id="a775d0828419ca96b70208fd8b783d718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775d0828419ca96b70208fd8b783d718">&#9670;&nbsp;</a></span>distinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T] sqlalchemy.sql._elements_constructors.distinct </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionArgument[_T]&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce an column-expression-level unary ``DISTINCT`` clause.

This applies the ``DISTINCT`` keyword to an **individual column
expression** (e.g. not the whole statement), and renders **specifically
in that column position**; this is used for containment within
an aggregate function, as in::

    from sqlalchemy import distinct, func

    stmt = select(users_table.c.id, func.count(distinct(users_table.c.name)))

The above would produce an statement resembling:

.. sourcecode:: sql

    SELECT user.id, count(DISTINCT user.name) FROM user

.. tip:: The :func:`_sql.distinct` function does **not** apply DISTINCT
   to the full SELECT statement, instead applying a DISTINCT modifier
   to **individual column expressions**.  For general ``SELECT DISTINCT``
   support, use the
   :meth:`_sql.Select.distinct` method on :class:`_sql.Select`.

The :func:`.distinct` function is also available as a column-level
method, e.g. :meth:`_expression.ColumnElement.distinct`, as in::

    stmt = select(func.count(users_table.c.name.distinct()))

The :func:`.distinct` operator is different from the
:meth:`_expression.Select.distinct` method of
:class:`_expression.Select`,
which produces a ``SELECT`` statement
with ``DISTINCT`` applied to the result set as a whole,
e.g. a ``SELECT DISTINCT`` expression.  See that method for further
information.

.. seealso::

    :meth:`_expression.ColumnElement.distinct`

    :meth:`_expression.Select.distinct`

    :data:`.func`</pre> 
</div>
</div>
<a id="a3671954a393fee0207682afdf3adf5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3671954a393fee0207682afdf3adf5d1">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Extract.html">Extract</a> sqlalchemy.sql._elements_constructors.extract </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ColumnExpressionArgument[Any]&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`.Extract` construct.

This is typically available as :func:`.extract`
as well as ``func.extract`` from the
:data:`.func` namespace.

:param field: The field to extract.

 .. warning:: This field is used as a literal SQL string.
     **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.

:param expr: A column or Python scalar expression serving as the
  right side of the ``EXTRACT`` expression.

E.g.::

    from sqlalchemy import extract
    from sqlalchemy import table, column

    logged_table = table(
        "user",
        column("id"),
        column("date_created"),
    )

    stmt = select(logged_table.c.id).where(
        extract("YEAR", logged_table.c.date_created) == 2021
    )

In the above example, the statement is used to select ids from the
database where the ``YEAR`` component matches a specific value.

Similarly, one can also select an extracted component::

    stmt = select(extract("YEAR", logged_table.c.date_created)).where(
        logged_table.c.id == 1
    )

The implementation of ``EXTRACT`` may vary across database backends.
Users are reminded to consult their database documentation.
</pre> 
</div>
</div>
<a id="af4351c18f5285c9fefaef2a756232222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4351c18f5285c9fefaef2a756232222">&#9670;&nbsp;</a></span>false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1False__.html">False_</a> sqlalchemy.sql._elements_constructors.false </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`.False_` construct.

E.g.:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy import false
    &gt;&gt;&gt; print(select(t.c.x).where(false()))
    {printsql}SELECT x FROM t WHERE false

A backend which does not support true/false constants will render as
an expression against 1 or 0:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; print(select(t.c.x).where(false()))
    {printsql}SELECT x FROM t WHERE 0 = 1

The :func:`.true` and :func:`.false` constants also feature
"short circuit" operation within an :func:`.and_` or :func:`.or_`
conjunction:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; print(select(t.c.x).where(or_(t.c.x &gt; 5, true())))
    {printsql}SELECT x FROM t WHERE true{stop}

    &gt;&gt;&gt; print(select(t.c.x).where(and_(t.c.x &gt; 5, false())))
    {printsql}SELECT x FROM t WHERE false{stop}

.. seealso::

    :func:`.true`</pre> 
</div>
</div>
<a id="ac0adc175859ec766093cc93b89ff23c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0adc175859ec766093cc93b89ff23c9">&#9670;&nbsp;</a></span>funcfilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1FunctionFilter.html">FunctionFilter</a>[_T] sqlalchemy.sql._elements_constructors.funcfilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1functions_1_1FunctionElement.html">FunctionElement</a>[_T]&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_ColumnExpressionArgument[bool]
&#160;</td>
          <td class="paramname"><em>criterion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a :class:`.FunctionFilter` object against a function.

Used against aggregate and window functions,
for database backends that support the "FILTER" clause.

E.g.::

    from sqlalchemy import funcfilter

    funcfilter(func.count(1), MyClass.name == "some name")

Would produce "COUNT(1) FILTER (WHERE myclass.name = 'some name')".

This function is also available from the :data:`~.expression.func`
construct itself via the :meth:`.FunctionElement.filter` method.

.. seealso::

    :ref:`tutorial_functions_within_group` - in the
    :ref:`unified_tutorial`

    :meth:`.FunctionElement.filter`</pre> 
</div>
</div>
<a id="a517af110eca3e1f74dda782754f8b787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517af110eca3e1f74dda782754f8b787">&#9670;&nbsp;</a></span>label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Label.html">Label</a>[_T] sqlalchemy.sql._elements_constructors.label </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ColumnExpressionArgument[_T]&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_TypeEngineArgument[_T]] &#160;</td>
          <td class="paramname"><em>type_</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`Label` object for the
given :class:`_expression.ColumnElement`.

A label changes the name of an element in the columns clause of a
``SELECT`` statement, typically via the ``AS`` SQL keyword.

This functionality is more conveniently available via the
:meth:`_expression.ColumnElement.label` method on
:class:`_expression.ColumnElement`.

:param name: label name

:param obj: a :class:`_expression.ColumnElement`.</pre> 
</div>
</div>
<a id="af12c501eb335f217057b608e5a10c767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12c501eb335f217057b608e5a10c767">&#9670;&nbsp;</a></span>not_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnElement.html">ColumnElement</a>[_T] sqlalchemy.sql._elements_constructors.not_ </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionArgument&#160;</td>
          <td class="paramname"><em>clause</em>[_T]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a negation of the given clause, i.e. ``NOT(clause)``.

The ``~`` operator is also overloaded on all
:class:`_expression.ColumnElement` subclasses to produce the
same result.</pre> 
</div>
</div>
<a id="a310c79c224de678ef4a7a77818c14c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310c79c224de678ef4a7a77818c14c0c">&#9670;&nbsp;</a></span>not_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BinaryExpression.html">BinaryExpression</a>[_T] sqlalchemy.sql._elements_constructors.not_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BinaryExpression.html">BinaryExpression</a>[_T]&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46be6ef0863028bc999503b5e1bc7d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46be6ef0863028bc999503b5e1bc7d57">&#9670;&nbsp;</a></span>null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Null.html">Null</a> sqlalchemy.sql._elements_constructors.null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a constant :class:`.Null` construct.</pre> 
</div>
</div>
<a id="a4927e66923176c22478540f14ea46f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4927e66923176c22478540f14ea46f93">&#9670;&nbsp;</a></span>nulls_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T] sqlalchemy.sql._elements_constructors.nulls_first </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionArgument[_T]&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce the ``NULLS FIRST`` modifier for an ``ORDER BY`` expression.

:func:`.nulls_first` is intended to modify the expression produced
by :func:`.asc` or :func:`.desc`, and indicates how NULL values
should be handled when they are encountered during ordering::


    from sqlalchemy import desc, nulls_first

    stmt = select(users_table).order_by(nulls_first(desc(users_table.c.name)))

The SQL expression from the above would resemble:

.. sourcecode:: sql

    SELECT id, name FROM user ORDER BY name DESC NULLS FIRST

Like :func:`.asc` and :func:`.desc`, :func:`.nulls_first` is typically
invoked from the column expression itself using
:meth:`_expression.ColumnElement.nulls_first`,
rather than as its standalone
function version, as in::

    stmt = select(users_table).order_by(
        users_table.c.name.desc().nulls_first()
    )

.. versionchanged:: 1.4 :func:`.nulls_first` is renamed from
    :func:`.nullsfirst` in previous releases.
    The previous name remains available for backwards compatibility.

.. seealso::

    :func:`.asc`

    :func:`.desc`

    :func:`.nulls_last`

    :meth:`_expression.Select.order_by`</pre> 
</div>
</div>
<a id="a11bc92bbba4109c8978710fe7c07a280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bc92bbba4109c8978710fe7c07a280">&#9670;&nbsp;</a></span>nulls_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1UnaryExpression.html">UnaryExpression</a>[_T] sqlalchemy.sql._elements_constructors.nulls_last </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionArgument[_T]&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce the ``NULLS LAST`` modifier for an ``ORDER BY`` expression.

:func:`.nulls_last` is intended to modify the expression produced
by :func:`.asc` or :func:`.desc`, and indicates how NULL values
should be handled when they are encountered during ordering::


    from sqlalchemy import desc, nulls_last

    stmt = select(users_table).order_by(nulls_last(desc(users_table.c.name)))

The SQL expression from the above would resemble:

.. sourcecode:: sql

    SELECT id, name FROM user ORDER BY name DESC NULLS LAST

Like :func:`.asc` and :func:`.desc`, :func:`.nulls_last` is typically
invoked from the column expression itself using
:meth:`_expression.ColumnElement.nulls_last`,
rather than as its standalone
function version, as in::

    stmt = select(users_table).order_by(users_table.c.name.desc().nulls_last())

.. versionchanged:: 1.4 :func:`.nulls_last` is renamed from
    :func:`.nullslast` in previous releases.
    The previous name remains available for backwards compatibility.

.. seealso::

    :func:`.asc`

    :func:`.desc`

    :func:`.nulls_first`

    :meth:`_expression.Select.order_by`</pre> 
</div>
</div>
<a id="a878e87a4dfd44e1b27111016ede7ab3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878e87a4dfd44e1b27111016ede7ab3f">&#9670;&nbsp;</a></span>or_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sqlalchemy.sql._elements_constructors.or_ </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>clauses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a conjunction of expressions joined by ``OR``.

E.g.::

    from sqlalchemy import or_

    stmt = select(users_table).where(
        or_(users_table.c.name == "wendy", users_table.c.name == "jack")
    )

The :func:`.or_` conjunction is also available using the
Python ``|`` operator (though note that compound expressions
need to be parenthesized in order to function with Python
operator precedence behavior)::

    stmt = select(users_table).where(
        (users_table.c.name == "wendy") | (users_table.c.name == "jack")
    )

The :func:`.or_` construct must be given at least one positional
argument in order to be valid; a :func:`.or_` construct with no
arguments is ambiguous.   To produce an "empty" or dynamically
generated :func:`.or_`  expression, from a given list of expressions,
a "default" element of :func:`_sql.false` (or just ``False``) should be
specified::

    from sqlalchemy import false

    or_criteria = or_(false(), *expressions)

The above expression will compile to SQL as the expression ``false``
or ``0 = 1``, depending on backend, if no other expressions are
present.  If expressions are present, then the :func:`_sql.false` value
is ignored as it does not affect the outcome of an OR expression which
has other elements.

.. deprecated:: 1.4  The :func:`.or_` element now requires that at
   least one argument is passed; creating the :func:`.or_` construct
   with no arguments is deprecated, and will emit a deprecation warning
   while continuing to produce a blank SQL string.

.. seealso::

    :func:`.and_`</pre> 
</div>
</div>
<a id="acf755692bbb06712f49067b68589f75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf755692bbb06712f49067b68589f75c">&#9670;&nbsp;</a></span>or_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ColumnElement.html">ColumnElement</a>[bool] sqlalchemy.sql._elements_constructors.or_ </td>
          <td>(</td>
          <td class="paramtype">Union[Literal[False], _ColumnExpressionArgument[bool]]&#160;</td>
          <td class="paramname"><em>initial_clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_ColumnExpressionArgument[bool]&#160;</td>
          <td class="paramname"><em>clauses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a conjunction of expressions joined by ``OR``.

E.g.::

    from sqlalchemy import or_

    stmt = select(users_table).where(
        or_(users_table.c.name == "wendy", users_table.c.name == "jack")
    )

The :func:`.or_` conjunction is also available using the
Python ``|`` operator (though note that compound expressions
need to be parenthesized in order to function with Python
operator precedence behavior)::

    stmt = select(users_table).where(
        (users_table.c.name == "wendy") | (users_table.c.name == "jack")
    )

The :func:`.or_` construct must be given at least one positional
argument in order to be valid; a :func:`.or_` construct with no
arguments is ambiguous.   To produce an "empty" or dynamically
generated :func:`.or_`  expression, from a given list of expressions,
a "default" element of :func:`_sql.false` (or just ``False``) should be
specified::

    from sqlalchemy import false

    or_criteria = or_(false(), *expressions)

The above expression will compile to SQL as the expression ``false``
or ``0 = 1``, depending on backend, if no other expressions are
present.  If expressions are present, then the :func:`_sql.false` value is
ignored as it does not affect the outcome of an OR expression which
has other elements.

.. deprecated:: 1.4  The :func:`.or_` element now requires that at
   least one argument is passed; creating the :func:`.or_` construct
   with no arguments is deprecated, and will emit a deprecation warning
   while continuing to produce a blank SQL string.

.. seealso::

    :func:`.and_`</pre> 
</div>
</div>
<a id="afc91cf2b5548fc2e2affe93ba44c103b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc91cf2b5548fc2e2affe93ba44c103b">&#9670;&nbsp;</a></span>outparam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1BindParameter.html">BindParameter</a>[_T] sqlalchemy.sql._elements_constructors.outparam </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1type__api_1_1TypeEngine.html">TypeEngine</a>[_T]] &#160;</td>
          <td class="paramname"><em>type_</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create an 'OUT' parameter for usage in functions (stored procedures),
for databases which support them.

The ``outparam`` can be used like a regular function parameter.
The "output" value will be available from the
:class:`~sqlalchemy.engine.CursorResult` object via its ``out_parameters``
attribute, which returns a dictionary containing the values.</pre> 
</div>
</div>
<a id="a5159bebe15b5444f90d42b346e7caa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5159bebe15b5444f90d42b346e7caa65">&#9670;&nbsp;</a></span>over()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Over.html">Over</a>[_T] sqlalchemy.sql._elements_constructors.over </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1functions_1_1FunctionElement.html">FunctionElement</a>[_T]&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_ByArgument] &#160;</td>
          <td class="paramname"><em>partition_by</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_ByArgument] &#160;</td>
          <td class="paramname"><em>order_by</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[typing_Tuple[Optional[int], Optional[int]]] &#160;</td>
          <td class="paramname"><em>range_</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[typing_Tuple[Optional[int], Optional[int]]] &#160;</td>
          <td class="paramname"><em>rows</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce an :class:`.Over` object against a function.

Used against aggregate or so-called "window" functions,
for database backends that support window functions.

:func:`_expression.over` is usually called using
the :meth:`.FunctionElement.over` method, e.g.::

    func.row_number().over(order_by=mytable.c.some_column)

Would produce:

.. sourcecode:: sql

    ROW_NUMBER() OVER(ORDER BY some_column)

Ranges are also possible using the :paramref:`.expression.over.range_`
and :paramref:`.expression.over.rows` parameters.  These
mutually-exclusive parameters each accept a 2-tuple, which contains
a combination of integers and None::

    func.row_number().over(order_by=my_table.c.some_column, range_=(None, 0))

The above would produce:

.. sourcecode:: sql

    ROW_NUMBER() OVER(ORDER BY some_column
    RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)

A value of ``None`` indicates "unbounded", a
value of zero indicates "current row", and negative / positive
integers indicate "preceding" and "following":

* RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING::

    func.row_number().over(order_by="x", range_=(-5, 10))

* ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW::

    func.row_number().over(order_by="x", rows=(None, 0))

* RANGE BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING::

    func.row_number().over(order_by="x", range_=(-2, None))

* RANGE BETWEEN 1 FOLLOWING AND 3 FOLLOWING::

    func.row_number().over(order_by="x", range_=(1, 3))

:param element: a :class:`.FunctionElement`, :class:`.WithinGroup`,
 or other compatible construct.
:param partition_by: a column element or string, or a list
 of such, that will be used as the PARTITION BY clause
 of the OVER construct.
:param order_by: a column element or string, or a list
 of such, that will be used as the ORDER BY clause
 of the OVER construct.
:param range\_: optional range clause for the window.  This is a
 tuple value which can contain integer values or ``None``,
 and will render a RANGE BETWEEN PRECEDING / FOLLOWING clause.

:param rows: optional rows clause for the window.  This is a tuple
 value which can contain integer values or None, and will render
 a ROWS BETWEEN PRECEDING / FOLLOWING clause.

This function is also available from the :data:`~.expression.func`
construct itself via the :meth:`.FunctionElement.over` method.

.. seealso::

    :ref:`tutorial_window_functions` - in the :ref:`unified_tutorial`

    :data:`.expression.func`

    :func:`_expression.within_group`</pre> 
</div>
</div>
<a id="ae65c5d912dcc878ff909c44313e75487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65c5d912dcc878ff909c44313e75487">&#9670;&nbsp;</a></span>text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1TextClause.html">TextClause</a> sqlalchemy.sql._elements_constructors.text </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a new :class:`_expression.TextClause` clause,
representing
a textual SQL string directly.

E.g.::

    from sqlalchemy import text

    t = text("SELECT * FROM users")
    result = connection.execute(t)

The advantages :func:`_expression.text`
provides over a plain string are
backend-neutral support for bind parameters, per-statement
execution options, as well as
bind parameter and result-column typing behavior, allowing
SQLAlchemy type constructs to play a role when executing
a statement that is specified literally.  The construct can also
be provided with a ``.c`` collection of column elements, allowing
it to be embedded in other SQL expression constructs as a subquery.

Bind parameters are specified by name, using the format ``:name``.
E.g.::

    t = text("SELECT * FROM users WHERE id=:user_id")
    result = connection.execute(t, {"user_id": 12})

For SQL statements where a colon is required verbatim, as within
an inline string, use a backslash to escape::

    t = text(r"SELECT * FROM users WHERE name='\:username'")

The :class:`_expression.TextClause`
construct includes methods which can
provide information about the bound parameters as well as the column
values which would be returned from the textual statement, assuming
it's an executable SELECT type of statement.  The
:meth:`_expression.TextClause.bindparams`
method is used to provide bound
parameter detail, and :meth:`_expression.TextClause.columns`
method allows
specification of return columns including names and types::

    t = (
        text("SELECT * FROM users WHERE id=:user_id")
        .bindparams(user_id=7)
        .columns(id=Integer, name=String)
    )

    for id, name in connection.execute(t):
        print(id, name)

The :func:`_expression.text` construct is used in cases when
a literal string SQL fragment is specified as part of a larger query,
such as for the WHERE clause of a SELECT statement::

    s = select(users.c.id, users.c.name).where(text("id=:user_id"))
    result = connection.execute(s, {"user_id": 12})

:func:`_expression.text` is also used for the construction
of a full, standalone statement using plain text.
As such, SQLAlchemy refers
to it as an :class:`.Executable` object and may be used
like any other statement passed to an ``.execute()`` method.

:param text:
  the text of the SQL statement to be created.  Use ``:&lt;param&gt;``
  to specify bind parameters; they will be compiled to their
  engine-specific format.

.. seealso::

    :ref:`tutorial_select_arbitrary_text`</pre> 
</div>
</div>
<a id="a909160b7374ca75cbc430b9c1cd5142e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909160b7374ca75cbc430b9c1cd5142e">&#9670;&nbsp;</a></span>true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1True__.html">True_</a> sqlalchemy.sql._elements_constructors.true </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a constant :class:`.True_` construct.

E.g.:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy import true
    &gt;&gt;&gt; print(select(t.c.x).where(true()))
    {printsql}SELECT x FROM t WHERE true

A backend which does not support true/false constants will render as
an expression against 1 or 0:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; print(select(t.c.x).where(true()))
    {printsql}SELECT x FROM t WHERE 1 = 1

The :func:`.true` and :func:`.false` constants also feature
"short circuit" operation within an :func:`.and_` or :func:`.or_`
conjunction:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; print(select(t.c.x).where(or_(t.c.x &gt; 5, true())))
    {printsql}SELECT x FROM t WHERE true{stop}

    &gt;&gt;&gt; print(select(t.c.x).where(and_(t.c.x &gt; 5, false())))
    {printsql}SELECT x FROM t WHERE false{stop}

.. seealso::

    :func:`.false`</pre> 
</div>
</div>
<a id="a9ee7f3597cd154cc74f5235e5072a45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee7f3597cd154cc74f5235e5072a45c">&#9670;&nbsp;</a></span>try_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1TryCast.html">TryCast</a>[_T] sqlalchemy.sql._elements_constructors.try_cast </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionOrLiteralArgument[Any]&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TypeEngineArgument[_T]&#160;</td>
          <td class="paramname"><em>type_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a ``TRY_CAST`` expression for backends which support it;
this is a ``CAST`` which returns NULL for un-castable conversions.

In SQLAlchemy, this construct is supported **only** by the SQL Server
dialect, and will raise a :class:`.CompileError` if used on other
included backends.  However, third party backends may also support
this construct.

.. tip:: As :func:`_sql.try_cast` originates from the SQL Server dialect,
   it's importable both from ``sqlalchemy.`` as well as from
   ``sqlalchemy.dialects.mssql``.

:func:`_sql.try_cast` returns an instance of :class:`.TryCast` and
generally behaves similarly to the :class:`.Cast` construct;
at the SQL level, the difference between ``CAST`` and ``TRY_CAST``
is that ``TRY_CAST`` returns NULL for an un-castable expression,
such as attempting to cast a string ``"hi"`` to an integer value.

E.g.::

    from sqlalchemy import select, try_cast, Numeric

    stmt = select(try_cast(product_table.c.unit_price, Numeric(10, 4)))

The above would render on Microsoft SQL Server as:

.. sourcecode:: sql

    SELECT TRY_CAST (product_table.unit_price AS NUMERIC(10, 4))
    FROM product_table

.. versionadded:: 2.0.14  :func:`.try_cast` has been
   generalized from the SQL Server dialect into a general use
   construct that may be supported by additional dialects.</pre> 
</div>
</div>
<a id="ab5bd982e8a54729096f132facda96dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bd982e8a54729096f132facda96dde">&#9670;&nbsp;</a></span>tuple_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1Tuple.html">Tuple</a> sqlalchemy.sql._elements_constructors.tuple_ </td>
          <td>(</td>
          <td class="paramtype">*_ColumnExpressionArgument[Any]&#160;</td>
          <td class="paramname"><em>clauses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Sequence[_TypeEngineArgument[Any]]] &#160;</td>
          <td class="paramname"><em>types</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`.Tuple`.

Main usage is to produce a composite IN construct using
:meth:`.ColumnOperators.in_` ::

    from sqlalchemy import tuple_

    tuple_(table.c.col1, table.c.col2).in_([(1, 2), (5, 12), (10, 19)])

.. versionchanged:: 1.3.6 Added support for SQLite IN tuples.

.. warning::

    The composite IN construct is not supported by all backends, and is
    currently known to work on PostgreSQL, MySQL, and SQLite.
    Unsupported backends will raise a subclass of
    :class:`~sqlalchemy.exc.DBAPIError` when such an expression is
    invoked.</pre> 
</div>
</div>
<a id="a71aa77fc566b5c1ffb074c95e2c6e6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71aa77fc566b5c1ffb074c95e2c6e6c1">&#9670;&nbsp;</a></span>type_coerce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1TypeCoerce.html">TypeCoerce</a>[_T] sqlalchemy.sql._elements_constructors.type_coerce </td>
          <td>(</td>
          <td class="paramtype">_ColumnExpressionOrLiteralArgument[Any]&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TypeEngineArgument[_T]&#160;</td>
          <td class="paramname"><em>type_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Associate a SQL expression with a particular type, without rendering
``CAST``.

E.g.::

    from sqlalchemy import type_coerce

    stmt = select(type_coerce(log_table.date_string, StringDateTime()))

The above construct will produce a :class:`.TypeCoerce` object, which
does not modify the rendering in any way on the SQL side, with the
possible exception of a generated label if used in a columns clause
context:

.. sourcecode:: sql

    SELECT date_string AS date_string FROM log

When result rows are fetched, the ``StringDateTime`` type processor
will be applied to result rows on behalf of the ``date_string`` column.

.. note:: the :func:`.type_coerce` construct does not render any
   SQL syntax of its own, including that it does not imply
   parenthesization.   Please use :meth:`.TypeCoerce.self_group`
   if explicit parenthesization is required.

In order to provide a named label for the expression, use
:meth:`_expression.ColumnElement.label`::

    stmt = select(
        type_coerce(log_table.date_string, StringDateTime()).label("date")
    )

A type that features bound-value handling will also have that behavior
take effect when literal values or :func:`.bindparam` constructs are
passed to :func:`.type_coerce` as targets.
For example, if a type implements the
:meth:`.TypeEngine.bind_expression`
method or :meth:`.TypeEngine.bind_processor` method or equivalent,
these functions will take effect at statement compilation/execution
time when a literal value is passed, as in::

    # bound-value handling of MyStringType will be applied to the
    # literal value "some string"
    stmt = select(type_coerce("some string", MyStringType))

When using :func:`.type_coerce` with composed expressions, note that
**parenthesis are not applied**.   If :func:`.type_coerce` is being
used in an operator context where the parenthesis normally present from
CAST are necessary, use the :meth:`.TypeCoerce.self_group` method:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; some_integer = column("someint", Integer)
    &gt;&gt;&gt; some_string = column("somestr", String)
    &gt;&gt;&gt; expr = type_coerce(some_integer + 5, String) + some_string
    &gt;&gt;&gt; print(expr)
    {printsql}someint + :someint_1 || somestr{stop}
    &gt;&gt;&gt; expr = type_coerce(some_integer + 5, String).self_group() + some_string
    &gt;&gt;&gt; print(expr)
    {printsql}(someint + :someint_1) || somestr{stop}

:param expression: A SQL expression, such as a
 :class:`_expression.ColumnElement`
 expression or a Python string which will be coerced into a bound
 literal value.

:param type\_: A :class:`.TypeEngine` class or instance indicating
 the type to which the expression is coerced.

.. seealso::

    :ref:`tutorial_casts`

    :func:`.cast`</pre> 
</div>
</div>
<a id="a8472d8714b43ca3823eed738c4584782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8472d8714b43ca3823eed738c4584782">&#9670;&nbsp;</a></span>within_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1WithinGroup.html">WithinGroup</a>[_T] sqlalchemy.sql._elements_constructors.within_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1functions_1_1FunctionElement.html">FunctionElement</a>[_T]&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_ColumnExpressionArgument[Any]
&#160;</td>
          <td class="paramname"><em>order_by</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a :class:`.WithinGroup` object against a function.

Used against so-called "ordered set aggregate" and "hypothetical
set aggregate" functions, including :class:`.percentile_cont`,
:class:`.rank`, :class:`.dense_rank`, etc.

:func:`_expression.within_group` is usually called using
the :meth:`.FunctionElement.within_group` method, e.g.::

    from sqlalchemy import within_group

    stmt = select(
        department.c.id,
        func.percentile_cont(0.5).within_group(department.c.salary.desc()),
    )

The above statement would produce SQL similar to
``SELECT department.id, percentile_cont(0.5)
WITHIN GROUP (ORDER BY department.salary DESC)``.

:param element: a :class:`.FunctionElement` construct, typically
 generated by :data:`~.expression.func`.
:param \*order_by: one or more column elements that will be used
 as the ORDER BY clause of the WITHIN GROUP construct.

.. seealso::

    :ref:`tutorial_functions_within_group` - in the
    :ref:`unified_tutorial`

    :data:`.expression.func`

    :func:`_expression.over`</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
