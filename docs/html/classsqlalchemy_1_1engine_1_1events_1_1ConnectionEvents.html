<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sqlalchemy.engine.events.ConnectionEvents Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesqlalchemy.html">sqlalchemy</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1engine.html">engine</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1engine_1_1events.html">events</a></li><li class="navelem"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html">ConnectionEvents</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sqlalchemy.engine.events.ConnectionEvents Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for sqlalchemy.engine.events.ConnectionEvents:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents__inherit__graph.png" border="0" usemap="#asqlalchemy_8engine_8events_8ConnectionEvents_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sqlalchemy.engine.events.ConnectionEvents:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents__coll__graph.png" border="0" usemap="#asqlalchemy_8engine_8events_8ConnectionEvents_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a10017b6573f3476a10359368184ecf"><td class="memItemLeft" align="right" valign="top">Optional[ Tuple[Executable, _CoreMultiExecuteParams, _CoreSingleExecuteParams]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a4a10017b6573f3476a10359368184ecf">before_execute</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, Executable clauseelement, _CoreMultiExecuteParams multiparams, _CoreSingleExecuteParams params, _ExecuteOptions execution_options)</td></tr>
<tr class="separator:a4a10017b6573f3476a10359368184ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc64ba5a78fea021b664c3e87c83843b"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#afc64ba5a78fea021b664c3e87c83843b">after_execute</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, Executable clauseelement, _CoreMultiExecuteParams multiparams, _CoreSingleExecuteParams params, _ExecuteOptions execution_options, <a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1Result.html">Result</a>[Any] result)</td></tr>
<tr class="separator:afc64ba5a78fea021b664c3e87c83843b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab438ccd54ae7c493694d01048d332abd"><td class="memItemLeft" align="right" valign="top">Optional[Tuple[str, _DBAPIAnyExecuteParams]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#ab438ccd54ae7c493694d01048d332abd">before_cursor_execute</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a> cursor, str statement, _DBAPIAnyExecuteParams parameters, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>] context, bool executemany)</td></tr>
<tr class="separator:ab438ccd54ae7c493694d01048d332abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2bbfeb9046be229880be8cdd5d3c15"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a9e2bbfeb9046be229880be8cdd5d3c15">after_cursor_execute</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, <a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a> cursor, str statement, _DBAPIAnyExecuteParams parameters, Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>] context, bool executemany)</td></tr>
<tr class="separator:a9e2bbfeb9046be229880be8cdd5d3c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f2ac194f490235fb8216ebd4d03e71"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#ad1f2ac194f490235fb8216ebd4d03e71">engine_connect</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn)</td></tr>
<tr class="separator:ad1f2ac194f490235fb8216ebd4d03e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9a385a91185bb466ba252fb6310f98"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a0e9a385a91185bb466ba252fb6310f98">set_connection_execution_options</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, Dict[str, Any] opts)</td></tr>
<tr class="separator:a0e9a385a91185bb466ba252fb6310f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3b044d7e54b63323d094947b0d8a79"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#aae3b044d7e54b63323d094947b0d8a79">set_engine_execution_options</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a> engine, Dict[str, Any] opts)</td></tr>
<tr class="separator:aae3b044d7e54b63323d094947b0d8a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ea1882065769381bbe20e351f640ff"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a83ea1882065769381bbe20e351f640ff">engine_disposed</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a> engine)</td></tr>
<tr class="separator:a83ea1882065769381bbe20e351f640ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960f61721721857198873598900b55a7"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a960f61721721857198873598900b55a7">begin</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn)</td></tr>
<tr class="separator:a960f61721721857198873598900b55a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298a7e3c63ab9a4754be793e0e2fb157"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a298a7e3c63ab9a4754be793e0e2fb157">rollback</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn)</td></tr>
<tr class="separator:a298a7e3c63ab9a4754be793e0e2fb157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca212083b6c96a89b322344b8c43cc19"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#aca212083b6c96a89b322344b8c43cc19">commit</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn)</td></tr>
<tr class="separator:aca212083b6c96a89b322344b8c43cc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcb9d3d6f7820ebe5a74c0ab8d8b0b3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#adbcb9d3d6f7820ebe5a74c0ab8d8b0b3">savepoint</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, str name)</td></tr>
<tr class="separator:adbcb9d3d6f7820ebe5a74c0ab8d8b0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7758b975436959c85bc931c6365443d7"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a7758b975436959c85bc931c6365443d7">rollback_savepoint</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, str name, None context)</td></tr>
<tr class="separator:a7758b975436959c85bc931c6365443d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57cfb3af9296075fa4535e54f8a8d46"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#aa57cfb3af9296075fa4535e54f8a8d46">release_savepoint</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, str name, None context)</td></tr>
<tr class="separator:aa57cfb3af9296075fa4535e54f8a8d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24b84cccc4e328dd5024d60a147240b"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#ae24b84cccc4e328dd5024d60a147240b">begin_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, Any xid)</td></tr>
<tr class="separator:ae24b84cccc4e328dd5024d60a147240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234a30e9f312bb9bd1d105df49cf7ab9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a234a30e9f312bb9bd1d105df49cf7ab9">prepare_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, Any xid)</td></tr>
<tr class="separator:a234a30e9f312bb9bd1d105df49cf7ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac960775a613b565926a3848112d7f2a0"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#ac960775a613b565926a3848112d7f2a0">rollback_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, Any xid, bool is_prepared)</td></tr>
<tr class="separator:ac960775a613b565926a3848112d7f2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cba4a7e974a0d041deee902090094eb"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1engine_1_1events_1_1ConnectionEvents.html#a0cba4a7e974a0d041deee902090094eb">commit_twophase</a> (self, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> conn, Any xid, bool is_prepared)</td></tr>
<tr class="separator:a0cba4a7e974a0d041deee902090094eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch.html">sqlalchemy.event.base._HasEventsDispatch</a></td></tr>
<tr class="memitem:a65b8d4888511c0d8993ee246df525f0d inherit pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1event_1_1attr_1_1__InstanceLevelDispatch.html">_InstanceLevelDispatch</a>[_ET]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch.html#a65b8d4888511c0d8993ee246df525f0d">__getattr__</a> (self, str name)</td></tr>
<tr class="separator:a65b8d4888511c0d8993ee246df525f0d inherit pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9026fd04cd9a1b42239d35300c03e03b inherit pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch.html#a9026fd04cd9a1b42239d35300c03e03b">__init_subclass__</a> (cls)</td></tr>
<tr class="separator:a9026fd04cd9a1b42239d35300c03e03b inherit pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Available events for
:class:`_engine.Connection` and :class:`_engine.Engine`.

The methods here define the name of an event as well as the names of
members that are passed to listener functions.

An event listener can be associated with any
:class:`_engine.Connection` or :class:`_engine.Engine`
class or instance, such as an :class:`_engine.Engine`, e.g.::

    from sqlalchemy import event, create_engine


    def before_cursor_execute(
        conn, cursor, statement, parameters, context, executemany
    ):
        log.info("Received statement: %s", statement)


    engine = create_engine("postgresql+psycopg2://scott:tiger@localhost/test")
    event.listen(engine, "before_cursor_execute", before_cursor_execute)

or with a specific :class:`_engine.Connection`::

    with engine.begin() as conn:

        @event.listens_for(conn, "before_cursor_execute")
        def before_cursor_execute(
            conn, cursor, statement, parameters, context, executemany
        ):
            log.info("Received statement: %s", statement)

When the methods are called with a `statement` parameter, such as in
:meth:`.after_cursor_execute` or :meth:`.before_cursor_execute`,
the statement is the exact SQL string that was prepared for transmission
to the DBAPI ``cursor`` in the connection's :class:`.Dialect`.

The :meth:`.before_execute` and :meth:`.before_cursor_execute`
events can also be established with the ``retval=True`` flag, which
allows modification of the statement and parameters to be sent
to the database.  The :meth:`.before_cursor_execute` event is
particularly useful here to add ad-hoc string transformations, such
as comments, to all executions::

    from sqlalchemy.engine import Engine
    from sqlalchemy import event


    @event.listens_for(Engine, "before_cursor_execute", retval=True)
    def comment_sql_calls(
        conn, cursor, statement, parameters, context, executemany
    ):
        statement = statement + " -- some comment"
        return statement, parameters

.. note:: :class:`_events.ConnectionEvents` can be established on any
   combination of :class:`_engine.Engine`, :class:`_engine.Connection`,
   as well
   as instances of each of those classes.  Events across all
   four scopes will fire off for a given instance of
   :class:`_engine.Connection`.  However, for performance reasons, the
   :class:`_engine.Connection` object determines at instantiation time
   whether or not its parent :class:`_engine.Engine` has event listeners
   established.   Event listeners added to the :class:`_engine.Engine`
   class or to an instance of :class:`_engine.Engine`
   *after* the instantiation
   of a dependent :class:`_engine.Connection` instance will usually
   *not* be available on that :class:`_engine.Connection` instance.
   The newly
   added listeners will instead take effect for
   :class:`_engine.Connection`
   instances created subsequent to those event listeners being
   established on the parent :class:`_engine.Engine` class or instance.

:param retval=False: Applies to the :meth:`.before_execute` and
  :meth:`.before_cursor_execute` events only.  When True, the
  user-defined event function must have a return value, which
  is a tuple of parameters that replace the given statement
  and parameters.  See those methods for a description of
  specific return arguments.</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9e2bbfeb9046be229880be8cdd5d3c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2bbfeb9046be229880be8cdd5d3c15">&#9670;&nbsp;</a></span>after_cursor_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.after_cursor_execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a>&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_DBAPIAnyExecuteParams&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>]&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>executemany</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept low-level cursor execute() events after execution.

:param conn: :class:`_engine.Connection` object
:param cursor: DBAPI cursor object.  Will have results pending
 if the statement was a SELECT, but these should not be consumed
 as they will be needed by the :class:`_engine.CursorResult`.
:param statement: string SQL statement, as passed to the DBAPI
:param parameters: Dictionary, tuple, or list of parameters being
 passed to the ``execute()`` or ``executemany()`` method of the
 DBAPI ``cursor``.  In some cases may be ``None``.
:param context: :class:`.ExecutionContext` object in use.  May
 be ``None``.
:param executemany: boolean, if ``True``, this is an ``executemany()``
 call, if ``False``, this is an ``execute()`` call.</pre> 
</div>
</div>
<a id="afc64ba5a78fea021b664c3e87c83843b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc64ba5a78fea021b664c3e87c83843b">&#9670;&nbsp;</a></span>after_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.after_execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Executable&#160;</td>
          <td class="paramname"><em>clauseelement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_CoreMultiExecuteParams&#160;</td>
          <td class="paramname"><em>multiparams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_CoreSingleExecuteParams&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ExecuteOptions&#160;</td>
          <td class="paramname"><em>execution_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1Result.html">Result</a>[Any]&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept high level execute() events after execute.


:param conn: :class:`_engine.Connection` object
:param clauseelement: SQL expression construct, :class:`.Compiled`
 instance, or string statement passed to
 :meth:`_engine.Connection.execute`.
:param multiparams: Multiple parameter sets, a list of dictionaries.
:param params: Single parameter set, a single dictionary.
:param execution_options: dictionary of execution
 options passed along with the statement, if any.  This is a merge
 of all options that will be used, including those of the statement,
 the connection, and those passed in to the method itself for
 the 2.0 style of execution.

 .. versionadded: 1.4

:param result: :class:`_engine.CursorResult` generated by the
 execution.</pre> 
</div>
</div>
<a id="ab438ccd54ae7c493694d01048d332abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab438ccd54ae7c493694d01048d332abd">&#9670;&nbsp;</a></span>before_cursor_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[Tuple[str, _DBAPIAnyExecuteParams]] sqlalchemy.engine.events.ConnectionEvents.before_cursor_execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1DBAPICursor.html">DBAPICursor</a>&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_DBAPIAnyExecuteParams&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1engine_1_1interfaces_1_1ExecutionContext.html">ExecutionContext</a>]&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>executemany</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept low-level cursor execute() events before execution,
receiving the string SQL statement and DBAPI-specific parameter list to
be invoked against a cursor.

This event is a good choice for logging as well as late modifications
to the SQL string.  It's less ideal for parameter modifications except
for those which are specific to a target backend.

This event can be optionally established with the ``retval=True``
flag.  The ``statement`` and ``parameters`` arguments should be
returned as a two-tuple in this case::

    @event.listens_for(Engine, "before_cursor_execute", retval=True)
    def before_cursor_execute(
        conn, cursor, statement, parameters, context, executemany
    ):
        # do something with statement, parameters
        return statement, parameters

See the example at :class:`_events.ConnectionEvents`.

:param conn: :class:`_engine.Connection` object
:param cursor: DBAPI cursor object
:param statement: string SQL statement, as to be passed to the DBAPI
:param parameters: Dictionary, tuple, or list of parameters being
 passed to the ``execute()`` or ``executemany()`` method of the
 DBAPI ``cursor``.  In some cases may be ``None``.
:param context: :class:`.ExecutionContext` object in use.  May
 be ``None``.
:param executemany: boolean, if ``True``, this is an ``executemany()``
 call, if ``False``, this is an ``execute()`` call.

.. seealso::

    :meth:`.before_execute`

    :meth:`.after_cursor_execute`</pre> 
</div>
</div>
<a id="a4a10017b6573f3476a10359368184ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a10017b6573f3476a10359368184ecf">&#9670;&nbsp;</a></span>before_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[
        Tuple[Executable, _CoreMultiExecuteParams, _CoreSingleExecuteParams]
    ] sqlalchemy.engine.events.ConnectionEvents.before_execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Executable&#160;</td>
          <td class="paramname"><em>clauseelement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_CoreMultiExecuteParams&#160;</td>
          <td class="paramname"><em>multiparams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_CoreSingleExecuteParams&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ExecuteOptions&#160;</td>
          <td class="paramname"><em>execution_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept high level execute() events, receiving uncompiled
SQL constructs and other objects prior to rendering into SQL.

This event is good for debugging SQL compilation issues as well
as early manipulation of the parameters being sent to the database,
as the parameter lists will be in a consistent format here.

This event can be optionally established with the ``retval=True``
flag.  The ``clauseelement``, ``multiparams``, and ``params``
arguments should be returned as a three-tuple in this case::

    @event.listens_for(Engine, "before_execute", retval=True)
    def before_execute(conn, clauseelement, multiparams, params):
        # do something with clauseelement, multiparams, params
        return clauseelement, multiparams, params

:param conn: :class:`_engine.Connection` object
:param clauseelement: SQL expression construct, :class:`.Compiled`
 instance, or string statement passed to
 :meth:`_engine.Connection.execute`.
:param multiparams: Multiple parameter sets, a list of dictionaries.
:param params: Single parameter set, a single dictionary.
:param execution_options: dictionary of execution
 options passed along with the statement, if any.  This is a merge
 of all options that will be used, including those of the statement,
 the connection, and those passed in to the method itself for
 the 2.0 style of execution.

 .. versionadded: 1.4

.. seealso::

    :meth:`.before_cursor_execute`</pre> 
</div>
</div>
<a id="a960f61721721857198873598900b55a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960f61721721857198873598900b55a7">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.begin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept begin() events.

:param conn: :class:`_engine.Connection` object</pre> 
</div>
</div>
<a id="ae24b84cccc4e328dd5024d60a147240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24b84cccc4e328dd5024d60a147240b">&#9670;&nbsp;</a></span>begin_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.begin_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>xid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept begin_twophase() events.

:param conn: :class:`_engine.Connection` object
:param xid: two-phase XID identifier</pre> 
</div>
</div>
<a id="aca212083b6c96a89b322344b8c43cc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca212083b6c96a89b322344b8c43cc19">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.commit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept commit() events, as initiated by a
:class:`.Transaction`.

Note that the :class:`_pool.Pool` may also "auto-commit"
a DBAPI connection upon checkin, if the ``reset_on_return``
flag is set to the value ``'commit'``.  To intercept this
commit, use the :meth:`_events.PoolEvents.reset` hook.

:param conn: :class:`_engine.Connection` object
</pre> 
</div>
</div>
<a id="a0cba4a7e974a0d041deee902090094eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cba4a7e974a0d041deee902090094eb">&#9670;&nbsp;</a></span>commit_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.commit_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
    &#160;</td>
          <td class="paramname"><em>is_prepared</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept commit_twophase() events.

:param conn: :class:`_engine.Connection` object
:param xid: two-phase XID identifier
:param is_prepared: boolean, indicates if
 :meth:`.TwoPhaseTransaction.prepare` was called.</pre> 
</div>
</div>
<a id="ad1f2ac194f490235fb8216ebd4d03e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f2ac194f490235fb8216ebd4d03e71">&#9670;&nbsp;</a></span>engine_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.engine_connect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept the creation of a new :class:`_engine.Connection`.

This event is called typically as the direct result of calling
the :meth:`_engine.Engine.connect` method.

It differs from the :meth:`_events.PoolEvents.connect` method, which
refers to the actual connection to a database at the DBAPI level;
a DBAPI connection may be pooled and reused for many operations.
In contrast, this event refers only to the production of a higher level
:class:`_engine.Connection` wrapper around such a DBAPI connection.

It also differs from the :meth:`_events.PoolEvents.checkout` event
in that it is specific to the :class:`_engine.Connection` object,
not the
DBAPI connection that :meth:`_events.PoolEvents.checkout` deals with,
although
this DBAPI connection is available here via the
:attr:`_engine.Connection.connection` attribute.
But note there can in fact
be multiple :meth:`_events.PoolEvents.checkout`
events within the lifespan
of a single :class:`_engine.Connection` object, if that
:class:`_engine.Connection`
is invalidated and re-established.

:param conn: :class:`_engine.Connection` object.

.. seealso::

    :meth:`_events.PoolEvents.checkout`
    the lower-level pool checkout event
    for an individual DBAPI connection</pre> 
</div>
</div>
<a id="a83ea1882065769381bbe20e351f640ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ea1882065769381bbe20e351f640ff">&#9670;&nbsp;</a></span>engine_disposed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.engine_disposed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a>&#160;</td>
          <td class="paramname"><em>engine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept when the :meth:`_engine.Engine.dispose` method is called.

The :meth:`_engine.Engine.dispose` method instructs the engine to
"dispose" of it's connection pool (e.g. :class:`_pool.Pool`), and
replaces it with a new one.  Disposing of the old pool has the
effect that existing checked-in connections are closed.  The new
pool does not establish any new connections until it is first used.

This event can be used to indicate that resources related to the
:class:`_engine.Engine` should also be cleaned up,
keeping in mind that the
:class:`_engine.Engine`
can still be used for new requests in which case
it re-acquires connection resources.</pre> 
</div>
</div>
<a id="a234a30e9f312bb9bd1d105df49cf7ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234a30e9f312bb9bd1d105df49cf7ab9">&#9670;&nbsp;</a></span>prepare_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.prepare_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>xid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept prepare_twophase() events.

:param conn: :class:`_engine.Connection` object
:param xid: two-phase XID identifier
</pre> 
</div>
</div>
<a id="aa57cfb3af9296075fa4535e54f8a8d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57cfb3af9296075fa4535e54f8a8d46">&#9670;&nbsp;</a></span>release_savepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.release_savepoint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None
    &#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept release_savepoint() events.

:param conn: :class:`_engine.Connection` object
:param name: specified name used for the savepoint.
:param context: not used</pre> 
</div>
</div>
<a id="a298a7e3c63ab9a4754be793e0e2fb157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298a7e3c63ab9a4754be793e0e2fb157">&#9670;&nbsp;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.rollback </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept rollback() events, as initiated by a
:class:`.Transaction`.

Note that the :class:`_pool.Pool` also "auto-rolls back"
a DBAPI connection upon checkin, if the ``reset_on_return``
flag is set to its default value of ``'rollback'``.
To intercept this
rollback, use the :meth:`_events.PoolEvents.reset` hook.

:param conn: :class:`_engine.Connection` object

.. seealso::

    :meth:`_events.PoolEvents.reset`</pre> 
</div>
</div>
<a id="a7758b975436959c85bc931c6365443d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7758b975436959c85bc931c6365443d7">&#9670;&nbsp;</a></span>rollback_savepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.rollback_savepoint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None
    &#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept rollback_savepoint() events.

:param conn: :class:`_engine.Connection` object
:param name: specified name used for the savepoint.
:param context: not used</pre> 
</div>
</div>
<a id="ac960775a613b565926a3848112d7f2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac960775a613b565926a3848112d7f2a0">&#9670;&nbsp;</a></span>rollback_twophase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.rollback_twophase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
    &#160;</td>
          <td class="paramname"><em>is_prepared</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept rollback_twophase() events.

:param conn: :class:`_engine.Connection` object
:param xid: two-phase XID identifier
:param is_prepared: boolean, indicates if
 :meth:`.TwoPhaseTransaction.prepare` was called.</pre> 
</div>
</div>
<a id="adbcb9d3d6f7820ebe5a74c0ab8d8b0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcb9d3d6f7820ebe5a74c0ab8d8b0b3">&#9670;&nbsp;</a></span>savepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.savepoint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept savepoint() events.

:param conn: :class:`_engine.Connection` object
:param name: specified name used for the savepoint.</pre> 
</div>
</div>
<a id="a0e9a385a91185bb466ba252fb6310f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9a385a91185bb466ba252fb6310f98">&#9670;&nbsp;</a></span>set_connection_execution_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.set_connection_execution_options </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any]
    &#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept when the :meth:`_engine.Connection.execution_options`
method is called.

This method is called after the new :class:`_engine.Connection`
has been
produced, with the newly updated execution options collection, but
before the :class:`.Dialect` has acted upon any of those new options.

Note that this method is not called when a new
:class:`_engine.Connection`
is produced which is inheriting execution options from its parent
:class:`_engine.Engine`; to intercept this condition, use the
:meth:`_events.ConnectionEvents.engine_connect` event.

:param conn: The newly copied :class:`_engine.Connection` object

:param opts: dictionary of options that were passed to the
 :meth:`_engine.Connection.execution_options` method.
 This dictionary may be modified in place to affect the ultimate
 options which take effect.

 .. versionadded:: 2.0 the ``opts`` dictionary may be modified
    in place.


.. seealso::

    :meth:`_events.ConnectionEvents.set_engine_execution_options`
    - event
    which is called when :meth:`_engine.Engine.execution_options`
    is called.</pre> 
</div>
</div>
<a id="aae3b044d7e54b63323d094947b0d8a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3b044d7e54b63323d094947b0d8a79">&#9670;&nbsp;</a></span>set_engine_execution_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.engine.events.ConnectionEvents.set_engine_execution_options </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a>&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any]
    &#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intercept when the :meth:`_engine.Engine.execution_options`
method is called.

The :meth:`_engine.Engine.execution_options` method produces a shallow
copy of the :class:`_engine.Engine` which stores the new options.
That new
:class:`_engine.Engine` is passed here.
A particular application of this
method is to add a :meth:`_events.ConnectionEvents.engine_connect`
event
handler to the given :class:`_engine.Engine`
which will perform some per-
:class:`_engine.Connection` task specific to these execution options.

:param conn: The newly copied :class:`_engine.Engine` object

:param opts: dictionary of options that were passed to the
 :meth:`_engine.Connection.execution_options` method.
 This dictionary may be modified in place to affect the ultimate
 options which take effect.

 .. versionadded:: 2.0 the ``opts`` dictionary may be modified
    in place.

.. seealso::

    :meth:`_events.ConnectionEvents.set_connection_execution_options`
    - event
    which is called when :meth:`_engine.Connection.execution_options`
    is
    called.</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>py3_env/lib/python3.10/site-packages/sqlalchemy/engine/<a class="el" href="py3__env_2lib_2python3_810_2site-packages_2sqlalchemy_2engine_2events_8py.html">events.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
