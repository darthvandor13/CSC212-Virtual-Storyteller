<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.solvers.pde Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html">pde</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.solvers.pde Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc979e84980458d380e3bcea7c2c8101"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#afc979e84980458d380e3bcea7c2c8101">pdsolve</a> (eq, func=None, hint='default', dict=False, solvefun=None, **kwargs)</td></tr>
<tr class="separator:afc979e84980458d380e3bcea7c2c8101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a570bf43cbe2c13df7f8f7b64f7140"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#af6a570bf43cbe2c13df7f8f7b64f7140">classify_pde</a> (eq, func=None, dict=False, *prep=True, **kwargs)</td></tr>
<tr class="separator:af6a570bf43cbe2c13df7f8f7b64f7140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6856854162917fdefc3d84db32b13b12"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#a6856854162917fdefc3d84db32b13b12">checkpdesol</a> (pde, sol, func=None, solve_for_func=True)</td></tr>
<tr class="separator:a6856854162917fdefc3d84db32b13b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059a1d53efdb0e58131705be100165d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#a059a1d53efdb0e58131705be100165d7">pde_1st_linear_constant_coeff_homogeneous</a> (eq, func, order, match, solvefun)</td></tr>
<tr class="separator:a059a1d53efdb0e58131705be100165d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322eb6afabbeee0f182e969402d3dc4a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#a322eb6afabbeee0f182e969402d3dc4a">pde_1st_linear_constant_coeff</a> (eq, func, order, match, solvefun)</td></tr>
<tr class="separator:a322eb6afabbeee0f182e969402d3dc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0411d90d68d64f3a87151f3974902f76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#a0411d90d68d64f3a87151f3974902f76">pde_1st_linear_variable_coeff</a> (eq, func, order, match, solvefun)</td></tr>
<tr class="separator:a0411d90d68d64f3a87151f3974902f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a450ddf4c73b3420db81ed86db1d7b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#a1a450ddf4c73b3420db81ed86db1d7b5">pde_separate</a> (eq, fun, sep, strategy='mul')</td></tr>
<tr class="separator:a1a450ddf4c73b3420db81ed86db1d7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59caa4e6a9d6efbab3f8ebb90d3e300f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#a59caa4e6a9d6efbab3f8ebb90d3e300f">pde_separate_add</a> (eq, fun, sep)</td></tr>
<tr class="separator:a59caa4e6a9d6efbab3f8ebb90d3e300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea030327be4b0294257287ed2e1376"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#a94ea030327be4b0294257287ed2e1376">pde_separate_mul</a> (eq, fun, sep)</td></tr>
<tr class="separator:a94ea030327be4b0294257287ed2e1376"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af725db7085aac121adc523c1001ecf33"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1pde.html#af725db7085aac121adc523c1001ecf33">allhints</a></td></tr>
<tr class="separator:af725db7085aac121adc523c1001ecf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module contains pdsolve() and different helper functions that it
uses. It is heavily inspired by the ode module and hence the basic
infrastructure remains the same.

**Functions in this module**

    These are the user functions in this module:

    - pdsolve()     - Solves PDE's
    - classify_pde() - Classifies PDEs into possible hints for dsolve().
    - pde_separate() - Separate variables in partial differential equation either by
                       additive or multiplicative separation approach.

    These are the helper functions in this module:

    - pde_separate_add() - Helper function for searching additive separable solutions.
    - pde_separate_mul() - Helper function for searching multiplicative
                           separable solutions.

**Currently implemented solver methods**

The following methods are implemented for solving partial differential
equations.  See the docstrings of the various pde_hint() functions for
more information on each (run help(pde)):

  - 1st order linear homogeneous partial differential equations
    with constant coefficients.
  - 1st order linear general partial differential equations
    with constant coefficients.
  - 1st order linear partial differential equations with
    variable coefficients.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6856854162917fdefc3d84db32b13b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6856854162917fdefc3d84db32b13b12">&#9670;&nbsp;</a></span>checkpdesol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.checkpdesol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>solve_for_func</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if the given solution satisfies the partial differential
equation.

pde is the partial differential equation which can be given in the
form of an equation or an expression. sol is the solution for which
the pde is to be checked. This can also be given in an equation or
an expression form. If the function is not provided, the helper
function _preprocess from deutils is used to identify the function.

If a sequence of solutions is passed, the same sort of container will be
used to return the result for each solution.

The following methods are currently being implemented to check if the
solution satisfies the PDE:

    1. Directly substitute the solution in the PDE and check. If the
       solution has not been solved for f, then it will solve for f
       provided solve_for_func has not been set to False.

If the solution satisfies the PDE, then a tuple (True, 0) is returned.
Otherwise a tuple (False, expr) where expr is the value obtained
after substituting the solution in the PDE. However if a known solution
returns False, it may be due to the inability of doit() to simplify it to zero.

Examples
========

&gt;&gt;&gt; from sympy import Function, symbols
&gt;&gt;&gt; from sympy.solvers.pde import checkpdesol, pdsolve
&gt;&gt;&gt; x, y = symbols('x y')
&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; eq = 2*f(x,y) + 3*f(x,y).diff(x) + 4*f(x,y).diff(y)
&gt;&gt;&gt; sol = pdsolve(eq)
&gt;&gt;&gt; assert checkpdesol(eq, sol)[0]
&gt;&gt;&gt; eq = x*f(x,y) + f(x,y).diff(x)
&gt;&gt;&gt; checkpdesol(eq, sol)
(False, (x*F(4*x - 3*y) - 6*F(4*x - 3*y)/25 + 4*Subs(Derivative(F(_xi_1), _xi_1), _xi_1, 4*x - 3*y))*exp(-6*x/25 - 8*y/25))
</pre> 
</div>
</div>
<a id="af6a570bf43cbe2c13df7f8f7b64f7140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a570bf43cbe2c13df7f8f7b64f7140">&#9670;&nbsp;</a></span>classify_pde()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.classify_pde </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>prep</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a tuple of possible pdsolve() classifications for a PDE.

The tuple is ordered so that first item is the classification that
pdsolve() uses to solve the PDE by default.  In general,
classifications near the beginning of the list will produce
better solutions faster than those near the end, though there are
always exceptions.  To make pdsolve use a different classification,
use pdsolve(PDE, func, hint=&lt;classification&gt;).  See also the pdsolve()
docstring for different meta-hints you can use.

If ``dict`` is true, classify_pde() will return a dictionary of
hint:match expression terms. This is intended for internal use by
pdsolve().  Note that because dictionaries are ordered arbitrarily,
this will most likely not be in the same order as the tuple.

You can get help on different hints by doing help(pde.pde_hintname),
where hintname is the name of the hint without "_Integral".

See sympy.pde.allhints or the sympy.pde docstring for a list of all
supported hints that can be returned from classify_pde.


Examples
========

&gt;&gt;&gt; from sympy.solvers.pde import classify_pde
&gt;&gt;&gt; from sympy import Function, Eq
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; u = f(x, y)
&gt;&gt;&gt; ux = u.diff(x)
&gt;&gt;&gt; uy = u.diff(y)
&gt;&gt;&gt; eq = Eq(1 + (2*(ux/u)) + (3*(uy/u)), 0)
&gt;&gt;&gt; classify_pde(eq)
('1st_linear_constant_coeff_homogeneous',)
</pre> 
</div>
</div>
<a id="a322eb6afabbeee0f182e969402d3dc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322eb6afabbeee0f182e969402d3dc4a">&#9670;&nbsp;</a></span>pde_1st_linear_constant_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.pde_1st_linear_constant_coeff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>solvefun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves a first order linear partial differential equation
with constant coefficients.

The general form of this partial differential equation is

.. math:: a \frac{\partial f(x,y)}{\partial x}
          + b \frac{\partial f(x,y)}{\partial y}
          + c f(x,y) = G(x,y)

where `a`, `b` and `c` are constants and `G(x, y)` can be an arbitrary
function in `x` and `y`.

The general solution of the PDE is:

.. math::
    f(x, y) = \left. \left[F(\eta) + \frac{1}{a^2 + b^2}
    \int\limits^{a x + b y} G\left(\frac{a \xi + b \eta}{a^2 + b^2},
    \frac{- a \eta + b \xi}{a^2 + b^2} \right)
    e^{\frac{c \xi}{a^2 + b^2}}\, d\xi\right]
    e^{- \frac{c \xi}{a^2 + b^2}}
    \right|_{\substack{\eta=- a y + b x\\ \xi=a x + b y }}\, ,

where `F(\eta)` is an arbitrary single-valued function. The solution
can be found in SymPy with ``pdsolve``::

    &gt;&gt;&gt; from sympy.solvers import pdsolve
    &gt;&gt;&gt; from sympy.abc import x, y, a, b, c
    &gt;&gt;&gt; from sympy import Function, pprint
    &gt;&gt;&gt; f = Function('f')
    &gt;&gt;&gt; G = Function('G')
    &gt;&gt;&gt; u = f(x, y)
    &gt;&gt;&gt; ux = u.diff(x)
    &gt;&gt;&gt; uy = u.diff(y)
    &gt;&gt;&gt; genform = a*ux + b*uy + c*u - G(x,y)
    &gt;&gt;&gt; pprint(genform)
      d               d
    a*--(f(x, y)) + b*--(f(x, y)) + c*f(x, y) - G(x, y)
      dx              dy
    &gt;&gt;&gt; pprint(pdsolve(genform, hint='1st_linear_constant_coeff_Integral'))
              //          a*x + b*y                                             \         \|
              ||              /                                                 |         ||
              ||             |                                                  |         ||
              ||             |                                      c*xi        |         ||
              ||             |                                     -------      |         ||
              ||             |                                      2    2      |         ||
              ||             |      /a*xi + b*eta  -a*eta + b*xi\  a  + b       |         ||
              ||             |     G|------------, -------------|*e        d(xi)|         ||
              ||             |      |   2    2         2    2   |               |         ||
              ||             |      \  a  + b         a  + b    /               |  -c*xi  ||
              ||             |                                                  |  -------||
              ||            /                                                   |   2    2||
              ||                                                                |  a  + b ||
    f(x, y) = ||F(eta) + -------------------------------------------------------|*e       ||
              ||                                  2    2                        |         ||
              \\                                 a  + b                         /         /|eta=-a*y + b*x, xi=a*x + b*y

Examples
========

&gt;&gt;&gt; from sympy.solvers.pde import pdsolve
&gt;&gt;&gt; from sympy import Function, pprint, exp
&gt;&gt;&gt; from sympy.abc import x,y
&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; eq = -2*f(x,y).diff(x) + 4*f(x,y).diff(y) + 5*f(x,y) - exp(x + 3*y)
&gt;&gt;&gt; pdsolve(eq)
Eq(f(x, y), (F(4*x + 2*y)*exp(x/2) + exp(x + 4*y)/15)*exp(-y))

References
==========

- Viktor Grigoryan, "Partial Differential Equations"
  Math 124A - Fall 2010, pp.7</pre> 
</div>
</div>
<a id="a059a1d53efdb0e58131705be100165d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059a1d53efdb0e58131705be100165d7">&#9670;&nbsp;</a></span>pde_1st_linear_constant_coeff_homogeneous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.pde_1st_linear_constant_coeff_homogeneous </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>solvefun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves a first order linear homogeneous
partial differential equation with constant coefficients.

The general form of this partial differential equation is

.. math:: a \frac{\partial f(x,y)}{\partial x}
          + b \frac{\partial f(x,y)}{\partial y} + c f(x,y) = 0

where `a`, `b` and `c` are constants.

The general solution is of the form:

.. math::
    f(x, y) = F(- a y + b x ) e^{- \frac{c (a x + b y)}{a^2 + b^2}}

and can be found in SymPy with ``pdsolve``::

    &gt;&gt;&gt; from sympy.solvers import pdsolve
    &gt;&gt;&gt; from sympy.abc import x, y, a, b, c
    &gt;&gt;&gt; from sympy import Function, pprint
    &gt;&gt;&gt; f = Function('f')
    &gt;&gt;&gt; u = f(x,y)
    &gt;&gt;&gt; ux = u.diff(x)
    &gt;&gt;&gt; uy = u.diff(y)
    &gt;&gt;&gt; genform = a*ux + b*uy + c*u
    &gt;&gt;&gt; pprint(genform)
      d               d
    a*--(f(x, y)) + b*--(f(x, y)) + c*f(x, y)
      dx              dy

    &gt;&gt;&gt; pprint(pdsolve(genform))
                             -c*(a*x + b*y)
                             ---------------
                                  2    2
                                 a  + b
    f(x, y) = F(-a*y + b*x)*e

Examples
========

&gt;&gt;&gt; from sympy import pdsolve
&gt;&gt;&gt; from sympy import Function, pprint
&gt;&gt;&gt; from sympy.abc import x,y
&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; pdsolve(f(x,y) + f(x,y).diff(x) + f(x,y).diff(y))
Eq(f(x, y), F(x - y)*exp(-x/2 - y/2))
&gt;&gt;&gt; pprint(pdsolve(f(x,y) + f(x,y).diff(x) + f(x,y).diff(y)))
                      x   y
                    - - - -
                      2   2
f(x, y) = F(x - y)*e

References
==========

- Viktor Grigoryan, "Partial Differential Equations"
  Math 124A - Fall 2010, pp.7</pre> 
</div>
</div>
<a id="a0411d90d68d64f3a87151f3974902f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0411d90d68d64f3a87151f3974902f76">&#9670;&nbsp;</a></span>pde_1st_linear_variable_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.pde_1st_linear_variable_coeff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>solvefun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves a first order linear partial differential equation
with variable coefficients. The general form of this partial
differential equation is

.. math:: a(x, y) \frac{\partial f(x, y)}{\partial x}
            + b(x, y) \frac{\partial f(x, y)}{\partial y}
            + c(x, y) f(x, y) = G(x, y)

where `a(x, y)`, `b(x, y)`, `c(x, y)` and `G(x, y)` are arbitrary
functions in `x` and `y`. This PDE is converted into an ODE by
making the following transformation:

1. `\xi` as `x`

2. `\eta` as the constant in the solution to the differential
   equation `\frac{dy}{dx} = -\frac{b}{a}`

Making the previous substitutions reduces it to the linear ODE

.. math:: a(\xi, \eta)\frac{du}{d\xi} + c(\xi, \eta)u - G(\xi, \eta) = 0

which can be solved using ``dsolve``.

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy import Function, pprint
&gt;&gt;&gt; a, b, c, G, f= [Function(i) for i in ['a', 'b', 'c', 'G', 'f']]
&gt;&gt;&gt; u = f(x,y)
&gt;&gt;&gt; ux = u.diff(x)
&gt;&gt;&gt; uy = u.diff(y)
&gt;&gt;&gt; genform = a(x, y)*u + b(x, y)*ux + c(x, y)*uy - G(x,y)
&gt;&gt;&gt; pprint(genform)
                                     d                     d
-G(x, y) + a(x, y)*f(x, y) + b(x, y)*--(f(x, y)) + c(x, y)*--(f(x, y))
                                     dx                    dy


Examples
========

&gt;&gt;&gt; from sympy.solvers.pde import pdsolve
&gt;&gt;&gt; from sympy import Function, pprint
&gt;&gt;&gt; from sympy.abc import x,y
&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; eq =  x*(u.diff(x)) - y*(u.diff(y)) + y**2*u - y**2
&gt;&gt;&gt; pdsolve(eq)
Eq(f(x, y), F(x*y)*exp(y**2/2) + 1)

References
==========

- Viktor Grigoryan, "Partial Differential Equations"
  Math 124A - Fall 2010, pp.7</pre> 
</div>
</div>
<a id="a1a450ddf4c73b3420db81ed86db1d7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a450ddf4c73b3420db81ed86db1d7b5">&#9670;&nbsp;</a></span>pde_separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.pde_separate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strategy</em> = <code>'mul'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Separate variables in partial differential equation either by additive
or multiplicative separation approach. It tries to rewrite an equation so
that one of the specified variables occurs on a different side of the
equation than the others.

:param eq: Partial differential equation

:param fun: Original function F(x, y, z)

:param sep: List of separated functions [X(x), u(y, z)]

:param strategy: Separation strategy. You can choose between additive
    separation ('add') and multiplicative separation ('mul') which is
    default.

Examples
========

&gt;&gt;&gt; from sympy import E, Eq, Function, pde_separate, Derivative as D
&gt;&gt;&gt; from sympy.abc import x, t
&gt;&gt;&gt; u, X, T = map(Function, 'uXT')

&gt;&gt;&gt; eq = Eq(D(u(x, t), x), E**(u(x, t))*D(u(x, t), t))
&gt;&gt;&gt; pde_separate(eq, u(x, t), [X(x), T(t)], strategy='add')
[exp(-X(x))*Derivative(X(x), x), exp(T(t))*Derivative(T(t), t)]

&gt;&gt;&gt; eq = Eq(D(u(x, t), x, 2), D(u(x, t), t, 2))
&gt;&gt;&gt; pde_separate(eq, u(x, t), [X(x), T(t)], strategy='mul')
[Derivative(X(x), (x, 2))/X(x), Derivative(T(t), (t, 2))/T(t)]

See Also
========
pde_separate_add, pde_separate_mul
</pre> 
</div>
</div>
<a id="a59caa4e6a9d6efbab3f8ebb90d3e300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59caa4e6a9d6efbab3f8ebb90d3e300f">&#9670;&nbsp;</a></span>pde_separate_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.pde_separate_add </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function for searching additive separable solutions.

Consider an equation of two independent variables x, y and a dependent
variable w, we look for the product of two functions depending on different
arguments:

`w(x, y, z) = X(x) + y(y, z)`

Examples
========

&gt;&gt;&gt; from sympy import E, Eq, Function, pde_separate_add, Derivative as D
&gt;&gt;&gt; from sympy.abc import x, t
&gt;&gt;&gt; u, X, T = map(Function, 'uXT')

&gt;&gt;&gt; eq = Eq(D(u(x, t), x), E**(u(x, t))*D(u(x, t), t))
&gt;&gt;&gt; pde_separate_add(eq, u(x, t), [X(x), T(t)])
[exp(-X(x))*Derivative(X(x), x), exp(T(t))*Derivative(T(t), t)]</pre> 
</div>
</div>
<a id="a94ea030327be4b0294257287ed2e1376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ea030327be4b0294257287ed2e1376">&#9670;&nbsp;</a></span>pde_separate_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.pde_separate_mul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function for searching multiplicative separable solutions.

Consider an equation of two independent variables x, y and a dependent
variable w, we look for the product of two functions depending on different
arguments:

`w(x, y, z) = X(x)*u(y, z)`

Examples
========

&gt;&gt;&gt; from sympy import Function, Eq, pde_separate_mul, Derivative as D
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; u, X, Y = map(Function, 'uXY')

&gt;&gt;&gt; eq = Eq(D(u(x, y), x, 2), D(u(x, y), y, 2))
&gt;&gt;&gt; pde_separate_mul(eq, u(x, y), [X(x), Y(y)])
[Derivative(X(x), (x, 2))/X(x), Derivative(Y(y), (y, 2))/Y(y)]</pre> 
</div>
</div>
<a id="afc979e84980458d380e3bcea7c2c8101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc979e84980458d380e3bcea7c2c8101">&#9670;&nbsp;</a></span>pdsolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.pde.pdsolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hint</em> = <code>'default'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>solvefun</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves any (supported) kind of partial differential equation.

**Usage**

    pdsolve(eq, f(x,y), hint) -&gt; Solve partial differential equation
    eq for function f(x,y), using method hint.

**Details**

    ``eq`` can be any supported partial differential equation (see
        the pde docstring for supported methods).  This can either
        be an Equality, or an expression, which is assumed to be
        equal to 0.

    ``f(x,y)`` is a function of two variables whose derivatives in that
        variable make up the partial differential equation. In many
        cases it is not necessary to provide this; it will be autodetected
        (and an error raised if it could not be detected).

    ``hint`` is the solving method that you want pdsolve to use.  Use
        classify_pde(eq, f(x,y)) to get all of the possible hints for
        a PDE.  The default hint, 'default', will use whatever hint
        is returned first by classify_pde().  See Hints below for
        more options that you can use for hint.

    ``solvefun`` is the convention used for arbitrary functions returned
        by the PDE solver. If not set by the user, it is set by default
        to be F.

**Hints**

    Aside from the various solving methods, there are also some
    meta-hints that you can pass to pdsolve():

    "default":
            This uses whatever hint is returned first by
            classify_pde(). This is the default argument to
            pdsolve().

    "all":
            To make pdsolve apply all relevant classification hints,
            use pdsolve(PDE, func, hint="all").  This will return a
            dictionary of hint:solution terms.  If a hint causes
            pdsolve to raise the NotImplementedError, value of that
            hint's key will be the exception object raised.  The
            dictionary will also include some special keys:

            - order: The order of the PDE.  See also ode_order() in
              deutils.py
            - default: The solution that would be returned by
              default.  This is the one produced by the hint that
              appears first in the tuple returned by classify_pde().

    "all_Integral":
            This is the same as "all", except if a hint also has a
            corresponding "_Integral" hint, it only returns the
            "_Integral" hint.  This is useful if "all" causes
            pdsolve() to hang because of a difficult or impossible
            integral.  This meta-hint will also be much faster than
            "all", because integrate() is an expensive routine.

    See also the classify_pde() docstring for more info on hints,
    and the pde docstring for a list of all supported hints.

**Tips**
    - You can declare the derivative of an unknown function this way:

        &gt;&gt;&gt; from sympy import Function, Derivative
        &gt;&gt;&gt; from sympy.abc import x, y # x and y are the independent variables
        &gt;&gt;&gt; f = Function("f")(x, y) # f is a function of x and y
        &gt;&gt;&gt; # fx will be the partial derivative of f with respect to x
        &gt;&gt;&gt; fx = Derivative(f, x)
        &gt;&gt;&gt; # fy will be the partial derivative of f with respect to y
        &gt;&gt;&gt; fy = Derivative(f, y)

    - See test_pde.py for many tests, which serves also as a set of
      examples for how to use pdsolve().
    - pdsolve always returns an Equality class (except for the case
      when the hint is "all" or "all_Integral"). Note that it is not possible
      to get an explicit solution for f(x, y) as in the case of ODE's
    - Do help(pde.pde_hintname) to get help more information on a
      specific hint


Examples
========

&gt;&gt;&gt; from sympy.solvers.pde import pdsolve
&gt;&gt;&gt; from sympy import Function, Eq
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; u = f(x, y)
&gt;&gt;&gt; ux = u.diff(x)
&gt;&gt;&gt; uy = u.diff(y)
&gt;&gt;&gt; eq = Eq(1 + (2*(ux/u)) + (3*(uy/u)), 0)
&gt;&gt;&gt; pdsolve(eq)
Eq(f(x, y), F(3*x - 2*y)*exp(-2*x/13 - 3*y/13))</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af725db7085aac121adc523c1001ecf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af725db7085aac121adc523c1001ecf33">&#9670;&nbsp;</a></span>allhints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple sympy.solvers.pde.allhints</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  (</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    <span class="stringliteral">&quot;1st_linear_constant_coeff_homogeneous&quot;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    <span class="stringliteral">&quot;1st_linear_constant_coeff&quot;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    <span class="stringliteral">&quot;1st_linear_constant_coeff_Integral&quot;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    <span class="stringliteral">&quot;1st_linear_variable_coeff&quot;</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    )</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
