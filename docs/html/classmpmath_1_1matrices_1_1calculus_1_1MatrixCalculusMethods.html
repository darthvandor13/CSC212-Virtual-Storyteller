<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.matrices.calculus.MatrixCalculusMethods Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1matrices.html">matrices</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1matrices_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html">MatrixCalculusMethods</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.matrices.calculus.MatrixCalculusMethods Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for mpmath.matrices.calculus.MatrixCalculusMethods:</div>
<div class="dyncontent">
<div class="center"><img src="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods__inherit__graph.png" border="0" usemap="#ampmath_8matrices_8calculus_8MatrixCalculusMethods_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mpmath.matrices.calculus.MatrixCalculusMethods:</div>
<div class="dyncontent">
<div class="center"><img src="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods__coll__graph.png" border="0" usemap="#ampmath_8matrices_8calculus_8MatrixCalculusMethods_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5e6f56f616d628a38cc12f41bb3e5d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#ad5e6f56f616d628a38cc12f41bb3e5d2">expm</a> (ctx, A, method='<a class="el" href="namespacempmath.html#a833252eccdb978acf46913e59fdaca3c">taylor</a>')</td></tr>
<tr class="separator:ad5e6f56f616d628a38cc12f41bb3e5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a02fadcda76abacaa9a176b0c7bfb78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#a0a02fadcda76abacaa9a176b0c7bfb78">cosm</a> (ctx, A)</td></tr>
<tr class="separator:a0a02fadcda76abacaa9a176b0c7bfb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dcbbff1bf3ccd72ed149fd0b05204c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#aa6dcbbff1bf3ccd72ed149fd0b05204c">sinm</a> (ctx, A)</td></tr>
<tr class="separator:aa6dcbbff1bf3ccd72ed149fd0b05204c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d198789cb46afb4657dfe8dfc6308cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#a1d198789cb46afb4657dfe8dfc6308cd">sqrtm</a> (ctx, A, _may_rotate=2)</td></tr>
<tr class="separator:a1d198789cb46afb4657dfe8dfc6308cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc9cd086dd03f092516ad5ac8cf8528"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#a4bc9cd086dd03f092516ad5ac8cf8528">logm</a> (ctx, A)</td></tr>
<tr class="separator:a4bc9cd086dd03f092516ad5ac8cf8528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e78b247ed6f3293e6394977215e160"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#ac5e78b247ed6f3293e6394977215e160">powm</a> (ctx, A, r)</td></tr>
<tr class="separator:ac5e78b247ed6f3293e6394977215e160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e6f56f616d628a38cc12f41bb3e5d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#ad5e6f56f616d628a38cc12f41bb3e5d2">expm</a> (ctx, A, method='<a class="el" href="namespacempmath.html#a833252eccdb978acf46913e59fdaca3c">taylor</a>')</td></tr>
<tr class="separator:ad5e6f56f616d628a38cc12f41bb3e5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a02fadcda76abacaa9a176b0c7bfb78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#a0a02fadcda76abacaa9a176b0c7bfb78">cosm</a> (ctx, A)</td></tr>
<tr class="separator:a0a02fadcda76abacaa9a176b0c7bfb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dcbbff1bf3ccd72ed149fd0b05204c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#aa6dcbbff1bf3ccd72ed149fd0b05204c">sinm</a> (ctx, A)</td></tr>
<tr class="separator:aa6dcbbff1bf3ccd72ed149fd0b05204c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d198789cb46afb4657dfe8dfc6308cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#a1d198789cb46afb4657dfe8dfc6308cd">sqrtm</a> (ctx, A, _may_rotate=2)</td></tr>
<tr class="separator:a1d198789cb46afb4657dfe8dfc6308cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc9cd086dd03f092516ad5ac8cf8528"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#a4bc9cd086dd03f092516ad5ac8cf8528">logm</a> (ctx, A)</td></tr>
<tr class="separator:a4bc9cd086dd03f092516ad5ac8cf8528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e78b247ed6f3293e6394977215e160"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1calculus_1_1MatrixCalculusMethods.html#ac5e78b247ed6f3293e6394977215e160">powm</a> (ctx, A, r)</td></tr>
<tr class="separator:ac5e78b247ed6f3293e6394977215e160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0a02fadcda76abacaa9a176b0c7bfb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a02fadcda76abacaa9a176b0c7bfb78">&#9670;&nbsp;</a></span>cosm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.cosm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gives the cosine of a square matrix `A`, defined in analogy
with the matrix exponential.

Examples::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; X = eye(3)
    &gt;&gt;&gt; cosm(X)
    [0.54030230586814               0.0               0.0]
    [             0.0  0.54030230586814               0.0]
    [             0.0               0.0  0.54030230586814]
    &gt;&gt;&gt; X = hilbert(3)
    &gt;&gt;&gt; cosm(X)
    [ 0.424403834569555  -0.316643413047167  -0.221474945949293]
    [-0.316643413047167   0.820646708837824  -0.127183694770039]
    [-0.221474945949293  -0.127183694770039   0.909236687217541]
    &gt;&gt;&gt; X = matrix([[1+j,-2],[0,-j]])
    &gt;&gt;&gt; cosm(X)
    [(0.833730025131149 - 0.988897705762865j)  (1.07485840848393 - 0.17192140544213j)]
    [                                     0.0               (1.54308063481524 + 0.0j)]
</pre> 
</div>
</div>
<a id="a0a02fadcda76abacaa9a176b0c7bfb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a02fadcda76abacaa9a176b0c7bfb78">&#9670;&nbsp;</a></span>cosm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.cosm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gives the cosine of a square matrix `A`, defined in analogy
with the matrix exponential.

Examples::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; X = eye(3)
    &gt;&gt;&gt; cosm(X)
    [0.54030230586814               0.0               0.0]
    [             0.0  0.54030230586814               0.0]
    [             0.0               0.0  0.54030230586814]
    &gt;&gt;&gt; X = hilbert(3)
    &gt;&gt;&gt; cosm(X)
    [ 0.424403834569555  -0.316643413047167  -0.221474945949293]
    [-0.316643413047167   0.820646708837824  -0.127183694770039]
    [-0.221474945949293  -0.127183694770039   0.909236687217541]
    &gt;&gt;&gt; X = matrix([[1+j,-2],[0,-j]])
    &gt;&gt;&gt; cosm(X)
    [(0.833730025131149 - 0.988897705762865j)  (1.07485840848393 - 0.17192140544213j)]
    [                                     0.0               (1.54308063481524 + 0.0j)]
</pre> 
</div>
</div>
<a id="ad5e6f56f616d628a38cc12f41bb3e5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e6f56f616d628a38cc12f41bb3e5d2">&#9670;&nbsp;</a></span>expm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.expm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'<a class="el" href="namespacempmath.html#a833252eccdb978acf46913e59fdaca3c">taylor</a>'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the matrix exponential of a square matrix `A`, which is defined
by the power series

.. math ::

    \exp(A) = I + A + \frac{A^2}{2!} + \frac{A^3}{3!} + \ldots

With method='taylor', the matrix exponential is computed
using the Taylor series. With method='pade', Pade approximants
are used instead.

**Examples**

Basic examples::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; expm(zeros(3))
    [1.0  0.0  0.0]
    [0.0  1.0  0.0]
    [0.0  0.0  1.0]
    &gt;&gt;&gt; expm(eye(3))
    [2.71828182845905               0.0               0.0]
    [             0.0  2.71828182845905               0.0]
    [             0.0               0.0  2.71828182845905]
    &gt;&gt;&gt; expm([[1,1,0],[1,0,1],[0,1,0]])
    [ 3.86814500615414  2.26812870852145  0.841130841230196]
    [ 2.26812870852145  2.44114713886289   1.42699786729125]
    [0.841130841230196  1.42699786729125    1.6000162976327]
    &gt;&gt;&gt; expm([[1,1,0],[1,0,1],[0,1,0]], method='pade')
    [ 3.86814500615414  2.26812870852145  0.841130841230196]
    [ 2.26812870852145  2.44114713886289   1.42699786729125]
    [0.841130841230196  1.42699786729125    1.6000162976327]
    &gt;&gt;&gt; expm([[1+j, 0], [1+j,1]])
    [(1.46869393991589 + 2.28735528717884j)                        0.0]
    [  (1.03776739863568 + 3.536943175722j)  (2.71828182845905 + 0.0j)]

Matrices with large entries are allowed::

    &gt;&gt;&gt; expm(matrix([[1,2],[2,3]])**25)
    [5.65024064048415e+2050488462815550  9.14228140091932e+2050488462815550]
    [9.14228140091932e+2050488462815550  1.47925220414035e+2050488462815551]

The identity `\exp(A+B) = \exp(A) \exp(B)` does not hold for
noncommuting matrices::

    &gt;&gt;&gt; A = hilbert(3)
    &gt;&gt;&gt; B = A + eye(3)
    &gt;&gt;&gt; chop(mnorm(A*B - B*A))
    0.0
    &gt;&gt;&gt; chop(mnorm(expm(A+B) - expm(A)*expm(B)))
    0.0
    &gt;&gt;&gt; B = A + ones(3)
    &gt;&gt;&gt; mnorm(A*B - B*A)
    1.8
    &gt;&gt;&gt; mnorm(expm(A+B) - expm(A)*expm(B))
    42.0927851137247</pre> 
</div>
</div>
<a id="ad5e6f56f616d628a38cc12f41bb3e5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e6f56f616d628a38cc12f41bb3e5d2">&#9670;&nbsp;</a></span>expm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.expm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'<a class="el" href="namespacempmath.html#a833252eccdb978acf46913e59fdaca3c">taylor</a>'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the matrix exponential of a square matrix `A`, which is defined
by the power series

.. math ::

    \exp(A) = I + A + \frac{A^2}{2!} + \frac{A^3}{3!} + \ldots

With method='taylor', the matrix exponential is computed
using the Taylor series. With method='pade', Pade approximants
are used instead.

**Examples**

Basic examples::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; expm(zeros(3))
    [1.0  0.0  0.0]
    [0.0  1.0  0.0]
    [0.0  0.0  1.0]
    &gt;&gt;&gt; expm(eye(3))
    [2.71828182845905               0.0               0.0]
    [             0.0  2.71828182845905               0.0]
    [             0.0               0.0  2.71828182845905]
    &gt;&gt;&gt; expm([[1,1,0],[1,0,1],[0,1,0]])
    [ 3.86814500615414  2.26812870852145  0.841130841230196]
    [ 2.26812870852145  2.44114713886289   1.42699786729125]
    [0.841130841230196  1.42699786729125    1.6000162976327]
    &gt;&gt;&gt; expm([[1,1,0],[1,0,1],[0,1,0]], method='pade')
    [ 3.86814500615414  2.26812870852145  0.841130841230196]
    [ 2.26812870852145  2.44114713886289   1.42699786729125]
    [0.841130841230196  1.42699786729125    1.6000162976327]
    &gt;&gt;&gt; expm([[1+j, 0], [1+j,1]])
    [(1.46869393991589 + 2.28735528717884j)                        0.0]
    [  (1.03776739863568 + 3.536943175722j)  (2.71828182845905 + 0.0j)]

Matrices with large entries are allowed::

    &gt;&gt;&gt; expm(matrix([[1,2],[2,3]])**25)
    [5.65024064048415e+2050488462815550  9.14228140091932e+2050488462815550]
    [9.14228140091932e+2050488462815550  1.47925220414035e+2050488462815551]

The identity `\exp(A+B) = \exp(A) \exp(B)` does not hold for
noncommuting matrices::

    &gt;&gt;&gt; A = hilbert(3)
    &gt;&gt;&gt; B = A + eye(3)
    &gt;&gt;&gt; chop(mnorm(A*B - B*A))
    0.0
    &gt;&gt;&gt; chop(mnorm(expm(A+B) - expm(A)*expm(B)))
    0.0
    &gt;&gt;&gt; B = A + ones(3)
    &gt;&gt;&gt; mnorm(A*B - B*A)
    1.8
    &gt;&gt;&gt; mnorm(expm(A+B) - expm(A)*expm(B))
    42.0927851137247</pre> 
</div>
</div>
<a id="a4bc9cd086dd03f092516ad5ac8cf8528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc9cd086dd03f092516ad5ac8cf8528">&#9670;&nbsp;</a></span>logm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.logm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a logarithm of the square matrix `A`, i.e. returns
a matrix `B = \log(A)` such that `\exp(B) = A`. The logarithm
of a matrix, if it exists, is not unique.

**Examples**

Logarithms of some simple matrices::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; X = eye(3)
    &gt;&gt;&gt; logm(X)
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]
    &gt;&gt;&gt; logm(2*X)
    [0.693147180559945                0.0                0.0]
    [              0.0  0.693147180559945                0.0]
    [              0.0                0.0  0.693147180559945]
    &gt;&gt;&gt; logm(expm(X))
    [1.0  0.0  0.0]
    [0.0  1.0  0.0]
    [0.0  0.0  1.0]

A logarithm of a complex matrix::

    &gt;&gt;&gt; X = matrix([[2+j, 1, 3], [1-j, 1-2*j, 1], [-4, -5, j]])
    &gt;&gt;&gt; B = logm(X)
    &gt;&gt;&gt; nprint(B)
    [ (0.808757 + 0.107759j)    (2.20752 + 0.202762j)   (1.07376 - 0.773874j)]
    [ (0.905709 - 0.107795j)  (0.0287395 - 0.824993j)  (0.111619 + 0.514272j)]
    [(-0.930151 + 0.399512j)   (-2.06266 - 0.674397j)  (0.791552 + 0.519839j)]
    &gt;&gt;&gt; chop(expm(B))
    [(2.0 + 1.0j)           1.0           3.0]
    [(1.0 - 1.0j)  (1.0 - 2.0j)           1.0]
    [        -4.0          -5.0  (0.0 + 1.0j)]

A matrix `X` close to the identity matrix, for which
`\log(\exp(X)) = \exp(\log(X)) = X` holds::

    &gt;&gt;&gt; X = eye(3) + hilbert(3)/4
    &gt;&gt;&gt; X
    [              1.25             0.125  0.0833333333333333]
    [             0.125  1.08333333333333              0.0625]
    [0.0833333333333333            0.0625                1.05]
    &gt;&gt;&gt; logm(expm(X))
    [              1.25             0.125  0.0833333333333333]
    [             0.125  1.08333333333333              0.0625]
    [0.0833333333333333            0.0625                1.05]
    &gt;&gt;&gt; expm(logm(X))
    [              1.25             0.125  0.0833333333333333]
    [             0.125  1.08333333333333              0.0625]
    [0.0833333333333333            0.0625                1.05]

A logarithm of a rotation matrix, giving back the angle of
the rotation::

    &gt;&gt;&gt; t = 3.7
    &gt;&gt;&gt; A = matrix([[cos(t),sin(t)],[-sin(t),cos(t)]])
    &gt;&gt;&gt; chop(logm(A))
    [             0.0  -2.58318530717959]
    [2.58318530717959                0.0]
    &gt;&gt;&gt; (2*pi-t)
    2.58318530717959

For some matrices, a logarithm does not exist::

    &gt;&gt;&gt; logm([[1,0], [0,0]])
    Traceback (most recent call last):
      ...
    ZeroDivisionError: matrix is numerically singular

Logarithm of a matrix with large entries::

    &gt;&gt;&gt; logm(hilbert(3) * 10**20).apply(re)
    [ 45.5597513593433  1.27721006042799  0.317662687717978]
    [ 1.27721006042799  42.5222778973542   2.24003708791604]
    [0.317662687717978  2.24003708791604    42.395212822267]</pre> 
</div>
</div>
<a id="a4bc9cd086dd03f092516ad5ac8cf8528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc9cd086dd03f092516ad5ac8cf8528">&#9670;&nbsp;</a></span>logm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.logm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a logarithm of the square matrix `A`, i.e. returns
a matrix `B = \log(A)` such that `\exp(B) = A`. The logarithm
of a matrix, if it exists, is not unique.

**Examples**

Logarithms of some simple matrices::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; X = eye(3)
    &gt;&gt;&gt; logm(X)
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]
    &gt;&gt;&gt; logm(2*X)
    [0.693147180559945                0.0                0.0]
    [              0.0  0.693147180559945                0.0]
    [              0.0                0.0  0.693147180559945]
    &gt;&gt;&gt; logm(expm(X))
    [1.0  0.0  0.0]
    [0.0  1.0  0.0]
    [0.0  0.0  1.0]

A logarithm of a complex matrix::

    &gt;&gt;&gt; X = matrix([[2+j, 1, 3], [1-j, 1-2*j, 1], [-4, -5, j]])
    &gt;&gt;&gt; B = logm(X)
    &gt;&gt;&gt; nprint(B)
    [ (0.808757 + 0.107759j)    (2.20752 + 0.202762j)   (1.07376 - 0.773874j)]
    [ (0.905709 - 0.107795j)  (0.0287395 - 0.824993j)  (0.111619 + 0.514272j)]
    [(-0.930151 + 0.399512j)   (-2.06266 - 0.674397j)  (0.791552 + 0.519839j)]
    &gt;&gt;&gt; chop(expm(B))
    [(2.0 + 1.0j)           1.0           3.0]
    [(1.0 - 1.0j)  (1.0 - 2.0j)           1.0]
    [        -4.0          -5.0  (0.0 + 1.0j)]

A matrix `X` close to the identity matrix, for which
`\log(\exp(X)) = \exp(\log(X)) = X` holds::

    &gt;&gt;&gt; X = eye(3) + hilbert(3)/4
    &gt;&gt;&gt; X
    [              1.25             0.125  0.0833333333333333]
    [             0.125  1.08333333333333              0.0625]
    [0.0833333333333333            0.0625                1.05]
    &gt;&gt;&gt; logm(expm(X))
    [              1.25             0.125  0.0833333333333333]
    [             0.125  1.08333333333333              0.0625]
    [0.0833333333333333            0.0625                1.05]
    &gt;&gt;&gt; expm(logm(X))
    [              1.25             0.125  0.0833333333333333]
    [             0.125  1.08333333333333              0.0625]
    [0.0833333333333333            0.0625                1.05]

A logarithm of a rotation matrix, giving back the angle of
the rotation::

    &gt;&gt;&gt; t = 3.7
    &gt;&gt;&gt; A = matrix([[cos(t),sin(t)],[-sin(t),cos(t)]])
    &gt;&gt;&gt; chop(logm(A))
    [             0.0  -2.58318530717959]
    [2.58318530717959                0.0]
    &gt;&gt;&gt; (2*pi-t)
    2.58318530717959

For some matrices, a logarithm does not exist::

    &gt;&gt;&gt; logm([[1,0], [0,0]])
    Traceback (most recent call last):
      ...
    ZeroDivisionError: matrix is numerically singular

Logarithm of a matrix with large entries::

    &gt;&gt;&gt; logm(hilbert(3) * 10**20).apply(re)
    [ 45.5597513593433  1.27721006042799  0.317662687717978]
    [ 1.27721006042799  42.5222778973542   2.24003708791604]
    [0.317662687717978  2.24003708791604    42.395212822267]</pre> 
</div>
</div>
<a id="ac5e78b247ed6f3293e6394977215e160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e78b247ed6f3293e6394977215e160">&#9670;&nbsp;</a></span>powm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.powm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes `A^r = \exp(A \log r)` for a matrix `A` and complex
number `r`.

**Examples**

Powers and inverse powers of a matrix::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; A = matrix([[4,1,4],[7,8,9],[10,2,11]])
    &gt;&gt;&gt; powm(A, 2)
    [ 63.0  20.0   69.0]
    [174.0  89.0  199.0]
    [164.0  48.0  179.0]
    &gt;&gt;&gt; chop(powm(powm(A, 4), 1/4.))
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; powm(extraprec(20)(powm)(A, -4), -1/4.)
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; chop(powm(powm(A, 1+0.5j), 1/(1+0.5j)))
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; powm(extraprec(5)(powm)(A, -1.5), -1/(1.5))
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]

A Fibonacci-generating matrix::

    &gt;&gt;&gt; powm([[1,1],[1,0]], 10)
    [89.0  55.0]
    [55.0  34.0]
    &gt;&gt;&gt; fib(10)
    55.0
    &gt;&gt;&gt; powm([[1,1],[1,0]], 6.5)
    [(16.5166626964253 - 0.0121089837381789j)  (10.2078589271083 + 0.0195927472575932j)]
    [(10.2078589271083 + 0.0195927472575932j)  (6.30880376931698 - 0.0317017309957721j)]
    &gt;&gt;&gt; (phi**6.5 - (1-phi)**6.5)/sqrt(5)
    (10.2078589271083 - 0.0195927472575932j)
    &gt;&gt;&gt; powm([[1,1],[1,0]], 6.2)
    [ (14.3076953002666 - 0.008222855781077j)  (8.81733464837593 + 0.0133048601383712j)]
    [(8.81733464837593 + 0.0133048601383712j)  (5.49036065189071 - 0.0215277159194482j)]
    &gt;&gt;&gt; (phi**6.2 - (1-phi)**6.2)/sqrt(5)
    (8.81733464837593 - 0.0133048601383712j)</pre> 
</div>
</div>
<a id="ac5e78b247ed6f3293e6394977215e160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e78b247ed6f3293e6394977215e160">&#9670;&nbsp;</a></span>powm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.powm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes `A^r = \exp(A \log r)` for a matrix `A` and complex
number `r`.

**Examples**

Powers and inverse powers of a matrix::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; A = matrix([[4,1,4],[7,8,9],[10,2,11]])
    &gt;&gt;&gt; powm(A, 2)
    [ 63.0  20.0   69.0]
    [174.0  89.0  199.0]
    [164.0  48.0  179.0]
    &gt;&gt;&gt; chop(powm(powm(A, 4), 1/4.))
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; powm(extraprec(20)(powm)(A, -4), -1/4.)
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; chop(powm(powm(A, 1+0.5j), 1/(1+0.5j)))
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; powm(extraprec(5)(powm)(A, -1.5), -1/(1.5))
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]

A Fibonacci-generating matrix::

    &gt;&gt;&gt; powm([[1,1],[1,0]], 10)
    [89.0  55.0]
    [55.0  34.0]
    &gt;&gt;&gt; fib(10)
    55.0
    &gt;&gt;&gt; powm([[1,1],[1,0]], 6.5)
    [(16.5166626964253 - 0.0121089837381789j)  (10.2078589271083 + 0.0195927472575932j)]
    [(10.2078589271083 + 0.0195927472575932j)  (6.30880376931698 - 0.0317017309957721j)]
    &gt;&gt;&gt; (phi**6.5 - (1-phi)**6.5)/sqrt(5)
    (10.2078589271083 - 0.0195927472575932j)
    &gt;&gt;&gt; powm([[1,1],[1,0]], 6.2)
    [ (14.3076953002666 - 0.008222855781077j)  (8.81733464837593 + 0.0133048601383712j)]
    [(8.81733464837593 + 0.0133048601383712j)  (5.49036065189071 - 0.0215277159194482j)]
    &gt;&gt;&gt; (phi**6.2 - (1-phi)**6.2)/sqrt(5)
    (8.81733464837593 - 0.0133048601383712j)</pre> 
</div>
</div>
<a id="aa6dcbbff1bf3ccd72ed149fd0b05204c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dcbbff1bf3ccd72ed149fd0b05204c">&#9670;&nbsp;</a></span>sinm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.sinm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gives the sine of a square matrix `A`, defined in analogy
with the matrix exponential.

Examples::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; X = eye(3)
    &gt;&gt;&gt; sinm(X)
    [0.841470984807897                0.0                0.0]
    [              0.0  0.841470984807897                0.0]
    [              0.0                0.0  0.841470984807897]
    &gt;&gt;&gt; X = hilbert(3)
    &gt;&gt;&gt; sinm(X)
    [0.711608512150994  0.339783913247439  0.220742837314741]
    [0.339783913247439  0.244113865695532  0.187231271174372]
    [0.220742837314741  0.187231271174372  0.155816730769635]
    &gt;&gt;&gt; X = matrix([[1+j,-2],[0,-j]])
    &gt;&gt;&gt; sinm(X)
    [(1.29845758141598 + 0.634963914784736j)  (-1.96751511930922 + 0.314700021761367j)]
    [                                    0.0                  (0.0 - 1.1752011936438j)]
</pre> 
</div>
</div>
<a id="aa6dcbbff1bf3ccd72ed149fd0b05204c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dcbbff1bf3ccd72ed149fd0b05204c">&#9670;&nbsp;</a></span>sinm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.sinm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gives the sine of a square matrix `A`, defined in analogy
with the matrix exponential.

Examples::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; X = eye(3)
    &gt;&gt;&gt; sinm(X)
    [0.841470984807897                0.0                0.0]
    [              0.0  0.841470984807897                0.0]
    [              0.0                0.0  0.841470984807897]
    &gt;&gt;&gt; X = hilbert(3)
    &gt;&gt;&gt; sinm(X)
    [0.711608512150994  0.339783913247439  0.220742837314741]
    [0.339783913247439  0.244113865695532  0.187231271174372]
    [0.220742837314741  0.187231271174372  0.155816730769635]
    &gt;&gt;&gt; X = matrix([[1+j,-2],[0,-j]])
    &gt;&gt;&gt; sinm(X)
    [(1.29845758141598 + 0.634963914784736j)  (-1.96751511930922 + 0.314700021761367j)]
    [                                    0.0                  (0.0 - 1.1752011936438j)]
</pre> 
</div>
</div>
<a id="a1d198789cb46afb4657dfe8dfc6308cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d198789cb46afb4657dfe8dfc6308cd">&#9670;&nbsp;</a></span>sqrtm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.sqrtm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_may_rotate</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a square root of the square matrix `A`, i.e. returns
a matrix `B = A^{1/2}` such that `B^2 = A`. The square root
of a matrix, if it exists, is not unique.

**Examples**

Square roots of some simple matrices::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; sqrtm([[1,0], [0,1]])
    [1.0  0.0]
    [0.0  1.0]
    &gt;&gt;&gt; sqrtm([[0,0], [0,0]])
    [0.0  0.0]
    [0.0  0.0]
    &gt;&gt;&gt; sqrtm([[2,0],[0,1]])
    [1.4142135623731  0.0]
    [            0.0  1.0]
    &gt;&gt;&gt; sqrtm([[1,1],[1,0]])
    [ (0.920442065259926 - 0.21728689675164j)  (0.568864481005783 + 0.351577584254143j)]
    [(0.568864481005783 + 0.351577584254143j)  (0.351577584254143 - 0.568864481005783j)]
    &gt;&gt;&gt; sqrtm([[1,0],[0,1]])
    [1.0  0.0]
    [0.0  1.0]
    &gt;&gt;&gt; sqrtm([[-1,0],[0,1]])
    [(0.0 - 1.0j)           0.0]
    [         0.0  (1.0 + 0.0j)]
    &gt;&gt;&gt; sqrtm([[j,0],[0,j]])
    [(0.707106781186547 + 0.707106781186547j)                                       0.0]
    [                                     0.0  (0.707106781186547 + 0.707106781186547j)]

A square root of a rotation matrix, giving the corresponding
half-angle rotation matrix::

    &gt;&gt;&gt; t1 = 0.75
    &gt;&gt;&gt; t2 = t1 * 0.5
    &gt;&gt;&gt; A1 = matrix([[cos(t1), -sin(t1)], [sin(t1), cos(t1)]])
    &gt;&gt;&gt; A2 = matrix([[cos(t2), -sin(t2)], [sin(t2), cos(t2)]])
    &gt;&gt;&gt; sqrtm(A1)
    [0.930507621912314  -0.366272529086048]
    [0.366272529086048   0.930507621912314]
    &gt;&gt;&gt; A2
    [0.930507621912314  -0.366272529086048]
    [0.366272529086048   0.930507621912314]

The identity `(A^2)^{1/2} = A` does not necessarily hold::

    &gt;&gt;&gt; A = matrix([[4,1,4],[7,8,9],[10,2,11]])
    &gt;&gt;&gt; sqrtm(A**2)
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; sqrtm(A)**2
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; A = matrix([[-4,1,4],[7,-8,9],[10,2,11]])
    &gt;&gt;&gt; sqrtm(A**2)
    [  7.43715112194995  -0.324127569985474   1.8481718827526]
    [-0.251549715716942    9.32699765900402  2.48221180985147]
    [  4.11609388833616   0.775751877098258   13.017955697342]
    &gt;&gt;&gt; chop(sqrtm(A)**2)
    [-4.0   1.0   4.0]
    [ 7.0  -8.0   9.0]
    [10.0   2.0  11.0]

For some matrices, a square root does not exist::

    &gt;&gt;&gt; sqrtm([[0,1], [0,0]])
    Traceback (most recent call last):
      ...
    ZeroDivisionError: matrix is numerically singular

Two examples from the documentation for Matlab's ``sqrtm``::

    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; sqrtm([[7,10],[15,22]])
    [1.56669890360128  1.74077655955698]
    [2.61116483933547  4.17786374293675]
    &gt;&gt;&gt;
    &gt;&gt;&gt; X = matrix(\
    ...   [[5,-4,1,0,0],
    ...   [-4,6,-4,1,0],
    ...   [1,-4,6,-4,1],
    ...   [0,1,-4,6,-4],
    ...   [0,0,1,-4,5]])
    &gt;&gt;&gt; Y = matrix(\
    ...   [[2,-1,-0,-0,-0],
    ...   [-1,2,-1,0,-0],
    ...   [0,-1,2,-1,0],
    ...   [-0,0,-1,2,-1],
    ...   [-0,-0,-0,-1,2]])
    &gt;&gt;&gt; mnorm(sqrtm(X) - Y)
    4.53155328326114e-19</pre> 
</div>
</div>
<a id="a1d198789cb46afb4657dfe8dfc6308cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d198789cb46afb4657dfe8dfc6308cd">&#9670;&nbsp;</a></span>sqrtm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.calculus.MatrixCalculusMethods.sqrtm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_may_rotate</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a square root of the square matrix `A`, i.e. returns
a matrix `B = A^{1/2}` such that `B^2 = A`. The square root
of a matrix, if it exists, is not unique.

**Examples**

Square roots of some simple matrices::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; sqrtm([[1,0], [0,1]])
    [1.0  0.0]
    [0.0  1.0]
    &gt;&gt;&gt; sqrtm([[0,0], [0,0]])
    [0.0  0.0]
    [0.0  0.0]
    &gt;&gt;&gt; sqrtm([[2,0],[0,1]])
    [1.4142135623731  0.0]
    [            0.0  1.0]
    &gt;&gt;&gt; sqrtm([[1,1],[1,0]])
    [ (0.920442065259926 - 0.21728689675164j)  (0.568864481005783 + 0.351577584254143j)]
    [(0.568864481005783 + 0.351577584254143j)  (0.351577584254143 - 0.568864481005783j)]
    &gt;&gt;&gt; sqrtm([[1,0],[0,1]])
    [1.0  0.0]
    [0.0  1.0]
    &gt;&gt;&gt; sqrtm([[-1,0],[0,1]])
    [(0.0 - 1.0j)           0.0]
    [         0.0  (1.0 + 0.0j)]
    &gt;&gt;&gt; sqrtm([[j,0],[0,j]])
    [(0.707106781186547 + 0.707106781186547j)                                       0.0]
    [                                     0.0  (0.707106781186547 + 0.707106781186547j)]

A square root of a rotation matrix, giving the corresponding
half-angle rotation matrix::

    &gt;&gt;&gt; t1 = 0.75
    &gt;&gt;&gt; t2 = t1 * 0.5
    &gt;&gt;&gt; A1 = matrix([[cos(t1), -sin(t1)], [sin(t1), cos(t1)]])
    &gt;&gt;&gt; A2 = matrix([[cos(t2), -sin(t2)], [sin(t2), cos(t2)]])
    &gt;&gt;&gt; sqrtm(A1)
    [0.930507621912314  -0.366272529086048]
    [0.366272529086048   0.930507621912314]
    &gt;&gt;&gt; A2
    [0.930507621912314  -0.366272529086048]
    [0.366272529086048   0.930507621912314]

The identity `(A^2)^{1/2} = A` does not necessarily hold::

    &gt;&gt;&gt; A = matrix([[4,1,4],[7,8,9],[10,2,11]])
    &gt;&gt;&gt; sqrtm(A**2)
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; sqrtm(A)**2
    [ 4.0  1.0   4.0]
    [ 7.0  8.0   9.0]
    [10.0  2.0  11.0]
    &gt;&gt;&gt; A = matrix([[-4,1,4],[7,-8,9],[10,2,11]])
    &gt;&gt;&gt; sqrtm(A**2)
    [  7.43715112194995  -0.324127569985474   1.8481718827526]
    [-0.251549715716942    9.32699765900402  2.48221180985147]
    [  4.11609388833616   0.775751877098258   13.017955697342]
    &gt;&gt;&gt; chop(sqrtm(A)**2)
    [-4.0   1.0   4.0]
    [ 7.0  -8.0   9.0]
    [10.0   2.0  11.0]

For some matrices, a square root does not exist::

    &gt;&gt;&gt; sqrtm([[0,1], [0,0]])
    Traceback (most recent call last):
      ...
    ZeroDivisionError: matrix is numerically singular

Two examples from the documentation for Matlab's ``sqrtm``::

    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; sqrtm([[7,10],[15,22]])
    [1.56669890360128  1.74077655955698]
    [2.61116483933547  4.17786374293675]
    &gt;&gt;&gt;
    &gt;&gt;&gt; X = matrix(\
    ...   [[5,-4,1,0,0],
    ...   [-4,6,-4,1,0],
    ...   [1,-4,6,-4,1],
    ...   [0,1,-4,6,-4],
    ...   [0,0,1,-4,5]])
    &gt;&gt;&gt; Y = matrix(\
    ...   [[2,-1,-0,-0,-0],
    ...   [-1,2,-1,0,-0],
    ...   [0,-1,2,-1,0],
    ...   [-0,0,-1,2,-1],
    ...   [-0,-0,-0,-1,2]])
    &gt;&gt;&gt; mnorm(sqrtm(X) - Y)
    4.53155328326114e-19</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/mpmath/matrices/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2mpmath_2matrices_2calculus_8py.html">calculus.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
