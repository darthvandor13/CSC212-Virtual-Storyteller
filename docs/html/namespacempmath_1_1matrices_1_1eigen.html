<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.matrices.eigen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1matrices.html">matrices</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html">eigen</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.matrices.eigen Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1eigen_1_1Eigen.html">Eigen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7c9a831cd1a752eecac0df73797694a3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a7c9a831cd1a752eecac0df73797694a3">defun</a> (f)</td></tr>
<tr class="separator:a7c9a831cd1a752eecac0df73797694a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2573e43b9be86006ccafdf47bc54abc8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a2573e43b9be86006ccafdf47bc54abc8">hessenberg_reduce_0</a> (ctx, A, T)</td></tr>
<tr class="separator:a2573e43b9be86006ccafdf47bc54abc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991256b9daadc6de1eb1ddf12a43972e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a991256b9daadc6de1eb1ddf12a43972e">hessenberg_reduce_1</a> (ctx, A, T)</td></tr>
<tr class="separator:a991256b9daadc6de1eb1ddf12a43972e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e258bdee4d4e8d99fb84712549ccf9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#aa9e258bdee4d4e8d99fb84712549ccf9">hessenberg</a> (ctx, A, overwrite_a=False)</td></tr>
<tr class="separator:aa9e258bdee4d4e8d99fb84712549ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fbb3a02bc44e9030cfd7a2bcc6e783"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a35fbb3a02bc44e9030cfd7a2bcc6e783">qr_step</a> (ctx, n0, n1, A, Q, shift)</td></tr>
<tr class="separator:a35fbb3a02bc44e9030cfd7a2bcc6e783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e18b3d37688da8948b69857eb6f6d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a17e18b3d37688da8948b69857eb6f6d1">hessenberg_qr</a> (ctx, A, Q)</td></tr>
<tr class="separator:a17e18b3d37688da8948b69857eb6f6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ad30b8064eac9c1383cabba0ed794a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a91ad30b8064eac9c1383cabba0ed794a">schur</a> (ctx, A, overwrite_a=False)</td></tr>
<tr class="separator:a91ad30b8064eac9c1383cabba0ed794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056b37f8b6dc4bde4a1f4e01d5ecb84"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a1056b37f8b6dc4bde4a1f4e01d5ecb84">eig_tr_r</a> (ctx, A)</td></tr>
<tr class="separator:a1056b37f8b6dc4bde4a1f4e01d5ecb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d035f75ef101cdf0b2cfdc9918f93b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a89d035f75ef101cdf0b2cfdc9918f93b">eig_tr_l</a> (ctx, A)</td></tr>
<tr class="separator:a89d035f75ef101cdf0b2cfdc9918f93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb02a54049db3bc41963663017b5eef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#a3eb02a54049db3bc41963663017b5eef">eig</a> (ctx, A, left=False, right=True, overwrite_a=False)</td></tr>
<tr class="separator:a3eb02a54049db3bc41963663017b5eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5def1288bc22f3cf3ede27d67cf4afe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1matrices_1_1eigen.html#aa5def1288bc22f3cf3ede27d67cf4afe">eig_sort</a> (ctx, E, EL=False, ER=False, f=&quot;real&quot;)</td></tr>
<tr class="separator:aa5def1288bc22f3cf3ede27d67cf4afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7c9a831cd1a752eecac0df73797694a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9a831cd1a752eecac0df73797694a3">&#9670;&nbsp;</a></span>defun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.defun </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3eb02a54049db3bc41963663017b5eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb02a54049db3bc41963663017b5eef">&#9670;&nbsp;</a></span>eig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.eig </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the eigenvalues and optionally the left and right
eigenvectors of a square matrix A. Given A, a vector E and matrices ER
and EL are calculated such that

                    A ER[:,i] =         E[i] ER[:,i]
            EL[i,:] A         = EL[i,:] E[i]

E contains the eigenvalues of A. The columns of ER contain the right eigenvectors
of A whereas the rows of EL contain the left eigenvectors.


input:
  A           : a real or complex square matrix of shape (n, n)
  left        : if true, the left eigenvectors are calculated.
  right       : if true, the right eigenvectors are calculated.
  overwrite_a : if true, allows modification of A which may improve
                performance. if false, A is not modified.

output:
  E    : a list of length n containing the eigenvalues of A.
  ER   : a matrix whose columns contain the right eigenvectors of A.
  EL   : a matrix whose rows contain the left eigenvectors of A.

return values:
   E            if left and right are both false.
  (E, ER)       if right is true and left is false.
  (E, EL)       if left is true and right is false.
  (E, EL, ER)   if left and right are true.


examples:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])
  &gt;&gt;&gt; E, ER = mp.eig(A)
  &gt;&gt;&gt; print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))
  [0.0]
  [0.0]
  [0.0]

  &gt;&gt;&gt; E, EL, ER = mp.eig(A,left = True, right = True)
  &gt;&gt;&gt; E, EL, ER = mp.eig_sort(E, EL, ER)
  &gt;&gt;&gt; mp.nprint(E)
  [2.0, 4.0, 9.0]
  &gt;&gt;&gt; print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))
  [0.0]
  [0.0]
  [0.0]
  &gt;&gt;&gt; print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))
  [0.0  0.0  0.0]

warning:
 - If there are multiple eigenvalues, the eigenvectors do not necessarily
   span the whole vectorspace, i.e. ER and EL may have not full rank.
   Furthermore in that case the eigenvectors are numerical ill-conditioned.
 - In the general case the eigenvalues have no natural order.

see also:
  - eigh (or eigsy, eighe) for the symmetric eigenvalue problem.
  - eig_sort for sorting of eigenvalues and eigenvectors
</pre> 
</div>
</div>
<a id="aa5def1288bc22f3cf3ede27d67cf4afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5def1288bc22f3cf3ede27d67cf4afe">&#9670;&nbsp;</a></span>eig_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.eig_sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>EL</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ER</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em> = <code>&quot;real&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine sorts the eigenvalues and eigenvectors delivered by ``eig``.

parameters:
  E  : the eigenvalues as delivered by eig
  EL : the left  eigenvectors as delivered by eig, or false
  ER : the right eigenvectors as delivered by eig, or false
  f  : either a string ("real" sort by increasing real part, "imag" sort by
       increasing imag part, "abs" sort by absolute value) or a function
       mapping complexs to the reals, i.e. ``f = lambda x: -mp.re(x) ``
       would sort the eigenvalues by decreasing real part.

return values:
   E            if EL and ER are both false.
  (E, ER)       if ER is not false and left is false.
  (E, EL)       if EL is not false and right is false.
  (E, EL, ER)   if EL and ER are not false.

example:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])
  &gt;&gt;&gt; E, EL, ER = mp.eig(A,left = True, right = True)
  &gt;&gt;&gt; E, EL, ER = mp.eig_sort(E, EL, ER)
  &gt;&gt;&gt; mp.nprint(E)
  [2.0, 4.0, 9.0]
  &gt;&gt;&gt; E, EL, ER = mp.eig_sort(E, EL, ER,f = lambda x: -mp.re(x))
  &gt;&gt;&gt; mp.nprint(E)
  [9.0, 4.0, 2.0]
  &gt;&gt;&gt; print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))
  [0.0]
  [0.0]
  [0.0]
  &gt;&gt;&gt; print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))
  [0.0  0.0  0.0]
</pre> 
</div>
</div>
<a id="a89d035f75ef101cdf0b2cfdc9918f93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d035f75ef101cdf0b2cfdc9918f93b">&#9670;&nbsp;</a></span>eig_tr_l()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.eig_tr_l </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine calculates the left eigenvectors of an upper right triangular matrix.

input:
  A      an upper right triangular matrix

output:
  EL     a matrix whose rows form the left eigenvectors of A

return value:  EL
</pre> 
</div>
</div>
<a id="a1056b37f8b6dc4bde4a1f4e01d5ecb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1056b37f8b6dc4bde4a1f4e01d5ecb84">&#9670;&nbsp;</a></span>eig_tr_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.eig_tr_r </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine calculates the right eigenvectors of an upper right triangular matrix.

input:
  A      an upper right triangular matrix

output:
  ER     a matrix whose columns form the right eigenvectors of A

return value: ER
</pre> 
</div>
</div>
<a id="aa9e258bdee4d4e8d99fb84712549ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e258bdee4d4e8d99fb84712549ccf9">&#9670;&nbsp;</a></span>hessenberg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.hessenberg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the Hessenberg decomposition of a square matrix A.
Given A, an unitary matrix Q is determined such that

      Q' A Q = H                and               Q' Q = Q Q' = 1

where H is an upper right Hessenberg matrix. Here ' denotes the hermitian
transpose (i.e. transposition and conjugation).

input:
  A            : a real or complex square matrix
  overwrite_a  : if true, allows modification of A which may improve
                 performance. if false, A is not modified.

output:
  Q : an unitary matrix
  H : an upper right Hessenberg matrix

example:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])
  &gt;&gt;&gt; Q, H = mp.hessenberg(A)
  &gt;&gt;&gt; mp.nprint(H, 3) # doctest:+SKIP
  [  3.15  2.23  4.44]
  [-0.769  4.85  3.05]
  [   0.0  3.61   7.0]
  &gt;&gt;&gt; print(mp.chop(A - Q * H * Q.transpose_conj()))
  [0.0  0.0  0.0]
  [0.0  0.0  0.0]
  [0.0  0.0  0.0]

return value:   (Q, H)
</pre> 
</div>
</div>
<a id="a17e18b3d37688da8948b69857eb6f6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e18b3d37688da8948b69857eb6f6d1">&#9670;&nbsp;</a></span>hessenberg_qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.hessenberg_qr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the Schur decomposition of an upper Hessenberg matrix A.
Given A, an unitary matrix Q is determined such that

      Q' A Q = R                   and                  Q' Q = Q Q' = 1

where R is an upper right triangular matrix. Here ' denotes the hermitian
transpose (i.e. transposition and conjugation).

parameters:
  A         (input/output) On input, A contains an upper Hessenberg matrix.
            On output, A is replace by the upper right triangluar matrix R.

  Q         (input/output) The parameter Q is multiplied by the unitary
            matrix Q arising from the Schur decomposition. Q can also be
            false, in which case the unitary matrix Q is not computated.
</pre> 
</div>
</div>
<a id="a2573e43b9be86006ccafdf47bc54abc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2573e43b9be86006ccafdf47bc54abc8">&#9670;&nbsp;</a></span>hessenberg_reduce_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.hessenberg_reduce_0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the (upper) Hessenberg decomposition of a square matrix A.
Given A, an unitary matrix Q is calculated such that

           Q' A Q = H              and             Q' Q = Q Q' = 1

where H is an upper Hessenberg matrix, meaning that it only contains zeros
below the first subdiagonal. Here ' denotes the hermitian transpose (i.e.
transposition and conjugation).

parameters:
  A         (input/output) On input, A contains the square matrix A of
            dimension (n,n). On output, A contains a compressed representation
            of Q and H.
  T         (output) An array of length n containing the first elements of
            the Householder reflectors.
</pre> 
</div>
</div>
<a id="a991256b9daadc6de1eb1ddf12a43972e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991256b9daadc6de1eb1ddf12a43972e">&#9670;&nbsp;</a></span>hessenberg_reduce_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.hessenberg_reduce_1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine forms the unitary matrix Q described in hessenberg_reduce_0.

parameters:
  A    (input/output) On input, A is the same matrix as delivered by
       hessenberg_reduce_0. On output, A is set to Q.

  T    (input) On input, T is the same array as delivered by hessenberg_reduce_0.
</pre> 
</div>
</div>
<a id="a35fbb3a02bc44e9030cfd7a2bcc6e783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fbb3a02bc44e9030cfd7a2bcc6e783">&#9670;&nbsp;</a></span>qr_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.qr_step </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This subroutine executes a single implicitly shifted QR step applied to an
upper Hessenberg matrix A. Given A and shift as input, first an QR
decomposition is calculated:

  Q R = A - shift * 1 .

The output is then following matrix:

  R Q + shift * 1

parameters:
  n0, n1    (input) Two integers which specify the submatrix A[n0:n1,n0:n1]
            on which this subroutine operators. The subdiagonal elements
            to the left and below this submatrix must be deflated (i.e. zero).
            following restriction is imposed: n1&gt;=n0+2
  A         (input/output) On input, A is an upper Hessenberg matrix.
            On output, A is replaced by "R Q + shift * 1"
  Q         (input/output) The parameter Q is multiplied by the unitary matrix
            Q arising from the QR decomposition. Q can also be false, in which
            case the unitary matrix Q is not computated.
  shift     (input) a complex number specifying the shift. idealy close to an
            eigenvalue of the bottemmost part of the submatrix A[n0:n1,n0:n1].

references:
  Stoer, Bulirsch - Introduction to Numerical Analysis.
  Kresser : Numerical Methods for General and Structured Eigenvalue Problems
</pre> 
</div>
</div>
<a id="a91ad30b8064eac9c1383cabba0ed794a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ad30b8064eac9c1383cabba0ed794a">&#9670;&nbsp;</a></span>schur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.eigen.schur </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_a</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This routine computes the Schur decomposition of a square matrix A.
Given A, an unitary matrix Q is determined such that

      Q' A Q = R                and               Q' Q = Q Q' = 1

where R is an upper right triangular matrix. Here ' denotes the
hermitian transpose (i.e. transposition and conjugation).

input:
  A            : a real or complex square matrix
  overwrite_a  : if true, allows modification of A which may improve
                 performance. if false, A is not modified.

output:
  Q : an unitary matrix
  R : an upper right triangular matrix

return value:   (Q, R)

example:
  &gt;&gt;&gt; from mpmath import mp
  &gt;&gt;&gt; A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])
  &gt;&gt;&gt; Q, R = mp.schur(A)
  &gt;&gt;&gt; mp.nprint(R, 3) # doctest:+SKIP
  [2.0  0.417  -2.53]
  [0.0    4.0  -4.74]
  [0.0    0.0    9.0]
  &gt;&gt;&gt; print(mp.chop(A - Q * R * Q.transpose_conj()))
  [0.0  0.0  0.0]
  [0.0  0.0  0.0]
  [0.0  0.0  0.0]

warning: The Schur decomposition is not unique.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
