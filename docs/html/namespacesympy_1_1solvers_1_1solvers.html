<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.solvers.solvers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html">solvers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.solvers.solvers Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6273d25d2aa704b47294dac589b0c53e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a6273d25d2aa704b47294dac589b0c53e">denoms</a> (eq, *<a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a01cdf5f6564661f6499a5b8395ede8ca">symbols</a>)</td></tr>
<tr class="separator:a6273d25d2aa704b47294dac589b0c53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cd6ea41b58fa55f97b5310e63e6a61"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#ad2cd6ea41b58fa55f97b5310e63e6a61">checksol</a> (f, symbol, sol=None, **flags)</td></tr>
<tr class="separator:ad2cd6ea41b58fa55f97b5310e63e6a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f1a5e3ac4aebf31835baffc73cde3b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a11f1a5e3ac4aebf31835baffc73cde3b">solve</a> (f, *<a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a01cdf5f6564661f6499a5b8395ede8ca">symbols</a>, **flags)</td></tr>
<tr class="separator:a11f1a5e3ac4aebf31835baffc73cde3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfb6b564f84b65cb4cce59ecc31815f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#adbfb6b564f84b65cb4cce59ecc31815f">solve_linear</a> (lhs, rhs=0, <a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a01cdf5f6564661f6499a5b8395ede8ca">symbols</a>=[], exclude=[])</td></tr>
<tr class="separator:adbfb6b564f84b65cb4cce59ecc31815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398c14d188192cdd170c01aad7fb5ec7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a398c14d188192cdd170c01aad7fb5ec7">minsolve_linear_system</a> (system, *<a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a01cdf5f6564661f6499a5b8395ede8ca">symbols</a>, **flags)</td></tr>
<tr class="separator:a398c14d188192cdd170c01aad7fb5ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151a13ea1786e027969ecb56870950cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a151a13ea1786e027969ecb56870950cd">solve_linear_system</a> (system, *<a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a01cdf5f6564661f6499a5b8395ede8ca">symbols</a>, **flags)</td></tr>
<tr class="separator:a151a13ea1786e027969ecb56870950cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930214140ad6ff8bc2b5df4be9429c2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a930214140ad6ff8bc2b5df4be9429c2e">solve_undetermined_coeffs</a> (equ, coeffs, *syms, **flags)</td></tr>
<tr class="separator:a930214140ad6ff8bc2b5df4be9429c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de5d6d3687d71b805422e69cb76e7f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a8de5d6d3687d71b805422e69cb76e7f8">solve_linear_system_LU</a> (matrix, syms)</td></tr>
<tr class="separator:a8de5d6d3687d71b805422e69cb76e7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca91a147a2cd903ec7b8a62c4d2d960"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a1ca91a147a2cd903ec7b8a62c4d2d960">det_perm</a> (M)</td></tr>
<tr class="separator:a1ca91a147a2cd903ec7b8a62c4d2d960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d116bb34678561bb2a0454d64c0aba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#ab6d116bb34678561bb2a0454d64c0aba">det_minor</a> (M)</td></tr>
<tr class="separator:ab6d116bb34678561bb2a0454d64c0aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488809b297a232d13eb8eefff398c7d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a488809b297a232d13eb8eefff398c7d1">det_quick</a> (M, method=None)</td></tr>
<tr class="separator:a488809b297a232d13eb8eefff398c7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3949e8c212a3a9247a622f242221566d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a3949e8c212a3a9247a622f242221566d">inv_quick</a> (M)</td></tr>
<tr class="separator:a3949e8c212a3a9247a622f242221566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd24403c1dc82b5356c67cea0a0f9af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a2dd24403c1dc82b5356c67cea0a0f9af">nsolve</a> (*args, dict=False, **kwargs)</td></tr>
<tr class="separator:a2dd24403c1dc82b5356c67cea0a0f9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d1950bc054b0158368a4084c218f29"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a87d1950bc054b0158368a4084c218f29">unrad</a> (eq, *syms, **flags)</td></tr>
<tr class="separator:a87d1950bc054b0158368a4084c218f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a74d480c8c8222b9a1e03fa5f95b97f27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a74d480c8c8222b9a1e03fa5f95b97f27">orig</a></td></tr>
<tr class="separator:a74d480c8c8222b9a1e03fa5f95b97f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cdf5f6564661f6499a5b8395ede8ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a01cdf5f6564661f6499a5b8395ede8ca">symbols</a></td></tr>
<tr class="separator:a01cdf5f6564661f6499a5b8395ede8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2419221bfe9565ea013bd4ed066b6c59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a2419221bfe9565ea013bd4ed066b6c59">swap_sym</a></td></tr>
<tr class="separator:a2419221bfe9565ea013bd4ed066b6c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4a9ab7bb876bcd4521d14f45f89655"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#abb4a9ab7bb876bcd4521d14f45f89655">i</a></td></tr>
<tr class="separator:abb4a9ab7bb876bcd4521d14f45f89655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4aa281b3ecea7db17ab9d28a5bad98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a7b4aa281b3ecea7db17ab9d28a5bad98">new_f</a></td></tr>
<tr class="separator:a7b4aa281b3ecea7db17ab9d28a5bad98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216a760b792b75fd1ed3a18d8a853d9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a216a760b792b75fd1ed3a18d8a853d9c">isubs</a></td></tr>
<tr class="separator:a216a760b792b75fd1ed3a18d8a853d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c97a9012c215b1a882a86f99cd93c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#a8f3c97a9012c215b1a882a86f99cd93c">restore</a></td></tr>
<tr class="separator:a8f3c97a9012c215b1a882a86f99cd93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5a7c9ff87be94c0e09c998e9c1f6b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solvers.html#abf5a7c9ff87be94c0e09c998e9c1f6b8">multi_inverses</a></td></tr>
<tr class="separator:abf5a7c9ff87be94c0e09c998e9c1f6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module contain solvers for all kinds of equations:

    - algebraic or transcendental, use solve()

    - recurrence, use rsolve()

    - differential, use dsolve()

    - nonlinear (numerically), use nsolve()
      (you will need a good starting point)</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ad2cd6ea41b58fa55f97b5310e63e6a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cd6ea41b58fa55f97b5310e63e6a61">&#9670;&nbsp;</a></span>checksol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.checksol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks whether sol is a solution of equation f == 0.

Explanation
===========

Input can be either a single symbol and corresponding value
or a dictionary of symbols and values. When given as a dictionary
and flag ``simplify=True``, the values in the dictionary will be
simplified. *f* can be a single equation or an iterable of equations.
A solution must satisfy all equations in *f* to be considered valid;
if a solution does not satisfy any equation, False is returned; if one or
more checks are inconclusive (and none are False) then None is returned.

Examples
========

&gt;&gt;&gt; from sympy import checksol, symbols
&gt;&gt;&gt; x, y = symbols('x,y')
&gt;&gt;&gt; checksol(x**4 - 1, x, 1)
True
&gt;&gt;&gt; checksol(x**4 - 1, x, 0)
False
&gt;&gt;&gt; checksol(x**2 + y**2 - 5**2, {x: 3, y: 4})
True

To check if an expression is zero using ``checksol()``, pass it
as *f* and send an empty dictionary for *symbol*:

&gt;&gt;&gt; checksol(x**2 + x - x*(x + 1), {})
True

None is returned if ``checksol()`` could not conclude.

flags:
    'numerical=True (default)'
       do a fast numerical check if ``f`` has only one symbol.
    'minimal=True (default is False)'
       a very fast, minimal testing.
    'warn=True (default is False)'
       show a warning if checksol() could not conclude.
    'simplify=True (default)'
       simplify solution before substituting into function and
       simplify the function before trying specific simplifications
    'force=True (default is False)'
       make positive all symbols without assumptions regarding sign.</pre> 
</div>
</div>
<a id="a6273d25d2aa704b47294dac589b0c53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6273d25d2aa704b47294dac589b0c53e">&#9670;&nbsp;</a></span>denoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.denoms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (recursively) set of all denominators that appear in *eq*
that contain any symbol in *symbols*; if *symbols* are not
provided then all denominators will be returned.

Examples
========

&gt;&gt;&gt; from sympy.solvers.solvers import denoms
&gt;&gt;&gt; from sympy.abc import x, y, z

&gt;&gt;&gt; denoms(x/y)
{y}

&gt;&gt;&gt; denoms(x/(y*z))
{y, z}

&gt;&gt;&gt; denoms(3/x + y/z)
{x, z}

&gt;&gt;&gt; denoms(x/2 + y/z)
{2, z}

If *symbols* are provided then only denominators containing
those symbols will be returned:

&gt;&gt;&gt; denoms(1/x + 1/y + 1/z, y, z)
{y, z}</pre> 
</div>
</div>
<a id="ab6d116bb34678561bb2a0454d64c0aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d116bb34678561bb2a0454d64c0aba">&#9670;&nbsp;</a></span>det_minor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.det_minor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the ``det(M)`` computed from minors without
introducing new nesting in products.

See Also
========

det_perm
det_quick</pre> 
</div>
</div>
<a id="a1ca91a147a2cd903ec7b8a62c4d2d960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca91a147a2cd903ec7b8a62c4d2d960">&#9670;&nbsp;</a></span>det_perm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.det_perm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the determinant of *M* by using permutations to select factors.

Explanation
===========

For sizes larger than 8 the number of permutations becomes prohibitively
large, or if there are no symbols in the matrix, it is better to use the
standard determinant routines (e.g., ``M.det()``.)

See Also
========

det_minor
det_quick</pre> 
</div>
</div>
<a id="a488809b297a232d13eb8eefff398c7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488809b297a232d13eb8eefff398c7d1">&#9670;&nbsp;</a></span>det_quick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.det_quick </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``det(M)`` assuming that either
there are lots of zeros or the size of the matrix
is small. If this assumption is not met, then the normal
Matrix.det function will be used with method = ``method``.

See Also
========

det_minor
det_perm</pre> 
</div>
</div>
<a id="a3949e8c212a3a9247a622f242221566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3949e8c212a3a9247a622f242221566d">&#9670;&nbsp;</a></span>inv_quick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.inv_quick </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the inverse of ``M``, assuming that either
there are lots of zeros or the size of the matrix
is small.
</pre> 
</div>
</div>
<a id="a398c14d188192cdd170c01aad7fb5ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398c14d188192cdd170c01aad7fb5ec7">&#9670;&nbsp;</a></span>minsolve_linear_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.minsolve_linear_system </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a particular solution to a linear system.

Explanation
===========

In particular, try to find a solution with the minimal possible number
of non-zero variables using a naive algorithm with exponential complexity.
If ``quick=True``, a heuristic is used.</pre> 
</div>
</div>
<a id="a2dd24403c1dc82b5356c67cea0a0f9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd24403c1dc82b5356c67cea0a0f9af">&#9670;&nbsp;</a></span>nsolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.nsolve </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a nonlinear equation system numerically: ``nsolve(f, [args,] x0,
modules=['mpmath'], **kwargs)``.

Explanation
===========

``f`` is a vector function of symbolic expressions representing the system.
*args* are the variables. If there is only one variable, this argument can
be omitted. ``x0`` is a starting vector close to a solution.

Use the modules keyword to specify which modules should be used to
evaluate the function and the Jacobian matrix. Make sure to use a module
that supports matrices. For more information on the syntax, please see the
docstring of ``lambdify``.

If the keyword arguments contain ``dict=True`` (default is False) ``nsolve``
will return a list (perhaps empty) of solution mappings. This might be
especially useful if you want to use ``nsolve`` as a fallback to solve since
using the dict argument for both methods produces return values of
consistent type structure. Please note: to keep this consistent with
``solve``, the solution will be returned in a list even though ``nsolve``
(currently at least) only finds one solution at a time.

Overdetermined systems are supported.

Examples
========

&gt;&gt;&gt; from sympy import Symbol, nsolve
&gt;&gt;&gt; import mpmath
&gt;&gt;&gt; mpmath.mp.dps = 15
&gt;&gt;&gt; x1 = Symbol('x1')
&gt;&gt;&gt; x2 = Symbol('x2')
&gt;&gt;&gt; f1 = 3 * x1**2 - 2 * x2**2 - 1
&gt;&gt;&gt; f2 = x1**2 - 2 * x1 + x2**2 + 2 * x2 - 8
&gt;&gt;&gt; print(nsolve((f1, f2), (x1, x2), (-1, 1)))
Matrix([[-1.19287309935246], [1.27844411169911]])

For one-dimensional functions the syntax is simplified:

&gt;&gt;&gt; from sympy import sin, nsolve
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; nsolve(sin(x), x, 2)
3.14159265358979
&gt;&gt;&gt; nsolve(sin(x), 2)
3.14159265358979

To solve with higher precision than the default, use the prec argument:

&gt;&gt;&gt; from sympy import cos
&gt;&gt;&gt; nsolve(cos(x) - x, 1)
0.739085133215161
&gt;&gt;&gt; nsolve(cos(x) - x, 1, prec=50)
0.73908513321516064165531208767387340401341175890076
&gt;&gt;&gt; cos(_)
0.73908513321516064165531208767387340401341175890076

To solve for complex roots of real functions, a nonreal initial point
must be specified:

&gt;&gt;&gt; from sympy import I
&gt;&gt;&gt; nsolve(x**2 + 2, I)
1.4142135623731*I

``mpmath.findroot`` is used and you can find their more extensive
documentation, especially concerning keyword parameters and
available solvers. Note, however, that functions which are very
steep near the root, the verification of the solution may fail. In
this case you should use the flag ``verify=False`` and
independently verify the solution.

&gt;&gt;&gt; from sympy import cos, cosh
&gt;&gt;&gt; f = cos(x)*cosh(x) - 1
&gt;&gt;&gt; nsolve(f, 3.14*100)
Traceback (most recent call last):
...
ValueError: Could not find root within given tolerance. (1.39267e+230 &gt; 2.1684e-19)
&gt;&gt;&gt; ans = nsolve(f, 3.14*100, verify=False); ans
312.588469032184
&gt;&gt;&gt; f.subs(x, ans).n(2)
2.1e+121
&gt;&gt;&gt; (f/f.diff(x)).subs(x, ans).n(2)
7.4e-15

One might safely skip the verification if bounds of the root are known
and a bisection method is used:

&gt;&gt;&gt; bounds = lambda i: (3.14*i, 3.14*(i + 1))
&gt;&gt;&gt; nsolve(f, bounds(100), solver='bisect', verify=False)
315.730061685774

Alternatively, a function may be better behaved when the
denominator is ignored. Since this is not always the case, however,
the decision of what function to use is left to the discretion of
the user.

&gt;&gt;&gt; eq = x**2/(1 - x)/(1 - 2*x)**2 - 100
&gt;&gt;&gt; nsolve(eq, 0.46)
Traceback (most recent call last):
...
ValueError: Could not find root within given tolerance. (10000 &gt; 2.1684e-19)
Try another starting point or tweak arguments.
&gt;&gt;&gt; nsolve(eq.as_numer_denom()[0], 0.46)
0.46792545969349058</pre> 
</div>
</div>
<a id="a11f1a5e3ac4aebf31835baffc73cde3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f1a5e3ac4aebf31835baffc73cde3b">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Algebraically solves equations and systems of equations.

Explanation
===========

Currently supported:
    - polynomial
    - transcendental
    - piecewise combinations of the above
    - systems of linear and polynomial equations
    - systems containing relational expressions
    - systems implied by undetermined coefficients

Examples
========

The default output varies according to the input and might
be a list (possibly empty), a dictionary, a list of
dictionaries or tuples, or an expression involving relationals.
For specifics regarding different forms of output that may appear, see :ref:`solve_output`.
Let it suffice here to say that to obtain a uniform output from
`solve` use ``dict=True`` or ``set=True`` (see below).

    &gt;&gt;&gt; from sympy import solve, Poly, Eq, Matrix, Symbol
    &gt;&gt;&gt; from sympy.abc import x, y, z, a, b

The expressions that are passed can be Expr, Equality, or Poly
classes (or lists of the same); a Matrix is considered to be a
list of all the elements of the matrix:

    &gt;&gt;&gt; solve(x - 3, x)
    [3]
    &gt;&gt;&gt; solve(Eq(x, 3), x)
    [3]
    &gt;&gt;&gt; solve(Poly(x - 3), x)
    [3]
    &gt;&gt;&gt; solve(Matrix([[x, x + y]]), x, y) == solve([x, x + y], x, y)
    True

If no symbols are indicated to be of interest and the equation is
univariate, a list of values is returned; otherwise, the keys in
a dictionary will indicate which (of all the variables used in
the expression(s)) variables and solutions were found:

    &gt;&gt;&gt; solve(x**2 - 4)
    [-2, 2]
    &gt;&gt;&gt; solve((x - a)*(y - b))
    [{a: x}, {b: y}]
    &gt;&gt;&gt; solve([x - 3, y - 1])
    {x: 3, y: 1}
    &gt;&gt;&gt; solve([x - 3, y**2 - 1])
    [{x: 3, y: -1}, {x: 3, y: 1}]

If you pass symbols for which solutions are sought, the output will vary
depending on the number of symbols you passed, whether you are passing
a list of expressions or not, and whether a linear system was solved.
Uniform output is attained by using ``dict=True`` or ``set=True``.

    &gt;&gt;&gt; #### *** feel free to skip to the stars below *** ####
    &gt;&gt;&gt; from sympy import TableForm
    &gt;&gt;&gt; h = [None, ';|;'.join(['e', 's', 'solve(e, s)', 'solve(e, s, dict=True)',
    ... 'solve(e, s, set=True)']).split(';')]
    &gt;&gt;&gt; t = []
    &gt;&gt;&gt; for e, s in [
    ...         (x - y, y),
    ...         (x - y, [x, y]),
    ...         (x**2 - y, [x, y]),
    ...         ([x - 3, y -1], [x, y]),
    ...         ]:
    ...     how = [{}, dict(dict=True), dict(set=True)]
    ...     res = [solve(e, s, **f) for f in how]
    ...     t.append([e, '|', s, '|'] + [res[0], '|', res[1], '|', res[2]])
    ...
    &gt;&gt;&gt; # ******************************************************* #
    &gt;&gt;&gt; TableForm(t, headings=h, alignments="&lt;")
    e              | s      | solve(e, s)  | solve(e, s, dict=True) | solve(e, s, set=True)
    ---------------------------------------------------------------------------------------
    x - y          | y      | [x]          | [{y: x}]               | ([y], {(x,)})
    x - y          | [x, y] | [(y, y)]     | [{x: y}]               | ([x, y], {(y, y)})
    x**2 - y       | [x, y] | [(x, x**2)]  | [{y: x**2}]            | ([x, y], {(x, x**2)})
    [x - 3, y - 1] | [x, y] | {x: 3, y: 1} | [{x: 3, y: 1}]         | ([x, y], {(3, 1)})

    * If any equation does not depend on the symbol(s) given, it will be
      eliminated from the equation set and an answer may be given
      implicitly in terms of variables that were not of interest:

        &gt;&gt;&gt; solve([x - y, y - 3], x)
        {x: y}

When you pass all but one of the free symbols, an attempt
is made to find a single solution based on the method of
undetermined coefficients. If it succeeds, a dictionary of values
is returned. If you want an algebraic solutions for one
or more of the symbols, pass the expression to be solved in a list:

    &gt;&gt;&gt; e = a*x + b - 2*x - 3
    &gt;&gt;&gt; solve(e, [a, b])
    {a: 2, b: 3}
    &gt;&gt;&gt; solve([e], [a, b])
    {a: -b/x + (2*x + 3)/x}

When there is no solution for any given symbol which will make all
expressions zero, the empty list is returned (or an empty set in
the tuple when ``set=True``):

    &gt;&gt;&gt; from sympy import sqrt
    &gt;&gt;&gt; solve(3, x)
    []
    &gt;&gt;&gt; solve(x - 3, y)
    []
    &gt;&gt;&gt; solve(sqrt(x) + 1, x, set=True)
    ([x], set())

When an object other than a Symbol is given as a symbol, it is
isolated algebraically and an implicit solution may be obtained.
This is mostly provided as a convenience to save you from replacing
the object with a Symbol and solving for that Symbol. It will only
work if the specified object can be replaced with a Symbol using the
subs method:

    &gt;&gt;&gt; from sympy import exp, Function
    &gt;&gt;&gt; f = Function('f')

    &gt;&gt;&gt; solve(f(x) - x, f(x))
    [x]
    &gt;&gt;&gt; solve(f(x).diff(x) - f(x) - x, f(x).diff(x))
    [x + f(x)]
    &gt;&gt;&gt; solve(f(x).diff(x) - f(x) - x, f(x))
    [-x + Derivative(f(x), x)]
    &gt;&gt;&gt; solve(x + exp(x)**2, exp(x), set=True)
    ([exp(x)], {(-sqrt(-x),), (sqrt(-x),)})

    &gt;&gt;&gt; from sympy import Indexed, IndexedBase, Tuple
    &gt;&gt;&gt; A = IndexedBase('A')
    &gt;&gt;&gt; eqs = Tuple(A[1] + A[2] - 3, A[1] - A[2] + 1)
    &gt;&gt;&gt; solve(eqs, eqs.atoms(Indexed))
    {A[1]: 1, A[2]: 2}

    * To solve for a function within a derivative, use :func:`~.dsolve`.

To solve for a symbol implicitly, use implicit=True:

    &gt;&gt;&gt; solve(x + exp(x), x)
    [-LambertW(1)]
    &gt;&gt;&gt; solve(x + exp(x), x, implicit=True)
    [-exp(x)]

It is possible to solve for anything in an expression that can be
replaced with a symbol using :obj:`~sympy.core.basic.Basic.subs`:

    &gt;&gt;&gt; solve(x + 2 + sqrt(3), x + 2)
    [-sqrt(3)]
    &gt;&gt;&gt; solve((x + 2 + sqrt(3), x + 4 + y), y, x + 2)
    {y: -2 + sqrt(3), x + 2: -sqrt(3)}

    * Nothing heroic is done in this implicit solving so you may end up
      with a symbol still in the solution:

        &gt;&gt;&gt; eqs = (x*y + 3*y + sqrt(3), x + 4 + y)
        &gt;&gt;&gt; solve(eqs, y, x + 2)
        {y: -sqrt(3)/(x + 3), x + 2: -2*x/(x + 3) - 6/(x + 3) + sqrt(3)/(x + 3)}
        &gt;&gt;&gt; solve(eqs, y*x, x)
        {x: -y - 4, x*y: -3*y - sqrt(3)}

    * If you attempt to solve for a number, remember that the number
      you have obtained does not necessarily mean that the value is
      equivalent to the expression obtained:

        &gt;&gt;&gt; solve(sqrt(2) - 1, 1)
        [sqrt(2)]
        &gt;&gt;&gt; solve(x - y + 1, 1)  # /!\ -1 is targeted, too
        [x/(y - 1)]
        &gt;&gt;&gt; [_.subs(z, -1) for _ in solve((x - y + 1).subs(-1, z), 1)]
        [-x + y]

**Additional Examples**

``solve()`` with check=True (default) will run through the symbol tags to
eliminate unwanted solutions. If no assumptions are included, all possible
solutions will be returned:

    &gt;&gt;&gt; x = Symbol("x")
    &gt;&gt;&gt; solve(x**2 - 1)
    [-1, 1]

By setting the ``positive`` flag, only one solution will be returned:

    &gt;&gt;&gt; pos = Symbol("pos", positive=True)
    &gt;&gt;&gt; solve(pos**2 - 1)
    [1]

When the solutions are checked, those that make any denominator zero
are automatically excluded. If you do not want to exclude such solutions,
then use the check=False option:

    &gt;&gt;&gt; from sympy import sin, limit
    &gt;&gt;&gt; solve(sin(x)/x)  # 0 is excluded
    [pi]

If ``check=False``, then a solution to the numerator being zero is found
but the value of $x = 0$ is a spurious solution since $\sin(x)/x$ has the well
known limit (without discontinuity) of 1 at $x = 0$:

    &gt;&gt;&gt; solve(sin(x)/x, check=False)
    [0, pi]

In the following case, however, the limit exists and is equal to the
value of $x = 0$ that is excluded when check=True:

    &gt;&gt;&gt; eq = x**2*(1/x - z**2/x)
    &gt;&gt;&gt; solve(eq, x)
    []
    &gt;&gt;&gt; solve(eq, x, check=False)
    [0]
    &gt;&gt;&gt; limit(eq, x, 0, '-')
    0
    &gt;&gt;&gt; limit(eq, x, 0, '+')
    0

**Solving Relationships**

When one or more expressions passed to ``solve`` is a relational,
a relational result is returned (and the ``dict`` and ``set`` flags
are ignored):

    &gt;&gt;&gt; solve(x &lt; 3)
    (-oo &lt; x) &amp; (x &lt; 3)
    &gt;&gt;&gt; solve([x &lt; 3, x**2 &gt; 4], x)
    ((-oo &lt; x) &amp; (x &lt; -2)) | ((2 &lt; x) &amp; (x &lt; 3))
    &gt;&gt;&gt; solve([x + y - 3, x &gt; 3], x)
    (3 &lt; x) &amp; (x &lt; oo) &amp; Eq(x, 3 - y)

Although checking of assumptions on symbols in relationals
is not done, setting assumptions will affect how certain
relationals might automatically simplify:

    &gt;&gt;&gt; solve(x**2 &gt; 4)
    ((-oo &lt; x) &amp; (x &lt; -2)) | ((2 &lt; x) &amp; (x &lt; oo))

    &gt;&gt;&gt; r = Symbol('r', real=True)
    &gt;&gt;&gt; solve(r**2 &gt; 4)
    (2 &lt; r) | (r &lt; -2)

There is currently no algorithm in SymPy that allows you to use
relationships to resolve more than one variable. So the following
does not determine that ``q &lt; 0`` (and trying to solve for ``r``
and ``q`` will raise an error):

    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; r, q = symbols('r, q', real=True)
    &gt;&gt;&gt; solve([r + q - 3, r &gt; 3], r)
    (3 &lt; r) &amp; Eq(r, 3 - q)

You can directly call the routine that ``solve`` calls
when it encounters a relational: :func:`~.reduce_inequalities`.
It treats Expr like Equality.

    &gt;&gt;&gt; from sympy import reduce_inequalities
    &gt;&gt;&gt; reduce_inequalities([x**2 - 4])
    Eq(x, -2) | Eq(x, 2)

If each relationship contains only one symbol of interest,
the expressions can be processed for multiple symbols:

    &gt;&gt;&gt; reduce_inequalities([0 &lt;= x  - 1, y &lt; 3], [x, y])
    (-oo &lt; y) &amp; (1 &lt;= x) &amp; (x &lt; oo) &amp; (y &lt; 3)

But an error is raised if any relationship has more than one
symbol of interest:

    &gt;&gt;&gt; reduce_inequalities([0 &lt;= x*y  - 1, y &lt; 3], [x, y])
    Traceback (most recent call last):
    ...
    NotImplementedError:
    inequality has more than one symbol of interest.

**Disabling High-Order Explicit Solutions**

When solving polynomial expressions, you might not want explicit solutions
(which can be quite long). If the expression is univariate, ``CRootOf``
instances will be returned instead:

    &gt;&gt;&gt; solve(x**3 - x + 1)
    [-1/((-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)) -
    (-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3,
    -(-1/2 + sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3 -
    1/((-1/2 + sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)),
    -(3*sqrt(69)/2 + 27/2)**(1/3)/3 -
    1/(3*sqrt(69)/2 + 27/2)**(1/3)]
    &gt;&gt;&gt; solve(x**3 - x + 1, cubics=False)
    [CRootOf(x**3 - x + 1, 0),
     CRootOf(x**3 - x + 1, 1),
     CRootOf(x**3 - x + 1, 2)]

If the expression is multivariate, no solution might be returned:

    &gt;&gt;&gt; solve(x**3 - x + a, x, cubics=False)
    []

Sometimes solutions will be obtained even when a flag is False because the
expression could be factored. In the following example, the equation can
be factored as the product of a linear and a quadratic factor so explicit
solutions (which did not require solving a cubic expression) are obtained:

    &gt;&gt;&gt; eq = x**3 + 3*x**2 + x - 1
    &gt;&gt;&gt; solve(eq, cubics=False)
    [-1, -1 + sqrt(2), -sqrt(2) - 1]

**Solving Equations Involving Radicals**

Because of SymPy's use of the principle root, some solutions
to radical equations will be missed unless check=False:

    &gt;&gt;&gt; from sympy import root
    &gt;&gt;&gt; eq = root(x**3 - 3*x**2, 3) + 1 - x
    &gt;&gt;&gt; solve(eq)
    []
    &gt;&gt;&gt; solve(eq, check=False)
    [1/3]

In the above example, there is only a single solution to the
equation. Other expressions will yield spurious roots which
must be checked manually; roots which give a negative argument
to odd-powered radicals will also need special checking:

    &gt;&gt;&gt; from sympy import real_root, S
    &gt;&gt;&gt; eq = root(x, 3) - root(x, 5) + S(1)/7
    &gt;&gt;&gt; solve(eq)  # this gives 2 solutions but misses a 3rd
    [CRootOf(7*x**5 - 7*x**3 + 1, 1)**15,
    CRootOf(7*x**5 - 7*x**3 + 1, 2)**15]
    &gt;&gt;&gt; sol = solve(eq, check=False)
    &gt;&gt;&gt; [abs(eq.subs(x,i).n(2)) for i in sol]
    [0.48, 0.e-110, 0.e-110, 0.052, 0.052]

The first solution is negative so ``real_root`` must be used to see that it
satisfies the expression:

    &gt;&gt;&gt; abs(real_root(eq.subs(x, sol[0])).n(2))
    0.e-110

If the roots of the equation are not real then more care will be
necessary to find the roots, especially for higher order equations.
Consider the following expression:

    &gt;&gt;&gt; expr = root(x, 3) - root(x, 5)

We will construct a known value for this expression at x = 3 by selecting
the 1-th root for each radical:

    &gt;&gt;&gt; expr1 = root(x, 3, 1) - root(x, 5, 1)
    &gt;&gt;&gt; v = expr1.subs(x, -3)

The ``solve`` function is unable to find any exact roots to this equation:

    &gt;&gt;&gt; eq = Eq(expr, v); eq1 = Eq(expr1, v)
    &gt;&gt;&gt; solve(eq, check=False), solve(eq1, check=False)
    ([], [])

The function ``unrad``, however, can be used to get a form of the equation
for which numerical roots can be found:

    &gt;&gt;&gt; from sympy.solvers.solvers import unrad
    &gt;&gt;&gt; from sympy import nroots
    &gt;&gt;&gt; e, (p, cov) = unrad(eq)
    &gt;&gt;&gt; pvals = nroots(e)
    &gt;&gt;&gt; inversion = solve(cov, x)[0]
    &gt;&gt;&gt; xvals = [inversion.subs(p, i) for i in pvals]

Although ``eq`` or ``eq1`` could have been used to find ``xvals``, the
solution can only be verified with ``expr1``:

    &gt;&gt;&gt; z = expr - v
    &gt;&gt;&gt; [xi.n(chop=1e-9) for xi in xvals if abs(z.subs(x, xi).n()) &lt; 1e-9]
    []
    &gt;&gt;&gt; z1 = expr1 - v
    &gt;&gt;&gt; [xi.n(chop=1e-9) for xi in xvals if abs(z1.subs(x, xi).n()) &lt; 1e-9]
    [-3.0]

Parameters
==========

f :
    - a single Expr or Poly that must be zero
    - an Equality
    - a Relational expression
    - a Boolean
    - iterable of one or more of the above

symbols : (object(s) to solve for) specified as
    - none given (other non-numeric objects will be used)
    - single symbol
    - denested list of symbols
      (e.g., ``solve(f, x, y)``)
    - ordered iterable of symbols
      (e.g., ``solve(f, [x, y])``)

flags :
    dict=True (default is False)
        Return list (perhaps empty) of solution mappings.
    set=True (default is False)
        Return list of symbols and set of tuple(s) of solution(s).
    exclude=[] (default)
        Do not try to solve for any of the free symbols in exclude;
        if expressions are given, the free symbols in them will
        be extracted automatically.
    check=True (default)
        If False, do not do any testing of solutions. This can be
        useful if you want to include solutions that make any
        denominator zero.
    numerical=True (default)
        Do a fast numerical check if *f* has only one symbol.
    minimal=True (default is False)
        A very fast, minimal testing.
    warn=True (default is False)
        Show a warning if ``checksol()`` could not conclude.
    simplify=True (default)
        Simplify all but polynomials of order 3 or greater before
        returning them and (if check is not False) use the
        general simplify function on the solutions and the
        expression obtained when they are substituted into the
        function which should be zero.
    force=True (default is False)
        Make positive all symbols without assumptions regarding sign.
    rational=True (default)
        Recast Floats as Rational; if this option is not used, the
        system containing Floats may fail to solve because of issues
        with polys. If rational=None, Floats will be recast as
        rationals but the answer will be recast as Floats. If the
        flag is False then nothing will be done to the Floats.
    manual=True (default is False)
        Do not use the polys/matrix method to solve a system of
        equations, solve them one at a time as you might "manually."
    implicit=True (default is False)
        Allows ``solve`` to return a solution for a pattern in terms of
        other functions that contain that pattern; this is only
        needed if the pattern is inside of some invertible function
        like cos, exp, ect.
    particular=True (default is False)
        Instructs ``solve`` to try to find a particular solution to
        a linear system with as many zeros as possible; this is very
        expensive.
    quick=True (default is False; ``particular`` must be True)
        Selects a fast heuristic to find a solution with many zeros
        whereas a value of False uses the very slow method guaranteed
        to find the largest number of zeros possible.
    cubics=True (default)
        Return explicit solutions when cubic expressions are encountered.
        When False, quartics and quintics are disabled, too.
    quartics=True (default)
        Return explicit solutions when quartic expressions are encountered.
        When False, quintics are disabled, too.
    quintics=True (default)
        Return explicit solutions (if possible) when quintic expressions
        are encountered.

See Also
========

rsolve: For solving recurrence relationships
dsolve: For solving differential equations</pre> 
</div>
</div>
<a id="adbfb6b564f84b65cb4cce59ecc31815f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfb6b564f84b65cb4cce59ecc31815f">&#9670;&nbsp;</a></span>solve_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.solve_linear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rhs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exclude</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a tuple derived from ``f = lhs - rhs`` that is one of
the following: ``(0, 1)``, ``(0, 0)``, ``(symbol, solution)``, ``(n, d)``.

Explanation
===========

``(0, 1)`` meaning that ``f`` is independent of the symbols in *symbols*
that are not in *exclude*.

``(0, 0)`` meaning that there is no solution to the equation amongst the
symbols given. If the first element of the tuple is not zero, then the
function is guaranteed to be dependent on a symbol in *symbols*.

``(symbol, solution)`` where symbol appears linearly in the numerator of
``f``, is in *symbols* (if given), and is not in *exclude* (if given). No
simplification is done to ``f`` other than a ``mul=True`` expansion, so the
solution will correspond strictly to a unique solution.

``(n, d)`` where ``n`` and ``d`` are the numerator and denominator of ``f``
when the numerator was not linear in any symbol of interest; ``n`` will
never be a symbol unless a solution for that symbol was found (in which case
the second element is the solution, not the denominator).

Examples
========

&gt;&gt;&gt; from sympy import cancel, Pow

``f`` is independent of the symbols in *symbols* that are not in
*exclude*:

&gt;&gt;&gt; from sympy import cos, sin, solve_linear
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; eq = y*cos(x)**2 + y*sin(x)**2 - y  # = y*(1 - 1) = 0
&gt;&gt;&gt; solve_linear(eq)
(0, 1)
&gt;&gt;&gt; eq = cos(x)**2 + sin(x)**2  # = 1
&gt;&gt;&gt; solve_linear(eq)
(0, 1)
&gt;&gt;&gt; solve_linear(x, exclude=[x])
(0, 1)

The variable ``x`` appears as a linear variable in each of the
following:

&gt;&gt;&gt; solve_linear(x + y**2)
(x, -y**2)
&gt;&gt;&gt; solve_linear(1/x - y**2)
(x, y**(-2))

When not linear in ``x`` or ``y`` then the numerator and denominator are
returned:

&gt;&gt;&gt; solve_linear(x**2/y**2 - 3)
(x**2 - 3*y**2, y**2)

If the numerator of the expression is a symbol, then ``(0, 0)`` is
returned if the solution for that symbol would have set any
denominator to 0:

&gt;&gt;&gt; eq = 1/(1/x - 2)
&gt;&gt;&gt; eq.as_numer_denom()
(x, 1 - 2*x)
&gt;&gt;&gt; solve_linear(eq)
(0, 0)

But automatic rewriting may cause a symbol in the denominator to
appear in the numerator so a solution will be returned:

&gt;&gt;&gt; (1/x)**-1
x
&gt;&gt;&gt; solve_linear((1/x)**-1)
(x, 0)

Use an unevaluated expression to avoid this:

&gt;&gt;&gt; solve_linear(Pow(1/x, -1, evaluate=False))
(0, 0)

If ``x`` is allowed to cancel in the following expression, then it
appears to be linear in ``x``, but this sort of cancellation is not
done by ``solve_linear`` so the solution will always satisfy the
original expression without causing a division by zero error.

&gt;&gt;&gt; eq = x**2*(1/x - z**2/x)
&gt;&gt;&gt; solve_linear(cancel(eq))
(x, 0)
&gt;&gt;&gt; solve_linear(eq)
(x**2*(1 - z**2), x)

A list of symbols for which a solution is desired may be given:

&gt;&gt;&gt; solve_linear(x + y + z, symbols=[y])
(y, -x - z)

A list of symbols to ignore may also be given:

&gt;&gt;&gt; solve_linear(x + y + z, exclude=[x])
(y, -x - z)

(A solution for ``y`` is obtained because it is the first variable
from the canonically sorted list of symbols that had a linear
solution.)</pre> 
</div>
</div>
<a id="a151a13ea1786e027969ecb56870950cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151a13ea1786e027969ecb56870950cd">&#9670;&nbsp;</a></span>solve_linear_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.solve_linear_system </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve system of $N$ linear equations with $M$ variables, which means
both under- and overdetermined systems are supported.

Explanation
===========

The possible number of solutions is zero, one, or infinite. Respectively,
this procedure will return None or a dictionary with solutions. In the
case of underdetermined systems, all arbitrary parameters are skipped.
This may cause a situation in which an empty dictionary is returned.
In that case, all symbols can be assigned arbitrary values.

Input to this function is a $N\times M + 1$ matrix, which means it has
to be in augmented form. If you prefer to enter $N$ equations and $M$
unknowns then use ``solve(Neqs, *Msymbols)`` instead. Note: a local
copy of the matrix is made by this routine so the matrix that is
passed will not be modified.

The algorithm used here is fraction-free Gaussian elimination,
which results, after elimination, in an upper-triangular matrix.
Then solutions are found using back-substitution. This approach
is more efficient and compact than the Gauss-Jordan method.

Examples
========

&gt;&gt;&gt; from sympy import Matrix, solve_linear_system
&gt;&gt;&gt; from sympy.abc import x, y

Solve the following system::

       x + 4 y ==  2
    -2 x +   y == 14

&gt;&gt;&gt; system = Matrix(( (1, 4, 2), (-2, 1, 14)))
&gt;&gt;&gt; solve_linear_system(system, x, y)
{x: -6, y: 2}

A degenerate system returns an empty dictionary:

&gt;&gt;&gt; system = Matrix(( (0,0,0), (0,0,0) ))
&gt;&gt;&gt; solve_linear_system(system, x, y)
{}</pre> 
</div>
</div>
<a id="a8de5d6d3687d71b805422e69cb76e7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de5d6d3687d71b805422e69cb76e7f8">&#9670;&nbsp;</a></span>solve_linear_system_LU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.solve_linear_system_LU </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>syms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the augmented matrix system using ``LUsolve`` and returns a
dictionary in which solutions are keyed to the symbols of *syms* as ordered.

Explanation
===========

The matrix must be invertible.

Examples
========

&gt;&gt;&gt; from sympy import Matrix, solve_linear_system_LU
&gt;&gt;&gt; from sympy.abc import x, y, z

&gt;&gt;&gt; solve_linear_system_LU(Matrix([
... [1, 2, 0, 1],
... [3, 2, 2, 1],
... [2, 0, 0, 1]]), [x, y, z])
{x: 1/2, y: 1/4, z: -1/2}

See Also
========

LUsolve</pre> 
</div>
</div>
<a id="a930214140ad6ff8bc2b5df4be9429c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930214140ad6ff8bc2b5df4be9429c2e">&#9670;&nbsp;</a></span>solve_undetermined_coeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.solve_undetermined_coeffs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a system of equations in $k$ parameters that is formed by
matching coefficients in variables ``coeffs`` that are on
factors dependent on the remaining variables (or those given
explicitly by ``syms``.

Explanation
===========

The result of this function is a dictionary with symbolic values of those
parameters with respect to coefficients in $q$ -- empty if there
is no solution or coefficients do not appear in the equation -- else
None (if the system was not recognized). If there is more than one
solution, the solutions are passed as a list. The output can be modified using
the same semantics as for `solve` since the flags that are passed are sent
directly to `solve` so, for example the flag ``dict=True`` will always return a list
of solutions as dictionaries.

This function accepts both Equality and Expr class instances.
The solving process is most efficient when symbols are specified
in addition to parameters to be determined,  but an attempt to
determine them (if absent) will be made. If an expected solution is not
obtained (and symbols were not specified) try specifying them.

Examples
========

&gt;&gt;&gt; from sympy import Eq, solve_undetermined_coeffs
&gt;&gt;&gt; from sympy.abc import a, b, c, h, p, k, x, y

&gt;&gt;&gt; solve_undetermined_coeffs(Eq(a*x + a + b, x/2), [a, b], x)
{a: 1/2, b: -1/2}
&gt;&gt;&gt; solve_undetermined_coeffs(a - 2, [a])
{a: 2}

The equation can be nonlinear in the symbols:

&gt;&gt;&gt; X, Y, Z = y, x**y, y*x**y
&gt;&gt;&gt; eq = a*X + b*Y + c*Z - X - 2*Y - 3*Z
&gt;&gt;&gt; coeffs = a, b, c
&gt;&gt;&gt; syms = x, y
&gt;&gt;&gt; solve_undetermined_coeffs(eq, coeffs, syms)
{a: 1, b: 2, c: 3}

And the system can be nonlinear in coefficients, too, but if
there is only a single solution, it will be returned as a
dictionary:

&gt;&gt;&gt; eq = a*x**2 + b*x + c - ((x - h)**2 + 4*p*k)/4/p
&gt;&gt;&gt; solve_undetermined_coeffs(eq, (h, p, k), x)
{h: -b/(2*a), k: (4*a*c - b**2)/(4*a), p: 1/(4*a)}

Multiple solutions are always returned in a list:

&gt;&gt;&gt; solve_undetermined_coeffs(a**2*x + b - x, [a, b], x)
[{a: -1, b: 0}, {a: 1, b: 0}]

Using flag ``dict=True`` (in keeping with semantics in :func:`~.solve`)
will force the result to always be a list with any solutions
as elements in that list.

&gt;&gt;&gt; solve_undetermined_coeffs(a*x - 2*x, [a], dict=True)
[{a: 2}]
</pre> 
</div>
</div>
<a id="a87d1950bc054b0158368a4084c218f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d1950bc054b0158368a4084c218f29">&#9670;&nbsp;</a></span>unrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solvers.unrad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove radicals with symbolic arguments and return (eq, cov),
None, or raise an error.

Explanation
===========

None is returned if there are no radicals to remove.

NotImplementedError is raised if there are radicals and they cannot be
removed or if the relationship between the original symbols and the
change of variable needed to rewrite the system as a polynomial cannot
be solved.

Otherwise the tuple, ``(eq, cov)``, is returned where:

*eq*, ``cov``
    *eq* is an equation without radicals (in the symbol(s) of
    interest) whose solutions are a superset of the solutions to the
    original expression. *eq* might be rewritten in terms of a new
    variable; the relationship to the original variables is given by
    ``cov`` which is a list containing ``v`` and ``v**p - b`` where
    ``p`` is the power needed to clear the radical and ``b`` is the
    radical now expressed as a polynomial in the symbols of interest.
    For example, for sqrt(2 - x) the tuple would be
    ``(c, c**2 - 2 + x)``. The solutions of *eq* will contain
    solutions to the original equation (if there are any).

*syms*
    An iterable of symbols which, if provided, will limit the focus of
    radical removal: only radicals with one or more of the symbols of
    interest will be cleared. All free symbols are used if *syms* is not
    set.

*flags* are used internally for communication during recursive calls.
Two options are also recognized:

    ``take``, when defined, is interpreted as a single-argument function
    that returns True if a given Pow should be handled.

Radicals can be removed from an expression if:

    *   All bases of the radicals are the same; a change of variables is
        done in this case.
    *   If all radicals appear in one term of the expression.
    *   There are only four terms with sqrt() factors or there are less than
        four terms having sqrt() factors.
    *   There are only two terms with radicals.

Examples
========

&gt;&gt;&gt; from sympy.solvers.solvers import unrad
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; from sympy import sqrt, Rational, root

&gt;&gt;&gt; unrad(sqrt(x)*x**Rational(1, 3) + 2)
(x**5 - 64, [])
&gt;&gt;&gt; unrad(sqrt(x) + root(x + 1, 3))
(-x**3 + x**2 + 2*x + 1, [])
&gt;&gt;&gt; eq = sqrt(x) + root(x, 3) - 2
&gt;&gt;&gt; unrad(eq)
(_p**3 + _p**2 - 2, [_p, _p**6 - x])</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abb4a9ab7bb876bcd4521d14f45f89655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4a9ab7bb876bcd4521d14f45f89655">&#9670;&nbsp;</a></span>i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.solvers.solvers.i</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a216a760b792b75fd1ed3a18d8a853d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216a760b792b75fd1ed3a18d8a853d9c">&#9670;&nbsp;</a></span>isubs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.solvers.solvers.isubs</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf5a7c9ff87be94c0e09c998e9c1f6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5a7c9ff87be94c0e09c998e9c1f6b8">&#9670;&nbsp;</a></span>multi_inverses</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.solvers.solvers.multi_inverses</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b4aa281b3ecea7db17ab9d28a5bad98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4aa281b3ecea7db17ab9d28a5bad98">&#9670;&nbsp;</a></span>new_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.solvers.solvers.new_f</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74d480c8c8222b9a1e03fa5f95b97f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d480c8c8222b9a1e03fa5f95b97f27">&#9670;&nbsp;</a></span>orig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.solvers.solvers.orig</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f3c97a9012c215b1a882a86f99cd93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3c97a9012c215b1a882a86f99cd93c">&#9670;&nbsp;</a></span>restore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.solvers.solvers.restore</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2419221bfe9565ea013bd4ed066b6c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2419221bfe9565ea013bd4ed066b6c59">&#9670;&nbsp;</a></span>swap_sym</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.solvers.solvers.swap_sym</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01cdf5f6564661f6499a5b8395ede8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01cdf5f6564661f6499a5b8395ede8ca">&#9670;&nbsp;</a></span>symbols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.solvers.solvers.symbols</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
