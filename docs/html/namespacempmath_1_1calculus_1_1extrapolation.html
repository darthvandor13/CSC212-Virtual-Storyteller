<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.calculus.extrapolation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html">extrapolation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.calculus.extrapolation Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1extrapolation_1_1levin__class.html">levin_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1extrapolation_1_1cohen__alt__class.html">cohen_alt_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42a48a18b7a64f3231583fa2e2908d22"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a42a48a18b7a64f3231583fa2e2908d22">richardson</a> (ctx, seq)</td></tr>
<tr class="separator:a42a48a18b7a64f3231583fa2e2908d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac10fa7e406f4bdbe90bbd26381000b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a5ac10fa7e406f4bdbe90bbd26381000b">shanks</a> (ctx, seq, table=None, randomized=False)</td></tr>
<tr class="separator:a5ac10fa7e406f4bdbe90bbd26381000b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123868a461b8899733cd803f8255e875"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a123868a461b8899733cd803f8255e875">levin</a> (ctx, method=&quot;levin&quot;, variant=&quot;u&quot;)</td></tr>
<tr class="separator:a123868a461b8899733cd803f8255e875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abee9863e8e3553dbbe47dc810dd2ac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a6abee9863e8e3553dbbe47dc810dd2ac">cohen_alt</a> (ctx)</td></tr>
<tr class="separator:a6abee9863e8e3553dbbe47dc810dd2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c87f34a227754ce71e8906c1af3788"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#af7c87f34a227754ce71e8906c1af3788">sumap</a> (ctx, f, interval, integral=None, error=False)</td></tr>
<tr class="separator:af7c87f34a227754ce71e8906c1af3788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16aa176beb2dee46a704ca4bce9c3c86"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a16aa176beb2dee46a704ca4bce9c3c86">sumem</a> (ctx, f, interval, tol=None, reject=10, integral=None, adiffs=None, bdiffs=None, verbose=False, error=False, _fast_abort=False)</td></tr>
<tr class="separator:a16aa176beb2dee46a704ca4bce9c3c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2291ece6d74abeeebaa35b5bb73b3b4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a2291ece6d74abeeebaa35b5bb73b3b4f">adaptive_extrapolation</a> (ctx, update, emfun, kwargs)</td></tr>
<tr class="separator:a2291ece6d74abeeebaa35b5bb73b3b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d1ff417beef7b1b3a7b6dfdb7fcb88"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a24d1ff417beef7b1b3a7b6dfdb7fcb88">nsum</a> (ctx, f, *intervals, **options)</td></tr>
<tr class="separator:a24d1ff417beef7b1b3a7b6dfdb7fcb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d6d5ff7bbda44013f866532a8c7cf6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a47d6d5ff7bbda44013f866532a8c7cf6">wrapsafe</a> (f)</td></tr>
<tr class="separator:a47d6d5ff7bbda44013f866532a8c7cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e7e577af5aa001f4c1a84a0e47a6e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a51e7e577af5aa001f4c1a84a0e47a6e3">standardize</a> (ctx, f, intervals, options)</td></tr>
<tr class="separator:a51e7e577af5aa001f4c1a84a0e47a6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c60ca81d747eda686a9ba395b5f3d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a46c60ca81d747eda686a9ba395b5f3d6">cartesian_product</a> (args)</td></tr>
<tr class="separator:a46c60ca81d747eda686a9ba395b5f3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab26af2b9712a311c6637d4b84d91ac8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#aab26af2b9712a311c6637d4b84d91ac8">fold_finite</a> (ctx, f, intervals)</td></tr>
<tr class="separator:aab26af2b9712a311c6637d4b84d91ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29eef06087bbac81f444ba01ad0b496"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#af29eef06087bbac81f444ba01ad0b496">standardize_infinite</a> (ctx, f, intervals)</td></tr>
<tr class="separator:af29eef06087bbac81f444ba01ad0b496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182f4d4e1d690547ecdfd6430e8056f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a182f4d4e1d690547ecdfd6430e8056f8">fold_infinite</a> (ctx, f, intervals)</td></tr>
<tr class="separator:a182f4d4e1d690547ecdfd6430e8056f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c86f11a7fcfeb25b0af292121cc8a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a050c86f11a7fcfeb25b0af292121cc8a">nprod</a> (ctx, f, interval, <a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a24d1ff417beef7b1b3a7b6dfdb7fcb88">nsum</a>=False, **kwargs)</td></tr>
<tr class="separator:a050c86f11a7fcfeb25b0af292121cc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30138200f954a95cc53f77348ffab2c8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#a30138200f954a95cc53f77348ffab2c8">limit</a> (ctx, f, x, direction=1, <a class="el" href="namespacempmath.html#a161cd0ed421a4cbc9a7a9ef18235af91">exp</a>=False, **kwargs)</td></tr>
<tr class="separator:a30138200f954a95cc53f77348ffab2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adbc7f99aa3f44f4d5f7125e01ef81853"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#adbc7f99aa3f44f4d5f7125e01ef81853">izip</a> = zip</td></tr>
<tr class="separator:adbc7f99aa3f44f4d5f7125e01ef81853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c740dec1958d514985fd1268adad9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1extrapolation.html#af0c740dec1958d514985fd1268adad9c">next</a> = next</td></tr>
<tr class="separator:af0c740dec1958d514985fd1268adad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2291ece6d74abeeebaa35b5bb73b3b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2291ece6d74abeeebaa35b5bb73b3b4f">&#9670;&nbsp;</a></span>adaptive_extrapolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.adaptive_extrapolation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>emfun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46c60ca81d747eda686a9ba395b5f3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c60ca81d747eda686a9ba395b5f3d6">&#9670;&nbsp;</a></span>cartesian_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.cartesian_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6abee9863e8e3553dbbe47dc810dd2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abee9863e8e3553dbbe47dc810dd2ac">&#9670;&nbsp;</a></span>cohen_alt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.cohen_alt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab26af2b9712a311c6637d4b84d91ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab26af2b9712a311c6637d4b84d91ac8">&#9670;&nbsp;</a></span>fold_finite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.fold_finite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a182f4d4e1d690547ecdfd6430e8056f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182f4d4e1d690547ecdfd6430e8056f8">&#9670;&nbsp;</a></span>fold_infinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.fold_infinite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a123868a461b8899733cd803f8255e875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123868a461b8899733cd803f8255e875">&#9670;&nbsp;</a></span>levin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.levin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;levin&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variant</em> = <code>&quot;u&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30138200f954a95cc53f77348ffab2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30138200f954a95cc53f77348ffab2c8">&#9670;&nbsp;</a></span>limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.limit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>direction</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exp</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes an estimate of the limit

.. math ::

    \lim_{t \to x} f(t)

where `x` may be finite or infinite.

For finite `x`, :func:`~mpmath.limit` evaluates `f(x + d/n)` for
consecutive integer values of `n`, where the approach direction
`d` may be specified using the *direction* keyword argument.
For infinite `x`, :func:`~mpmath.limit` evaluates values of
`f(\mathrm{sign}(x) \cdot n)`.

If the approach to the limit is not sufficiently fast to give
an accurate estimate directly, :func:`~mpmath.limit` attempts to find
the limit using Richardson extrapolation or the Shanks
transformation. You can select between these methods using
the *method* keyword (see documentation of :func:`~mpmath.nsum` for
more information).

**Options**

The following options are available with essentially the
same meaning as for :func:`~mpmath.nsum`: *tol*, *method*, *maxterms*,
*steps*, *verbose*.

If the option *exp=True* is set, `f` will be
sampled at exponentially spaced points `n = 2^1, 2^2, 2^3, \ldots`
instead of the linearly spaced points `n = 1, 2, 3, \ldots`.
This can sometimes improve the rate of convergence so that
:func:`~mpmath.limit` may return a more accurate answer (and faster).
However, do note that this can only be used if `f`
supports fast and accurate evaluation for arguments that
are extremely close to the limit point (or if infinite,
very large arguments).

**Examples**

A basic evaluation of a removable singularity::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 30; mp.pretty = True
    &gt;&gt;&gt; limit(lambda x: (x-sin(x))/x**3, 0)
    0.166666666666666666666666666667

Computing the exponential function using its limit definition::

    &gt;&gt;&gt; limit(lambda n: (1+3/n)**n, inf)
    20.0855369231876677409285296546
    &gt;&gt;&gt; exp(3)
    20.0855369231876677409285296546

A limit for `\pi`::

    &gt;&gt;&gt; f = lambda n: 2**(4*n+1)*fac(n)**4/(2*n+1)/fac(2*n)**2
    &gt;&gt;&gt; limit(f, inf)
    3.14159265358979323846264338328

Calculating the coefficient in Stirling's formula::

    &gt;&gt;&gt; limit(lambda n: fac(n) / (sqrt(n)*(n/e)**n), inf)
    2.50662827463100050241576528481
    &gt;&gt;&gt; sqrt(2*pi)
    2.50662827463100050241576528481

Evaluating Euler's constant `\gamma` using the limit representation

.. math ::

    \gamma = \lim_{n \rightarrow \infty } \left[ \left(
    \sum_{k=1}^n \frac{1}{k} \right) - \log(n) \right]

(which converges notoriously slowly)::

    &gt;&gt;&gt; f = lambda n: sum([mpf(1)/k for k in range(1,int(n)+1)]) - log(n)
    &gt;&gt;&gt; limit(f, inf)
    0.577215664901532860606512090082
    &gt;&gt;&gt; +euler
    0.577215664901532860606512090082

With default settings, the following limit converges too slowly
to be evaluated accurately. Changing to exponential sampling
however gives a perfect result::

    &gt;&gt;&gt; f = lambda x: sqrt(x**3+x**2)/(sqrt(x**3)+x)
    &gt;&gt;&gt; limit(f, inf)
    0.992831158558330281129249686491
    &gt;&gt;&gt; limit(f, inf, exp=True)
    1.0</pre> 
</div>
</div>
<a id="a050c86f11a7fcfeb25b0af292121cc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050c86f11a7fcfeb25b0af292121cc8a">&#9670;&nbsp;</a></span>nprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.nprod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nsum</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the product

.. math ::

    P = \prod_{k=a}^b f(k)

where `(a, b)` = *interval*, and where `a = -\infty` and/or
`b = \infty` are allowed.

By default, :func:`~mpmath.nprod` uses the same extrapolation methods as
:func:`~mpmath.nsum`, except applied to the partial products rather than
partial sums, and the same keyword options as for :func:`~mpmath.nsum` are
supported. If ``nsum=True``, the product is instead computed via
:func:`~mpmath.nsum` as

.. math ::

    P = \exp\left( \sum_{k=a}^b \log(f(k)) \right).

This is slower, but can sometimes yield better results. It is
also required (and used automatically) when Euler-Maclaurin
summation is requested.

**Examples**

A simple finite product::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 25; mp.pretty = True
    &gt;&gt;&gt; nprod(lambda k: k, [1, 4])
    24.0

A large number of infinite products have known exact values,
and can therefore be used as a reference. Most of the following
examples are taken from MathWorld [1].

A few infinite products with simple values are::

    &gt;&gt;&gt; 2*nprod(lambda k: (4*k**2)/(4*k**2-1), [1, inf])
    3.141592653589793238462643
    &gt;&gt;&gt; nprod(lambda k: (1+1/k)**2/(1+2/k), [1, inf])
    2.0
    &gt;&gt;&gt; nprod(lambda k: (k**3-1)/(k**3+1), [2, inf])
    0.6666666666666666666666667
    &gt;&gt;&gt; nprod(lambda k: (1-1/k**2), [2, inf])
    0.5

Next, several more infinite products with more complicated
values::

    &gt;&gt;&gt; nprod(lambda k: exp(1/k**2), [1, inf]); exp(pi**2/6)
    5.180668317897115748416626
    5.180668317897115748416626

    &gt;&gt;&gt; nprod(lambda k: (k**2-1)/(k**2+1), [2, inf]); pi*csch(pi)
    0.2720290549821331629502366
    0.2720290549821331629502366

    &gt;&gt;&gt; nprod(lambda k: (k**4-1)/(k**4+1), [2, inf])
    0.8480540493529003921296502
    &gt;&gt;&gt; pi*sinh(pi)/(cosh(sqrt(2)*pi)-cos(sqrt(2)*pi))
    0.8480540493529003921296502

    &gt;&gt;&gt; nprod(lambda k: (1+1/k+1/k**2)**2/(1+2/k+3/k**2), [1, inf])
    1.848936182858244485224927
    &gt;&gt;&gt; 3*sqrt(2)*cosh(pi*sqrt(3)/2)**2*csch(pi*sqrt(2))/pi
    1.848936182858244485224927

    &gt;&gt;&gt; nprod(lambda k: (1-1/k**4), [2, inf]); sinh(pi)/(4*pi)
    0.9190194775937444301739244
    0.9190194775937444301739244

    &gt;&gt;&gt; nprod(lambda k: (1-1/k**6), [2, inf])
    0.9826842777421925183244759
    &gt;&gt;&gt; (1+cosh(pi*sqrt(3)))/(12*pi**2)
    0.9826842777421925183244759

    &gt;&gt;&gt; nprod(lambda k: (1+1/k**2), [2, inf]); sinh(pi)/(2*pi)
    1.838038955187488860347849
    1.838038955187488860347849

    &gt;&gt;&gt; nprod(lambda n: (1+1/n)**n * exp(1/(2*n)-1), [1, inf])
    1.447255926890365298959138
    &gt;&gt;&gt; exp(1+euler/2)/sqrt(2*pi)
    1.447255926890365298959138

The following two products are equivalent and can be evaluated in
terms of a Jacobi theta function. Pi can be replaced by any value
(as long as convergence is preserved)::

    &gt;&gt;&gt; nprod(lambda k: (1-pi**-k)/(1+pi**-k), [1, inf])
    0.3838451207481672404778686
    &gt;&gt;&gt; nprod(lambda k: tanh(k*log(pi)/2), [1, inf])
    0.3838451207481672404778686
    &gt;&gt;&gt; jtheta(4,0,1/pi)
    0.3838451207481672404778686

This product does not have a known closed form value::

    &gt;&gt;&gt; nprod(lambda k: (1-1/2**k), [1, inf])
    0.2887880950866024212788997

A product taken from `-\infty`::

    &gt;&gt;&gt; nprod(lambda k: 1-k**(-3), [-inf,-2])
    0.8093965973662901095786805
    &gt;&gt;&gt; cosh(pi*sqrt(3)/2)/(3*pi)
    0.8093965973662901095786805

A doubly infinite product::

    &gt;&gt;&gt; nprod(lambda k: exp(1/(1+k**2)), [-inf, inf])
    23.41432688231864337420035
    &gt;&gt;&gt; exp(pi/tanh(pi))
    23.41432688231864337420035

A product requiring the use of Euler-Maclaurin summation to compute
an accurate value::

    &gt;&gt;&gt; nprod(lambda k: (1-1/k**2.5), [2, inf], method='e')
    0.696155111336231052898125

**References**

1. [Weisstein]_ http://mathworld.wolfram.com/InfiniteProduct.html</pre> 
</div>
</div>
<a id="a24d1ff417beef7b1b3a7b6dfdb7fcb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d1ff417beef7b1b3a7b6dfdb7fcb88">&#9670;&nbsp;</a></span>nsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.nsum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>intervals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the sum

.. math :: S = \sum_{k=a}^b f(k)

where `(a, b)` = *interval*, and where `a = -\infty` and/or
`b = \infty` are allowed, or more generally

.. math :: S = \sum_{k_1=a_1}^{b_1} \cdots
               \sum_{k_n=a_n}^{b_n} f(k_1,\ldots,k_n)

if multiple intervals are given.

Two examples of infinite series that can be summed by :func:`~mpmath.nsum`,
where the first converges rapidly and the second converges slowly,
are::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; nsum(lambda n: 1/fac(n), [0, inf])
    2.71828182845905
    &gt;&gt;&gt; nsum(lambda n: 1/n**2, [1, inf])
    1.64493406684823

When appropriate, :func:`~mpmath.nsum` applies convergence acceleration to
accurately estimate the sums of slowly convergent series. If the series is
finite, :func:`~mpmath.nsum` currently does not attempt to perform any
extrapolation, and simply calls :func:`~mpmath.fsum`.

Multidimensional infinite series are reduced to a single-dimensional
series over expanding hypercubes; if both infinite and finite dimensions
are present, the finite ranges are moved innermost. For more advanced
control over the summation order, use nested calls to :func:`~mpmath.nsum`,
or manually rewrite the sum as a single-dimensional series.

**Options**

*tol*
    Desired maximum final error. Defaults roughly to the
    epsilon of the working precision.

*method*
    Which summation algorithm to use (described below).
    Default: ``'richardson+shanks'``.

*maxterms*
    Cancel after at most this many terms. Default: 10*dps.

*steps*
    An iterable giving the number of terms to add between
    each extrapolation attempt. The default sequence is
    [10, 20, 30, 40, ...]. For example, if you know that
    approximately 100 terms will be required, efficiency might be
    improved by setting this to [100, 10]. Then the first
    extrapolation will be performed after 100 terms, the second
    after 110, etc.

*verbose*
    Print details about progress.

*ignore*
    If enabled, any term that raises ``ArithmeticError``
    or ``ValueError`` (e.g. through division by zero) is replaced
    by a zero. This is convenient for lattice sums with
    a singular term near the origin.

**Methods**

Unfortunately, an algorithm that can efficiently sum any infinite
series does not exist. :func:`~mpmath.nsum` implements several different
algorithms that each work well in different cases. The *method*
keyword argument selects a method.

The default method is ``'r+s'``, i.e. both Richardson extrapolation
and Shanks transformation is attempted. A slower method that
handles more cases is ``'r+s+e'``. For very high precision
summation, or if the summation needs to be fast (for example if
multiple sums need to be evaluated), it is a good idea to
investigate which one method works best and only use that.

``'richardson'`` / ``'r'``:
    Uses Richardson extrapolation. Provides useful extrapolation
    when `f(k) \sim P(k)/Q(k)` or when `f(k) \sim (-1)^k P(k)/Q(k)`
    for polynomials `P` and `Q`. See :func:`~mpmath.richardson` for
    additional information.

``'shanks'`` / ``'s'``:
    Uses Shanks transformation. Typically provides useful
    extrapolation when `f(k) \sim c^k` or when successive terms
    alternate signs. Is able to sum some divergent series.
    See :func:`~mpmath.shanks` for additional information.

``'levin'`` / ``'l'``:
    Uses the Levin transformation. It performs better than the Shanks
    transformation for logarithmic convergent or alternating divergent
    series. The ``'levin_variant'``-keyword selects the variant. Valid
    choices are "u", "t", "v" and "all" whereby "all" uses all three
    u,t and v simultanously (This is good for performance comparison in
    conjunction with "verbose=True"). Instead of the Levin transform one can
    also use the Sidi-S transform by selecting the method ``'sidi'``.
    See :func:`~mpmath.levin` for additional details.

``'alternating'`` / ``'a'``:
    This is the convergence acceleration of alternating series developped
    by Cohen, Villegras and Zagier.
    See :func:`~mpmath.cohen_alt` for additional details.

``'euler-maclaurin'`` / ``'e'``:
    Uses the Euler-Maclaurin summation formula to approximate
    the remainder sum by an integral. This requires high-order
    numerical derivatives and numerical integration. The advantage
    of this algorithm is that it works regardless of the
    decay rate of `f`, as long as `f` is sufficiently smooth.
    See :func:`~mpmath.sumem` for additional information.

``'direct'`` / ``'d'``:
    Does not perform any extrapolation. This can be used
    (and should only be used for) rapidly convergent series.
    The summation automatically stops when the terms
    decrease below the target tolerance.

**Basic examples**

A finite sum::

    &gt;&gt;&gt; nsum(lambda k: 1/k, [1, 6])
    2.45

Summation of a series going to negative infinity and a doubly
infinite series::

    &gt;&gt;&gt; nsum(lambda k: 1/k**2, [-inf, -1])
    1.64493406684823
    &gt;&gt;&gt; nsum(lambda k: 1/(1+k**2), [-inf, inf])
    3.15334809493716

:func:`~mpmath.nsum` handles sums of complex numbers::

    &gt;&gt;&gt; nsum(lambda k: (0.5+0.25j)**k, [0, inf])
    (1.6 + 0.8j)

The following sum converges very rapidly, so it is most
efficient to sum it by disabling convergence acceleration::

    &gt;&gt;&gt; mp.dps = 1000
    &gt;&gt;&gt; a = nsum(lambda k: -(-1)**k * k**2 / fac(2*k), [1, inf],
    ...     method='direct')
    &gt;&gt;&gt; b = (cos(1)+sin(1))/4
    &gt;&gt;&gt; abs(a-b) &lt; mpf('1e-998')
    True

**Examples with Richardson extrapolation**

Richardson extrapolation works well for sums over rational
functions, as well as their alternating counterparts::

    &gt;&gt;&gt; mp.dps = 50
    &gt;&gt;&gt; nsum(lambda k: 1 / k**3, [1, inf],
    ...     method='richardson')
    1.2020569031595942853997381615114499907649862923405
    &gt;&gt;&gt; zeta(3)
    1.2020569031595942853997381615114499907649862923405

    &gt;&gt;&gt; nsum(lambda n: (n + 3)/(n**3 + n**2), [1, inf],
    ...     method='richardson')
    2.9348022005446793094172454999380755676568497036204
    &gt;&gt;&gt; pi**2/2-2
    2.9348022005446793094172454999380755676568497036204

    &gt;&gt;&gt; nsum(lambda k: (-1)**k / k**3, [1, inf],
    ...     method='richardson')
    -0.90154267736969571404980362113358749307373971925537
    &gt;&gt;&gt; -3*zeta(3)/4
    -0.90154267736969571404980362113358749307373971925538

**Examples with Shanks transformation**

The Shanks transformation works well for geometric series
and typically provides excellent acceleration for Taylor
series near the border of their disk of convergence.
Here we apply it to a series for `\log(2)`, which can be
seen as the Taylor series for `\log(1+x)` with `x = 1`::

    &gt;&gt;&gt; nsum(lambda k: -(-1)**k/k, [1, inf],
    ...     method='shanks')
    0.69314718055994530941723212145817656807550013436025
    &gt;&gt;&gt; log(2)
    0.69314718055994530941723212145817656807550013436025

Here we apply it to a slowly convergent geometric series::

    &gt;&gt;&gt; nsum(lambda k: mpf('0.995')**k, [0, inf],
    ...     method='shanks')
    200.0

Finally, Shanks' method works very well for alternating series
where `f(k) = (-1)^k g(k)`, and often does so regardless of
the exact decay rate of `g(k)`::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; nsum(lambda k: (-1)**(k+1) / k**1.5, [1, inf],
    ...     method='shanks')
    0.765147024625408
    &gt;&gt;&gt; (2-sqrt(2))*zeta(1.5)/2
    0.765147024625408

The following slowly convergent alternating series has no known
closed-form value. Evaluating the sum a second time at higher
precision indicates that the value is probably correct::

    &gt;&gt;&gt; nsum(lambda k: (-1)**k / log(k), [2, inf],
    ...     method='shanks')
    0.924299897222939
    &gt;&gt;&gt; mp.dps = 30
    &gt;&gt;&gt; nsum(lambda k: (-1)**k / log(k), [2, inf],
    ...     method='shanks')
    0.92429989722293885595957018136

**Examples with Levin transformation**

The following example calculates Euler's constant as the constant term in
the Laurent expansion of zeta(s) at s=1. This sum converges extremly slow
because of the logarithmic convergence behaviour of the Dirichlet series
for zeta.

  &gt;&gt;&gt; mp.dps = 30
  &gt;&gt;&gt; z = mp.mpf(10) ** (-10)
  &gt;&gt;&gt; a = mp.nsum(lambda n: n**(-(1+z)), [1, mp.inf], method = "levin") - 1 / z
  &gt;&gt;&gt; print(mp.chop(a - mp.euler, tol = 1e-10))
  0.0

Now we sum the zeta function outside its range of convergence
(attention: This does not work at the negative integers!):

  &gt;&gt;&gt; mp.dps = 15
  &gt;&gt;&gt; w = mp.nsum(lambda n: n ** (2 + 3j), [1, mp.inf], method = "levin", levin_variant = "v")
  &gt;&gt;&gt; print(mp.chop(w - mp.zeta(-2-3j)))
  0.0

The next example resummates an asymptotic series expansion of an integral
related to the exponential integral.

  &gt;&gt;&gt; mp.dps = 15
  &gt;&gt;&gt; z = mp.mpf(10)
  &gt;&gt;&gt; # exact = mp.quad(lambda x: mp.exp(-x)/(1+x/z),[0,mp.inf])
  &gt;&gt;&gt; exact = z * mp.exp(z) * mp.expint(1,z) # this is the symbolic expression for the integral
  &gt;&gt;&gt; w = mp.nsum(lambda n: (-1) ** n * mp.fac(n) * z ** (-n), [0, mp.inf], method = "sidi", levin_variant = "t")
  &gt;&gt;&gt; print(mp.chop(w - exact))
  0.0

Following highly divergent asymptotic expansion needs some care. Firstly we
need copious amount of working precision. Secondly the stepsize must not be
chosen to large, otherwise nsum may miss the point where the Levin transform
converges and reach the point where only numerical garbage is produced due to
numerical cancellation.

  &gt;&gt;&gt; mp.dps = 15
  &gt;&gt;&gt; z = mp.mpf(2)
  &gt;&gt;&gt; # exact = mp.quad(lambda x: mp.exp( -x * x / 2 - z * x ** 4), [0,mp.inf]) * 2 / mp.sqrt(2 * mp.pi)
  &gt;&gt;&gt; exact = mp.exp(mp.one / (32 * z)) * mp.besselk(mp.one / 4, mp.one / (32 * z)) / (4 * mp.sqrt(z * mp.pi)) # this is the symbolic expression for the integral
  &gt;&gt;&gt; w = mp.nsum(lambda n: (-z)**n * mp.fac(4 * n) / (mp.fac(n) * mp.fac(2 * n) * (4 ** n)),
  ...   [0, mp.inf], method = "levin", levin_variant = "t", workprec = 8*mp.prec, steps = [2] + [1 for x in xrange(1000)])
  &gt;&gt;&gt; print(mp.chop(w - exact))
  0.0

The hypergeoemtric function can also be summed outside its range of convergence:

  &gt;&gt;&gt; mp.dps = 15
  &gt;&gt;&gt; z = 2 + 1j
  &gt;&gt;&gt; exact = mp.hyp2f1(2 / mp.mpf(3), 4 / mp.mpf(3), 1 / mp.mpf(3), z)
  &gt;&gt;&gt; f = lambda n: mp.rf(2 / mp.mpf(3), n) * mp.rf(4 / mp.mpf(3), n) * z**n / (mp.rf(1 / mp.mpf(3), n) * mp.fac(n))
  &gt;&gt;&gt; v = mp.nsum(f, [0, mp.inf], method = "levin", steps = [10 for x in xrange(1000)])
  &gt;&gt;&gt; print(mp.chop(exact-v))
  0.0

**Examples with Cohen's alternating series resummation**

  The next example sums the alternating zeta function:

  &gt;&gt;&gt; v = mp.nsum(lambda n: (-1)**(n-1) / n, [1, mp.inf], method = "a")
  &gt;&gt;&gt; print(mp.chop(v - mp.log(2)))
  0.0

  The derivate of the alternating zeta function outside its range of
  convergence:

  &gt;&gt;&gt; v = mp.nsum(lambda n: (-1)**n * mp.log(n) * n, [1, mp.inf], method = "a")
  &gt;&gt;&gt; print(mp.chop(v - mp.diff(lambda s: mp.altzeta(s), -1)))
  0.0

**Examples with Euler-Maclaurin summation**

The sum in the following example has the wrong rate of convergence
for either Richardson or Shanks to be effective.

    &gt;&gt;&gt; f = lambda k: log(k)/k**2.5
    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; nsum(f, [1, inf], method='euler-maclaurin')
    0.38734195032621
    &gt;&gt;&gt; -diff(zeta, 2.5)
    0.38734195032621

Increasing ``steps`` improves speed at higher precision::

    &gt;&gt;&gt; mp.dps = 50
    &gt;&gt;&gt; nsum(f, [1, inf], method='euler-maclaurin', steps=[250])
    0.38734195032620997271199237593105101319948228874688
    &gt;&gt;&gt; -diff(zeta, 2.5)
    0.38734195032620997271199237593105101319948228874688

**Divergent series**

The Shanks transformation is able to sum some *divergent*
series. In particular, it is often able to sum Taylor series
beyond their radius of convergence (this is due to a relation
between the Shanks transformation and Pade approximations;
see :func:`~mpmath.pade` for an alternative way to evaluate divergent
Taylor series). Furthermore the Levin-transform examples above
contain some divergent series resummation.

Here we apply it to `\log(1+x)` far outside the region of
convergence::

    &gt;&gt;&gt; mp.dps = 50
    &gt;&gt;&gt; nsum(lambda k: -(-9)**k/k, [1, inf],
    ...     method='shanks')
    2.3025850929940456840179914546843642076011014886288
    &gt;&gt;&gt; log(10)
    2.3025850929940456840179914546843642076011014886288

A particular type of divergent series that can be summed
using the Shanks transformation is geometric series.
The result is the same as using the closed-form formula
for an infinite geometric series::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; for n in range(-8, 8):
    ...     if n == 1:
    ...         continue
    ...     print("%s %s %s" % (mpf(n), mpf(1)/(1-n),
    ...         nsum(lambda k: n**k, [0, inf], method='shanks')))
    ...
    -8.0 0.111111111111111 0.111111111111111
    -7.0 0.125 0.125
    -6.0 0.142857142857143 0.142857142857143
    -5.0 0.166666666666667 0.166666666666667
    -4.0 0.2 0.2
    -3.0 0.25 0.25
    -2.0 0.333333333333333 0.333333333333333
    -1.0 0.5 0.5
    0.0 1.0 1.0
    2.0 -1.0 -1.0
    3.0 -0.5 -0.5
    4.0 -0.333333333333333 -0.333333333333333
    5.0 -0.25 -0.25
    6.0 -0.2 -0.2
    7.0 -0.166666666666667 -0.166666666666667

**Multidimensional sums**

Any combination of finite and infinite ranges is allowed for the
summation indices::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; nsum(lambda x,y: x+y, [2,3], [4,5])
    28.0
    &gt;&gt;&gt; nsum(lambda x,y: x/2**y, [1,3], [1,inf])
    6.0
    &gt;&gt;&gt; nsum(lambda x,y: y/2**x, [1,inf], [1,3])
    6.0
    &gt;&gt;&gt; nsum(lambda x,y,z: z/(2**x*2**y), [1,inf], [1,inf], [3,4])
    7.0
    &gt;&gt;&gt; nsum(lambda x,y,z: y/(2**x*2**z), [1,inf], [3,4], [1,inf])
    7.0
    &gt;&gt;&gt; nsum(lambda x,y,z: x/(2**z*2**y), [3,4], [1,inf], [1,inf])
    7.0

Some nice examples of double series with analytic solutions or
reductions to single-dimensional series (see [1])::

    &gt;&gt;&gt; nsum(lambda m, n: 1/2**(m*n), [1,inf], [1,inf])
    1.60669515241529
    &gt;&gt;&gt; nsum(lambda n: 1/(2**n-1), [1,inf])
    1.60669515241529

    &gt;&gt;&gt; nsum(lambda i,j: (-1)**(i+j)/(i**2+j**2), [1,inf], [1,inf])
    0.278070510848213
    &gt;&gt;&gt; pi*(pi-3*ln2)/12
    0.278070510848213

    &gt;&gt;&gt; nsum(lambda i,j: (-1)**(i+j)/(i+j)**2, [1,inf], [1,inf])
    0.129319852864168
    &gt;&gt;&gt; altzeta(2) - altzeta(1)
    0.129319852864168

    &gt;&gt;&gt; nsum(lambda i,j: (-1)**(i+j)/(i+j)**3, [1,inf], [1,inf])
    0.0790756439455825
    &gt;&gt;&gt; altzeta(3) - altzeta(2)
    0.0790756439455825

    &gt;&gt;&gt; nsum(lambda m,n: m**2*n/(3**m*(n*3**m+m*3**n)),
    ...     [1,inf], [1,inf])
    0.28125
    &gt;&gt;&gt; mpf(9)/32
    0.28125

    &gt;&gt;&gt; nsum(lambda i,j: fac(i-1)*fac(j-1)/fac(i+j),
    ...     [1,inf], [1,inf], workprec=400)
    1.64493406684823
    &gt;&gt;&gt; zeta(2)
    1.64493406684823

A hard example of a multidimensional sum is the Madelung constant
in three dimensions (see [2]). The defining sum converges very
slowly and only conditionally, so :func:`~mpmath.nsum` is lucky to
obtain an accurate value through convergence acceleration. The
second evaluation below uses a much more efficient, rapidly
convergent 2D sum::

    &gt;&gt;&gt; nsum(lambda x,y,z: (-1)**(x+y+z)/(x*x+y*y+z*z)**0.5,
    ...     [-inf,inf], [-inf,inf], [-inf,inf], ignore=True)
    -1.74756459463318
    &gt;&gt;&gt; nsum(lambda x,y: -12*pi*sech(0.5*pi * \
    ...     sqrt((2*x+1)**2+(2*y+1)**2))**2, [0,inf], [0,inf])
    -1.74756459463318

Another example of a lattice sum in 2D::

    &gt;&gt;&gt; nsum(lambda x,y: (-1)**(x+y) / (x**2+y**2), [-inf,inf],
    ...     [-inf,inf], ignore=True)
    -2.1775860903036
    &gt;&gt;&gt; -pi*ln2
    -2.1775860903036

An example of an Eisenstein series::

    &gt;&gt;&gt; nsum(lambda m,n: (m+n*1j)**(-4), [-inf,inf], [-inf,inf],
    ...     ignore=True)
    (3.1512120021539 + 0.0j)

**References**

1. [Weisstein]_ http://mathworld.wolfram.com/DoubleSeries.html,
2. [Weisstein]_ http://mathworld.wolfram.com/MadelungConstants.html</pre> 
</div>
</div>
<a id="a42a48a18b7a64f3231583fa2e2908d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a48a18b7a64f3231583fa2e2908d22">&#9670;&nbsp;</a></span>richardson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.richardson </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a list ``seq`` of the first `N` elements of a slowly convergent
infinite sequence, :func:`~mpmath.richardson` computes the `N`-term
Richardson extrapolate for the limit.

:func:`~mpmath.richardson` returns `(v, c)` where `v` is the estimated
limit and `c` is the magnitude of the largest weight used during the
computation. The weight provides an estimate of the precision
lost to cancellation. Due to cancellation effects, the sequence must
be typically be computed at a much higher precision than the target
accuracy of the extrapolation.

**Applicability and issues**

The `N`-step Richardson extrapolation algorithm used by
:func:`~mpmath.richardson` is described in [1].

Richardson extrapolation only works for a specific type of sequence,
namely one converging like partial sums of
`P(1)/Q(1) + P(2)/Q(2) + \ldots` where `P` and `Q` are polynomials.
When the sequence does not convergence at such a rate
:func:`~mpmath.richardson` generally produces garbage.

Richardson extrapolation has the advantage of being fast: the `N`-term
extrapolate requires only `O(N)` arithmetic operations, and usually
produces an estimate that is accurate to `O(N)` digits. Contrast with
the Shanks transformation (see :func:`~mpmath.shanks`), which requires
`O(N^2)` operations.

:func:`~mpmath.richardson` is unable to produce an estimate for the
approximation error. One way to estimate the error is to perform
two extrapolations with slightly different `N` and comparing the
results.

Richardson extrapolation does not work for oscillating sequences.
As a simple workaround, :func:`~mpmath.richardson` detects if the last
three elements do not differ monotonically, and in that case
applies extrapolation only to the even-index elements.

**Example**

Applying Richardson extrapolation to the Leibniz series for `\pi`::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 30; mp.pretty = True
    &gt;&gt;&gt; S = [4*sum(mpf(-1)**n/(2*n+1) for n in range(m))
    ...     for m in range(1,30)]
    &gt;&gt;&gt; v, c = richardson(S[:10])
    &gt;&gt;&gt; v
    3.2126984126984126984126984127
    &gt;&gt;&gt; nprint([v-pi, c])
    [0.0711058, 2.0]

    &gt;&gt;&gt; v, c = richardson(S[:30])
    &gt;&gt;&gt; v
    3.14159265468624052829954206226
    &gt;&gt;&gt; nprint([v-pi, c])
    [1.09645e-9, 20833.3]

**References**

1. [BenderOrszag]_ pp. 375-376</pre> 
</div>
</div>
<a id="a5ac10fa7e406f4bdbe90bbd26381000b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac10fa7e406f4bdbe90bbd26381000b">&#9670;&nbsp;</a></span>shanks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.shanks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>randomized</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a list ``seq`` of the first `N` elements of a slowly
convergent infinite sequence `(A_k)`, :func:`~mpmath.shanks` computes the iterated
Shanks transformation `S(A), S(S(A)), \ldots, S^{N/2}(A)`. The Shanks
transformation often provides strong convergence acceleration,
especially if the sequence is oscillating.

The iterated Shanks transformation is computed using the Wynn
epsilon algorithm (see [1]). :func:`~mpmath.shanks` returns the full
epsilon table generated by Wynn's algorithm, which can be read
off as follows:

* The table is a list of lists forming a lower triangular matrix,
  where higher row and column indices correspond to more accurate
  values.
* The columns with even index hold dummy entries (required for the
  computation) and the columns with odd index hold the actual
  extrapolates.
* The last element in the last row is typically the most
  accurate estimate of the limit.
* The difference to the third last element in the last row
  provides an estimate of the approximation error.
* The magnitude of the second last element provides an estimate
  of the numerical accuracy lost to cancellation.

For convenience, so the extrapolation is stopped at an odd index
so that ``shanks(seq)[-1][-1]`` always gives an estimate of the
limit.

Optionally, an existing table can be passed to :func:`~mpmath.shanks`.
This can be used to efficiently extend a previous computation after
new elements have been appended to the sequence. The table will
then be updated in-place.

**The Shanks transformation**

The Shanks transformation is defined as follows (see [2]): given
the input sequence `(A_0, A_1, \ldots)`, the transformed sequence is
given by

.. math ::

    S(A_k) = \frac{A_{k+1}A_{k-1}-A_k^2}{A_{k+1}+A_{k-1}-2 A_k}

The Shanks transformation gives the exact limit `A_{\infty}` in a
single step if `A_k = A + a q^k`. Note in particular that it
extrapolates the exact sum of a geometric series in a single step.

Applying the Shanks transformation once often improves convergence
substantially for an arbitrary sequence, but the optimal effect is
obtained by applying it iteratively:
`S(S(A_k)), S(S(S(A_k))), \ldots`.

Wynn's epsilon algorithm provides an efficient way to generate
the table of iterated Shanks transformations. It reduces the
computation of each element to essentially a single division, at
the cost of requiring dummy elements in the table. See [1] for
details.

**Precision issues**

Due to cancellation effects, the sequence must be typically be
computed at a much higher precision than the target accuracy
of the extrapolation.

If the Shanks transformation converges to the exact limit (such
as if the sequence is a geometric series), then a division by
zero occurs. By default, :func:`~mpmath.shanks` handles this case by
terminating the iteration and returning the table it has
generated so far. With *randomized=True*, it will instead
replace the zero by a pseudorandom number close to zero.
(TODO: find a better solution to this problem.)

**Examples**

We illustrate by applying Shanks transformation to the Leibniz
series for `\pi`::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 50
    &gt;&gt;&gt; S = [4*sum(mpf(-1)**n/(2*n+1) for n in range(m))
    ...     for m in range(1,30)]
    &gt;&gt;&gt;
    &gt;&gt;&gt; T = shanks(S[:7])
    &gt;&gt;&gt; for row in T:
    ...     nprint(row)
    ...
    [-0.75]
    [1.25, 3.16667]
    [-1.75, 3.13333, -28.75]
    [2.25, 3.14524, 82.25, 3.14234]
    [-2.75, 3.13968, -177.75, 3.14139, -969.937]
    [3.25, 3.14271, 327.25, 3.14166, 3515.06, 3.14161]

The extrapolated accuracy is about 4 digits, and about 4 digits
may have been lost due to cancellation::

    &gt;&gt;&gt; L = T[-1]
    &gt;&gt;&gt; nprint([abs(L[-1] - pi), abs(L[-1] - L[-3]), abs(L[-2])])
    [2.22532e-5, 4.78309e-5, 3515.06]

Now we extend the computation::

    &gt;&gt;&gt; T = shanks(S[:25], T)
    &gt;&gt;&gt; L = T[-1]
    &gt;&gt;&gt; nprint([abs(L[-1] - pi), abs(L[-1] - L[-3]), abs(L[-2])])
    [3.75527e-19, 1.48478e-19, 2.96014e+17]

The value for pi is now accurate to 18 digits. About 18 digits may
also have been lost to cancellation.

Here is an example with a geometric series, where the convergence
is immediate (the sum is exactly 1)::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; for row in shanks([0.5, 0.75, 0.875, 0.9375, 0.96875]):
    ...     nprint(row)
    [4.0]
    [8.0, 1.0]

**References**

1. [GravesMorris]_

2. [BenderOrszag]_ pp. 368-375</pre> 
</div>
</div>
<a id="a51e7e577af5aa001f4c1a84a0e47a6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e7e577af5aa001f4c1a84a0e47a6e3">&#9670;&nbsp;</a></span>standardize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.standardize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>intervals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af29eef06087bbac81f444ba01ad0b496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29eef06087bbac81f444ba01ad0b496">&#9670;&nbsp;</a></span>standardize_infinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.standardize_infinite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7c87f34a227754ce71e8906c1af3788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c87f34a227754ce71e8906c1af3788">&#9670;&nbsp;</a></span>sumap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.sumap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>integral</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluates an infinite series of an analytic summand *f* using the
Abel-Plana formula

.. math ::

    \sum_{k=0}^{\infty} f(k) = \int_0^{\infty} f(t) dt + \frac{1}{2} f(0) +
        i \int_0^{\infty} \frac{f(it)-f(-it)}{e^{2\pi t}-1} dt.

Unlike the Euler-Maclaurin formula (see :func:`~mpmath.sumem`),
the Abel-Plana formula does not require derivatives. However,
it only works when `|f(it)-f(-it)|` does not
increase too rapidly with `t`.

**Examples**

The Abel-Plana formula is particularly useful when the summand
decreases like a power of `k`; for example when the sum is a pure
zeta function::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 25; mp.pretty = True
    &gt;&gt;&gt; sumap(lambda k: 1/k**2.5, [1,inf])
    1.34148725725091717975677
    &gt;&gt;&gt; zeta(2.5)
    1.34148725725091717975677
    &gt;&gt;&gt; sumap(lambda k: 1/(k+1j)**(2.5+2.5j), [1,inf])
    (-3.385361068546473342286084 - 0.7432082105196321803869551j)
    &gt;&gt;&gt; zeta(2.5+2.5j, 1+1j)
    (-3.385361068546473342286084 - 0.7432082105196321803869551j)

If the series is alternating, numerical quadrature along the real
line is likely to give poor results, so it is better to evaluate
the first term symbolically whenever possible:

    &gt;&gt;&gt; n=3; z=-0.75
    &gt;&gt;&gt; I = expint(n,-log(z))
    &gt;&gt;&gt; chop(sumap(lambda k: z**k / k**n, [1,inf], integral=I))
    -0.6917036036904594510141448
    &gt;&gt;&gt; polylog(n,z)
    -0.6917036036904594510141448</pre> 
</div>
</div>
<a id="a16aa176beb2dee46a704ca4bce9c3c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16aa176beb2dee46a704ca4bce9c3c86">&#9670;&nbsp;</a></span>sumem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.sumem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reject</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>integral</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>adiffs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bdiffs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_fast_abort</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Uses the Euler-Maclaurin formula to compute an approximation accurate
to within ``tol`` (which defaults to the present epsilon) of the sum

.. math ::

    S = \sum_{k=a}^b f(k)

where `(a,b)` are given by ``interval`` and `a` or `b` may be
infinite. The approximation is

.. math ::

    S \sim \int_a^b f(x) \,dx + \frac{f(a)+f(b)}{2} +
    \sum_{k=1}^{\infty} \frac{B_{2k}}{(2k)!}
    \left(f^{(2k-1)}(b)-f^{(2k-1)}(a)\right).

The last sum in the Euler-Maclaurin formula is not generally
convergent (a notable exception is if `f` is a polynomial, in
which case Euler-Maclaurin actually gives an exact result).

The summation is stopped as soon as the quotient between two
consecutive terms falls below *reject*. That is, by default
(*reject* = 10), the summation is continued as long as each
term adds at least one decimal.

Although not convergent, convergence to a given tolerance can
often be "forced" if `b = \infty` by summing up to `a+N` and then
applying the Euler-Maclaurin formula to the sum over the range
`(a+N+1, \ldots, \infty)`. This procedure is implemented by
:func:`~mpmath.nsum`.

By default numerical quadrature and differentiation is used.
If the symbolic values of the integral and endpoint derivatives
are known, it is more efficient to pass the value of the
integral explicitly as ``integral`` and the derivatives
explicitly as ``adiffs`` and ``bdiffs``. The derivatives
should be given as iterables that yield
`f(a), f'(a), f''(a), \ldots` (and the equivalent for `b`).

**Examples**

Summation of an infinite series, with automatic and symbolic
integral and derivative values (the second should be much faster)::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 50; mp.pretty = True
    &gt;&gt;&gt; sumem(lambda n: 1/n**2, [32, inf])
    0.03174336652030209012658168043874142714132886413417
    &gt;&gt;&gt; I = mpf(1)/32
    &gt;&gt;&gt; D = adiffs=((-1)**n*fac(n+1)*32**(-2-n) for n in range(999))
    &gt;&gt;&gt; sumem(lambda n: 1/n**2, [32, inf], integral=I, adiffs=D)
    0.03174336652030209012658168043874142714132886413417

An exact evaluation of a finite polynomial sum::

    &gt;&gt;&gt; sumem(lambda n: n**5-12*n**2+3*n, [-100000, 200000])
    10500155000624963999742499550000.0
    &gt;&gt;&gt; print(sum(n**5-12*n**2+3*n for n in range(-100000, 200001)))
    10500155000624963999742499550000</pre> 
</div>
</div>
<a id="a47d6d5ff7bbda44013f866532a8c7cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d6d5ff7bbda44013f866532a8c7cf6">&#9670;&nbsp;</a></span>wrapsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.extrapolation.wrapsafe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="adbc7f99aa3f44f4d5f7125e01ef81853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc7f99aa3f44f4d5f7125e01ef81853">&#9670;&nbsp;</a></span>izip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpmath.calculus.extrapolation.izip = zip</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0c740dec1958d514985fd1268adad9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c740dec1958d514985fd1268adad9c">&#9670;&nbsp;</a></span>next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpmath.calculus.extrapolation.next = next</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
