<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: backoff._decorator Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebackoff.html">backoff</a></li><li class="navelem"><a class="el" href="namespacebackoff_1_1__decorator.html">_decorator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">backoff._decorator Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1b1e86d0dd68bc54cd7c9bb7728b8825"><td class="memItemLeft" align="right" valign="top">Callable[[_CallableT], _CallableT]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebackoff_1_1__decorator.html#a1b1e86d0dd68bc54cd7c9bb7728b8825">on_predicate</a> (_WaitGenerator wait_gen, _Predicate[Any] predicate=operator.not_, *Optional[_MaybeCallable[int]] max_tries=None, Optional[_MaybeCallable[float]] max_time=None, Union[_Jitterer, None] jitter=full_jitter, Union[_Handler, Iterable[_Handler], None] on_success=None, Union[_Handler, Iterable[_Handler], None] on_backoff=None, Union[_Handler, Iterable[_Handler], None] on_giveup=None, _MaybeLogger logger='backoff', int backoff_log_level=logging.INFO, int giveup_log_level=logging.ERROR, **Any wait_gen_kwargs)</td></tr>
<tr class="separator:a1b1e86d0dd68bc54cd7c9bb7728b8825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6a5d60c750ac5043eea62f3cb84d4f"><td class="memItemLeft" align="right" valign="top">Callable[[_CallableT], _CallableT]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebackoff_1_1__decorator.html#abb6a5d60c750ac5043eea62f3cb84d4f">on_exception</a> (_WaitGenerator wait_gen, _MaybeSequence[Type[Exception]] exception, *Optional[_MaybeCallable[int]] max_tries=None, Optional[_MaybeCallable[float]] max_time=None, Union[_Jitterer, None] jitter=full_jitter, _Predicate[Exception] giveup=lambda e:False, Union[_Handler, Iterable[_Handler], None] on_success=None, Union[_Handler, Iterable[_Handler], None] on_backoff=None, Union[_Handler, Iterable[_Handler], None] on_giveup=None, bool raise_on_giveup=True, _MaybeLogger logger='backoff', int backoff_log_level=logging.INFO, int giveup_log_level=logging.ERROR, **Any wait_gen_kwargs)</td></tr>
<tr class="separator:abb6a5d60c750ac5043eea62f3cb84d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abb6a5d60c750ac5043eea62f3cb84d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6a5d60c750ac5043eea62f3cb84d4f">&#9670;&nbsp;</a></span>on_exception()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Callable[[_CallableT], _CallableT] backoff._decorator.on_exception </td>
          <td>(</td>
          <td class="paramtype">_WaitGenerator&#160;</td>
          <td class="paramname"><em>wait_gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_MaybeSequence[Type[Exception]]&#160;</td>
          <td class="paramname"><em>exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[_MaybeCallable[int]] &#160;</td>
          <td class="paramname"><em>max_tries</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_MaybeCallable[float]] &#160;</td>
          <td class="paramname"><em>max_time</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[_Jitterer, None] &#160;</td>
          <td class="paramname"><em>jitter</em> = <code>full_jitter</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate[Exception] &#160;</td>
          <td class="paramname"><em>giveup</em> = <code>lambda&#160;e:&#160;False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[_Handler, Iterable[_Handler], None] &#160;</td>
          <td class="paramname"><em>on_success</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[_Handler, Iterable[_Handler], None] &#160;</td>
          <td class="paramname"><em>on_backoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[_Handler, Iterable[_Handler], None] &#160;</td>
          <td class="paramname"><em>on_giveup</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>raise_on_giveup</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_MaybeLogger &#160;</td>
          <td class="paramname"><em>logger</em> = <code>'backoff'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>backoff_log_level</em> = <code>logging.INFO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>giveup_log_level</em> = <code>logging.ERROR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>wait_gen_kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns decorator for backoff and retry triggered by exception.

Args:
    wait_gen: A generator yielding successive wait times in
        seconds.
    exception: An exception type (or tuple of types) which triggers
        backoff.
    max_tries: The maximum number of attempts to make before giving
        up. Once exhausted, the exception will be allowed to escape.
        The default value of None means there is no limit to the
        number of tries. If a callable is passed, it will be
        evaluated at runtime and its return value used.
    max_time: The maximum total amount of time to try for before
        giving up. Once expired, the exception will be allowed to
        escape. If a callable is passed, it will be
        evaluated at runtime and its return value used.
    jitter: A function of the value yielded by wait_gen returning
        the actual time to wait. This distributes wait times
        stochastically in order to avoid timing collisions across
        concurrent clients. Wait times are jittered by default
        using the full_jitter function. Jittering may be disabled
        altogether by passing jitter=None.
    giveup: Function accepting an exception instance and
        returning whether or not to give up. Optional. The default
        is to always continue.
    on_success: Callable (or iterable of callables) with a unary
        signature to be called in the event of success. The
        parameter is a dict containing details about the invocation.
    on_backoff: Callable (or iterable of callables) with a unary
        signature to be called in the event of a backoff. The
        parameter is a dict containing details about the invocation.
    on_giveup: Callable (or iterable of callables) with a unary
        signature to be called in the event that max_tries
        is exceeded.  The parameter is a dict containing details
        about the invocation.
    raise_on_giveup: Boolean indicating whether the registered exceptions
        should be raised on giveup. Defaults to `True`
    logger: Name or Logger object to log to. Defaults to 'backoff'.
    backoff_log_level: log level for the backoff event. Defaults to "INFO"
    giveup_log_level: log level for the give up event. Defaults to "ERROR"
    **wait_gen_kwargs: Any additional keyword args specified will be
        passed to wait_gen when it is initialized.  Any callable
        args will first be evaluated and their return values passed.
        This is useful for runtime configuration.
</pre> 
</div>
</div>
<a id="a1b1e86d0dd68bc54cd7c9bb7728b8825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1e86d0dd68bc54cd7c9bb7728b8825">&#9670;&nbsp;</a></span>on_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Callable[[_CallableT], _CallableT] backoff._decorator.on_predicate </td>
          <td>(</td>
          <td class="paramtype">_WaitGenerator&#160;</td>
          <td class="paramname"><em>wait_gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate[Any] &#160;</td>
          <td class="paramname"><em>predicate</em> = <code>operator.not_</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[_MaybeCallable[int]] &#160;</td>
          <td class="paramname"><em>max_tries</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_MaybeCallable[float]] &#160;</td>
          <td class="paramname"><em>max_time</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[_Jitterer, None] &#160;</td>
          <td class="paramname"><em>jitter</em> = <code>full_jitter</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[_Handler, Iterable[_Handler], None] &#160;</td>
          <td class="paramname"><em>on_success</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[_Handler, Iterable[_Handler], None] &#160;</td>
          <td class="paramname"><em>on_backoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[_Handler, Iterable[_Handler], None] &#160;</td>
          <td class="paramname"><em>on_giveup</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_MaybeLogger &#160;</td>
          <td class="paramname"><em>logger</em> = <code>'backoff'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>backoff_log_level</em> = <code>logging.INFO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>giveup_log_level</em> = <code>logging.ERROR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>wait_gen_kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns decorator for backoff and retry triggered by predicate.

Args:
    wait_gen: A generator yielding successive wait times in
        seconds.
    predicate: A function which when called on the return value of
        the target function will trigger backoff when considered
        truthily. If not specified, the default behavior is to
        backoff on falsey return values.
    max_tries: The maximum number of attempts to make before giving
        up. In the case of failure, the result of the last attempt
        will be returned. The default value of None means there
        is no limit to the number of tries. If a callable is passed,
        it will be evaluated at runtime and its return value used.
    max_time: The maximum total amount of time to try for before
        giving up. If this time expires, the result of the last
        attempt will be returned. If a callable is passed, it will
        be evaluated at runtime and its return value used.
    jitter: A function of the value yielded by wait_gen returning
        the actual time to wait. This distributes wait times
        stochastically in order to avoid timing collisions across
        concurrent clients. Wait times are jittered by default
        using the full_jitter function. Jittering may be disabled
        altogether by passing jitter=None.
    on_success: Callable (or iterable of callables) with a unary
        signature to be called in the event of success. The
        parameter is a dict containing details about the invocation.
    on_backoff: Callable (or iterable of callables) with a unary
        signature to be called in the event of a backoff. The
        parameter is a dict containing details about the invocation.
    on_giveup: Callable (or iterable of callables) with a unary
        signature to be called in the event that max_tries
        is exceeded.  The parameter is a dict containing details
        about the invocation.
    logger: Name of logger or Logger object to log to. Defaults to
        'backoff'.
    backoff_log_level: log level for the backoff event. Defaults to "INFO"
    giveup_log_level: log level for the give up event. Defaults to "ERROR"
    **wait_gen_kwargs: Any additional keyword args specified will be
        passed to wait_gen when it is initialized.  Any callable
        args will first be evaluated and their return values passed.
        This is useful for runtime configuration.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
