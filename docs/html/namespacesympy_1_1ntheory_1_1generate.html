<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.ntheory.generate Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1ntheory.html">ntheory</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html">generate</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.ntheory.generate Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1ntheory_1_1generate_1_1Sieve.html">Sieve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac53e43b2dd68b6b0f40caf212ec812c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#ac53e43b2dd68b6b0f40caf212ec812c9">prime</a> (nth)</td></tr>
<tr class="separator:ac53e43b2dd68b6b0f40caf212ec812c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071cdbb2b8b8991fca430cb3f7852967"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#a071cdbb2b8b8991fca430cb3f7852967">primepi</a> (n)</td></tr>
<tr class="separator:a071cdbb2b8b8991fca430cb3f7852967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34448a33620ec53c86bc07a011bf8a9b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#a34448a33620ec53c86bc07a011bf8a9b">nextprime</a> (n, ith=1)</td></tr>
<tr class="separator:a34448a33620ec53c86bc07a011bf8a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127bfb071444a98ccc837a4da036436f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#a127bfb071444a98ccc837a4da036436f">prevprime</a> (n)</td></tr>
<tr class="separator:a127bfb071444a98ccc837a4da036436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1380fcb5d817899468916ff2c44acce3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#a1380fcb5d817899468916ff2c44acce3">primerange</a> (a, b=None)</td></tr>
<tr class="separator:a1380fcb5d817899468916ff2c44acce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab927b9c5fc4dd33c29901339d570fd0e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#ab927b9c5fc4dd33c29901339d570fd0e">randprime</a> (a, b)</td></tr>
<tr class="separator:ab927b9c5fc4dd33c29901339d570fd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8c03bd73622031c9215832fbae0f30"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#a4d8c03bd73622031c9215832fbae0f30">primorial</a> (n, nth=True)</td></tr>
<tr class="separator:a4d8c03bd73622031c9215832fbae0f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3fdb5a24057b5670a0e15b31ec9f36"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#a5d3fdb5a24057b5670a0e15b31ec9f36">cycle_length</a> (f, x0, nmax=None, values=False)</td></tr>
<tr class="separator:a5d3fdb5a24057b5670a0e15b31ec9f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed074eabc8bec29181ae783986799c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#a7ed074eabc8bec29181ae783986799c7">composite</a> (nth)</td></tr>
<tr class="separator:a7ed074eabc8bec29181ae783986799c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c20433a4850baa41db241ad0ee049ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#a3c20433a4850baa41db241ad0ee049ef">compositepi</a> (n)</td></tr>
<tr class="separator:a3c20433a4850baa41db241ad0ee049ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af60f2c01a9c8cd1608336a087751338e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1generate.html#af60f2c01a9c8cd1608336a087751338e">sieve</a> = <a class="el" href="classsympy_1_1ntheory_1_1generate_1_1Sieve.html">Sieve</a>()</td></tr>
<tr class="separator:af60f2c01a9c8cd1608336a087751338e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Generating and counting primes.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a7ed074eabc8bec29181ae783986799c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed074eabc8bec29181ae783986799c7">&#9670;&nbsp;</a></span>composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.composite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the nth composite number, with the composite numbers indexed as
    composite(1) = 4, composite(2) = 6, etc....

    Examples
    ========

    &gt;&gt;&gt; from sympy import composite
    &gt;&gt;&gt; composite(36)
    52
    &gt;&gt;&gt; composite(1)
    4
    &gt;&gt;&gt; composite(17737)
    20000

    See Also
    ========

    sympy.ntheory.primetest.isprime : Test if n is prime
    primerange : Generate all primes in a given range
    primepi : Return the number of primes less than or equal to n
    prime : Return the nth prime
    compositepi : Return the number of positive composite numbers less than or equal to n
</pre> 
</div>
</div>
<a id="a3c20433a4850baa41db241ad0ee049ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c20433a4850baa41db241ad0ee049ef">&#9670;&nbsp;</a></span>compositepi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.compositepi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the number of positive composite numbers less than or equal to n.
    The first positive composite is 4, i.e. compositepi(4) = 1.

    Examples
    ========

    &gt;&gt;&gt; from sympy import compositepi
    &gt;&gt;&gt; compositepi(25)
    15
    &gt;&gt;&gt; compositepi(1000)
    831

    See Also
    ========

    sympy.ntheory.primetest.isprime : Test if n is prime
    primerange : Generate all primes in a given range
    prime : Return the nth prime
    primepi : Return the number of primes less than or equal to n
    composite : Return the nth composite number
</pre> 
</div>
</div>
<a id="a5d3fdb5a24057b5670a0e15b31ec9f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3fdb5a24057b5670a0e15b31ec9f36">&#9670;&nbsp;</a></span>cycle_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.cycle_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nmax</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a given iterated sequence, return a generator that gives
the length of the iterated cycle (lambda) and the length of terms
before the cycle begins (mu); if ``values`` is True then the
terms of the sequence will be returned instead. The sequence is
started with value ``x0``.

Note: more than the first lambda + mu terms may be returned and this
is the cost of cycle detection with Brent's method; there are, however,
generally less terms calculated than would have been calculated if the
proper ending point were determined, e.g. by using Floyd's method.

&gt;&gt;&gt; from sympy.ntheory.generate import cycle_length

This will yield successive values of i &lt;-- func(i):

    &gt;&gt;&gt; def gen(func, i):
    ...     while 1:
    ...         yield i
    ...         i = func(i)
    ...

A function is defined:

    &gt;&gt;&gt; func = lambda i: (i**2 + 1) % 51

and given a seed of 4 and the mu and lambda terms calculated:

    &gt;&gt;&gt; next(cycle_length(func, 4))
    (6, 3)

We can see what is meant by looking at the output:

    &gt;&gt;&gt; iter = cycle_length(func, 4, values=True)
    &gt;&gt;&gt; list(iter)
    [4, 17, 35, 2, 5, 26, 14, 44, 50, 2, 5, 26, 14]

There are 6 repeating values after the first 3.

If a sequence is suspected of being longer than you might wish, ``nmax``
can be used to exit early (and mu will be returned as None):

    &gt;&gt;&gt; next(cycle_length(func, 4, nmax = 4))
    (4, None)
    &gt;&gt;&gt; list(cycle_length(func, 4, nmax = 4, values=True))
    [4, 17, 35, 2]

Code modified from:
    https://en.wikipedia.org/wiki/Cycle_detection.
</pre> 
</div>
</div>
<a id="a34448a33620ec53c86bc07a011bf8a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34448a33620ec53c86bc07a011bf8a9b">&#9670;&nbsp;</a></span>nextprime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.nextprime </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ith</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the ith prime greater than n.

    Parameters
    ==========

    n : integer
    ith : positive integer

    Returns
    =======

    int : Return the ith prime greater than n

    Raises
    ======

    ValueError
        If ``ith &lt;= 0``.
        If ``n`` or ``ith`` is not an integer.

    Notes
    =====

    Potential primes are located at 6*j +/- 1. This
    property is used during searching.

    &gt;&gt;&gt; from sympy import nextprime
    &gt;&gt;&gt; [(i, nextprime(i)) for i in range(10, 15)]
    [(10, 11), (11, 13), (12, 13), (13, 17), (14, 17)]
    &gt;&gt;&gt; nextprime(2, ith=2) # the 2nd prime after 2
    5

    See Also
    ========

    prevprime : Return the largest prime smaller than n
    primerange : Generate all primes in a given range</pre> 
</div>
</div>
<a id="a127bfb071444a98ccc837a4da036436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127bfb071444a98ccc837a4da036436f">&#9670;&nbsp;</a></span>prevprime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.prevprime </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the largest prime smaller than n.

    Notes
    =====

    Potential primes are located at 6*j +/- 1. This
    property is used during searching.

    &gt;&gt;&gt; from sympy import prevprime
    &gt;&gt;&gt; [(i, prevprime(i)) for i in range(10, 15)]
    [(10, 7), (11, 7), (12, 11), (13, 11), (14, 13)]

    See Also
    ========

    nextprime : Return the ith prime greater than n
    primerange : Generates all primes in a given range
</pre> 
</div>
</div>
<a id="ac53e43b2dd68b6b0f40caf212ec812c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53e43b2dd68b6b0f40caf212ec812c9">&#9670;&nbsp;</a></span>prime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.prime </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the nth prime, with the primes indexed as prime(1) = 2,
    prime(2) = 3, etc.... The nth prime is approximately $n\log(n)$.

    Logarithmic integral of $x$ is a pretty nice approximation for number of
    primes $\le x$, i.e.
    li(x) ~ pi(x)
    In fact, for the numbers we are concerned about( x&lt;1e11 ),
    li(x) - pi(x) &lt; 50000

    Also,
    li(x) &gt; pi(x) can be safely assumed for the numbers which
    can be evaluated by this function.

    Here, we find the least integer m such that li(m) &gt; n using binary search.
    Now pi(m-1) &lt; li(m-1) &lt;= n,

    We find pi(m - 1) using primepi function.

    Starting from m, we have to find n - pi(m-1) more primes.

    For the inputs this implementation can handle, we will have to test
    primality for at max about 10**5 numbers, to get our answer.

    Examples
    ========

    &gt;&gt;&gt; from sympy import prime
    &gt;&gt;&gt; prime(10)
    29
    &gt;&gt;&gt; prime(1)
    2
    &gt;&gt;&gt; prime(100000)
    1299709

    See Also
    ========

    sympy.ntheory.primetest.isprime : Test if n is prime
    primerange : Generate all primes in a given range
    primepi : Return the number of primes less than or equal to n

    References
    ==========

    .. [1] https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29
    .. [2] https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number
    .. [3] https://en.wikipedia.org/wiki/Skewes%27_number
</pre> 
</div>
</div>
<a id="a071cdbb2b8b8991fca430cb3f7852967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071cdbb2b8b8991fca430cb3f7852967">&#9670;&nbsp;</a></span>primepi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.primepi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Represents the prime counting function pi(n) = the number
    of prime numbers less than or equal to n.

    .. deprecated:: 1.13

        The ``primepi`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.primepi`
        instead. See its documentation for more information. See
        :ref:`deprecated-ntheory-symbolic-functions` for details.

    Algorithm Description:

    In sieve method, we remove all multiples of prime p
    except p itself.

    Let phi(i,j) be the number of integers 2 &lt;= k &lt;= i
    which remain after sieving from primes less than
    or equal to j.
    Clearly, pi(n) = phi(n, sqrt(n))

    If j is not a prime,
    phi(i,j) = phi(i, j - 1)

    if j is a prime,
    We remove all numbers(except j) whose
    smallest prime factor is j.

    Let $x= j \times a$ be such a number, where $2 \le a \le i / j$
    Now, after sieving from primes $\le j - 1$,
    a must remain
    (because x, and hence a has no prime factor $\le j - 1$)
    Clearly, there are phi(i / j, j - 1) such a
    which remain on sieving from primes $\le j - 1$

    Now, if a is a prime less than equal to j - 1,
    $x= j \times a$ has smallest prime factor = a, and
    has already been removed(by sieving from a).
    So, we do not need to remove it again.
    (Note: there will be pi(j - 1) such x)

    Thus, number of x, that will be removed are:
    phi(i / j, j - 1) - phi(j - 1, j - 1)
    (Note that pi(j - 1) = phi(j - 1, j - 1))

    $\Rightarrow$ phi(i,j) = phi(i, j - 1) - phi(i / j, j - 1) + phi(j - 1, j - 1)

    So,following recursion is used and implemented as dp:

    phi(a, b) = phi(a, b - 1), if b is not a prime
    phi(a, b) = phi(a, b-1)-phi(a / b, b-1) + phi(b-1, b-1), if b is prime

    Clearly a is always of the form floor(n / k),
    which can take at most $2\sqrt{n}$ values.
    Two arrays arr1,arr2 are maintained
    arr1[i] = phi(i, j),
    arr2[i] = phi(n // i, j)

    Finally the answer is arr2[1]

    Examples
    ========

    &gt;&gt;&gt; from sympy import primepi, prime, prevprime, isprime
    &gt;&gt;&gt; primepi(25)
    9

    So there are 9 primes less than or equal to 25. Is 25 prime?

    &gt;&gt;&gt; isprime(25)
    False

    It is not. So the first prime less than 25 must be the
    9th prime:

    &gt;&gt;&gt; prevprime(25) == prime(9)
    True

    See Also
    ========

    sympy.ntheory.primetest.isprime : Test if n is prime
    primerange : Generate all primes in a given range
    prime : Return the nth prime
</pre> 
</div>
</div>
<a id="a1380fcb5d817899468916ff2c44acce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1380fcb5d817899468916ff2c44acce3">&#9670;&nbsp;</a></span>primerange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.primerange </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Generate a list of all prime numbers in the range [2, a),
    or [a, b).

    If the range exists in the default sieve, the values will
    be returned from there; otherwise values will be returned
    but will not modify the sieve.

    Examples
    ========

    &gt;&gt;&gt; from sympy import primerange, prime

    All primes less than 19:

    &gt;&gt;&gt; list(primerange(19))
    [2, 3, 5, 7, 11, 13, 17]

    All primes greater than or equal to 7 and less than 19:

    &gt;&gt;&gt; list(primerange(7, 19))
    [7, 11, 13, 17]

    All primes through the 10th prime

    &gt;&gt;&gt; list(primerange(prime(10) + 1))
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

    The Sieve method, primerange, is generally faster but it will
    occupy more memory as the sieve stores values. The default
    instance of Sieve, named sieve, can be used:

    &gt;&gt;&gt; from sympy import sieve
    &gt;&gt;&gt; list(sieve.primerange(1, 30))
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

    Notes
    =====

    Some famous conjectures about the occurrence of primes in a given
    range are [1]:

    - Twin primes: though often not, the following will give 2 primes
                an infinite number of times:
                    primerange(6*n - 1, 6*n + 2)
    - Legendre's: the following always yields at least one prime
                    primerange(n**2, (n+1)**2+1)
    - Bertrand's (proven): there is always a prime in the range
                    primerange(n, 2*n)
    - Brocard's: there are at least four primes in the range
                    primerange(prime(n)**2, prime(n+1)**2)

    The average gap between primes is log(n) [2]; the gap between
    primes can be arbitrarily large since sequences of composite
    numbers are arbitrarily large, e.g. the numbers in the sequence
    n! + 2, n! + 3 ... n! + n are all composite.

    See Also
    ========

    prime : Return the nth prime
    nextprime : Return the ith prime greater than n
    prevprime : Return the largest prime smaller than n
    randprime : Returns a random prime in a given range
    primorial : Returns the product of primes based on condition
    Sieve.primerange : return range from already computed primes
                       or extend the sieve to contain the requested
                       range.

    References
    ==========

    .. [1] https://en.wikipedia.org/wiki/Prime_number
    .. [2] https://primes.utm.edu/notes/gaps.html
</pre> 
</div>
</div>
<a id="a4d8c03bd73622031c9215832fbae0f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8c03bd73622031c9215832fbae0f30">&#9670;&nbsp;</a></span>primorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.primorial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nth</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the product of the first n primes (default) or
the primes less than or equal to n (when ``nth=False``).

Examples
========

&gt;&gt;&gt; from sympy.ntheory.generate import primorial, primerange
&gt;&gt;&gt; from sympy import factorint, Mul, primefactors, sqrt
&gt;&gt;&gt; primorial(4) # the first 4 primes are 2, 3, 5, 7
210
&gt;&gt;&gt; primorial(4, nth=False) # primes &lt;= 4 are 2 and 3
6
&gt;&gt;&gt; primorial(1)
2
&gt;&gt;&gt; primorial(1, nth=False)
1
&gt;&gt;&gt; primorial(sqrt(101), nth=False)
210

One can argue that the primes are infinite since if you take
a set of primes and multiply them together (e.g. the primorial) and
then add or subtract 1, the result cannot be divided by any of the
original factors, hence either 1 or more new primes must divide this
product of primes.

In this case, the number itself is a new prime:

&gt;&gt;&gt; factorint(primorial(4) + 1)
{211: 1}

In this case two new primes are the factors:

&gt;&gt;&gt; factorint(primorial(4) - 1)
{11: 1, 19: 1}

Here, some primes smaller and larger than the primes multiplied together
are obtained:

&gt;&gt;&gt; p = list(primerange(10, 20))
&gt;&gt;&gt; sorted(set(primefactors(Mul(*p) + 1)).difference(set(p)))
[2, 5, 31, 149]

See Also
========

primerange : Generate all primes in a given range</pre> 
</div>
</div>
<a id="ab927b9c5fc4dd33c29901339d570fd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab927b9c5fc4dd33c29901339d570fd0e">&#9670;&nbsp;</a></span>randprime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.generate.randprime </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return a random prime number in the range [a, b).

    Bertrand's postulate assures that
    randprime(a, 2*a) will always succeed for a &gt; 1.

    Note that due to implementation difficulties,
    the prime numbers chosen are not uniformly random.
    For example, there are two primes in the range [112, 128),
    ``113`` and ``127``, but ``randprime(112, 128)`` returns ``127``
    with a probability of 15/17.

    Examples
    ========

    &gt;&gt;&gt; from sympy import randprime, isprime
    &gt;&gt;&gt; randprime(1, 30) #doctest: +SKIP
    13
    &gt;&gt;&gt; isprime(randprime(1, 30))
    True

    See Also
    ========

    primerange : Generate all primes in a given range

    References
    ==========

    .. [1] https://en.wikipedia.org/wiki/Bertrand's_postulate</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af60f2c01a9c8cd1608336a087751338e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60f2c01a9c8cd1608336a087751338e">&#9670;&nbsp;</a></span>sieve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.ntheory.generate.sieve = <a class="el" href="classsympy_1_1ntheory_1_1generate_1_1Sieve.html">Sieve</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
