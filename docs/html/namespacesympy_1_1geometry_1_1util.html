<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.geometry.util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1geometry_1_1util.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.geometry.util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f428e2a778f68cbe5af716b89c5370e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#a2f428e2a778f68cbe5af716b89c5370e">find</a> (x, equation)</td></tr>
<tr class="separator:a2f428e2a778f68cbe5af716b89c5370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297bc255043b94b16584e60b3a472233"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#a297bc255043b94b16584e60b3a472233">are_coplanar</a> (*e)</td></tr>
<tr class="separator:a297bc255043b94b16584e60b3a472233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e9160c61e69c8786a5fb7f47aaca80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#a35e9160c61e69c8786a5fb7f47aaca80">are_similar</a> (e1, e2)</td></tr>
<tr class="separator:a35e9160c61e69c8786a5fb7f47aaca80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c82f8046e19936fc8503fedf1f21f4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#a31c82f8046e19936fc8503fedf1f21f4">centroid</a> (*args)</td></tr>
<tr class="separator:a31c82f8046e19936fc8503fedf1f21f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021d0f5d34be7d3c59a31de48c01868f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#a021d0f5d34be7d3c59a31de48c01868f">closest_points</a> (*args)</td></tr>
<tr class="separator:a021d0f5d34be7d3c59a31de48c01868f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cde4fef4182f64c13b46fe53dcbfbe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#ac1cde4fef4182f64c13b46fe53dcbfbe">convex_hull</a> (*args, polygon=True)</td></tr>
<tr class="separator:ac1cde4fef4182f64c13b46fe53dcbfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987027b0ec9dd7ee01d037c3ea0d8b27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#a987027b0ec9dd7ee01d037c3ea0d8b27">farthest_points</a> (*args)</td></tr>
<tr class="separator:a987027b0ec9dd7ee01d037c3ea0d8b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e05f057fb7a8dcacc12b1c580c1cce9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#a9e05f057fb7a8dcacc12b1c580c1cce9">idiff</a> (eq, y, x, n=1)</td></tr>
<tr class="separator:a9e05f057fb7a8dcacc12b1c580c1cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72207c83d60a0bc230c79a9d1bbe4a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1geometry_1_1util.html#ac72207c83d60a0bc230c79a9d1bbe4a2">intersection</a> (*entities, pairwise=False, **kwargs)</td></tr>
<tr class="separator:ac72207c83d60a0bc230c79a9d1bbe4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Utility functions for geometrical entities.

Contains
========
intersection
convex_hull
closest_points
farthest_points
are_coplanar
are_similar</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a297bc255043b94b16584e60b3a472233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297bc255043b94b16584e60b3a472233">&#9670;&nbsp;</a></span>are_coplanar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.are_coplanar </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns True if the given entities are coplanar otherwise False

Parameters
==========

e: entities to be checked for being coplanar

Returns
=======

Boolean

Examples
========

&gt;&gt;&gt; from sympy import Point3D, Line3D
&gt;&gt;&gt; from sympy.geometry.util import are_coplanar
&gt;&gt;&gt; a = Line3D(Point3D(5, 0, 0), Point3D(1, -1, 1))
&gt;&gt;&gt; b = Line3D(Point3D(0, -2, 0), Point3D(3, 1, 1))
&gt;&gt;&gt; c = Line3D(Point3D(0, -1, 0), Point3D(5, -1, 9))
&gt;&gt;&gt; are_coplanar(a, b, c)
False</pre> 
</div>
</div>
<a id="a35e9160c61e69c8786a5fb7f47aaca80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e9160c61e69c8786a5fb7f47aaca80">&#9670;&nbsp;</a></span>are_similar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.are_similar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Are two geometrical entities similar.

Can one geometrical entity be uniformly scaled to the other?

Parameters
==========

e1 : GeometryEntity
e2 : GeometryEntity

Returns
=======

are_similar : boolean

Raises
======

GeometryError
    When `e1` and `e2` cannot be compared.

Notes
=====

If the two objects are equal then they are similar.

See Also
========

sympy.geometry.entity.GeometryEntity.is_similar

Examples
========

&gt;&gt;&gt; from sympy import Point, Circle, Triangle, are_similar
&gt;&gt;&gt; c1, c2 = Circle(Point(0, 0), 4), Circle(Point(1, 4), 3)
&gt;&gt;&gt; t1 = Triangle(Point(0, 0), Point(1, 0), Point(0, 1))
&gt;&gt;&gt; t2 = Triangle(Point(0, 0), Point(2, 0), Point(0, 2))
&gt;&gt;&gt; t3 = Triangle(Point(0, 0), Point(3, 0), Point(0, 1))
&gt;&gt;&gt; are_similar(t1, t2)
True
&gt;&gt;&gt; are_similar(t1, t3)
False</pre> 
</div>
</div>
<a id="a31c82f8046e19936fc8503fedf1f21f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c82f8046e19936fc8503fedf1f21f4">&#9670;&nbsp;</a></span>centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.centroid </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the centroid (center of mass) of the collection containing only Points,
Segments or Polygons. The centroid is the weighted average of the individual centroid
where the weights are the lengths (of segments) or areas (of polygons).
Overlapping regions will add to the weight of that region.

If there are no objects (or a mixture of objects) then None is returned.

See Also
========

sympy.geometry.point.Point, sympy.geometry.line.Segment,
sympy.geometry.polygon.Polygon

Examples
========

&gt;&gt;&gt; from sympy import Point, Segment, Polygon
&gt;&gt;&gt; from sympy.geometry.util import centroid
&gt;&gt;&gt; p = Polygon((0, 0), (10, 0), (10, 10))
&gt;&gt;&gt; q = p.translate(0, 20)
&gt;&gt;&gt; p.centroid, q.centroid
(Point2D(20/3, 10/3), Point2D(20/3, 70/3))
&gt;&gt;&gt; centroid(p, q)
Point2D(20/3, 40/3)
&gt;&gt;&gt; p, q = Segment((0, 0), (2, 0)), Segment((0, 0), (2, 2))
&gt;&gt;&gt; centroid(p, q)
Point2D(1, 2 - sqrt(2))
&gt;&gt;&gt; centroid(Point(0, 0), Point(2, 0))
Point2D(1, 0)

Stacking 3 polygons on top of each other effectively triples the
weight of that polygon:

&gt;&gt;&gt; p = Polygon((0, 0), (1, 0), (1, 1), (0, 1))
&gt;&gt;&gt; q = Polygon((1, 0), (3, 0), (3, 1), (1, 1))
&gt;&gt;&gt; centroid(p, q)
Point2D(3/2, 1/2)
&gt;&gt;&gt; centroid(p, p, p, q) # centroid x-coord shifts left
Point2D(11/10, 1/2)

Stacking the squares vertically above and below p has the same
effect:

&gt;&gt;&gt; centroid(p, p.translate(0, 1), p.translate(0, -1), q)
Point2D(11/10, 1/2)</pre> 
</div>
</div>
<a id="a021d0f5d34be7d3c59a31de48c01868f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021d0f5d34be7d3c59a31de48c01868f">&#9670;&nbsp;</a></span>closest_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.closest_points </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the subset of points from a set of points that were
the closest to each other in the 2D plane.

Parameters
==========

args
    A collection of Points on 2D plane.

Notes
=====

This can only be performed on a set of points whose coordinates can
be ordered on the number line. If there are no ties then a single
pair of Points will be in the set.

Examples
========

&gt;&gt;&gt; from sympy import closest_points, Triangle
&gt;&gt;&gt; Triangle(sss=(3, 4, 5)).args
(Point2D(0, 0), Point2D(3, 0), Point2D(3, 4))
&gt;&gt;&gt; closest_points(*_)
{(Point2D(0, 0), Point2D(3, 0))}

References
==========

.. [1] https://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairPS.html

.. [2] Sweep line algorithm
    https://en.wikipedia.org/wiki/Sweep_line_algorithm</pre> 
</div>
</div>
<a id="ac1cde4fef4182f64c13b46fe53dcbfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cde4fef4182f64c13b46fe53dcbfbe">&#9670;&nbsp;</a></span>convex_hull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.convex_hull </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>polygon</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The convex hull surrounding the Points contained in the list of entities.

Parameters
==========

args : a collection of Points, Segments and/or Polygons

Optional parameters
===================

polygon : Boolean. If True, returns a Polygon, if false a tuple, see below.
          Default is True.

Returns
=======

convex_hull : Polygon if ``polygon`` is True else as a tuple `(U, L)` where
              ``L`` and ``U`` are the lower and upper hulls, respectively.

Notes
=====

This can only be performed on a set of points whose coordinates can
be ordered on the number line.

See Also
========

sympy.geometry.point.Point, sympy.geometry.polygon.Polygon

Examples
========

&gt;&gt;&gt; from sympy import convex_hull
&gt;&gt;&gt; points = [(1, 1), (1, 2), (3, 1), (-5, 2), (15, 4)]
&gt;&gt;&gt; convex_hull(*points)
Polygon(Point2D(-5, 2), Point2D(1, 1), Point2D(3, 1), Point2D(15, 4))
&gt;&gt;&gt; convex_hull(*points, **dict(polygon=False))
([Point2D(-5, 2), Point2D(15, 4)],
 [Point2D(-5, 2), Point2D(1, 1), Point2D(3, 1), Point2D(15, 4)])

References
==========

.. [1] https://en.wikipedia.org/wiki/Graham_scan

.. [2] Andrew's Monotone Chain Algorithm
  (A.M. Andrew,
  "Another Efficient Algorithm for Convex Hulls in Two Dimensions", 1979)
  https://web.archive.org/web/20210511015444/http://geomalgorithms.com/a10-_hull-1.html</pre> 
</div>
</div>
<a id="a987027b0ec9dd7ee01d037c3ea0d8b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987027b0ec9dd7ee01d037c3ea0d8b27">&#9670;&nbsp;</a></span>farthest_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.farthest_points </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the subset of points from a set of points that were
the furthest apart from each other in the 2D plane.

Parameters
==========

args
    A collection of Points on 2D plane.

Notes
=====

This can only be performed on a set of points whose coordinates can
be ordered on the number line. If there are no ties then a single
pair of Points will be in the set.

Examples
========

&gt;&gt;&gt; from sympy.geometry import farthest_points, Triangle
&gt;&gt;&gt; Triangle(sss=(3, 4, 5)).args
(Point2D(0, 0), Point2D(3, 0), Point2D(3, 4))
&gt;&gt;&gt; farthest_points(*_)
{(Point2D(0, 0), Point2D(3, 4))}

References
==========

.. [1] https://code.activestate.com/recipes/117225-convex-hull-and-diameter-of-2d-point-sets/

.. [2] Rotating Callipers Technique
    https://en.wikipedia.org/wiki/Rotating_calipers</pre> 
</div>
</div>
<a id="a2f428e2a778f68cbe5af716b89c5370e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f428e2a778f68cbe5af716b89c5370e">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.find </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks whether a Symbol matching ``x`` is present in ``equation``
or not. If present, the matching symbol is returned, else a
ValueError is raised. If ``x`` is a string the matching symbol
will have the same name; if ``x`` is a Symbol then it will be
returned if found.

Examples
========

&gt;&gt;&gt; from sympy.geometry.util import find
&gt;&gt;&gt; from sympy import Dummy
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; find('x', x)
x
&gt;&gt;&gt; find('x', Dummy('x'))
_x

The dummy symbol is returned since it has a matching name:

&gt;&gt;&gt; _.name == 'x'
True
&gt;&gt;&gt; find(x, Dummy('x'))
Traceback (most recent call last):
...
ValueError: could not find x
</pre> 
</div>
</div>
<a id="a9e05f057fb7a8dcacc12b1c580c1cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e05f057fb7a8dcacc12b1c580c1cce9">&#9670;&nbsp;</a></span>idiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.idiff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``dy/dx`` assuming that ``eq == 0``.

Parameters
==========

y : the dependent variable or a list of dependent variables (with y first)
x : the variable that the derivative is being taken with respect to
n : the order of the derivative (default is 1)

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y, a
&gt;&gt;&gt; from sympy.geometry.util import idiff

&gt;&gt;&gt; circ = x**2 + y**2 - 4
&gt;&gt;&gt; idiff(circ, y, x)
-x/y
&gt;&gt;&gt; idiff(circ, y, x, 2).simplify()
(-x**2 - y**2)/y**3

Here, ``a`` is assumed to be independent of ``x``:

&gt;&gt;&gt; idiff(x + a + y, y, x)
-1

Now the x-dependence of ``a`` is made explicit by listing ``a`` after
``y`` in a list.

&gt;&gt;&gt; idiff(x + a + y, [y, a], x)
-Derivative(a, x) - 1

See Also
========

sympy.core.function.Derivative: represents unevaluated derivatives
sympy.core.function.diff: explicitly differentiates wrt symbols</pre> 
</div>
</div>
<a id="ac72207c83d60a0bc230c79a9d1bbe4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72207c83d60a0bc230c79a9d1bbe4a2">&#9670;&nbsp;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.geometry.util.intersection </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pairwise</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The intersection of a collection of GeometryEntity instances.

Parameters
==========
entities : sequence of GeometryEntity
pairwise (keyword argument) : Can be either True or False

Returns
=======
intersection : list of GeometryEntity

Raises
======
NotImplementedError
    When unable to calculate intersection.

Notes
=====
The intersection of any geometrical entity with itself should return
a list with one item: the entity in question.
An intersection requires two or more entities. If only a single
entity is given then the function will return an empty list.
It is possible for `intersection` to miss intersections that one
knows exists because the required quantities were not fully
simplified internally.
Reals should be converted to Rationals, e.g. Rational(str(real_num))
or else failures due to floating point issues may result.

Case 1: When the keyword argument 'pairwise' is False (default value):
In this case, the function returns a list of intersections common to
all entities.

Case 2: When the keyword argument 'pairwise' is True:
In this case, the functions returns a list intersections that occur
between any pair of entities.

See Also
========

sympy.geometry.entity.GeometryEntity.intersection

Examples
========

&gt;&gt;&gt; from sympy import Ray, Circle, intersection
&gt;&gt;&gt; c = Circle((0, 1), 1)
&gt;&gt;&gt; intersection(c, c.center)
[]
&gt;&gt;&gt; right = Ray((0, 0), (1, 0))
&gt;&gt;&gt; up = Ray((0, 0), (0, 1))
&gt;&gt;&gt; intersection(c, right, up)
[Point2D(0, 0)]
&gt;&gt;&gt; intersection(c, right, up, pairwise=True)
[Point2D(0, 0), Point2D(0, 2)]
&gt;&gt;&gt; left = Ray((1, 0), (0, 0))
&gt;&gt;&gt; intersection(right, left)
[Segment2D(Point2D(0, 0), Point2D(1, 0))]</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
