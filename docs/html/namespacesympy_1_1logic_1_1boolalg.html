<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.logic.boolalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1logic.html">logic</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html">boolalg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.logic.boolalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Boolean.html">Boolean</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1BooleanAtom.html">BooleanAtom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1BooleanTrue.html">BooleanTrue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1BooleanFalse.html">BooleanFalse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1BooleanFunction.html">BooleanFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1And.html">And</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Or.html">Or</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Not.html">Not</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Xor.html">Xor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Nand.html">Nand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Nor.html">Nor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Xnor.html">Xnor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Implies.html">Implies</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Equivalent.html">Equivalent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1ITE.html">ITE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Exclusive.html">Exclusive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a25c48f48fe23746c8273e5ccdec56e00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a25c48f48fe23746c8273e5ccdec56e00">as_Boolean</a> (e)</td></tr>
<tr class="separator:a25c48f48fe23746c8273e5ccdec56e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec5b602e75b7c95e531207f2b22136d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a0ec5b602e75b7c95e531207f2b22136d">conjuncts</a> (expr)</td></tr>
<tr class="separator:a0ec5b602e75b7c95e531207f2b22136d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04244892e99c4019a4e78bedd45ebf6f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a04244892e99c4019a4e78bedd45ebf6f">disjuncts</a> (expr)</td></tr>
<tr class="separator:a04244892e99c4019a4e78bedd45ebf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bc2673cf3cc23397eca0ade9a2bdbc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#ad7bc2673cf3cc23397eca0ade9a2bdbc">distribute_and_over_or</a> (expr)</td></tr>
<tr class="separator:ad7bc2673cf3cc23397eca0ade9a2bdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9598bbcb5f4815d9a9fd9c9d2c4d08f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a9598bbcb5f4815d9a9fd9c9d2c4d08f7">distribute_or_over_and</a> (expr)</td></tr>
<tr class="separator:a9598bbcb5f4815d9a9fd9c9d2c4d08f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33913256af86c81992f3f8cee75b8f11"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a33913256af86c81992f3f8cee75b8f11">distribute_xor_over_and</a> (expr)</td></tr>
<tr class="separator:a33913256af86c81992f3f8cee75b8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a056903264a8593be368779d912fc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a98a056903264a8593be368779d912fc0">to_anf</a> (expr, deep=True)</td></tr>
<tr class="separator:a98a056903264a8593be368779d912fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fad1d60671b203d2047c72424c3a45"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a91fad1d60671b203d2047c72424c3a45">to_nnf</a> (expr, simplify=True)</td></tr>
<tr class="separator:a91fad1d60671b203d2047c72424c3a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a60318e4c6f6d513fbb462fe8da4f87"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a1a60318e4c6f6d513fbb462fe8da4f87">to_cnf</a> (expr, simplify=False, force=False)</td></tr>
<tr class="separator:a1a60318e4c6f6d513fbb462fe8da4f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb51f4da136289911f5e8c4239282b4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#aedb51f4da136289911f5e8c4239282b4">to_dnf</a> (expr, simplify=False, force=False)</td></tr>
<tr class="separator:aedb51f4da136289911f5e8c4239282b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4815b85a44226e98b46e90d6fa257662"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a4815b85a44226e98b46e90d6fa257662">is_anf</a> (expr)</td></tr>
<tr class="separator:a4815b85a44226e98b46e90d6fa257662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9880c48e703d99dcf8b017ec7d69e2c2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a9880c48e703d99dcf8b017ec7d69e2c2">is_nnf</a> (expr, simplified=True)</td></tr>
<tr class="separator:a9880c48e703d99dcf8b017ec7d69e2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dce00f6ac68acee62a1fbddf4b2d75"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#ac0dce00f6ac68acee62a1fbddf4b2d75">is_cnf</a> (expr)</td></tr>
<tr class="separator:ac0dce00f6ac68acee62a1fbddf4b2d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e59494ef37608c2a9b90a366a391fc8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a7e59494ef37608c2a9b90a366a391fc8">is_dnf</a> (expr)</td></tr>
<tr class="separator:a7e59494ef37608c2a9b90a366a391fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1417190cf6fe49c7d744acf08453ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a3f1417190cf6fe49c7d744acf08453ae">eliminate_implications</a> (expr)</td></tr>
<tr class="separator:a3f1417190cf6fe49c7d744acf08453ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ef398bc91e75f259c5feef2ef38c31"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#af6ef398bc91e75f259c5feef2ef38c31">is_literal</a> (expr)</td></tr>
<tr class="separator:af6ef398bc91e75f259c5feef2ef38c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187f851dc30f3be598258b514b0e0b5a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a187f851dc30f3be598258b514b0e0b5a">to_int_repr</a> (clauses, symbols)</td></tr>
<tr class="separator:a187f851dc30f3be598258b514b0e0b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e72ff3932913f130cb2b78fba1d189"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a61e72ff3932913f130cb2b78fba1d189">term_to_integer</a> (term)</td></tr>
<tr class="separator:a61e72ff3932913f130cb2b78fba1d189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583ac089ff086591d3899c9784112f72"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a583ac089ff086591d3899c9784112f72">truth_table</a> (expr, variables, input=True)</td></tr>
<tr class="separator:a583ac089ff086591d3899c9784112f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5afc8332bf517a83c6ba23891e085a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#ade5afc8332bf517a83c6ba23891e085a">SOPform</a> (variables, minterms, dontcares=None)</td></tr>
<tr class="separator:ade5afc8332bf517a83c6ba23891e085a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c30b961e8a374117faa25ebcadadb4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#ad9c30b961e8a374117faa25ebcadadb4">POSform</a> (variables, minterms, dontcares=None)</td></tr>
<tr class="separator:ad9c30b961e8a374117faa25ebcadadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb66c8a458f4e0792812be9b7846314"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#acfb66c8a458f4e0792812be9b7846314">ANFform</a> (variables, truthvalues)</td></tr>
<tr class="separator:acfb66c8a458f4e0792812be9b7846314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61454268021f306ad5d424803953db61"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a61454268021f306ad5d424803953db61">anf_coeffs</a> (truthvalues)</td></tr>
<tr class="separator:a61454268021f306ad5d424803953db61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d63d325daa4b800b245156428358d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a24d63d325daa4b800b245156428358d5">bool_minterm</a> (k, variables)</td></tr>
<tr class="separator:a24d63d325daa4b800b245156428358d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0846399b78aaf97744187bcc37e7100f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a0846399b78aaf97744187bcc37e7100f">bool_maxterm</a> (k, variables)</td></tr>
<tr class="separator:a0846399b78aaf97744187bcc37e7100f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69607836b46c5df67ee40b9dce7105"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a7e69607836b46c5df67ee40b9dce7105">bool_monomial</a> (k, variables)</td></tr>
<tr class="separator:a7e69607836b46c5df67ee40b9dce7105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d214418e905307b9641aa99d1bcf93c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a1d214418e905307b9641aa99d1bcf93c">simplify_logic</a> (expr, form=None, deep=True, force=False, dontcare=None)</td></tr>
<tr class="separator:a1d214418e905307b9641aa99d1bcf93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b31cbf6bd847f0ee8813e8557adf2c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a71b31cbf6bd847f0ee8813e8557adf2c">bool_map</a> (bool1, bool2)</td></tr>
<tr class="separator:a71b31cbf6bd847f0ee8813e8557adf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbd81850021b3278565e73d928f77b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a0fbd81850021b3278565e73d928f77b7">simplify_univariate</a> (expr)</td></tr>
<tr class="separator:a0fbd81850021b3278565e73d928f77b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafb52e27a3b0817187d2f96af0421d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#adafb52e27a3b0817187d2f96af0421d4">gateinputcount</a> (expr)</td></tr>
<tr class="separator:adafb52e27a3b0817187d2f96af0421d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1eb8ca8f24ac02a8cfa82c9e2681da55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#a1eb8ca8f24ac02a8cfa82c9e2681da55">true</a> = <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1BooleanTrue.html">BooleanTrue</a>()</td></tr>
<tr class="separator:a1eb8ca8f24ac02a8cfa82c9e2681da55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9650aedfb0cc6069367ebc8ef960fa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#af9650aedfb0cc6069367ebc8ef960fa0">false</a> = <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1BooleanFalse.html">BooleanFalse</a>()</td></tr>
<tr class="separator:af9650aedfb0cc6069367ebc8ef960fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b2095e6fd5c7bcf70cabb1439f38f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#ad8b2095e6fd5c7bcf70cabb1439f38f4">integer_to_term</a> = ibin</td></tr>
<tr class="separator:ad8b2095e6fd5c7bcf70cabb1439f38f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bf6bb41a81e5d43e80d3005c249b4c"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1logic_1_1boolalg.html#ae5bf6bb41a81e5d43e80d3005c249b4c">BooleanGates</a> = (<a class="el" href="classsympy_1_1logic_1_1boolalg_1_1And.html">And</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Or.html">Or</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Xor.html">Xor</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Nand.html">Nand</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Nor.html">Nor</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Not.html">Not</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Xnor.html">Xnor</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1ITE.html">ITE</a>)</td></tr>
<tr class="separator:ae5bf6bb41a81e5d43e80d3005c249b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Boolean algebra module for SymPy
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a61454268021f306ad5d424803953db61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61454268021f306ad5d424803953db61">&#9670;&nbsp;</a></span>anf_coeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.anf_coeffs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>truthvalues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a list of truth values of some boolean expression
to the list of coefficients of the polynomial mod 2 (exclusive
disjunction) representing the boolean expression in ANF
(i.e., the "Zhegalkin polynomial").

There are `2^n` possible Zhegalkin monomials in `n` variables, since
each monomial is fully specified by the presence or absence of
each variable.

We can enumerate all the monomials. For example, boolean
function with four variables ``(a, b, c, d)`` can contain
up to `2^4 = 16` monomials. The 13-th monomial is the
product ``a &amp; b &amp; d``, because 13 in binary is 1, 1, 0, 1.

A given monomial's presence or absence in a polynomial corresponds
to that monomial's coefficient being 1 or 0 respectively.

Examples
========
&gt;&gt;&gt; from sympy.logic.boolalg import anf_coeffs, bool_monomial, Xor
&gt;&gt;&gt; from sympy.abc import a, b, c
&gt;&gt;&gt; truthvalues = [0, 1, 1, 0, 0, 1, 0, 1]
&gt;&gt;&gt; coeffs = anf_coeffs(truthvalues)
&gt;&gt;&gt; coeffs
[0, 1, 1, 0, 0, 0, 1, 0]
&gt;&gt;&gt; polynomial = Xor(*[
...     bool_monomial(k, [a, b, c])
...     for k, coeff in enumerate(coeffs) if coeff == 1
... ])
&gt;&gt;&gt; polynomial
b ^ c ^ (a &amp; b)</pre> 
</div>
</div>
<a id="acfb66c8a458f4e0792812be9b7846314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb66c8a458f4e0792812be9b7846314">&#9670;&nbsp;</a></span>ANFform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.ANFform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>truthvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The ANFform function converts the list of truth values to
Algebraic Normal Form (ANF).

The variables must be given as the first argument.

Return True, False, logical :py:class:`~.And` function (i.e., the
"Zhegalkin monomial") or logical :py:class:`~.Xor` function (i.e.,
the "Zhegalkin polynomial"). When True and False
are represented by 1 and 0, respectively, then
:py:class:`~.And` is multiplication and :py:class:`~.Xor` is addition.

Formally a "Zhegalkin monomial" is the product (logical
And) of a finite set of distinct variables, including
the empty set whose product is denoted 1 (True).
A "Zhegalkin polynomial" is the sum (logical Xor) of a
set of Zhegalkin monomials, with the empty set denoted
by 0 (False).

Parameters
==========

variables : list of variables
truthvalues : list of 1's and 0's (result column of truth table)

Examples
========
&gt;&gt;&gt; from sympy.logic.boolalg import ANFform
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; ANFform([x], [1, 0])
x ^ True
&gt;&gt;&gt; ANFform([x, y], [0, 1, 1, 1])
x ^ y ^ (x &amp; y)

References
==========

.. [1] https://en.wikipedia.org/wiki/Zhegalkin_polynomial</pre> 
</div>
</div>
<a id="a25c48f48fe23746c8273e5ccdec56e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c48f48fe23746c8273e5ccdec56e00">&#9670;&nbsp;</a></span>as_Boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.as_Boolean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like ``bool``, return the Boolean value of an expression, e,
which can be any instance of :py:class:`~.Boolean` or ``bool``.

Examples
========

&gt;&gt;&gt; from sympy import true, false, nan
&gt;&gt;&gt; from sympy.logic.boolalg import as_Boolean
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; as_Boolean(0) is false
True
&gt;&gt;&gt; as_Boolean(1) is true
True
&gt;&gt;&gt; as_Boolean(x)
x
&gt;&gt;&gt; as_Boolean(2)
Traceback (most recent call last):
...
TypeError: expecting bool or Boolean, not `2`.
&gt;&gt;&gt; as_Boolean(nan)
Traceback (most recent call last):
...
TypeError: expecting bool or Boolean, not `nan`.</pre> 
</div>
</div>
<a id="a71b31cbf6bd847f0ee8813e8557adf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b31cbf6bd847f0ee8813e8557adf2c">&#9670;&nbsp;</a></span>bool_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.bool_map </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bool1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bool2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the simplified version of *bool1*, and the mapping of variables
that makes the two expressions *bool1* and *bool2* represent the same
logical behaviour for some correspondence between the variables
of each.
If more than one mappings of this sort exist, one of them
is returned.

For example, ``And(x, y)`` is logically equivalent to ``And(a, b)`` for
the mapping ``{x: a, y: b}`` or ``{x: b, y: a}``.
If no such mapping exists, return ``False``.

Examples
========

&gt;&gt;&gt; from sympy import SOPform, bool_map, Or, And, Not, Xor
&gt;&gt;&gt; from sympy.abc import w, x, y, z, a, b, c, d
&gt;&gt;&gt; function1 = SOPform([x, z, y],[[1, 0, 1], [0, 0, 1]])
&gt;&gt;&gt; function2 = SOPform([a, b, c],[[1, 0, 1], [1, 0, 0]])
&gt;&gt;&gt; bool_map(function1, function2)
(y &amp; ~z, {y: a, z: b})

The results are not necessarily unique, but they are canonical. Here,
``(w, z)`` could be ``(a, d)`` or ``(d, a)``:

&gt;&gt;&gt; eq =  Or(And(Not(y), w), And(Not(y), z), And(x, y))
&gt;&gt;&gt; eq2 = Or(And(Not(c), a), And(Not(c), d), And(b, c))
&gt;&gt;&gt; bool_map(eq, eq2)
((x &amp; y) | (w &amp; ~y) | (z &amp; ~y), {w: a, x: b, y: c, z: d})
&gt;&gt;&gt; eq = And(Xor(a, b), c, And(c,d))
&gt;&gt;&gt; bool_map(eq, eq.subs(c, x))
(c &amp; d &amp; (a | b) &amp; (~a | ~b), {a: a, b: b, c: d, d: x})</pre> 
</div>
</div>
<a id="a0846399b78aaf97744187bcc37e7100f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0846399b78aaf97744187bcc37e7100f">&#9670;&nbsp;</a></span>bool_maxterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.bool_maxterm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the k-th maxterm.

Each maxterm is assigned an index based on the opposite
conventional binary encoding used for minterms. The maxterm
convention assigns the value 0 to the direct form and 1 to
the complemented form.

Parameters
==========

k : int or list of 1's and 0's (complementation pattern)
variables : list of variables

Examples
========
&gt;&gt;&gt; from sympy.logic.boolalg import bool_maxterm
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; bool_maxterm([1, 0, 1], [x, y, z])
y | ~x | ~z
&gt;&gt;&gt; bool_maxterm(6, [x, y, z])
z | ~x | ~y

References
==========

.. [1] https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms</pre> 
</div>
</div>
<a id="a24d63d325daa4b800b245156428358d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d63d325daa4b800b245156428358d5">&#9670;&nbsp;</a></span>bool_minterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.bool_minterm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the k-th minterm.

Minterms are numbered by a binary encoding of the complementation
pattern of the variables. This convention assigns the value 1 to
the direct form and 0 to the complemented form.

Parameters
==========

k : int or list of 1's and 0's (complementation pattern)
variables : list of variables

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import bool_minterm
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; bool_minterm([1, 0, 1], [x, y, z])
x &amp; z &amp; ~y
&gt;&gt;&gt; bool_minterm(6, [x, y, z])
x &amp; y &amp; ~z

References
==========

.. [1] https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms</pre> 
</div>
</div>
<a id="a7e69607836b46c5df67ee40b9dce7105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e69607836b46c5df67ee40b9dce7105">&#9670;&nbsp;</a></span>bool_monomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.bool_monomial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the k-th monomial.

Monomials are numbered by a binary encoding of the presence and
absences of the variables. This convention assigns the value
1 to the presence of variable and 0 to the absence of variable.

Each boolean function can be uniquely represented by a
Zhegalkin Polynomial (Algebraic Normal Form). The Zhegalkin
Polynomial of the boolean function with `n` variables can contain
up to `2^n` monomials. We can enumerate all the monomials.
Each monomial is fully specified by the presence or absence
of each variable.

For example, boolean function with four variables ``(a, b, c, d)``
can contain up to `2^4 = 16` monomials. The 13-th monomial is the
product ``a &amp; b &amp; d``, because 13 in binary is 1, 1, 0, 1.

Parameters
==========

k : int or list of 1's and 0's
variables : list of variables

Examples
========
&gt;&gt;&gt; from sympy.logic.boolalg import bool_monomial
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; bool_monomial([1, 0, 1], [x, y, z])
x &amp; z
&gt;&gt;&gt; bool_monomial(6, [x, y, z])
x &amp; y</pre> 
</div>
</div>
<a id="a0ec5b602e75b7c95e531207f2b22136d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec5b602e75b7c95e531207f2b22136d">&#9670;&nbsp;</a></span>conjuncts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.conjuncts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of the conjuncts in ``expr``.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import conjuncts
&gt;&gt;&gt; from sympy.abc import A, B
&gt;&gt;&gt; conjuncts(A &amp; B)
frozenset({A, B})
&gt;&gt;&gt; conjuncts(A | B)
frozenset({A | B})</pre> 
</div>
</div>
<a id="a04244892e99c4019a4e78bedd45ebf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04244892e99c4019a4e78bedd45ebf6f">&#9670;&nbsp;</a></span>disjuncts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.disjuncts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of the disjuncts in ``expr``.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import disjuncts
&gt;&gt;&gt; from sympy.abc import A, B
&gt;&gt;&gt; disjuncts(A | B)
frozenset({A, B})
&gt;&gt;&gt; disjuncts(A &amp; B)
frozenset({A &amp; B})</pre> 
</div>
</div>
<a id="ad7bc2673cf3cc23397eca0ade9a2bdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bc2673cf3cc23397eca0ade9a2bdbc">&#9670;&nbsp;</a></span>distribute_and_over_or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.distribute_and_over_or </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a sentence ``expr`` consisting of conjunctions and disjunctions
of literals, return an equivalent sentence in CNF.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import distribute_and_over_or, And, Or, Not
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; distribute_and_over_or(Or(A, And(Not(B), Not(C))))
(A | ~B) &amp; (A | ~C)</pre> 
</div>
</div>
<a id="a9598bbcb5f4815d9a9fd9c9d2c4d08f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9598bbcb5f4815d9a9fd9c9d2c4d08f7">&#9670;&nbsp;</a></span>distribute_or_over_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.distribute_or_over_and </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a sentence ``expr`` consisting of conjunctions and disjunctions
of literals, return an equivalent sentence in DNF.

Note that the output is NOT simplified.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import distribute_or_over_and, And, Or, Not
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; distribute_or_over_and(And(Or(Not(A), B), C))
(B &amp; C) | (C &amp; ~A)</pre> 
</div>
</div>
<a id="a33913256af86c81992f3f8cee75b8f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33913256af86c81992f3f8cee75b8f11">&#9670;&nbsp;</a></span>distribute_xor_over_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.distribute_xor_over_and </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a sentence ``expr`` consisting of conjunction and
exclusive disjunctions of literals, return an
equivalent exclusive disjunction.

Note that the output is NOT simplified.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import distribute_xor_over_and, And, Xor, Not
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; distribute_xor_over_and(And(Xor(Not(A), B), C))
(B &amp; C) ^ (C &amp; ~A)
</pre> 
</div>
</div>
<a id="a3f1417190cf6fe49c7d744acf08453ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1417190cf6fe49c7d744acf08453ae">&#9670;&nbsp;</a></span>eliminate_implications()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.eliminate_implications </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Change :py:class:`~.Implies` and :py:class:`~.Equivalent` into
:py:class:`~.And`, :py:class:`~.Or`, and :py:class:`~.Not`.
That is, return an expression that is equivalent to ``expr``, but has only
``&amp;``, ``|``, and ``~`` as logical
operators.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import Implies, Equivalent, \
     eliminate_implications
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; eliminate_implications(Implies(A, B))
B | ~A
&gt;&gt;&gt; eliminate_implications(Equivalent(A, B))
(A | ~B) &amp; (B | ~A)
&gt;&gt;&gt; eliminate_implications(Equivalent(A, B, C))
(A | ~C) &amp; (B | ~A) &amp; (C | ~B)</pre> 
</div>
</div>
<a id="adafb52e27a3b0817187d2f96af0421d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafb52e27a3b0817187d2f96af0421d4">&#9670;&nbsp;</a></span>gateinputcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.gateinputcount </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the total number of inputs for the logic gates realizing the
Boolean expression.

Returns
=======

int
    Number of gate inputs

Note
====

Not all Boolean functions count as gate here, only those that are
considered to be standard gates. These are: :py:class:`~.And`,
:py:class:`~.Or`, :py:class:`~.Xor`, :py:class:`~.Not`, and
:py:class:`~.ITE` (multiplexer). :py:class:`~.Nand`, :py:class:`~.Nor`,
and :py:class:`~.Xnor` will be evaluated to ``Not(And())`` etc.

Examples
========

&gt;&gt;&gt; from sympy.logic import And, Or, Nand, Not, gateinputcount
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; expr = And(x, y)
&gt;&gt;&gt; gateinputcount(expr)
2
&gt;&gt;&gt; gateinputcount(Or(expr, z))
4

Note that ``Nand`` is automatically evaluated to ``Not(And())`` so

&gt;&gt;&gt; gateinputcount(Nand(x, y, z))
4
&gt;&gt;&gt; gateinputcount(Not(And(x, y, z)))
4

Although this can be avoided by using ``evaluate=False``

&gt;&gt;&gt; gateinputcount(Nand(x, y, z, evaluate=False))
3

Also note that a comparison will count as a Boolean variable:

&gt;&gt;&gt; gateinputcount(And(x &gt; z, y &gt;= 2))
2

As will a symbol:
&gt;&gt;&gt; gateinputcount(x)
0</pre> 
</div>
</div>
<a id="a4815b85a44226e98b46e90d6fa257662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4815b85a44226e98b46e90d6fa257662">&#9670;&nbsp;</a></span>is_anf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.is_anf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if ``expr``  is in Algebraic Normal Form (ANF).

A logical expression is in ANF if it has the form

.. math:: 1 \oplus a \oplus b \oplus ab \oplus abc

i.e. it is purely true, purely false, conjunction of
variables or exclusive disjunction. The exclusive
disjunction can only contain true, variables or
conjunction of variables. No negations are permitted.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import And, Not, Xor, true, is_anf
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; is_anf(true)
True
&gt;&gt;&gt; is_anf(A)
True
&gt;&gt;&gt; is_anf(And(A, B, C))
True
&gt;&gt;&gt; is_anf(Xor(A, Not(B)))
False</pre> 
</div>
</div>
<a id="ac0dce00f6ac68acee62a1fbddf4b2d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dce00f6ac68acee62a1fbddf4b2d75">&#9670;&nbsp;</a></span>is_cnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.is_cnf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether or not an expression is in conjunctive normal form.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import is_cnf
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; is_cnf(A | B | C)
True
&gt;&gt;&gt; is_cnf(A &amp; B &amp; C)
True
&gt;&gt;&gt; is_cnf((A &amp; B) | C)
False</pre> 
</div>
</div>
<a id="a7e59494ef37608c2a9b90a366a391fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e59494ef37608c2a9b90a366a391fc8">&#9670;&nbsp;</a></span>is_dnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.is_dnf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether or not an expression is in disjunctive normal form.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import is_dnf
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; is_dnf(A | B | C)
True
&gt;&gt;&gt; is_dnf(A &amp; B &amp; C)
True
&gt;&gt;&gt; is_dnf((A &amp; B) | C)
True
&gt;&gt;&gt; is_dnf(A &amp; (B | C))
False</pre> 
</div>
</div>
<a id="af6ef398bc91e75f259c5feef2ef38c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ef398bc91e75f259c5feef2ef38c31">&#9670;&nbsp;</a></span>is_literal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.is_literal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if expr is a literal, else False.

Examples
========

&gt;&gt;&gt; from sympy import Or, Q
&gt;&gt;&gt; from sympy.abc import A, B
&gt;&gt;&gt; from sympy.logic.boolalg import is_literal
&gt;&gt;&gt; is_literal(A)
True
&gt;&gt;&gt; is_literal(~A)
True
&gt;&gt;&gt; is_literal(Q.zero(A))
True
&gt;&gt;&gt; is_literal(A + B)
True
&gt;&gt;&gt; is_literal(Or(A, B))
False</pre> 
</div>
</div>
<a id="a9880c48e703d99dcf8b017ec7d69e2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9880c48e703d99dcf8b017ec7d69e2c2">&#9670;&nbsp;</a></span>is_nnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.is_nnf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>simplified</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if ``expr`` is in Negation Normal Form (NNF).

A logical expression is in NNF if it
contains only :py:class:`~.And`, :py:class:`~.Or` and :py:class:`~.Not`,
and :py:class:`~.Not` is applied only to literals.
If ``simplified`` is ``True``, checks if result contains no redundant clauses.

Examples
========

&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; from sympy.logic.boolalg import Not, is_nnf
&gt;&gt;&gt; is_nnf(A &amp; B | ~C)
True
&gt;&gt;&gt; is_nnf((A | ~A) &amp; (B | C))
False
&gt;&gt;&gt; is_nnf((A | ~A) &amp; (B | C), False)
True
&gt;&gt;&gt; is_nnf(Not(A &amp; B) | C)
False
&gt;&gt;&gt; is_nnf((A &gt;&gt; B) &amp; (B &gt;&gt; A))
False</pre> 
</div>
</div>
<a id="ad9c30b961e8a374117faa25ebcadadb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c30b961e8a374117faa25ebcadadb4">&#9670;&nbsp;</a></span>POSform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.POSform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minterms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dontcares</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The POSform function uses simplified_pairs and a redundant-group
eliminating algorithm to convert the list of all input combinations
that generate '1' (the minterms) into the smallest product-of-sums form.

The variables must be given as the first argument.

Return a logical :py:class:`~.And` function (i.e., the "product of sums"
or "POS" form) that gives the desired outcome. If there are inputs that can
be ignored, pass them as a list, too.

The result will be one of the (perhaps many) functions that satisfy
the conditions.

Examples
========

&gt;&gt;&gt; from sympy.logic import POSform
&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; w, x, y, z = symbols('w x y z')
&gt;&gt;&gt; minterms = [[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 1, 1],
...             [1, 0, 1, 1], [1, 1, 1, 1]]
&gt;&gt;&gt; dontcares = [[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 1]]
&gt;&gt;&gt; POSform([w, x, y, z], minterms, dontcares)
z &amp; (y | ~w)

The terms can also be represented as integers:

&gt;&gt;&gt; minterms = [1, 3, 7, 11, 15]
&gt;&gt;&gt; dontcares = [0, 2, 5]
&gt;&gt;&gt; POSform([w, x, y, z], minterms, dontcares)
z &amp; (y | ~w)

They can also be specified using dicts, which does not have to be fully
specified:

&gt;&gt;&gt; minterms = [{w: 0, x: 1}, {y: 1, z: 1, x: 0}]
&gt;&gt;&gt; POSform([w, x, y, z], minterms)
(x | y) &amp; (x | z) &amp; (~w | ~x)

Or a combination:

&gt;&gt;&gt; minterms = [4, 7, 11, [1, 1, 1, 1]]
&gt;&gt;&gt; dontcares = [{w : 0, x : 0, y: 0}, 5]
&gt;&gt;&gt; POSform([w, x, y, z], minterms, dontcares)
(w | x) &amp; (y | ~w) &amp; (z | ~y)

See also
========

SOPform

References
==========

.. [1] https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm
.. [2] https://en.wikipedia.org/wiki/Don%27t-care_term</pre> 
</div>
</div>
<a id="a1d214418e905307b9641aa99d1bcf93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d214418e905307b9641aa99d1bcf93c">&#9670;&nbsp;</a></span>simplify_logic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.simplify_logic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>form</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dontcare</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function simplifies a boolean function to its simplified version
in SOP or POS form. The return type is an :py:class:`~.Or` or
:py:class:`~.And` object in SymPy.

Parameters
==========

expr : Boolean

form : string (``'cnf'`` or ``'dnf'``) or ``None`` (default).
    If ``'cnf'`` or ``'dnf'``, the simplest expression in the corresponding
    normal form is returned; if ``None``, the answer is returned
    according to the form with fewest args (in CNF by default).

deep : bool (default ``True``)
    Indicates whether to recursively simplify any
    non-boolean functions contained within the input.

force : bool (default ``False``)
    As the simplifications require exponential time in the number
    of variables, there is by default a limit on expressions with
    8 variables. When the expression has more than 8 variables
    only symbolical simplification (controlled by ``deep``) is
    made. By setting ``force`` to ``True``, this limit is removed. Be
    aware that this can lead to very long simplification times.

dontcare : Boolean
    Optimize expression under the assumption that inputs where this
    expression is true are don't care. This is useful in e.g. Piecewise
    conditions, where later conditions do not need to consider inputs that
    are converted by previous conditions. For example, if a previous
    condition is ``And(A, B)``, the simplification of expr can be made
    with don't cares for ``And(A, B)``.

Examples
========

&gt;&gt;&gt; from sympy.logic import simplify_logic
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; b = (~x &amp; ~y &amp; ~z) | ( ~x &amp; ~y &amp; z)
&gt;&gt;&gt; simplify_logic(b)
~x &amp; ~y
&gt;&gt;&gt; simplify_logic(x | y, dontcare=y)
x

References
==========

.. [1] https://en.wikipedia.org/wiki/Don%27t-care_term</pre> 
</div>
</div>
<a id="a0fbd81850021b3278565e73d928f77b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbd81850021b3278565e73d928f77b7">&#9670;&nbsp;</a></span>simplify_univariate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.simplify_univariate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">return a simplified version of univariate boolean expression, else ``expr``</pre> 
</div>
</div>
<a id="ade5afc8332bf517a83c6ba23891e085a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5afc8332bf517a83c6ba23891e085a">&#9670;&nbsp;</a></span>SOPform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.SOPform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minterms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dontcares</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The SOPform function uses simplified_pairs and a redundant group-
eliminating algorithm to convert the list of all input combos that
generate '1' (the minterms) into the smallest sum-of-products form.

The variables must be given as the first argument.

Return a logical :py:class:`~.Or` function (i.e., the "sum of products" or
"SOP" form) that gives the desired outcome. If there are inputs that can
be ignored, pass them as a list, too.

The result will be one of the (perhaps many) functions that satisfy
the conditions.

Examples
========

&gt;&gt;&gt; from sympy.logic import SOPform
&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; w, x, y, z = symbols('w x y z')
&gt;&gt;&gt; minterms = [[0, 0, 0, 1], [0, 0, 1, 1],
...             [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 1, 1]]
&gt;&gt;&gt; dontcares = [[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 1]]
&gt;&gt;&gt; SOPform([w, x, y, z], minterms, dontcares)
(y &amp; z) | (~w &amp; ~x)

The terms can also be represented as integers:

&gt;&gt;&gt; minterms = [1, 3, 7, 11, 15]
&gt;&gt;&gt; dontcares = [0, 2, 5]
&gt;&gt;&gt; SOPform([w, x, y, z], minterms, dontcares)
(y &amp; z) | (~w &amp; ~x)

They can also be specified using dicts, which does not have to be fully
specified:

&gt;&gt;&gt; minterms = [{w: 0, x: 1}, {y: 1, z: 1, x: 0}]
&gt;&gt;&gt; SOPform([w, x, y, z], minterms)
(x &amp; ~w) | (y &amp; z &amp; ~x)

Or a combination:

&gt;&gt;&gt; minterms = [4, 7, 11, [1, 1, 1, 1]]
&gt;&gt;&gt; dontcares = [{w : 0, x : 0, y: 0}, 5]
&gt;&gt;&gt; SOPform([w, x, y, z], minterms, dontcares)
(w &amp; y &amp; z) | (~w &amp; ~y) | (x &amp; z &amp; ~w)

See also
========

POSform

References
==========

.. [1] https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm
.. [2] https://en.wikipedia.org/wiki/Don%27t-care_term</pre> 
</div>
</div>
<a id="a61e72ff3932913f130cb2b78fba1d189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e72ff3932913f130cb2b78fba1d189">&#9670;&nbsp;</a></span>term_to_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.term_to_integer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an integer corresponding to the base-2 digits given by *term*.

Parameters
==========

term : a string or list of ones and zeros

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import term_to_integer
&gt;&gt;&gt; term_to_integer([1, 0, 0])
4
&gt;&gt;&gt; term_to_integer('100')
4</pre> 
</div>
</div>
<a id="a98a056903264a8593be368779d912fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a056903264a8593be368779d912fc0">&#9670;&nbsp;</a></span>to_anf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.to_anf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deep</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts expr to Algebraic Normal Form (ANF).

ANF is a canonical normal form, which means that two
equivalent formulas will convert to the same ANF.

A logical expression is in ANF if it has the form

.. math:: 1 \oplus a \oplus b \oplus ab \oplus abc

i.e. it can be:
    - purely true,
    - purely false,
    - conjunction of variables,
    - exclusive disjunction.

The exclusive disjunction can only contain true, variables
or conjunction of variables. No negations are permitted.

If ``deep`` is ``False``, arguments of the boolean
expression are considered variables, i.e. only the
top-level expression is converted to ANF.

Examples
========
&gt;&gt;&gt; from sympy.logic.boolalg import And, Or, Not, Implies, Equivalent
&gt;&gt;&gt; from sympy.logic.boolalg import to_anf
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; to_anf(Not(A))
A ^ True
&gt;&gt;&gt; to_anf(And(Or(A, B), Not(C)))
A ^ B ^ (A &amp; B) ^ (A &amp; C) ^ (B &amp; C) ^ (A &amp; B &amp; C)
&gt;&gt;&gt; to_anf(Implies(Not(A), Equivalent(B, C)), deep=False)
True ^ ~A ^ (~A &amp; (Equivalent(B, C)))</pre> 
</div>
</div>
<a id="a1a60318e4c6f6d513fbb462fe8da4f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a60318e4c6f6d513fbb462fe8da4f87">&#9670;&nbsp;</a></span>to_cnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.to_cnf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a propositional logical sentence ``expr`` to conjunctive normal
form: ``((A | ~B | ...) &amp; (B | C | ...) &amp; ...)``.
If ``simplify`` is ``True``, ``expr`` is evaluated to its simplest CNF
form using the Quine-McCluskey algorithm; this may take a long
time. If there are more than 8 variables the ``force`` flag must be set
to ``True`` to simplify (default is ``False``).

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import to_cnf
&gt;&gt;&gt; from sympy.abc import A, B, D
&gt;&gt;&gt; to_cnf(~(A | B) | D)
(D | ~A) &amp; (D | ~B)
&gt;&gt;&gt; to_cnf((A | B) &amp; (A | ~A), True)
A | B</pre> 
</div>
</div>
<a id="aedb51f4da136289911f5e8c4239282b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb51f4da136289911f5e8c4239282b4">&#9670;&nbsp;</a></span>to_dnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.to_dnf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a propositional logical sentence ``expr`` to disjunctive normal
form: ``((A &amp; ~B &amp; ...) | (B &amp; C &amp; ...) | ...)``.
If ``simplify`` is ``True``, ``expr`` is evaluated to its simplest DNF form using
the Quine-McCluskey algorithm; this may take a long
time. If there are more than 8 variables, the ``force`` flag must be set to
``True`` to simplify (default is ``False``).

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import to_dnf
&gt;&gt;&gt; from sympy.abc import A, B, C
&gt;&gt;&gt; to_dnf(B &amp; (A | C))
(A &amp; B) | (B &amp; C)
&gt;&gt;&gt; to_dnf((A &amp; B) | (A &amp; ~B) | (B &amp; C) | (~B &amp; C), True)
A | C</pre> 
</div>
</div>
<a id="a187f851dc30f3be598258b514b0e0b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187f851dc30f3be598258b514b0e0b5a">&#9670;&nbsp;</a></span>to_int_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.to_int_repr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clauses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Takes clauses in CNF format and puts them into an integer representation.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import to_int_repr
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; to_int_repr([x | y, y], [x, y]) == [{1, 2}, {2}]
True</pre> 
</div>
</div>
<a id="a91fad1d60671b203d2047c72424c3a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fad1d60671b203d2047c72424c3a45">&#9670;&nbsp;</a></span>to_nnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.to_nnf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts ``expr`` to Negation Normal Form (NNF).

A logical expression is in NNF if it
contains only :py:class:`~.And`, :py:class:`~.Or` and :py:class:`~.Not`,
and :py:class:`~.Not` is applied only to literals.
If ``simplify`` is ``True``, the result contains no redundant clauses.

Examples
========

&gt;&gt;&gt; from sympy.abc import A, B, C, D
&gt;&gt;&gt; from sympy.logic.boolalg import Not, Equivalent, to_nnf
&gt;&gt;&gt; to_nnf(Not((~A &amp; ~B) | (C &amp; D)))
(A | B) &amp; (~C | ~D)
&gt;&gt;&gt; to_nnf(Equivalent(A &gt;&gt; B, B &gt;&gt; A))
(A | ~B | (A &amp; ~B)) &amp; (B | ~A | (B &amp; ~A))</pre> 
</div>
</div>
<a id="a583ac089ff086591d3899c9784112f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583ac089ff086591d3899c9784112f72">&#9670;&nbsp;</a></span>truth_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.logic.boolalg.truth_table </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a generator of all possible configurations of the input variables,
and the result of the boolean expression for those values.

Parameters
==========

expr : Boolean expression

variables : list of variables

input : bool (default ``True``)
    Indicates whether to return the input combinations.

Examples
========

&gt;&gt;&gt; from sympy.logic.boolalg import truth_table
&gt;&gt;&gt; from sympy.abc import x,y
&gt;&gt;&gt; table = truth_table(x &gt;&gt; y, [x, y])
&gt;&gt;&gt; for t in table:
...     print('{0} -&gt; {1}'.format(*t))
[0, 0] -&gt; True
[0, 1] -&gt; True
[1, 0] -&gt; False
[1, 1] -&gt; True

&gt;&gt;&gt; table = truth_table(x | y, [x, y])
&gt;&gt;&gt; list(table)
[([0, 0], False), ([0, 1], True), ([1, 0], True), ([1, 1], True)]

If ``input`` is ``False``, ``truth_table`` returns only a list of truth values.
In this case, the corresponding input values of variables can be
deduced from the index of a given output.

&gt;&gt;&gt; from sympy.utilities.iterables import ibin
&gt;&gt;&gt; vars = [y, x]
&gt;&gt;&gt; values = truth_table(x &gt;&gt; y, vars, input=False)
&gt;&gt;&gt; values = list(values)
&gt;&gt;&gt; values
[True, False, True, True]

&gt;&gt;&gt; for i, value in enumerate(values):
...     print('{0} -&gt; {1}'.format(list(zip(
...     vars, ibin(i, len(vars)))), value))
[(y, 0), (x, 0)] -&gt; True
[(y, 0), (x, 1)] -&gt; False
[(y, 1), (x, 0)] -&gt; True
[(y, 1), (x, 1)] -&gt; True</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae5bf6bb41a81e5d43e80d3005c249b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bf6bb41a81e5d43e80d3005c249b4c">&#9670;&nbsp;</a></span>BooleanGates</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple sympy.logic.boolalg.BooleanGates = (<a class="el" href="classsympy_1_1logic_1_1boolalg_1_1And.html">And</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Or.html">Or</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Xor.html">Xor</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Nand.html">Nand</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Nor.html">Nor</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Not.html">Not</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1Xnor.html">Xnor</a>, <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1ITE.html">ITE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9650aedfb0cc6069367ebc8ef960fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9650aedfb0cc6069367ebc8ef960fa0">&#9670;&nbsp;</a></span>false</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.logic.boolalg.false = <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1BooleanFalse.html">BooleanFalse</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8b2095e6fd5c7bcf70cabb1439f38f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b2095e6fd5c7bcf70cabb1439f38f4">&#9670;&nbsp;</a></span>integer_to_term</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.logic.boolalg.integer_to_term = ibin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb8ca8f24ac02a8cfa82c9e2681da55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb8ca8f24ac02a8cfa82c9e2681da55">&#9670;&nbsp;</a></span>true</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.logic.boolalg.true = <a class="el" href="classsympy_1_1logic_1_1boolalg_1_1BooleanTrue.html">BooleanTrue</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
