<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: humanfriendly.text Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehumanfriendly.html">humanfriendly</a></li><li class="navelem"><a class="el" href="namespacehumanfriendly_1_1text.html">text</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">humanfriendly.text Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abee5f2a4d47536e7e25cf7caa97bc12f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#abee5f2a4d47536e7e25cf7caa97bc12f">compact</a> (text, *args, **kw)</td></tr>
<tr class="separator:abee5f2a4d47536e7e25cf7caa97bc12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b24cba0eb95e4cefaa7f88fa945c3d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#a63b24cba0eb95e4cefaa7f88fa945c3d">compact_empty_lines</a> (text)</td></tr>
<tr class="separator:a63b24cba0eb95e4cefaa7f88fa945c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9651f146a577e643a315752501f572c2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#a9651f146a577e643a315752501f572c2">concatenate</a> (items, conjunction='and', serial_comma=False)</td></tr>
<tr class="separator:a9651f146a577e643a315752501f572c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c4a15160e79e89c127b7b9dbfdfce1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#ab7c4a15160e79e89c127b7b9dbfdfce1">dedent</a> (text, *args, **kw)</td></tr>
<tr class="separator:ab7c4a15160e79e89c127b7b9dbfdfce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00638933cb1da04e563eeec2963475f4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#a00638933cb1da04e563eeec2963475f4">format</a> (text, *args, **kw)</td></tr>
<tr class="separator:a00638933cb1da04e563eeec2963475f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a7460bbc44f89bbd4a2e8583297319"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#ac7a7460bbc44f89bbd4a2e8583297319">generate_slug</a> (text, delimiter=&quot;-&quot;)</td></tr>
<tr class="separator:ac7a7460bbc44f89bbd4a2e8583297319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca58ebedc1c8da2741045d2c380ae63"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#aaca58ebedc1c8da2741045d2c380ae63">is_empty_line</a> (text)</td></tr>
<tr class="separator:aaca58ebedc1c8da2741045d2c380ae63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0a5831d5e1ab021b9a1567235ad4b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#a8a0a5831d5e1ab021b9a1567235ad4b0">join_lines</a> (text)</td></tr>
<tr class="separator:a8a0a5831d5e1ab021b9a1567235ad4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf09be7fb3185532ae1c46e815ddd584"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#acf09be7fb3185532ae1c46e815ddd584">pluralize</a> (count, singular, plural=None)</td></tr>
<tr class="separator:acf09be7fb3185532ae1c46e815ddd584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63a8d5046dd2a7b96e21da18005b782"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#ac63a8d5046dd2a7b96e21da18005b782">pluralize_raw</a> (count, singular, plural=None)</td></tr>
<tr class="separator:ac63a8d5046dd2a7b96e21da18005b782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dcd0e3a61dda22ac6a3aef8f4c2340"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#a98dcd0e3a61dda22ac6a3aef8f4c2340">random_string</a> (length=(25, 100), characters=string.ascii_letters)</td></tr>
<tr class="separator:a98dcd0e3a61dda22ac6a3aef8f4c2340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576b31b299f49f54ab2e2efa7a563a78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#a576b31b299f49f54ab2e2efa7a563a78">split</a> (text, delimiter=',')</td></tr>
<tr class="separator:a576b31b299f49f54ab2e2efa7a563a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d3d9a6999efe81f3bf4d6854bab14a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#ac5d3d9a6999efe81f3bf4d6854bab14a">split_paragraphs</a> (text)</td></tr>
<tr class="separator:ac5d3d9a6999efe81f3bf4d6854bab14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fdf88fd9bc663580a2ff9e1c920aaf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#a02fdf88fd9bc663580a2ff9e1c920aaf">tokenize</a> (text)</td></tr>
<tr class="separator:a02fdf88fd9bc663580a2ff9e1c920aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042c13c341f2f5597d12a03e74e52776"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehumanfriendly_1_1text.html#a042c13c341f2f5597d12a03e74e52776">trim_empty_lines</a> (text)</td></tr>
<tr class="separator:a042c13c341f2f5597d12a03e74e52776"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abee5f2a4d47536e7e25cf7caa97bc12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee5f2a4d47536e7e25cf7caa97bc12f">&#9670;&nbsp;</a></span>compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.compact </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compact whitespace in a string.

Trims leading and trailing whitespace, replaces runs of whitespace
characters with a single space and interpolates any arguments using
:func:`format()`.

:param text: The text to compact (a string).
:param args: Any positional arguments are interpolated using :func:`format()`.
:param kw: Any keyword arguments are interpolated using :func:`format()`.
:returns: The compacted text (a string).

Here's an example of how I like to use the :func:`compact()` function, this
is an example from a random unrelated project I'm working on at the moment::

    raise PortDiscoveryError(compact("""
        Failed to discover port(s) that Apache is listening on!
        Maybe I'm parsing the wrong configuration file? ({filename})
    """, filename=self.ports_config))

The combination of :func:`compact()` and Python's multi line strings allows
me to write long text fragments with interpolated variables that are easy
to write, easy to read and work well with Python's whitespace
sensitivity.
</pre> 
</div>
</div>
<a id="a63b24cba0eb95e4cefaa7f88fa945c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b24cba0eb95e4cefaa7f88fa945c3d">&#9670;&nbsp;</a></span>compact_empty_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.compact_empty_lines </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replace repeating empty lines with a single empty line (similar to ``cat -s``).

:param text: The text in which to compact empty lines (a string).
:returns: The text with empty lines compacted (a string).
</pre> 
</div>
</div>
<a id="a9651f146a577e643a315752501f572c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9651f146a577e643a315752501f572c2">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.concatenate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>conjunction</em> = <code>'and'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>serial_comma</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Concatenate a list of items in a human friendly way.

:param items:

    A sequence of strings.

:param conjunction:

    The word to use before the last item (a string, defaults to "and").

:param serial_comma:

    :data:`True` to use a `serial comma`_, :data:`False` otherwise
    (defaults to :data:`False`).

:returns:

    A single string.

&gt;&gt;&gt; from humanfriendly.text import concatenate
&gt;&gt;&gt; concatenate(["eggs", "milk", "bread"])
'eggs, milk and bread'

.. _serial comma: https://en.wikipedia.org/wiki/Serial_comma
</pre> 
</div>
</div>
<a id="ab7c4a15160e79e89c127b7b9dbfdfce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c4a15160e79e89c127b7b9dbfdfce1">&#9670;&nbsp;</a></span>dedent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.dedent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dedent a string (remove common leading whitespace from all lines).

Removes common leading whitespace from all lines in the string using
:func:`textwrap.dedent()`, removes leading and trailing empty lines using
:func:`trim_empty_lines()` and interpolates any arguments using
:func:`format()`.

:param text: The text to dedent (a string).
:param args: Any positional arguments are interpolated using :func:`format()`.
:param kw: Any keyword arguments are interpolated using :func:`format()`.
:returns: The dedented text (a string).

The :func:`compact()` function's documentation contains an example of how I
like to use the :func:`compact()` and :func:`dedent()` functions. The main
difference is that I use :func:`compact()` for text that will be presented
to the user (where whitespace is not so significant) and :func:`dedent()`
for data file and code generation tasks (where newlines and indentation are
very significant).
</pre> 
</div>
</div>
<a id="a00638933cb1da04e563eeec2963475f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00638933cb1da04e563eeec2963475f4">&#9670;&nbsp;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.format </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Format a string using the string formatting operator and/or :meth:`str.format()`.

:param text: The text to format (a string).
:param args: Any positional arguments are interpolated into the text using
             the string formatting operator (``%``). If no positional
             arguments are given no interpolation is done.
:param kw: Any keyword arguments are interpolated into the text using the
           :meth:`str.format()` function. If no keyword arguments are given
           no interpolation is done.
:returns: The text with any positional and/or keyword arguments
          interpolated (a string).

The implementation of this function is so trivial that it seems silly to
even bother writing and documenting it. Justifying this requires some
context :-).

**Why format() instead of the string formatting operator?**

For really simple string interpolation Python's string formatting operator
is ideal, but it does have some strange quirks:

- When you switch from interpolating a single value to interpolating
  multiple values you have to wrap them in tuple syntax. Because
  :func:`format()` takes a `variable number of arguments`_ it always
  receives a tuple (which saves me a context switch :-). Here's an
  example:

  &gt;&gt;&gt; from humanfriendly.text import format
  &gt;&gt;&gt; # The string formatting operator.
  &gt;&gt;&gt; print('the magic number is %s' % 42)
  the magic number is 42
  &gt;&gt;&gt; print('the magic numbers are %s and %s' % (12, 42))
  the magic numbers are 12 and 42
  &gt;&gt;&gt; # The format() function.
  &gt;&gt;&gt; print(format('the magic number is %s', 42))
  the magic number is 42
  &gt;&gt;&gt; print(format('the magic numbers are %s and %s', 12, 42))
  the magic numbers are 12 and 42

- When you interpolate a single value and someone accidentally passes in a
  tuple your code raises a :exc:`~exceptions.TypeError`. Because
  :func:`format()` takes a `variable number of arguments`_ it always
  receives a tuple so this can never happen. Here's an example:

  &gt;&gt;&gt; # How expecting to interpolate a single value can fail.
  &gt;&gt;&gt; value = (12, 42)
  &gt;&gt;&gt; print('the magic value is %s' % value)
  Traceback (most recent call last):
    File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  TypeError: not all arguments converted during string formatting
  &gt;&gt;&gt; # The following line works as intended, no surprises here!
  &gt;&gt;&gt; print(format('the magic value is %s', value))
  the magic value is (12, 42)

**Why format() instead of the str.format() method?**

When you're doing complex string interpolation the :meth:`str.format()`
function results in more readable code, however I frequently find myself
adding parentheses to force evaluation order. The :func:`format()` function
avoids this because of the relative priority between the comma and dot
operators. Here's an example:

&gt;&gt;&gt; "{adjective} example" + " " + "(can't think of anything less {adjective})".format(adjective='silly')
"{adjective} example (can't think of anything less silly)"
&gt;&gt;&gt; ("{adjective} example" + " " + "(can't think of anything less {adjective})").format(adjective='silly')
"silly example (can't think of anything less silly)"
&gt;&gt;&gt; format("{adjective} example" + " " + "(can't think of anything less {adjective})", adjective='silly')
"silly example (can't think of anything less silly)"

The :func:`compact()` and :func:`dedent()` functions are wrappers that
combine :func:`format()` with whitespace manipulation to make it easy to
write nice to read Python code.

.. _variable number of arguments: https://docs.python.org/2/tutorial/controlflow.html#arbitrary-argument-lists
</pre> 
</div>
</div>
<a id="ac7a7460bbc44f89bbd4a2e8583297319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a7460bbc44f89bbd4a2e8583297319">&#9670;&nbsp;</a></span>generate_slug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.generate_slug </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;-&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert text to a normalized "slug" without whitespace.

:param text: The original text, for example ``Some Random Text!``.
:param delimiter: The delimiter used to separate words
                  (defaults to the ``-`` character).
:returns: The slug text, for example ``some-random-text``.
:raises: :exc:`~exceptions.ValueError` when the provided
         text is nonempty but results in an empty slug.
</pre> 
</div>
</div>
<a id="aaca58ebedc1c8da2741045d2c380ae63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca58ebedc1c8da2741045d2c380ae63">&#9670;&nbsp;</a></span>is_empty_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.is_empty_line </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if a text is empty or contains only whitespace.

:param text: The text to check for "emptiness" (a string).
:returns: :data:`True` if the text is empty or contains only whitespace,
          :data:`False` otherwise.
</pre> 
</div>
</div>
<a id="a8a0a5831d5e1ab021b9a1567235ad4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0a5831d5e1ab021b9a1567235ad4b0">&#9670;&nbsp;</a></span>join_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.join_lines </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove "hard wrapping" from the paragraphs in a string.

:param text: The text to reformat (a string).
:returns: The text without hard wrapping (a string).

This function works by removing line breaks when the last character before
a line break and the first character after the line break are both
non-whitespace characters. This means that common leading indentation will
break :func:`join_lines()` (in that case you can use :func:`dedent()`
before calling :func:`join_lines()`).
</pre> 
</div>
</div>
<a id="acf09be7fb3185532ae1c46e815ddd584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf09be7fb3185532ae1c46e815ddd584">&#9670;&nbsp;</a></span>pluralize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.pluralize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>singular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plural</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Combine a count with the singular or plural form of a word.

:param count: The count (a number).
:param singular: The singular form of the word (a string).
:param plural: The plural form of the word (a string or :data:`None`).
:returns: The count and singular or plural word concatenated (a string).

See :func:`pluralize_raw()` for the logic underneath :func:`pluralize()`.
</pre> 
</div>
</div>
<a id="ac63a8d5046dd2a7b96e21da18005b782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63a8d5046dd2a7b96e21da18005b782">&#9670;&nbsp;</a></span>pluralize_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.pluralize_raw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>singular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plural</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Select the singular or plural form of a word based on a count.

:param count: The count (a number).
:param singular: The singular form of the word (a string).
:param plural: The plural form of the word (a string or :data:`None`).
:returns: The singular or plural form of the word (a string).

When the given count is exactly 1.0 the singular form of the word is
selected, in all other cases the plural form of the word is selected.

If the plural form of the word is not provided it is obtained by
concatenating the singular form of the word with the letter "s". Of course
this will not always be correct, which is why you have the option to
specify both forms.
</pre> 
</div>
</div>
<a id="a98dcd0e3a61dda22ac6a3aef8f4c2340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dcd0e3a61dda22ac6a3aef8f4c2340">&#9670;&nbsp;</a></span>random_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.random_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>(25,&#160;100)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>characters</em> = <code>string.ascii_letters</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">random_string(length=(25, 100), characters=string.ascii_letters)
Generate a random string.

:param length: The length of the string to be generated (a number or a
               tuple with two numbers). If this is a tuple then a random
               number between the two numbers given in the tuple is used.
:param characters: The characters to be used (a string, defaults
                   to :data:`string.ascii_letters`).
:returns: A random string.

The :func:`random_string()` function is very useful in test suites; by the
time I included it in :mod:`humanfriendly.text` I had already included
variants of this function in seven different test suites :-).
</pre> 
</div>
</div>
<a id="a576b31b299f49f54ab2e2efa7a563a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576b31b299f49f54ab2e2efa7a563a78">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.split </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>','</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Split a comma-separated list of strings.

:param text: The text to split (a string).
:param delimiter: The delimiter to split on (a string).
:returns: A list of zero or more nonempty strings.

Here's the default behavior of Python's built in :meth:`str.split()`
function:

&gt;&gt;&gt; 'foo,bar, baz,'.split(',')
['foo', 'bar', ' baz', '']

In contrast here's the default behavior of the :func:`split()` function:

&gt;&gt;&gt; from humanfriendly.text import split
&gt;&gt;&gt; split('foo,bar, baz,')
['foo', 'bar', 'baz']

Here is an example that parses a nested data structure (a mapping of
logging level names to one or more styles per level) that's encoded in a
string so it can be set as an environment variable:

&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; encoded_data = 'debug=green;warning=yellow;error=red;critical=red,bold'
&gt;&gt;&gt; parsed_data = dict((k, split(v, ',')) for k, v in (split(kv, '=') for kv in split(encoded_data, ';')))
&gt;&gt;&gt; pprint(parsed_data)
{'debug': ['green'],
 'warning': ['yellow'],
 'error': ['red'],
 'critical': ['red', 'bold']}
</pre> 
</div>
</div>
<a id="ac5d3d9a6999efe81f3bf4d6854bab14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d3d9a6999efe81f3bf4d6854bab14a">&#9670;&nbsp;</a></span>split_paragraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.split_paragraphs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Split a string into paragraphs (one or more lines delimited by an empty line).

:param text: The text to split into paragraphs (a string).
:returns: A list of strings.
</pre> 
</div>
</div>
<a id="a02fdf88fd9bc663580a2ff9e1c920aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fdf88fd9bc663580a2ff9e1c920aaf">&#9670;&nbsp;</a></span>tokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.tokenize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tokenize a text into numbers and strings.

:param text: The text to tokenize (a string).
:returns: A list of strings and/or numbers.

This function is used to implement robust tokenization of user input in
functions like :func:`.parse_size()` and :func:`.parse_timespan()`. It
automatically coerces integer and floating point numbers, ignores
whitespace and knows how to separate numbers from strings even without
whitespace. Some examples to make this more concrete:

&gt;&gt;&gt; from humanfriendly.text import tokenize
&gt;&gt;&gt; tokenize('42')
[42]
&gt;&gt;&gt; tokenize('42MB')
[42, 'MB']
&gt;&gt;&gt; tokenize('42.5MB')
[42.5, 'MB']
&gt;&gt;&gt; tokenize('42.5 MB')
[42.5, 'MB']
</pre> 
</div>
</div>
<a id="a042c13c341f2f5597d12a03e74e52776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042c13c341f2f5597d12a03e74e52776">&#9670;&nbsp;</a></span>trim_empty_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def humanfriendly.text.trim_empty_lines </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Trim leading and trailing empty lines from the given text.

:param text: The text to trim (a string).
:returns: The trimmed text (a string).
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
