<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.utilities.iterables Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1utilities.html">utilities</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html">iterables</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.utilities.iterables Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1iterables_1_1NotIterable.html">NotIterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a304fc3ddb554dca9eebd32dfa3f7edb8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a304fc3ddb554dca9eebd32dfa3f7edb8">is_palindromic</a> (s, i=0, j=None)</td></tr>
<tr class="separator:a304fc3ddb554dca9eebd32dfa3f7edb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1246ba127afb5cb8f4b119004c6d71"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#afc1246ba127afb5cb8f4b119004c6d71">flatten</a> (<a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a45b0a7e9ea29792f77082e5d8cd2ab91">iterable</a>, levels=None, cls=None)</td></tr>
<tr class="separator:afc1246ba127afb5cb8f4b119004c6d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ae92c62da178a600fc0c2f362e5a52"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a34ae92c62da178a600fc0c2f362e5a52">unflatten</a> (iter, n=2)</td></tr>
<tr class="separator:a34ae92c62da178a600fc0c2f362e5a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613b8c7171fc81f5e4579180324e34f3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a613b8c7171fc81f5e4579180324e34f3">reshape</a> (seq, how)</td></tr>
<tr class="separator:a613b8c7171fc81f5e4579180324e34f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b199cc531cc9bf68a8720ccdf4add8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a63b199cc531cc9bf68a8720ccdf4add8">group</a> (seq, multiple=True)</td></tr>
<tr class="separator:a63b199cc531cc9bf68a8720ccdf4add8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed866dfaeabec95eebdc0e1672b6c6e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#abed866dfaeabec95eebdc0e1672b6c6e">iproduct</a> (*iterables)</td></tr>
<tr class="separator:abed866dfaeabec95eebdc0e1672b6c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611081f5b49055554805fc2617fcbb62"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a611081f5b49055554805fc2617fcbb62">multiset</a> (seq)</td></tr>
<tr class="separator:a611081f5b49055554805fc2617fcbb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edb0e79fab332d35a9ace8ea4d1d0e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a1edb0e79fab332d35a9ace8ea4d1d0e8">ibin</a> (n, bits=None, str=False)</td></tr>
<tr class="separator:a1edb0e79fab332d35a9ace8ea4d1d0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210175207eac4a4503692e99f9488766"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a210175207eac4a4503692e99f9488766">variations</a> (seq, n, repetition=False)</td></tr>
<tr class="separator:a210175207eac4a4503692e99f9488766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d91706be350f08104b9125c7a18206d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a7d91706be350f08104b9125c7a18206d">subsets</a> (seq, k=None, repetition=False)</td></tr>
<tr class="separator:a7d91706be350f08104b9125c7a18206d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ea9d9681f3fdcea119910ddb453964"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#af4ea9d9681f3fdcea119910ddb453964">filter_symbols</a> (iterator, exclude)</td></tr>
<tr class="separator:af4ea9d9681f3fdcea119910ddb453964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf12233932b130a1a8a210515da851c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#accf12233932b130a1a8a210515da851c">numbered_symbols</a> (prefix='x', cls=None, start=0, exclude=(), *args, **assumptions)</td></tr>
<tr class="separator:accf12233932b130a1a8a210515da851c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f75ae8649148b7a42f5edc3f270fe8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a30f75ae8649148b7a42f5edc3f270fe8">capture</a> (func)</td></tr>
<tr class="separator:a30f75ae8649148b7a42f5edc3f270fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1ba7f896953a94220f690bfbef8872"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#ade1ba7f896953a94220f690bfbef8872">sift</a> (seq, keyfunc, binary=False)</td></tr>
<tr class="separator:ade1ba7f896953a94220f690bfbef8872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81edbeef35e85f7e78670da4a341dd97"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a81edbeef35e85f7e78670da4a341dd97">take</a> (iter, n)</td></tr>
<tr class="separator:a81edbeef35e85f7e78670da4a341dd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5947225e14568997cafcd97932aecf91"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a5947225e14568997cafcd97932aecf91">dict_merge</a> (*dicts)</td></tr>
<tr class="separator:a5947225e14568997cafcd97932aecf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb8174e735c666cf39b218ec857a9cc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#adeb8174e735c666cf39b218ec857a9cc">common_prefix</a> (*seqs)</td></tr>
<tr class="separator:adeb8174e735c666cf39b218ec857a9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797a4355e818536edf597fd181222274"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a797a4355e818536edf597fd181222274">common_suffix</a> (*seqs)</td></tr>
<tr class="separator:a797a4355e818536edf597fd181222274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e5615e96f38a1c9aaa8a702db6dcbe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a97e5615e96f38a1c9aaa8a702db6dcbe">prefixes</a> (seq)</td></tr>
<tr class="separator:a97e5615e96f38a1c9aaa8a702db6dcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5070946bca23f7cc821d927a504fb36d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a5070946bca23f7cc821d927a504fb36d">postfixes</a> (seq)</td></tr>
<tr class="separator:a5070946bca23f7cc821d927a504fb36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8e45f553b38473558befc7c9d682f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#aeb8e45f553b38473558befc7c9d682f8">topological_sort</a> (graph, key=None)</td></tr>
<tr class="separator:aeb8e45f553b38473558befc7c9d682f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3d3ee8764aa239fee59c5631854e8d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a3c3d3ee8764aa239fee59c5631854e8d">strongly_connected_components</a> (G)</td></tr>
<tr class="separator:a3c3d3ee8764aa239fee59c5631854e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7bf2c5a67703b6002fa23af35fc83e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#aef7bf2c5a67703b6002fa23af35fc83e">connected_components</a> (G)</td></tr>
<tr class="separator:aef7bf2c5a67703b6002fa23af35fc83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52a72ef71b6dc4da54e13fa10c364f0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#aa52a72ef71b6dc4da54e13fa10c364f0">rotate_left</a> (x, y)</td></tr>
<tr class="separator:aa52a72ef71b6dc4da54e13fa10c364f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae632cd1b4f824d7a99eb7f904299d8e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#aae632cd1b4f824d7a99eb7f904299d8e">rotate_right</a> (x, y)</td></tr>
<tr class="separator:aae632cd1b4f824d7a99eb7f904299d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3df6aa45be733c15e00eebb96d48fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#aae3df6aa45be733c15e00eebb96d48fb">least_rotation</a> (x, key=None)</td></tr>
<tr class="separator:aae3df6aa45be733c15e00eebb96d48fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ccf5a1d35c173d4f3de07d97f517e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a60ccf5a1d35c173d4f3de07d97f517e3">multiset_combinations</a> (m, n, g=None)</td></tr>
<tr class="separator:a60ccf5a1d35c173d4f3de07d97f517e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92723958abe93c91388ccd744791c2c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a92723958abe93c91388ccd744791c2c5">multiset_permutations</a> (m, size=None, g=None)</td></tr>
<tr class="separator:a92723958abe93c91388ccd744791c2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164dabb76856d81dc3269214886a9be1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a164dabb76856d81dc3269214886a9be1">multiset_partitions</a> (<a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a611081f5b49055554805fc2617fcbb62">multiset</a>, m=None)</td></tr>
<tr class="separator:a164dabb76856d81dc3269214886a9be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62b7ca53ea4282867de5acf27b4be4c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#aa62b7ca53ea4282867de5acf27b4be4c">partitions</a> (n, m=None, k=None, size=False)</td></tr>
<tr class="separator:aa62b7ca53ea4282867de5acf27b4be4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b733ed72754b6b003745460eddb3365"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a1b733ed72754b6b003745460eddb3365">ordered_partitions</a> (n, m=None, sort=True)</td></tr>
<tr class="separator:a1b733ed72754b6b003745460eddb3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70367ba5fc0cfe32b2040b1222934a84"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a70367ba5fc0cfe32b2040b1222934a84">binary_partitions</a> (n)</td></tr>
<tr class="separator:a70367ba5fc0cfe32b2040b1222934a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788481ecf84d3d76873add4282c55c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#af788481ecf84d3d76873add4282c55c3">has_dups</a> (seq)</td></tr>
<tr class="separator:af788481ecf84d3d76873add4282c55c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d3502891534965c226d719af1e912d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#ad1d3502891534965c226d719af1e912d">has_variety</a> (seq)</td></tr>
<tr class="separator:ad1d3502891534965c226d719af1e912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c34fcfa400209a82af97b81877181a1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a1c34fcfa400209a82af97b81877181a1">uniq</a> (seq, result=None)</td></tr>
<tr class="separator:a1c34fcfa400209a82af97b81877181a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8804559048b299fb124f540b69c0b831"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a8804559048b299fb124f540b69c0b831">generate_bell</a> (n)</td></tr>
<tr class="separator:a8804559048b299fb124f540b69c0b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441fdc80c0154c1abaf8ec4b339d0600"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a441fdc80c0154c1abaf8ec4b339d0600">generate_involutions</a> (n)</td></tr>
<tr class="separator:a441fdc80c0154c1abaf8ec4b339d0600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ece2d38c1c8dc7069c710644151d2df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a8ece2d38c1c8dc7069c710644151d2df">multiset_derangements</a> (s)</td></tr>
<tr class="separator:a8ece2d38c1c8dc7069c710644151d2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013b7fe5ee5c480799e7810b5908379e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a013b7fe5ee5c480799e7810b5908379e">random_derangement</a> (t, choice=None, strict=True)</td></tr>
<tr class="separator:a013b7fe5ee5c480799e7810b5908379e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c48e0412a34e55bd5010aac00a137f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#ae2c48e0412a34e55bd5010aac00a137f">generate_derangements</a> (s)</td></tr>
<tr class="separator:ae2c48e0412a34e55bd5010aac00a137f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0f0fb2794bb6f1929f321beb17463a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#adf0f0fb2794bb6f1929f321beb17463a">necklaces</a> (n, k, free=False)</td></tr>
<tr class="separator:adf0f0fb2794bb6f1929f321beb17463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e13d438f728fcb1cda81da606cb38b4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a6e13d438f728fcb1cda81da606cb38b4">bracelets</a> (n, k)</td></tr>
<tr class="separator:a6e13d438f728fcb1cda81da606cb38b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d0e6e7106e127180edf754747a1276"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#af2d0e6e7106e127180edf754747a1276">generate_oriented_forest</a> (n)</td></tr>
<tr class="separator:af2d0e6e7106e127180edf754747a1276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe991cff53576b4d71337ba43d78113c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#afe991cff53576b4d71337ba43d78113c">minlex</a> (seq, directed=True, key=None)</td></tr>
<tr class="separator:afe991cff53576b4d71337ba43d78113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af453fff96873e09d9ef786582d664ff4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#af453fff96873e09d9ef786582d664ff4">runs</a> (seq, op=gt)</td></tr>
<tr class="separator:af453fff96873e09d9ef786582d664ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb89d74bd14719c78d014f33fcd285d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a8fb89d74bd14719c78d014f33fcd285d">sequence_partitions</a> (l, n)</td></tr>
<tr class="separator:a8fb89d74bd14719c78d014f33fcd285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1debcfdd2a61a658310414e3d2848fa4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a1debcfdd2a61a658310414e3d2848fa4">sequence_partitions_empty</a> (l, n)</td></tr>
<tr class="separator:a1debcfdd2a61a658310414e3d2848fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecec36efaad3b02a2a16b6ada47c65e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#aecec36efaad3b02a2a16b6ada47c65e6">kbins</a> (l, k, <a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a92342ee315805d7ded5e769045ae68f7">ordered</a>=None)</td></tr>
<tr class="separator:aecec36efaad3b02a2a16b6ada47c65e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557532a07e5c32ba71dc9160cb1a7267"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a557532a07e5c32ba71dc9160cb1a7267">permute_signs</a> (t)</td></tr>
<tr class="separator:a557532a07e5c32ba71dc9160cb1a7267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b556f979f7a4f8681907d4ef36acf5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#af6b556f979f7a4f8681907d4ef36acf5">signed_permutations</a> (t)</td></tr>
<tr class="separator:af6b556f979f7a4f8681907d4ef36acf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302cfe20aec8670bb220bc76028f34c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a302cfe20aec8670bb220bc76028f34c7">rotations</a> (s, dir=1)</td></tr>
<tr class="separator:a302cfe20aec8670bb220bc76028f34c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae88f1a552b0272b8ebde60eedea7db"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a8ae88f1a552b0272b8ebde60eedea7db">roundrobin</a> (*iterables)</td></tr>
<tr class="separator:a8ae88f1a552b0272b8ebde60eedea7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b0a7e9ea29792f77082e5d8cd2ab91"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a45b0a7e9ea29792f77082e5d8cd2ab91">iterable</a> (i, exclude=(str, dict, <a class="el" href="classsympy_1_1utilities_1_1iterables_1_1NotIterable.html">NotIterable</a>))</td></tr>
<tr class="separator:a45b0a7e9ea29792f77082e5d8cd2ab91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276dcb73ec7a7a90ea6bfe379310ac6e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a276dcb73ec7a7a90ea6bfe379310ac6e">is_sequence</a> (i, include=None)</td></tr>
<tr class="separator:a276dcb73ec7a7a90ea6bfe379310ac6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55edf1fe6ae45558887c3ada5da2e50"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#aa55edf1fe6ae45558887c3ada5da2e50">postorder_traversal</a> (node, keys=None)</td></tr>
<tr class="separator:aa55edf1fe6ae45558887c3ada5da2e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe15d3e70a09010ea1cc1d627f5ba4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#affe15d3e70a09010ea1cc1d627f5ba4f">interactive_traversal</a> (expr)</td></tr>
<tr class="separator:affe15d3e70a09010ea1cc1d627f5ba4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d3c492b3747e37f3f97e69d436a649"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a76d3c492b3747e37f3f97e69d436a649">default_sort_key</a> (*args, **kwargs)</td></tr>
<tr class="separator:a76d3c492b3747e37f3f97e69d436a649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92342ee315805d7ded5e769045ae68f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1iterables.html#a92342ee315805d7ded5e769045ae68f7">ordered</a> (*args, **kwargs)</td></tr>
<tr class="separator:a92342ee315805d7ded5e769045ae68f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a70367ba5fc0cfe32b2040b1222934a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70367ba5fc0cfe32b2040b1222934a84">&#9670;&nbsp;</a></span>binary_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.binary_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates the binary partition of *n*.

A binary partition consists only of numbers that are
powers of two. Each step reduces a `2^{k+1}` to `2^k` and
`2^k`. Thus 16 is converted to 8 and 8.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import binary_partitions
&gt;&gt;&gt; for i in binary_partitions(5):
...     print(i)
...
[4, 1]
[2, 2, 1]
[2, 1, 1, 1]
[1, 1, 1, 1, 1]

References
==========

.. [1] TAOCP 4, section 7.2.1.5, problem 64</pre> 
</div>
</div>
<a id="a6e13d438f728fcb1cda81da606cb38b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e13d438f728fcb1cda81da606cb38b4">&#9670;&nbsp;</a></span>bracelets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.bracelets </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper to necklaces to return a free (unrestricted) necklace.</pre> 
</div>
</div>
<a id="a30f75ae8649148b7a42f5edc3f270fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f75ae8649148b7a42f5edc3f270fe8">&#9670;&nbsp;</a></span>capture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.capture </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the printed output of func().

``func`` should be a function without arguments that produces output with
print statements.

&gt;&gt;&gt; from sympy.utilities.iterables import capture
&gt;&gt;&gt; from sympy import pprint
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; def foo():
...     print('hello world!')
...
&gt;&gt;&gt; 'hello' in capture(foo) # foo, not foo()
True
&gt;&gt;&gt; capture(lambda: pprint(2/x))
'2\\n-\\nx\\n'</pre> 
</div>
</div>
<a id="adeb8174e735c666cf39b218ec857a9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb8174e735c666cf39b218ec857a9cc">&#9670;&nbsp;</a></span>common_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.common_prefix </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>seqs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the subsequence that is a common start of sequences in ``seqs``.

&gt;&gt;&gt; from sympy.utilities.iterables import common_prefix
&gt;&gt;&gt; common_prefix(list(range(3)))
[0, 1, 2]
&gt;&gt;&gt; common_prefix(list(range(3)), list(range(4)))
[0, 1, 2]
&gt;&gt;&gt; common_prefix([1, 2, 3], [1, 2, 5])
[1, 2]
&gt;&gt;&gt; common_prefix([1, 2, 3], [1, 3, 5])
[1]
</pre> 
</div>
</div>
<a id="a797a4355e818536edf597fd181222274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797a4355e818536edf597fd181222274">&#9670;&nbsp;</a></span>common_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.common_suffix </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>seqs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the subsequence that is a common ending of sequences in ``seqs``.

&gt;&gt;&gt; from sympy.utilities.iterables import common_suffix
&gt;&gt;&gt; common_suffix(list(range(3)))
[0, 1, 2]
&gt;&gt;&gt; common_suffix(list(range(3)), list(range(4)))
[]
&gt;&gt;&gt; common_suffix([1, 2, 3], [9, 2, 3])
[2, 3]
&gt;&gt;&gt; common_suffix([1, 2, 3], [9, 7, 3])
[3]
</pre> 
</div>
</div>
<a id="aef7bf2c5a67703b6002fa23af35fc83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7bf2c5a67703b6002fa23af35fc83e">&#9670;&nbsp;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.connected_components </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Connected components of an undirected graph or weakly connected components
of a directed graph.


Parameters
==========

G : tuple[list, list[tuple[T, T]]
    A tuple consisting of a list of vertices and a list of edges of
    a graph whose connected components are to be found.


Examples
========


Given an undirected graph::

    graph {
        A -- B
        C -- D
    }

.. graphviz::

    graph {
        A -- B
        C -- D
    }

We can find the connected components using this function if we include
each edge in both directions::

    &gt;&gt;&gt; from sympy.utilities.iterables import connected_components

    &gt;&gt;&gt; V = ['A', 'B', 'C', 'D']
    &gt;&gt;&gt; E = [('A', 'B'), ('B', 'A'), ('C', 'D'), ('D', 'C')]
    &gt;&gt;&gt; connected_components((V, E))
    [['A', 'B'], ['C', 'D']]

The weakly connected components of a directed graph can found the same
way.


Notes
=====

The vertices of the graph must be hashable for the data structures used.
If the vertices are unhashable replace them with integer indices.

This function uses Tarjan's algorithm to compute the connected components
in `O(|V|+|E|)` (linear) time.


References
==========

.. [1] https://en.wikipedia.org/wiki/Component_%28graph_theory%29
.. [2] https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm


See Also
========

sympy.utilities.iterables.strongly_connected_components</pre> 
</div>
</div>
<a id="a76d3c492b3747e37f3f97e69d436a649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d3c492b3747e37f3f97e69d436a649">&#9670;&nbsp;</a></span>default_sort_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.default_sort_key </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5947225e14568997cafcd97932aecf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5947225e14568997cafcd97932aecf91">&#9670;&nbsp;</a></span>dict_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.dict_merge </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dicts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Merge dictionaries into a single dictionary. </pre> 
</div>
</div>
<a id="af4ea9d9681f3fdcea119910ddb453964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ea9d9681f3fdcea119910ddb453964">&#9670;&nbsp;</a></span>filter_symbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.filter_symbols </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Only yield elements from `iterator` that do not occur in `exclude`.

Parameters
==========

iterator : iterable
    iterator to take elements from

exclude : iterable
    elements to exclude

Returns
=======

iterator : iterator
    filtered iterator
</pre> 
</div>
</div>
<a id="afc1246ba127afb5cb8f4b119004c6d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1246ba127afb5cb8f4b119004c6d71">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.flatten </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>levels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Recursively denest iterable containers.

&gt;&gt;&gt; from sympy import flatten

&gt;&gt;&gt; flatten([1, 2, 3])
[1, 2, 3]
&gt;&gt;&gt; flatten([1, 2, [3]])
[1, 2, 3]
&gt;&gt;&gt; flatten([1, [2, 3], [4, 5]])
[1, 2, 3, 4, 5]
&gt;&gt;&gt; flatten([1.0, 2, (1, None)])
[1.0, 2, 1, None]

If you want to denest only a specified number of levels of
nested containers, then set ``levels`` flag to the desired
number of levels::

&gt;&gt;&gt; ls = [[(-2, -1), (1, 2)], [(0, 0)]]

&gt;&gt;&gt; flatten(ls, levels=1)
[(-2, -1), (1, 2), (0, 0)]

If cls argument is specified, it will only flatten instances of that
class, for example:

&gt;&gt;&gt; from sympy import Basic, S
&gt;&gt;&gt; class MyOp(Basic):
...     pass
...
&gt;&gt;&gt; flatten([MyOp(S(1), MyOp(S(2), S(3)))], cls=MyOp)
[1, 2, 3]

adapted from https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks
</pre> 
</div>
</div>
<a id="a8804559048b299fb124f540b69c0b831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8804559048b299fb124f540b69c0b831">&#9670;&nbsp;</a></span>generate_bell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.generate_bell </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return permutations of [0, 1, ..., n - 1] such that each permutation
differs from the last by the exchange of a single pair of neighbors.
The ``n!`` permutations are returned as an iterator. In order to obtain
the next permutation from a random starting permutation, use the
``next_trotterjohnson`` method of the Permutation class (which generates
the same sequence in a different manner).

Examples
========

&gt;&gt;&gt; from itertools import permutations
&gt;&gt;&gt; from sympy.utilities.iterables import generate_bell
&gt;&gt;&gt; from sympy import zeros, Matrix

This is the sort of permutation used in the ringing of physical bells,
and does not produce permutations in lexicographical order. Rather, the
permutations differ from each other by exactly one inversion, and the
position at which the swapping occurs varies periodically in a simple
fashion. Consider the first few permutations of 4 elements generated
by ``permutations`` and ``generate_bell``:

&gt;&gt;&gt; list(permutations(range(4)))[:5]
[(0, 1, 2, 3), (0, 1, 3, 2), (0, 2, 1, 3), (0, 2, 3, 1), (0, 3, 1, 2)]
&gt;&gt;&gt; list(generate_bell(4))[:5]
[(0, 1, 2, 3), (0, 1, 3, 2), (0, 3, 1, 2), (3, 0, 1, 2), (3, 0, 2, 1)]

Notice how the 2nd and 3rd lexicographical permutations have 3 elements
out of place whereas each "bell" permutation always has only two
elements out of place relative to the previous permutation (and so the
signature (+/-1) of a permutation is opposite of the signature of the
previous permutation).

How the position of inversion varies across the elements can be seen
by tracing out where the largest number appears in the permutations:

&gt;&gt;&gt; m = zeros(4, 24)
&gt;&gt;&gt; for i, p in enumerate(generate_bell(4)):
...     m[:, i] = Matrix([j - 3 for j in list(p)])  # make largest zero
&gt;&gt;&gt; m.print_nonzero('X')
[XXX  XXXXXX  XXXXXX  XXX]
[XX XX XXXX XX XXXX XX XX]
[X XXXX XX XXXX XX XXXX X]
[ XXXXXX  XXXXXX  XXXXXX ]

See Also
========

sympy.combinatorics.permutations.Permutation.next_trotterjohnson

References
==========

.. [1] https://en.wikipedia.org/wiki/Method_ringing

.. [2] https://stackoverflow.com/questions/4856615/recursive-permutation/4857018

.. [3] https://web.archive.org/web/20160313023044/http://programminggeeks.com/bell-algorithm-for-permutation/

.. [4] https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm

.. [5] Generating involutions, derangements, and relatives by ECO
       Vincent Vajnovszki, DMTCS vol 1 issue 12, 2010</pre> 
</div>
</div>
<a id="ae2c48e0412a34e55bd5010aac00a137f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c48e0412a34e55bd5010aac00a137f">&#9670;&nbsp;</a></span>generate_derangements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.generate_derangements </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return unique derangements of the elements of iterable ``s``.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import generate_derangements
&gt;&gt;&gt; list(generate_derangements([0, 1, 2]))
[[1, 2, 0], [2, 0, 1]]
&gt;&gt;&gt; list(generate_derangements([0, 1, 2, 2]))
[[2, 2, 0, 1], [2, 2, 1, 0]]
&gt;&gt;&gt; list(generate_derangements([0, 1, 1]))
[]

See Also
========

sympy.functions.combinatorial.factorials.subfactorial</pre> 
</div>
</div>
<a id="a441fdc80c0154c1abaf8ec4b339d0600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441fdc80c0154c1abaf8ec4b339d0600">&#9670;&nbsp;</a></span>generate_involutions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.generate_involutions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates involutions.

An involution is a permutation that when multiplied
by itself equals the identity permutation. In this
implementation the involutions are generated using
Fixed Points.

Alternatively, an involution can be considered as
a permutation that does not contain any cycles with
a length that is greater than two.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import generate_involutions
&gt;&gt;&gt; list(generate_involutions(3))
[(0, 1, 2), (0, 2, 1), (1, 0, 2), (2, 1, 0)]
&gt;&gt;&gt; len(list(generate_involutions(4)))
10

References
==========

.. [1] https://mathworld.wolfram.com/PermutationInvolution.html</pre> 
</div>
</div>
<a id="af2d0e6e7106e127180edf754747a1276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d0e6e7106e127180edf754747a1276">&#9670;&nbsp;</a></span>generate_oriented_forest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.generate_oriented_forest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This algorithm generates oriented forests.

An oriented graph is a directed graph having no symmetric pair of directed
edges. A forest is an acyclic graph, i.e., it has no cycles. A forest can
also be described as a disjoint union of trees, which are graphs in which
any two vertices are connected by exactly one simple path.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import generate_oriented_forest
&gt;&gt;&gt; list(generate_oriented_forest(4))
[[0, 1, 2, 3], [0, 1, 2, 2], [0, 1, 2, 1], [0, 1, 2, 0], \
[0, 1, 1, 1], [0, 1, 1, 0], [0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0]]

References
==========

.. [1] T. Beyer and S.M. Hedetniemi: constant time generation of
       rooted trees, SIAM J. Computing Vol. 9, No. 4, November 1980

.. [2] https://stackoverflow.com/questions/1633833/oriented-forest-taocp-algorithm-in-python</pre> 
</div>
</div>
<a id="a63b199cc531cc9bf68a8720ccdf4add8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b199cc531cc9bf68a8720ccdf4add8">&#9670;&nbsp;</a></span>group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiple</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Splits a sequence into a list of lists of equal, adjacent elements.

Examples
========

&gt;&gt;&gt; from sympy import group

&gt;&gt;&gt; group([1, 1, 1, 2, 2, 3])
[[1, 1, 1], [2, 2], [3]]
&gt;&gt;&gt; group([1, 1, 1, 2, 2, 3], multiple=False)
[(1, 3), (2, 2), (3, 1)]
&gt;&gt;&gt; group([1, 1, 3, 2, 2, 1], multiple=False)
[(1, 2), (3, 1), (2, 2), (1, 1)]

See Also
========

multiset</pre> 
</div>
</div>
<a id="af788481ecf84d3d76873add4282c55c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af788481ecf84d3d76873add4282c55c3">&#9670;&nbsp;</a></span>has_dups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.has_dups </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if there are any duplicate elements in ``seq``.

Examples
========

&gt;&gt;&gt; from sympy import has_dups, Dict, Set
&gt;&gt;&gt; has_dups((1, 2, 1))
True
&gt;&gt;&gt; has_dups(range(3))
False
&gt;&gt;&gt; all(has_dups(c) is False for c in (set(), Set(), dict(), Dict()))
True
</pre> 
</div>
</div>
<a id="ad1d3502891534965c226d719af1e912d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d3502891534965c226d719af1e912d">&#9670;&nbsp;</a></span>has_variety()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.has_variety </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if there are any different elements in ``seq``.

Examples
========

&gt;&gt;&gt; from sympy import has_variety

&gt;&gt;&gt; has_variety((1, 2, 1))
True
&gt;&gt;&gt; has_variety((1, 1, 1))
False
</pre> 
</div>
</div>
<a id="a1edb0e79fab332d35a9ace8ea4d1d0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edb0e79fab332d35a9ace8ea4d1d0e8">&#9670;&nbsp;</a></span>ibin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.ibin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>str</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of length ``bits`` corresponding to the binary value
of ``n`` with small bits to the right (last). If bits is omitted, the
length will be the number required to represent ``n``. If the bits are
desired in reversed order, use the ``[::-1]`` slice of the returned list.

If a sequence of all bits-length lists starting from ``[0, 0,..., 0]``
through ``[1, 1, ..., 1]`` are desired, pass a non-integer for bits, e.g.
``'all'``.

If the bit *string* is desired pass ``str=True``.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import ibin
&gt;&gt;&gt; ibin(2)
[1, 0]
&gt;&gt;&gt; ibin(2, 4)
[0, 0, 1, 0]

If all lists corresponding to 0 to 2**n - 1, pass a non-integer
for bits:

&gt;&gt;&gt; bits = 2
&gt;&gt;&gt; for i in ibin(2, 'all'):
...     print(i)
(0, 0)
(0, 1)
(1, 0)
(1, 1)

If a bit string is desired of a given length, use str=True:

&gt;&gt;&gt; n = 123
&gt;&gt;&gt; bits = 10
&gt;&gt;&gt; ibin(n, bits, str=True)
'0001111011'
&gt;&gt;&gt; ibin(n, bits, str=True)[::-1]  # small bits left
'1101111000'
&gt;&gt;&gt; list(ibin(3, 'all', str=True))
['000', '001', '010', '011', '100', '101', '110', '111']</pre> 
</div>
</div>
<a id="affe15d3e70a09010ea1cc1d627f5ba4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe15d3e70a09010ea1cc1d627f5ba4f">&#9670;&nbsp;</a></span>interactive_traversal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.interactive_traversal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abed866dfaeabec95eebdc0e1672b6c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed866dfaeabec95eebdc0e1672b6c6e">&#9670;&nbsp;</a></span>iproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.iproduct </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cartesian product of iterables.

Generator of the Cartesian product of iterables. This is analogous to
itertools.product except that it works with infinite iterables and will
yield any item from the infinite product eventually.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import iproduct
&gt;&gt;&gt; sorted(iproduct([1,2], [3,4]))
[(1, 3), (1, 4), (2, 3), (2, 4)]

With an infinite iterator:

&gt;&gt;&gt; from sympy import S
&gt;&gt;&gt; (3,) in iproduct(S.Integers)
True
&gt;&gt;&gt; (3, 4) in iproduct(S.Integers, S.Integers)
True

.. seealso::

   `itertools.product
   &lt;https://docs.python.org/3/library/itertools.html#itertools.product&gt;`_
</pre> 
</div>
</div>
<a id="a304fc3ddb554dca9eebd32dfa3f7edb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304fc3ddb554dca9eebd32dfa3f7edb8">&#9670;&nbsp;</a></span>is_palindromic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.is_palindromic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if the sequence is the same from left to right as it
is from right to left in the whole sequence (default) or in the
Python slice ``s[i: j]``; else False.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import is_palindromic
&gt;&gt;&gt; is_palindromic([1, 0, 1])
True
&gt;&gt;&gt; is_palindromic('abcbb')
False
&gt;&gt;&gt; is_palindromic('abcbb', 1)
False

Normal Python slicing is performed in place so there is no need to
create a slice of the sequence for testing:

&gt;&gt;&gt; is_palindromic('abcbb', 1, -1)
True
&gt;&gt;&gt; is_palindromic('abcbb', -4, -1)
True

See Also
========

sympy.ntheory.digits.is_palindromic: tests integers</pre> 
</div>
</div>
<a id="a276dcb73ec7a7a90ea6bfe379310ac6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276dcb73ec7a7a90ea6bfe379310ac6e">&#9670;&nbsp;</a></span>is_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.is_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>include</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a boolean indicating whether ``i`` is a sequence in the SymPy
sense. If anything that fails the test below should be included as
being a sequence for your application, set 'include' to that object's
type; multiple types should be passed as a tuple of types.

Note: although generators can generate a sequence, they often need special
handling to make sure their elements are captured before the generator is
exhausted, so these are not included by default in the definition of a
sequence.

See also: iterable

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import is_sequence
&gt;&gt;&gt; from types import GeneratorType
&gt;&gt;&gt; is_sequence([])
True
&gt;&gt;&gt; is_sequence(set())
False
&gt;&gt;&gt; is_sequence('abc')
False
&gt;&gt;&gt; is_sequence('abc', include=str)
True
&gt;&gt;&gt; generator = (c for c in 'abc')
&gt;&gt;&gt; is_sequence(generator)
False
&gt;&gt;&gt; is_sequence(generator, include=(str, GeneratorType))
True</pre> 
</div>
</div>
<a id="a45b0a7e9ea29792f77082e5d8cd2ab91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b0a7e9ea29792f77082e5d8cd2ab91">&#9670;&nbsp;</a></span>iterable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.iterable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exclude</em> = <code>(str,&#160;dict,&#160;<a class="el" href="classsympy_1_1utilities_1_1iterables_1_1NotIterable.html">NotIterable</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a boolean indicating whether ``i`` is SymPy iterable.
True also indicates that the iterator is finite, e.g. you can
call list(...) on the instance.

When SymPy is working with iterables, it is almost always assuming
that the iterable is not a string or a mapping, so those are excluded
by default. If you want a pure Python definition, make exclude=None. To
exclude multiple items, pass them as a tuple.

You can also set the _iterable attribute to True or False on your class,
which will override the checks here, including the exclude test.

As a rule of thumb, some SymPy functions use this to check if they should
recursively map over an object. If an object is technically iterable in
the Python sense but does not desire this behavior (e.g., because its
iteration is not finite, or because iteration might induce an unwanted
computation), it should disable it by setting the _iterable attribute to False.

See also: is_sequence

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import iterable
&gt;&gt;&gt; from sympy import Tuple
&gt;&gt;&gt; things = [[1], (1,), set([1]), Tuple(1), (j for j in [1, 2]), {1:2}, '1', 1]
&gt;&gt;&gt; for i in things:
...     print('%s %s' % (iterable(i), type(i)))
True &lt;... 'list'&gt;
True &lt;... 'tuple'&gt;
True &lt;... 'set'&gt;
True &lt;class 'sympy.core.containers.Tuple'&gt;
True &lt;... 'generator'&gt;
False &lt;... 'dict'&gt;
False &lt;... 'str'&gt;
False &lt;... 'int'&gt;

&gt;&gt;&gt; iterable({}, exclude=None)
True
&gt;&gt;&gt; iterable({}, exclude=str)
True
&gt;&gt;&gt; iterable("no", exclude=str)
False</pre> 
</div>
</div>
<a id="aecec36efaad3b02a2a16b6ada47c65e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecec36efaad3b02a2a16b6ada47c65e6">&#9670;&nbsp;</a></span>kbins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.kbins </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordered</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return sequence ``l`` partitioned into ``k`` bins.

Examples
========

The default is to give the items in the same order, but grouped
into k partitions without any reordering:

&gt;&gt;&gt; from sympy.utilities.iterables import kbins
&gt;&gt;&gt; for p in kbins(list(range(5)), 2):
...     print(p)
...
[[0], [1, 2, 3, 4]]
[[0, 1], [2, 3, 4]]
[[0, 1, 2], [3, 4]]
[[0, 1, 2, 3], [4]]

The ``ordered`` flag is either None (to give the simple partition
of the elements) or is a 2 digit integer indicating whether the order of
the bins and the order of the items in the bins matters. Given::

    A = [[0], [1, 2]]
    B = [[1, 2], [0]]
    C = [[2, 1], [0]]
    D = [[0], [2, 1]]

the following values for ``ordered`` have the shown meanings::

    00 means A == B == C == D
    01 means A == B
    10 means A == D
    11 means A == A

&gt;&gt;&gt; for ordered_flag in [None, 0, 1, 10, 11]:
...     print('ordered = %s' % ordered_flag)
...     for p in kbins(list(range(3)), 2, ordered=ordered_flag):
...         print('     %s' % p)
...
ordered = None
     [[0], [1, 2]]
     [[0, 1], [2]]
ordered = 0
     [[0, 1], [2]]
     [[0, 2], [1]]
     [[0], [1, 2]]
ordered = 1
     [[0], [1, 2]]
     [[0], [2, 1]]
     [[1], [0, 2]]
     [[1], [2, 0]]
     [[2], [0, 1]]
     [[2], [1, 0]]
ordered = 10
     [[0, 1], [2]]
     [[2], [0, 1]]
     [[0, 2], [1]]
     [[1], [0, 2]]
     [[0], [1, 2]]
     [[1, 2], [0]]
ordered = 11
     [[0], [1, 2]]
     [[0, 1], [2]]
     [[0], [2, 1]]
     [[0, 2], [1]]
     [[1], [0, 2]]
     [[1, 0], [2]]
     [[1], [2, 0]]
     [[1, 2], [0]]
     [[2], [0, 1]]
     [[2, 0], [1]]
     [[2], [1, 0]]
     [[2, 1], [0]]

See Also
========

partitions, multiset_partitions</pre> 
</div>
</div>
<a id="aae3df6aa45be733c15e00eebb96d48fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3df6aa45be733c15e00eebb96d48fb">&#9670;&nbsp;</a></span>least_rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.least_rotation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of steps of left rotation required to
obtain lexicographically minimal string/list/tuple, etc.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import least_rotation, rotate_left
&gt;&gt;&gt; a = [3, 1, 5, 1, 2]
&gt;&gt;&gt; least_rotation(a)
3
&gt;&gt;&gt; rotate_left(a, _)
[1, 2, 3, 1, 5]

References
==========

.. [1] https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation</pre> 
</div>
</div>
<a id="afe991cff53576b4d71337ba43d78113c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe991cff53576b4d71337ba43d78113c">&#9670;&nbsp;</a></span>minlex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.minlex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>directed</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the rotation of the sequence in which the lexically smallest
elements appear first, e.g. `cba \rightarrow acb`.

The sequence returned is a tuple, unless the input sequence is a string
in which case a string is returned.

If ``directed`` is False then the smaller of the sequence and the
reversed sequence is returned, e.g. `cba \rightarrow abc`.

If ``key`` is not None then it is used to extract a comparison key from each element in iterable.

Examples
========

&gt;&gt;&gt; from sympy.combinatorics.polyhedron import minlex
&gt;&gt;&gt; minlex((1, 2, 0))
(0, 1, 2)
&gt;&gt;&gt; minlex((1, 0, 2))
(0, 2, 1)
&gt;&gt;&gt; minlex((1, 0, 2), directed=False)
(0, 1, 2)

&gt;&gt;&gt; minlex('11010011000', directed=True)
'00011010011'
&gt;&gt;&gt; minlex('11010011000', directed=False)
'00011001011'

&gt;&gt;&gt; minlex(('bb', 'aaa', 'c', 'a'))
('a', 'bb', 'aaa', 'c')
&gt;&gt;&gt; minlex(('bb', 'aaa', 'c', 'a'), key=len)
('c', 'a', 'bb', 'aaa')</pre> 
</div>
</div>
<a id="a611081f5b49055554805fc2617fcbb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611081f5b49055554805fc2617fcbb62">&#9670;&nbsp;</a></span>multiset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.multiset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the hashable sequence in multiset form with values being the
multiplicity of the item in the sequence.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import multiset
&gt;&gt;&gt; multiset('mississippi')
{'i': 4, 'm': 1, 'p': 2, 's': 4}

See Also
========

group</pre> 
</div>
</div>
<a id="a60ccf5a1d35c173d4f3de07d97f517e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ccf5a1d35c173d4f3de07d97f517e3">&#9670;&nbsp;</a></span>multiset_combinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.multiset_combinations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the unique combinations of size ``n`` from multiset ``m``.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import multiset_combinations
&gt;&gt;&gt; from itertools import combinations
&gt;&gt;&gt; [''.join(i) for i in  multiset_combinations('baby', 3)]
['abb', 'aby', 'bby']

&gt;&gt;&gt; def count(f, s): return len(list(f(s, 3)))

The number of combinations depends on the number of letters; the
number of unique combinations depends on how the letters are
repeated.

&gt;&gt;&gt; s1 = 'abracadabra'
&gt;&gt;&gt; s2 = 'banana tree'
&gt;&gt;&gt; count(combinations, s1), count(multiset_combinations, s1)
(165, 23)
&gt;&gt;&gt; count(combinations, s2), count(multiset_combinations, s2)
(165, 54)</pre> 
</div>
</div>
<a id="a8ece2d38c1c8dc7069c710644151d2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ece2d38c1c8dc7069c710644151d2df">&#9670;&nbsp;</a></span>multiset_derangements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.multiset_derangements </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate derangements of the elements of s *in place*.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import multiset_derangements, uniq

Because the derangements of multisets (not sets) are generated
in place, copies of the return value must be made if a collection
of derangements is desired or else all values will be the same:

&gt;&gt;&gt; list(uniq([i for i in multiset_derangements('1233')]))
[[None, None, None, None]]
&gt;&gt;&gt; [i.copy() for i in multiset_derangements('1233')]
[['3', '3', '1', '2'], ['3', '3', '2', '1']]
&gt;&gt;&gt; [''.join(i) for i in multiset_derangements('1233')]
['3312', '3321']
</pre> 
</div>
</div>
<a id="a164dabb76856d81dc3269214886a9be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164dabb76856d81dc3269214886a9be1">&#9670;&nbsp;</a></span>multiset_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.multiset_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return unique partitions of the given multiset (in list form).
If ``m`` is None, all multisets will be returned, otherwise only
partitions with ``m`` parts will be returned.

If ``multiset`` is an integer, a range [0, 1, ..., multiset - 1]
will be supplied.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import multiset_partitions
&gt;&gt;&gt; list(multiset_partitions([1, 2, 3, 4], 2))
[[[1, 2, 3], [4]], [[1, 2, 4], [3]], [[1, 2], [3, 4]],
[[1, 3, 4], [2]], [[1, 3], [2, 4]], [[1, 4], [2, 3]],
[[1], [2, 3, 4]]]
&gt;&gt;&gt; list(multiset_partitions([1, 2, 3, 4], 1))
[[[1, 2, 3, 4]]]

Only unique partitions are returned and these will be returned in a
canonical order regardless of the order of the input:

&gt;&gt;&gt; a = [1, 2, 2, 1]
&gt;&gt;&gt; ans = list(multiset_partitions(a, 2))
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; list(multiset_partitions(a, 2)) == ans
True
&gt;&gt;&gt; a = range(3, 1, -1)
&gt;&gt;&gt; (list(multiset_partitions(a)) ==
...  list(multiset_partitions(sorted(a))))
True

If m is omitted then all partitions will be returned:

&gt;&gt;&gt; list(multiset_partitions([1, 1, 2]))
[[[1, 1, 2]], [[1, 1], [2]], [[1, 2], [1]], [[1], [1], [2]]]
&gt;&gt;&gt; list(multiset_partitions([1]*3))
[[[1, 1, 1]], [[1], [1, 1]], [[1], [1], [1]]]

Counting
========

The number of partitions of a set is given by the bell number:

&gt;&gt;&gt; from sympy import bell
&gt;&gt;&gt; len(list(multiset_partitions(5))) == bell(5) == 52
True

The number of partitions of length k from a set of size n is given by the
Stirling Number of the 2nd kind:

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import stirling
&gt;&gt;&gt; stirling(5, 2) == len(list(multiset_partitions(5, 2))) == 15
True

These comments on counting apply to *sets*, not multisets.

Notes
=====

When all the elements are the same in the multiset, the order
of the returned partitions is determined by the ``partitions``
routine. If one is counting partitions then it is better to use
the ``nT`` function.

See Also
========

partitions
sympy.combinatorics.partitions.Partition
sympy.combinatorics.partitions.IntegerPartition
sympy.functions.combinatorial.numbers.nT</pre> 
</div>
</div>
<a id="a92723958abe93c91388ccd744791c2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92723958abe93c91388ccd744791c2c5">&#9670;&nbsp;</a></span>multiset_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.multiset_permutations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the unique permutations of multiset ``m``.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import multiset_permutations
&gt;&gt;&gt; from sympy import factorial
&gt;&gt;&gt; [''.join(i) for i in multiset_permutations('aab')]
['aab', 'aba', 'baa']
&gt;&gt;&gt; factorial(len('banana'))
720
&gt;&gt;&gt; len(list(multiset_permutations('banana')))
60
</pre> 
</div>
</div>
<a id="adf0f0fb2794bb6f1929f321beb17463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0f0fb2794bb6f1929f321beb17463a">&#9670;&nbsp;</a></span>necklaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.necklaces </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>free</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A routine to generate necklaces that may (free=True) or may not
(free=False) be turned over to be viewed. The "necklaces" returned
are comprised of ``n`` integers (beads) with ``k`` different
values (colors). Only unique necklaces are returned.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import necklaces, bracelets
&gt;&gt;&gt; def show(s, i):
...     return ''.join(s[j] for j in i)

The "unrestricted necklace" is sometimes also referred to as a
"bracelet" (an object that can be turned over, a sequence that can
be reversed) and the term "necklace" is used to imply a sequence
that cannot be reversed. So ACB == ABC for a bracelet (rotate and
reverse) while the two are different for a necklace since rotation
alone cannot make the two sequences the same.

(mnemonic: Bracelets can be viewed Backwards, but Not Necklaces.)

&gt;&gt;&gt; B = [show('ABC', i) for i in bracelets(3, 3)]
&gt;&gt;&gt; N = [show('ABC', i) for i in necklaces(3, 3)]
&gt;&gt;&gt; set(N) - set(B)
{'ACB'}

&gt;&gt;&gt; list(necklaces(4, 2))
[(0, 0, 0, 0), (0, 0, 0, 1), (0, 0, 1, 1),
 (0, 1, 0, 1), (0, 1, 1, 1), (1, 1, 1, 1)]

&gt;&gt;&gt; [show('.o', i) for i in bracelets(4, 2)]
['....', '...o', '..oo', '.o.o', '.ooo', 'oooo']

References
==========

.. [1] https://mathworld.wolfram.com/Necklace.html

.. [2] Frank Ruskey, Carla Savage, and Terry Min Yih Wang,
    Generating necklaces, Journal of Algorithms 13 (1992), 414-430;
    https://doi.org/10.1016/0196-6774(92)90047-G</pre> 
</div>
</div>
<a id="accf12233932b130a1a8a210515da851c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf12233932b130a1a8a210515da851c">&#9670;&nbsp;</a></span>numbered_symbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.numbered_symbols </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>'x'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exclude</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>assumptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate an infinite stream of Symbols consisting of a prefix and
increasing subscripts provided that they do not occur in ``exclude``.

Parameters
==========

prefix : str, optional
    The prefix to use. By default, this function will generate symbols of
    the form "x0", "x1", etc.

cls : class, optional
    The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``
    or ``Dummy``.

start : int, optional
    The start number.  By default, it is 0.

exclude : list, tuple, set of cls, optional
    Symbols to be excluded.

*args, **kwargs
    Additional positional and keyword arguments are passed to the *cls* class.

Returns
=======

sym : Symbol
    The subscripted symbols.
</pre> 
</div>
</div>
<a id="a92342ee315805d7ded5e769045ae68f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92342ee315805d7ded5e769045ae68f7">&#9670;&nbsp;</a></span>ordered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.ordered </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b733ed72754b6b003745460eddb3365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b733ed72754b6b003745460eddb3365">&#9670;&nbsp;</a></span>ordered_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.ordered_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates ordered partitions of integer *n*.

Parameters
==========
n : int
m : int, optional
    The default value gives partitions of all sizes else only
    those with size m. In addition, if *m* is not None then
    partitions are generated *in place* (see examples).
sort : bool, default: True
    Controls whether partitions are
    returned in sorted order when *m* is not None; when False,
    the partitions are returned as fast as possible with elements
    sorted, but when m|n the partitions will not be in
    ascending lexicographical order.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import ordered_partitions

All partitions of 5 in ascending lexicographical:

&gt;&gt;&gt; for p in ordered_partitions(5):
...     print(p)
[1, 1, 1, 1, 1]
[1, 1, 1, 2]
[1, 1, 3]
[1, 2, 2]
[1, 4]
[2, 3]
[5]

Only partitions of 5 with two parts:

&gt;&gt;&gt; for p in ordered_partitions(5, 2):
...     print(p)
[1, 4]
[2, 3]

When ``m`` is given, a given list objects will be used more than
once for speed reasons so you will not see the correct partitions
unless you make a copy of each as it is generated:

&gt;&gt;&gt; [p for p in ordered_partitions(7, 3)]
[[1, 1, 1], [1, 1, 1], [1, 1, 1], [2, 2, 2]]
&gt;&gt;&gt; [list(p) for p in ordered_partitions(7, 3)]
[[1, 1, 5], [1, 2, 4], [1, 3, 3], [2, 2, 3]]

When ``n`` is a multiple of ``m``, the elements are still sorted
but the partitions themselves will be *unordered* if sort is False;
the default is to return them in ascending lexicographical order.

&gt;&gt;&gt; for p in ordered_partitions(6, 2):
...     print(p)
[1, 5]
[2, 4]
[3, 3]

But if speed is more important than ordering, sort can be set to
False:

&gt;&gt;&gt; for p in ordered_partitions(6, 2, sort=False):
...     print(p)
[1, 5]
[3, 3]
[2, 4]

References
==========

.. [1] Generating Integer Partitions, [online],
    Available: https://jeromekelleher.net/generating-integer-partitions.html
.. [2] Jerome Kelleher and Barry O'Sullivan, "Generating All
    Partitions: A Comparison Of Two Encodings", [online],
    Available: https://arxiv.org/pdf/0909.2331v2.pdf
</pre> 
</div>
</div>
<a id="aa62b7ca53ea4282867de5acf27b4be4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62b7ca53ea4282867de5acf27b4be4c">&#9670;&nbsp;</a></span>partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate all partitions of positive integer, n.

Each partition is represented as a dictionary, mapping an integer
to the number of copies of that integer in the partition.  For example,
the first partition of 4 returned is {4: 1}, "4: one of them".

Parameters
==========
n : int
m : int, optional
    limits number of parts in partition (mnemonic: m, maximum parts)
k : int, optional
    limits the numbers that are kept in the partition (mnemonic: k, keys)
size : bool, default: False
    If ``True``, (M, P) is returned where M is the sum of the
    multiplicities and P is the generated partition.
    If ``False``, only the generated partition is returned.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import partitions

The numbers appearing in the partition (the key of the returned dict)
are limited with k:

&gt;&gt;&gt; for p in partitions(6, k=2):  # doctest: +SKIP
...     print(p)
{2: 3}
{1: 2, 2: 2}
{1: 4, 2: 1}
{1: 6}

The maximum number of parts in the partition (the sum of the values in
the returned dict) are limited with m (default value, None, gives
partitions from 1 through n):

&gt;&gt;&gt; for p in partitions(6, m=2):  # doctest: +SKIP
...     print(p)
...
{6: 1}
{1: 1, 5: 1}
{2: 1, 4: 1}
{3: 2}

References
==========

.. [1] modified from Tim Peter's version to allow for k and m values:
       https://code.activestate.com/recipes/218332-generator-for-integer-partitions/

See Also
========

sympy.combinatorics.partitions.Partition
sympy.combinatorics.partitions.IntegerPartition</pre> 
</div>
</div>
<a id="a557532a07e5c32ba71dc9160cb1a7267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557532a07e5c32ba71dc9160cb1a7267">&#9670;&nbsp;</a></span>permute_signs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.permute_signs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return iterator in which the signs of non-zero elements
of t are permuted.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import permute_signs
&gt;&gt;&gt; list(permute_signs((0, 1, 2)))
[(0, 1, 2), (0, -1, 2), (0, 1, -2), (0, -1, -2)]
</pre> 
</div>
</div>
<a id="a5070946bca23f7cc821d927a504fb36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5070946bca23f7cc821d927a504fb36d">&#9670;&nbsp;</a></span>postfixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.postfixes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate all postfixes of a sequence.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import postfixes

&gt;&gt;&gt; list(postfixes([1,2,3,4]))
[[4], [3, 4], [2, 3, 4], [1, 2, 3, 4]]</pre> 
</div>
</div>
<a id="aa55edf1fe6ae45558887c3ada5da2e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55edf1fe6ae45558887c3ada5da2e50">&#9670;&nbsp;</a></span>postorder_traversal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.postorder_traversal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97e5615e96f38a1c9aaa8a702db6dcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e5615e96f38a1c9aaa8a702db6dcbe">&#9670;&nbsp;</a></span>prefixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.prefixes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate all prefixes of a sequence.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import prefixes

&gt;&gt;&gt; list(prefixes([1,2,3,4]))
[[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]</pre> 
</div>
</div>
<a id="a013b7fe5ee5c480799e7810b5908379e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013b7fe5ee5c480799e7810b5908379e">&#9670;&nbsp;</a></span>random_derangement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.random_derangement </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>choice</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of elements in which none are in the same positions
as they were originally. If an element fills more than half of the positions
then an error will be raised since no derangement is possible. To obtain
a derangement of as many items as possible--with some of the most numerous
remaining in their original positions--pass `strict=False`. To produce a
pseudorandom derangment, pass a pseudorandom selector like `choice` (see
below).

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import random_derangement
&gt;&gt;&gt; t = 'SymPy: a CAS in pure Python'
&gt;&gt;&gt; d = random_derangement(t)
&gt;&gt;&gt; all(i != j for i, j in zip(d, t))
True

A predictable result can be obtained by using a pseudorandom
generator for the choice:

&gt;&gt;&gt; from sympy.core.random import seed, choice as c
&gt;&gt;&gt; seed(1)
&gt;&gt;&gt; d = [''.join(random_derangement(t, c)) for i in range(5)]
&gt;&gt;&gt; assert len(set(d)) != 1  # we got different values

By reseeding, the same sequence can be obtained:

&gt;&gt;&gt; seed(1)
&gt;&gt;&gt; d2 = [''.join(random_derangement(t, c)) for i in range(5)]
&gt;&gt;&gt; assert d == d2
</pre> 
</div>
</div>
<a id="a613b8c7171fc81f5e4579180324e34f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613b8c7171fc81f5e4579180324e34f3">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.reshape </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>how</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reshape the sequence according to the template in ``how``.

Examples
========

&gt;&gt;&gt; from sympy.utilities import reshape
&gt;&gt;&gt; seq = list(range(1, 9))

&gt;&gt;&gt; reshape(seq, [4]) # lists of 4
[[1, 2, 3, 4], [5, 6, 7, 8]]

&gt;&gt;&gt; reshape(seq, (4,)) # tuples of 4
[(1, 2, 3, 4), (5, 6, 7, 8)]

&gt;&gt;&gt; reshape(seq, (2, 2)) # tuples of 4
[(1, 2, 3, 4), (5, 6, 7, 8)]

&gt;&gt;&gt; reshape(seq, (2, [2])) # (i, i, [i, i])
[(1, 2, [3, 4]), (5, 6, [7, 8])]

&gt;&gt;&gt; reshape(seq, ((2,), [2])) # etc....
[((1, 2), [3, 4]), ((5, 6), [7, 8])]

&gt;&gt;&gt; reshape(seq, (1, [2], 1))
[(1, [2, 3], 4), (5, [6, 7], 8)]

&gt;&gt;&gt; reshape(tuple(seq), ([[1], 1, (2,)],))
(([[1], 2, (3, 4)],), ([[5], 6, (7, 8)],))

&gt;&gt;&gt; reshape(tuple(seq), ([1], 1, (2,)))
(([1], 2, (3, 4)), ([5], 6, (7, 8)))

&gt;&gt;&gt; reshape(list(range(12)), [2, [3], {2}, (1, (3,), 1)])
[[0, 1, [2, 3, 4], {5, 6}, (7, (8, 9, 10), 11)]]</pre> 
</div>
</div>
<a id="aa52a72ef71b6dc4da54e13fa10c364f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52a72ef71b6dc4da54e13fa10c364f0">&#9670;&nbsp;</a></span>rotate_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.rotate_left </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Left rotates a list x by the number of steps specified
in y.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import rotate_left
&gt;&gt;&gt; a = [0, 1, 2]
&gt;&gt;&gt; rotate_left(a, 1)
[1, 2, 0]
</pre> 
</div>
</div>
<a id="aae632cd1b4f824d7a99eb7f904299d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae632cd1b4f824d7a99eb7f904299d8e">&#9670;&nbsp;</a></span>rotate_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.rotate_right </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Right rotates a list x by the number of steps specified
in y.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import rotate_right
&gt;&gt;&gt; a = [0, 1, 2]
&gt;&gt;&gt; rotate_right(a, 1)
[2, 0, 1]
</pre> 
</div>
</div>
<a id="a302cfe20aec8670bb220bc76028f34c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302cfe20aec8670bb220bc76028f34c7">&#9670;&nbsp;</a></span>rotations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.rotations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dir</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a generator giving the items in s as list where
each subsequent list has the items rotated to the left (default)
or right (``dir=-1``) relative to the previous list.

Examples
========

&gt;&gt;&gt; from sympy import rotations
&gt;&gt;&gt; list(rotations([1,2,3]))
[[1, 2, 3], [2, 3, 1], [3, 1, 2]]
&gt;&gt;&gt; list(rotations([1,2,3], -1))
[[1, 2, 3], [3, 1, 2], [2, 3, 1]]
</pre> 
</div>
</div>
<a id="a8ae88f1a552b0272b8ebde60eedea7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae88f1a552b0272b8ebde60eedea7db">&#9670;&nbsp;</a></span>roundrobin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.roundrobin </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">roundrobin recipe taken from itertools documentation:
https://docs.python.org/3/library/itertools.html#itertools-recipes

roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C

Recipe credited to George Sakkis
</pre> 
</div>
</div>
<a id="af453fff96873e09d9ef786582d664ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af453fff96873e09d9ef786582d664ff4">&#9670;&nbsp;</a></span>runs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.runs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>op</em> = <code>gt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Group the sequence into lists in which successive elements
all compare the same with the comparison operator, ``op``:
op(seq[i + 1], seq[i]) is True from all elements in a run.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import runs
&gt;&gt;&gt; from operator import ge
&gt;&gt;&gt; runs([0, 1, 2, 2, 1, 4, 3, 2, 2])
[[0, 1, 2], [2], [1, 4], [3], [2], [2]]
&gt;&gt;&gt; runs([0, 1, 2, 2, 1, 4, 3, 2, 2], op=ge)
[[0, 1, 2, 2], [1, 4], [3], [2, 2]]
</pre> 
</div>
</div>
<a id="a8fb89d74bd14719c78d014f33fcd285d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb89d74bd14719c78d014f33fcd285d">&#9670;&nbsp;</a></span>sequence_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.sequence_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the partition of sequence $l$ into $n$ bins

Explanation
===========

Given the sequence $l_1 \cdots l_m \in V^+$ where
$V^+$ is the Kleene plus of $V$

The set of $n$ partitions of $l$ is defined as:

.. math::
    \{(s_1, \cdots, s_n) | s_1 \in V^+, \cdots, s_n \in V^+,
    s_1 \cdots s_n = l_1 \cdots l_m\}

Parameters
==========

l : Sequence[T]
    A nonempty sequence of any Python objects

n : int
    A positive integer

Yields
======

out : list[Sequence[T]]
    A list of sequences with concatenation equals $l$.
    This should conform with the type of $l$.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import sequence_partitions
&gt;&gt;&gt; for out in sequence_partitions([1, 2, 3, 4], 2):
...     print(out)
[[1], [2, 3, 4]]
[[1, 2], [3, 4]]
[[1, 2, 3], [4]]

Notes
=====

This is modified version of EnricoGiampieri's partition generator
from https://stackoverflow.com/questions/13131491/partition-n-items-into-k-bins-in-python-lazily

See Also
========

sequence_partitions_empty
</pre> 
</div>
</div>
<a id="a1debcfdd2a61a658310414e3d2848fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1debcfdd2a61a658310414e3d2848fa4">&#9670;&nbsp;</a></span>sequence_partitions_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.sequence_partitions_empty </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the partition of sequence $l$ into $n$ bins with
empty sequence

Explanation
===========

Given the sequence $l_1 \cdots l_m \in V^*$ where
$V^*$ is the Kleene star of $V$

The set of $n$ partitions of $l$ is defined as:

.. math::
    \{(s_1, \cdots, s_n) | s_1 \in V^*, \cdots, s_n \in V^*,
    s_1 \cdots s_n = l_1 \cdots l_m\}

There are more combinations than :func:`sequence_partitions` because
empty sequence can fill everywhere, so we try to provide different
utility for this.

Parameters
==========

l : Sequence[T]
    A sequence of any Python objects (can be possibly empty)

n : int
    A positive integer

Yields
======

out : list[Sequence[T]]
    A list of sequences with concatenation equals $l$.
    This should conform with the type of $l$.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import sequence_partitions_empty
&gt;&gt;&gt; for out in sequence_partitions_empty([1, 2, 3, 4], 2):
...     print(out)
[[], [1, 2, 3, 4]]
[[1], [2, 3, 4]]
[[1, 2], [3, 4]]
[[1, 2, 3], [4]]
[[1, 2, 3, 4], []]

See Also
========

sequence_partitions
</pre> 
</div>
</div>
<a id="ade1ba7f896953a94220f690bfbef8872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1ba7f896953a94220f690bfbef8872">&#9670;&nbsp;</a></span>sift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.sift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keyfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>binary</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sift the sequence, ``seq`` according to ``keyfunc``.

Returns
=======

When ``binary`` is ``False`` (default), the output is a dictionary
where elements of ``seq`` are stored in a list keyed to the value
of keyfunc for that element. If ``binary`` is True then a tuple
with lists ``T`` and ``F`` are returned where ``T`` is a list
containing elements of seq for which ``keyfunc`` was ``True`` and
``F`` containing those elements for which ``keyfunc`` was ``False``;
a ValueError is raised if the ``keyfunc`` is not binary.

Examples
========

&gt;&gt;&gt; from sympy.utilities import sift
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy import sqrt, exp, pi, Tuple

&gt;&gt;&gt; sift(range(5), lambda x: x % 2)
{0: [0, 2, 4], 1: [1, 3]}

sift() returns a defaultdict() object, so any key that has no matches will
give [].

&gt;&gt;&gt; sift([x], lambda x: x.is_commutative)
{True: [x]}
&gt;&gt;&gt; _[False]
[]

Sometimes you will not know how many keys you will get:

&gt;&gt;&gt; sift([sqrt(x), exp(x), (y**x)**2],
...      lambda x: x.as_base_exp()[0])
{E: [exp(x)], x: [sqrt(x)], y: [y**(2*x)]}

Sometimes you expect the results to be binary; the
results can be unpacked by setting ``binary`` to True:

&gt;&gt;&gt; sift(range(4), lambda x: x % 2, binary=True)
([1, 3], [0, 2])
&gt;&gt;&gt; sift(Tuple(1, pi), lambda x: x.is_rational, binary=True)
([1], [pi])

A ValueError is raised if the predicate was not actually binary
(which is a good test for the logic where sifting is used and
binary results were expected):

&gt;&gt;&gt; unknown = exp(1) - pi  # the rationality of this is unknown
&gt;&gt;&gt; args = Tuple(1, pi, unknown)
&gt;&gt;&gt; sift(args, lambda x: x.is_rational, binary=True)
Traceback (most recent call last):
...
ValueError: keyfunc gave non-binary output

The non-binary sifting shows that there were 3 keys generated:

&gt;&gt;&gt; set(sift(args, lambda x: x.is_rational).keys())
{None, False, True}

If you need to sort the sifted items it might be better to use
``ordered`` which can economically apply multiple sort keys
to a sequence while sorting.

See Also
========

ordered</pre> 
</div>
</div>
<a id="af6b556f979f7a4f8681907d4ef36acf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b556f979f7a4f8681907d4ef36acf5">&#9670;&nbsp;</a></span>signed_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.signed_permutations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return iterator in which the signs of non-zero elements
of t and the order of the elements are permuted and all
returned values are unique.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import signed_permutations
&gt;&gt;&gt; list(signed_permutations((0, 1, 2)))
[(0, 1, 2), (0, -1, 2), (0, 1, -2), (0, -1, -2), (0, 2, 1),
(0, -2, 1), (0, 2, -1), (0, -2, -1), (1, 0, 2), (-1, 0, 2),
(1, 0, -2), (-1, 0, -2), (1, 2, 0), (-1, 2, 0), (1, -2, 0),
(-1, -2, 0), (2, 0, 1), (-2, 0, 1), (2, 0, -1), (-2, 0, -1),
(2, 1, 0), (-2, 1, 0), (2, -1, 0), (-2, -1, 0)]
</pre> 
</div>
</div>
<a id="a3c3d3ee8764aa239fee59c5631854e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3d3ee8764aa239fee59c5631854e8d">&#9670;&nbsp;</a></span>strongly_connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.strongly_connected_components </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Strongly connected components of a directed graph in reverse topological
order.


Parameters
==========

G : tuple[list, list[tuple[T, T]]
    A tuple consisting of a list of vertices and a list of edges of
    a graph whose strongly connected components are to be found.


Examples
========

Consider a directed graph (in dot notation)::

    digraph {
        A -&gt; B
        A -&gt; C
        B -&gt; C
        C -&gt; B
        B -&gt; D
    }

.. graphviz::

    digraph {
        A -&gt; B
        A -&gt; C
        B -&gt; C
        C -&gt; B
        B -&gt; D
    }

where vertices are the letters A, B, C and D. This graph can be encoded
using Python's elementary data structures as follows::

    &gt;&gt;&gt; V = ['A', 'B', 'C', 'D']
    &gt;&gt;&gt; E = [('A', 'B'), ('A', 'C'), ('B', 'C'), ('C', 'B'), ('B', 'D')]

The strongly connected components of this graph can be computed as

    &gt;&gt;&gt; from sympy.utilities.iterables import strongly_connected_components

    &gt;&gt;&gt; strongly_connected_components((V, E))
    [['D'], ['B', 'C'], ['A']]

This also gives the components in reverse topological order.

Since the subgraph containing B and C has a cycle they must be together in
a strongly connected component. A and D are connected to the rest of the
graph but not in a cyclic manner so they appear as their own strongly
connected components.


Notes
=====

The vertices of the graph must be hashable for the data structures used.
If the vertices are unhashable replace them with integer indices.

This function uses Tarjan's algorithm to compute the strongly connected
components in `O(|V|+|E|)` (linear) time.


References
==========

.. [1] https://en.wikipedia.org/wiki/Strongly_connected_component
.. [2] https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm


See Also
========

sympy.utilities.iterables.connected_components</pre> 
</div>
</div>
<a id="a7d91706be350f08104b9125c7a18206d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d91706be350f08104b9125c7a18206d">&#9670;&nbsp;</a></span>subsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.subsets </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repetition</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates all `k`-subsets (combinations) from an `n`-element set, ``seq``.

A `k`-subset of an `n`-element set is any subset of length exactly `k`. The
number of `k`-subsets of an `n`-element set is given by ``binomial(n, k)``,
whereas there are `2^n` subsets all together. If `k` is ``None`` then all
`2^n` subsets will be returned from shortest to longest.

Examples
========

&gt;&gt;&gt; from sympy import subsets

``subsets(seq, k)`` will return the
`\frac{n!}{k!(n - k)!}` `k`-subsets (combinations)
without repetition, i.e. once an item has been removed, it can no
longer be "taken":

    &gt;&gt;&gt; list(subsets([1, 2], 2))
    [(1, 2)]
    &gt;&gt;&gt; list(subsets([1, 2]))
    [(), (1,), (2,), (1, 2)]
    &gt;&gt;&gt; list(subsets([1, 2, 3], 2))
    [(1, 2), (1, 3), (2, 3)]


``subsets(seq, k, repetition=True)`` will return the
`\frac{(n - 1 + k)!}{k!(n - 1)!}`
combinations *with* repetition:

    &gt;&gt;&gt; list(subsets([1, 2], 2, repetition=True))
    [(1, 1), (1, 2), (2, 2)]

If you ask for more items than are in the set you get the empty set unless
you allow repetitions:

    &gt;&gt;&gt; list(subsets([0, 1], 3, repetition=False))
    []
    &gt;&gt;&gt; list(subsets([0, 1], 3, repetition=True))
    [(0, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 1)]</pre> 
</div>
</div>
<a id="a81edbeef35e85f7e78670da4a341dd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81edbeef35e85f7e78670da4a341dd97">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.take </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``n`` items from ``iter`` iterator. </pre> 
</div>
</div>
<a id="aeb8e45f553b38473558befc7c9d682f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8e45f553b38473558befc7c9d682f8">&#9670;&nbsp;</a></span>topological_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.topological_sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Topological sort of graph's vertices.

Parameters
==========

graph : tuple[list, list[tuple[T, T]]
    A tuple consisting of a list of vertices and a list of edges of
    a graph to be sorted topologically.

key : callable[T] (optional)
    Ordering key for vertices on the same level. By default the natural
    (e.g. lexicographic) ordering is used (in this case the base type
    must implement ordering relations).

Examples
========

Consider a graph::

    +---+     +---+     +---+
    | 7 |\    | 5 |     | 3 |
    +---+ \   +---+     +---+
      |   _\___/ ____   _/ |
      |  /  \___/    \ /   |
      V  V           V V   |
     +----+         +---+  |
     | 11 |         | 8 |  |
     +----+         +---+  |
      | | \____   ___/ _   |
      | \      \ /    / \  |
      V  \     V V   /  V  V
    +---+ \   +---+ |  +----+
    | 2 |  |  | 9 | |  | 10 |
    +---+  |  +---+ |  +----+
           \________/

where vertices are integers. This graph can be encoded using
elementary Python's data structures as follows::

    &gt;&gt;&gt; V = [2, 3, 5, 7, 8, 9, 10, 11]
    &gt;&gt;&gt; E = [(7, 11), (7, 8), (5, 11), (3, 8), (3, 10),
    ...      (11, 2), (11, 9), (11, 10), (8, 9)]

To compute a topological sort for graph ``(V, E)`` issue::

    &gt;&gt;&gt; from sympy.utilities.iterables import topological_sort

    &gt;&gt;&gt; topological_sort((V, E))
    [3, 5, 7, 8, 11, 2, 9, 10]

If specific tie breaking approach is needed, use ``key`` parameter::

    &gt;&gt;&gt; topological_sort((V, E), key=lambda v: -v)
    [7, 5, 11, 3, 10, 8, 9, 2]

Only acyclic graphs can be sorted. If the input graph has a cycle,
then ``ValueError`` will be raised::

    &gt;&gt;&gt; topological_sort((V, E + [(10, 7)]))
    Traceback (most recent call last):
    ...
    ValueError: cycle detected

References
==========

.. [1] https://en.wikipedia.org/wiki/Topological_sorting</pre> 
</div>
</div>
<a id="a34ae92c62da178a600fc0c2f362e5a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ae92c62da178a600fc0c2f362e5a52">&#9670;&nbsp;</a></span>unflatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.unflatten </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Group ``iter`` into tuples of length ``n``. Raise an error if
the length of ``iter`` is not a multiple of ``n``.
</pre> 
</div>
</div>
<a id="a1c34fcfa400209a82af97b81877181a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c34fcfa400209a82af97b81877181a1">&#9670;&nbsp;</a></span>uniq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.uniq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield unique elements from ``seq`` as an iterator. The second
parameter ``result``  is used internally; it is not necessary
to pass anything for this.

Note: changing the sequence during iteration will raise a
RuntimeError if the size of the sequence is known; if you pass
an iterator and advance the iterator you will change the
output of this routine but there will be no warning.

Examples
========

&gt;&gt;&gt; from sympy.utilities.iterables import uniq
&gt;&gt;&gt; dat = [1, 4, 1, 5, 4, 2, 1, 2]
&gt;&gt;&gt; type(uniq(dat)) in (list, tuple)
False

&gt;&gt;&gt; list(uniq(dat))
[1, 4, 5, 2]
&gt;&gt;&gt; list(uniq(x for x in dat))
[1, 4, 5, 2]
&gt;&gt;&gt; list(uniq([[1], [2, 1], [1]]))
[[1], [2, 1]]
</pre> 
</div>
</div>
<a id="a210175207eac4a4503692e99f9488766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210175207eac4a4503692e99f9488766">&#9670;&nbsp;</a></span>variations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.iterables.variations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repetition</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator over the n-sized variations of ``seq`` (size N).
``repetition`` controls whether items in ``seq`` can appear more than once;

Examples
========

``variations(seq, n)`` will return `\frac{N!}{(N - n)!}` permutations without
repetition of ``seq``'s elements:

    &gt;&gt;&gt; from sympy import variations
    &gt;&gt;&gt; list(variations([1, 2], 2))
    [(1, 2), (2, 1)]

``variations(seq, n, True)`` will return the `N^n` permutations obtained
by allowing repetition of elements:

    &gt;&gt;&gt; list(variations([1, 2], 2, repetition=True))
    [(1, 1), (1, 2), (2, 1), (2, 2)]

If you ask for more items than are in the set you get the empty set unless
you allow repetitions:

    &gt;&gt;&gt; list(variations([0, 1], 3, repetition=False))
    []
    &gt;&gt;&gt; list(variations([0, 1], 3, repetition=True))[:4]
    [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1)]

.. seealso::

   `itertools.permutations
   &lt;https://docs.python.org/3/library/itertools.html#itertools.permutations&gt;`_,
   `itertools.product
   &lt;https://docs.python.org/3/library/itertools.html#itertools.product&gt;`_
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
