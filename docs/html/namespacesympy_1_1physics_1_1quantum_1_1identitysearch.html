<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.physics.quantum.identitysearch Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics.html">physics</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics_1_1quantum.html">quantum</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html">identitysearch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.physics.quantum.identitysearch Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1physics_1_1quantum_1_1identitysearch_1_1GateIdentity.html">GateIdentity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8a24b17b7493b20f51905b0ce523c00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#af8a24b17b7493b20f51905b0ce523c00">is_scalar_sparse_matrix</a> (circuit, nqubits, identity_only, eps=1e-11)</td></tr>
<tr class="separator:af8a24b17b7493b20f51905b0ce523c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5947ce1adee91dbae593f44474b080"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a9f5947ce1adee91dbae593f44474b080">is_scalar_nonsparse_matrix</a> (circuit, nqubits, identity_only, eps=None)</td></tr>
<tr class="separator:a9f5947ce1adee91dbae593f44474b080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bda2905ad0912d555dd6547a7854d3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a0bda2905ad0912d555dd6547a7854d3f">ll_op</a> (left, right)</td></tr>
<tr class="separator:a0bda2905ad0912d555dd6547a7854d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7741ab5041ce0f4e7c39dab5e04611d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a7741ab5041ce0f4e7c39dab5e04611d2">lr_op</a> (left, right)</td></tr>
<tr class="separator:a7741ab5041ce0f4e7c39dab5e04611d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb78cd02cb1582e9508ded3d02067fc7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#afb78cd02cb1582e9508ded3d02067fc7">rl_op</a> (left, right)</td></tr>
<tr class="separator:afb78cd02cb1582e9508ded3d02067fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867dff4b9eda53b14d221cd1056e772e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a867dff4b9eda53b14d221cd1056e772e">rr_op</a> (left, right)</td></tr>
<tr class="separator:a867dff4b9eda53b14d221cd1056e772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc27aa4eeda311a9ec3bdde91d72a41"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a7fc27aa4eeda311a9ec3bdde91d72a41">generate_gate_rules</a> (gate_seq, return_as_muls=False)</td></tr>
<tr class="separator:a7fc27aa4eeda311a9ec3bdde91d72a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c76db37eeb2c7934d0632f33c05da9f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a6c76db37eeb2c7934d0632f33c05da9f">generate_equivalent_ids</a> (gate_seq, return_as_muls=False)</td></tr>
<tr class="separator:a6c76db37eeb2c7934d0632f33c05da9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa569c8da09f4b31a3026db6e08295fb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#aa569c8da09f4b31a3026db6e08295fb3">is_degenerate</a> (identity_set, gate_identity)</td></tr>
<tr class="separator:aa569c8da09f4b31a3026db6e08295fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d156ad3259e7fa1f5b14751fba45ba4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a4d156ad3259e7fa1f5b14751fba45ba4">is_reducible</a> (circuit, nqubits, begin, end)</td></tr>
<tr class="separator:a4d156ad3259e7fa1f5b14751fba45ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40708b42713b0922ca6173d75d04e14a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a40708b42713b0922ca6173d75d04e14a">bfs_identity_search</a> (gate_list, nqubits, max_depth=None, identity_only=False)</td></tr>
<tr class="separator:a40708b42713b0922ca6173d75d04e14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61b6fa9495a902ffa84c3e34b97ac9b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#ac61b6fa9495a902ffa84c3e34b97ac9b">random_identity_search</a> (gate_list, numgates, nqubits)</td></tr>
<tr class="separator:ac61b6fa9495a902ffa84c3e34b97ac9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5b65ad0cfdfe4e5efcd32dbed1bd7e6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a5b65ad0cfdfe4e5efcd32dbed1bd7e6b">np</a> = import_module('numpy')</td></tr>
<tr class="separator:a5b65ad0cfdfe4e5efcd32dbed1bd7e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a744dec0fe5ec5256d62284d002236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a24a744dec0fe5ec5256d62284d002236">scipy</a> = import_module('scipy', import_kwargs={'fromlist': ['sparse']})</td></tr>
<tr class="separator:a24a744dec0fe5ec5256d62284d002236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d507141c3a1ca87d88a130be34fbc8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#a51d507141c3a1ca87d88a130be34fbc8">is_scalar_matrix</a> = <a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#af8a24b17b7493b20f51905b0ce523c00">is_scalar_sparse_matrix</a></td></tr>
<tr class="separator:a51d507141c3a1ca87d88a130be34fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a40708b42713b0922ca6173d75d04e14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40708b42713b0922ca6173d75d04e14a">&#9670;&nbsp;</a></span>bfs_identity_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.bfs_identity_search </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gate_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nqubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>identity_only</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Constructs a set of gate identities from the list of possible gates.

Performs a breadth first search over the space of gate identities.
This allows the finding of the shortest gate identities first.

Parameters
==========

gate_list : list, Gate
    A list of Gates from which to search for gate identities.
nqubits : int
    The number of qubits the quantum circuit operates on.
max_depth : int
    The longest quantum circuit to construct from gate_list.
identity_only : bool
    True to search for gate identities that reduce to identity;
    False to search for gate identities that reduce to a scalar.

Examples
========

Find a list of gate identities:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import bfs_identity_search
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; bfs_identity_search([x], 1, max_depth=2)
{GateIdentity(X(0), X(0))}

&gt;&gt;&gt; bfs_identity_search([x, y, z], 1)
{GateIdentity(X(0), X(0)), GateIdentity(Y(0), Y(0)),
 GateIdentity(Z(0), Z(0)), GateIdentity(X(0), Y(0), Z(0))}

Find a list of identities that only equal to 1:

&gt;&gt;&gt; bfs_identity_search([x, y, z], 1, identity_only=True)
{GateIdentity(X(0), X(0)), GateIdentity(Y(0), Y(0)),
 GateIdentity(Z(0), Z(0))}
</pre> 
</div>
</div>
<a id="a6c76db37eeb2c7934d0632f33c05da9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c76db37eeb2c7934d0632f33c05da9f">&#9670;&nbsp;</a></span>generate_equivalent_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.generate_equivalent_ids </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gate_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_as_muls</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a set of equivalent gate identities.

A gate identity is a quantum circuit such that the product
of the gates in the circuit is equal to a scalar value.
For example, XYZ = i, where X, Y, Z are the Pauli gates and
i is the imaginary value, is considered a gate identity.

This function uses the four operations (LL, LR, RL, RR)
to generate the gate rules and, subsequently, to locate equivalent
gate identities.

Note that all equivalent identities are reachable in n operations
from the starting gate identity, where n is the number of gates
in the sequence.

The max number of gate identities is 2n, where n is the number
of gates in the sequence (unproven).

Parameters
==========

gate_seq : Gate tuple, Mul, or Number
    A variable length tuple or Mul of Gates whose product is equal to
    a scalar matrix.
return_as_muls: bool
    True to return as Muls; False to return as tuples

Examples
========

Find equivalent gate identities from the current circuit with tuples:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import generate_equivalent_ids
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; generate_equivalent_ids((x, x))
{(X(0), X(0))}

&gt;&gt;&gt; generate_equivalent_ids((x, y, z))
{(X(0), Y(0), Z(0)), (X(0), Z(0), Y(0)), (Y(0), X(0), Z(0)),
 (Y(0), Z(0), X(0)), (Z(0), X(0), Y(0)), (Z(0), Y(0), X(0))}

Find equivalent gate identities from the current circuit with Muls:

&gt;&gt;&gt; generate_equivalent_ids(x*x, return_as_muls=True)
{1}

&gt;&gt;&gt; generate_equivalent_ids(x*y*z, return_as_muls=True)
{X(0)*Y(0)*Z(0), X(0)*Z(0)*Y(0), Y(0)*X(0)*Z(0),
 Y(0)*Z(0)*X(0), Z(0)*X(0)*Y(0), Z(0)*Y(0)*X(0)}
</pre> 
</div>
</div>
<a id="a7fc27aa4eeda311a9ec3bdde91d72a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc27aa4eeda311a9ec3bdde91d72a41">&#9670;&nbsp;</a></span>generate_gate_rules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.generate_gate_rules </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gate_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_as_muls</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a set of gate rules.  Each gate rules is represented
as a 2-tuple of tuples or Muls.  An empty tuple represents an arbitrary
scalar value.

This function uses the four operations (LL, LR, RL, RR)
to generate the gate rules.

A gate rule is an expression such as ABC = D or AB = CD, where
A, B, C, and D are gates.  Each value on either side of the
equal sign represents a circuit.  The four operations allow
one to find a set of equivalent circuits from a gate identity.
The letters denoting the operation tell the user what
activities to perform on each expression.  The first letter
indicates which side of the equal sign to focus on.  The
second letter indicates which gate to focus on given the
side.  Once this information is determined, the inverse
of the gate is multiplied on both circuits to create a new
gate rule.

For example, given the identity, ABCD = 1, a LL operation
means look at the left value and multiply both left sides by the
inverse of the leftmost gate A.  If A is Hermitian, the inverse
of A is still A.  The resulting new rule is BCD = A.

The following is a summary of the four operations.  Assume
that in the examples, all gates are Hermitian.

    LL : left circuit, left multiply
         ABCD = E -&gt; AABCD = AE -&gt; BCD = AE
    LR : left circuit, right multiply
         ABCD = E -&gt; ABCDD = ED -&gt; ABC = ED
    RL : right circuit, left multiply
         ABC = ED -&gt; EABC = EED -&gt; EABC = D
    RR : right circuit, right multiply
         AB = CD -&gt; ABD = CDD -&gt; ABD = C

The number of gate rules generated is n*(n+1), where n
is the number of gates in the sequence (unproven).

Parameters
==========

gate_seq : Gate tuple, Mul, or Number
    A variable length tuple or Mul of Gates whose product is equal to
    a scalar matrix
return_as_muls : bool
    True to return a set of Muls; False to return a set of tuples

Examples
========

Find the gate rules of the current circuit using tuples:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import generate_gate_rules
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; generate_gate_rules((x, x))
{((X(0),), (X(0),)), ((X(0), X(0)), ())}

&gt;&gt;&gt; generate_gate_rules((x, y, z))
{((), (X(0), Z(0), Y(0))), ((), (Y(0), X(0), Z(0))),
 ((), (Z(0), Y(0), X(0))), ((X(0),), (Z(0), Y(0))),
 ((Y(0),), (X(0), Z(0))), ((Z(0),), (Y(0), X(0))),
 ((X(0), Y(0)), (Z(0),)), ((Y(0), Z(0)), (X(0),)),
 ((Z(0), X(0)), (Y(0),)), ((X(0), Y(0), Z(0)), ()),
 ((Y(0), Z(0), X(0)), ()), ((Z(0), X(0), Y(0)), ())}

Find the gate rules of the current circuit using Muls:

&gt;&gt;&gt; generate_gate_rules(x*x, return_as_muls=True)
{(1, 1)}

&gt;&gt;&gt; generate_gate_rules(x*y*z, return_as_muls=True)
{(1, X(0)*Z(0)*Y(0)), (1, Y(0)*X(0)*Z(0)),
 (1, Z(0)*Y(0)*X(0)), (X(0)*Y(0), Z(0)),
 (Y(0)*Z(0), X(0)), (Z(0)*X(0), Y(0)),
 (X(0)*Y(0)*Z(0), 1), (Y(0)*Z(0)*X(0), 1),
 (Z(0)*X(0)*Y(0), 1), (X(0), Z(0)*Y(0)),
 (Y(0), X(0)*Z(0)), (Z(0), Y(0)*X(0))}
</pre> 
</div>
</div>
<a id="aa569c8da09f4b31a3026db6e08295fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa569c8da09f4b31a3026db6e08295fb3">&#9670;&nbsp;</a></span>is_degenerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.is_degenerate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>identity_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gate_identity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if a gate identity is a permutation of another identity.

Parameters
==========

identity_set : set
    A Python set with GateIdentity objects.
gate_identity : GateIdentity
    The GateIdentity to check for existence in the set.

Examples
========

Check if the identity is a permutation of another identity:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import (
...     GateIdentity, is_degenerate)
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; an_identity = GateIdentity(x, y, z)
&gt;&gt;&gt; id_set = {an_identity}
&gt;&gt;&gt; another_id = (y, z, x)
&gt;&gt;&gt; is_degenerate(id_set, another_id)
True

&gt;&gt;&gt; another_id = (x, x)
&gt;&gt;&gt; is_degenerate(id_set, another_id)
False
</pre> 
</div>
</div>
<a id="a4d156ad3259e7fa1f5b14751fba45ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d156ad3259e7fa1f5b14751fba45ba4">&#9670;&nbsp;</a></span>is_reducible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.is_reducible </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>circuit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nqubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determines if a circuit is reducible by checking
if its subcircuits are scalar values.

Parameters
==========

circuit : Gate tuple
    A tuple of Gates representing a circuit.  The circuit to check
    if a gate identity is contained in a subcircuit.
nqubits : int
    The number of qubits the circuit operates on.
begin : int
    The leftmost gate in the circuit to include in a subcircuit.
end : int
    The rightmost gate in the circuit to include in a subcircuit.

Examples
========

Check if the circuit can be reduced:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import is_reducible
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; is_reducible((x, y, z), 1, 0, 3)
True

Check if an interval in the circuit can be reduced:

&gt;&gt;&gt; is_reducible((x, y, z), 1, 1, 3)
False

&gt;&gt;&gt; is_reducible((x, y, y), 1, 1, 3)
True
</pre> 
</div>
</div>
<a id="a9f5947ce1adee91dbae593f44474b080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5947ce1adee91dbae593f44474b080">&#9670;&nbsp;</a></span>is_scalar_nonsparse_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.is_scalar_nonsparse_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>circuit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nqubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>identity_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if a given circuit, in matrix form, is equivalent to
a scalar value.

Parameters
==========

circuit : Gate tuple
    Sequence of quantum gates representing a quantum circuit
nqubits : int
    Number of qubits in the circuit
identity_only : bool
    Check for only identity matrices
eps : number
    This argument is ignored. It is just for signature compatibility with
    is_scalar_sparse_matrix.

Note: Used in situations when is_scalar_sparse_matrix has bugs
</pre> 
</div>
</div>
<a id="af8a24b17b7493b20f51905b0ce523c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a24b17b7493b20f51905b0ce523c00">&#9670;&nbsp;</a></span>is_scalar_sparse_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.is_scalar_sparse_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>circuit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nqubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>identity_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-11</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if a given scipy.sparse matrix is a scalar matrix.

A scalar matrix is such that B = bI, where B is the scalar
matrix, b is some scalar multiple, and I is the identity
matrix.  A scalar matrix would have only the element b along
it's main diagonal and zeroes elsewhere.

Parameters
==========

circuit : Gate tuple
    Sequence of quantum gates representing a quantum circuit
nqubits : int
    Number of qubits in the circuit
identity_only : bool
    Check for only identity matrices
eps : number
    The tolerance value for zeroing out elements in the matrix.
    Values in the range [-eps, +eps] will be changed to a zero.
</pre> 
</div>
</div>
<a id="a0bda2905ad0912d555dd6547a7854d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bda2905ad0912d555dd6547a7854d3f">&#9670;&nbsp;</a></span>ll_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.ll_op </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a LL operation.

A LL operation multiplies both left and right circuits
with the dagger of the left circuit's leftmost gate, and
the dagger is multiplied on the left side of both circuits.

If a LL is possible, it returns the new gate rule as a
2-tuple (LHS, RHS), where LHS is the left circuit and
and RHS is the right circuit of the new rule.
If a LL is not possible, None is returned.

Parameters
==========

left : Gate tuple
    The left circuit of a gate rule expression.
right : Gate tuple
    The right circuit of a gate rule expression.

Examples
========

Generate a new gate rule using a LL operation:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import ll_op
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; ll_op((x, y, z), ())
((Y(0), Z(0)), (X(0),))

&gt;&gt;&gt; ll_op((y, z), (x,))
((Z(0),), (Y(0), X(0)))
</pre> 
</div>
</div>
<a id="a7741ab5041ce0f4e7c39dab5e04611d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7741ab5041ce0f4e7c39dab5e04611d2">&#9670;&nbsp;</a></span>lr_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.lr_op </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a LR operation.

A LR operation multiplies both left and right circuits
with the dagger of the left circuit's rightmost gate, and
the dagger is multiplied on the right side of both circuits.

If a LR is possible, it returns the new gate rule as a
2-tuple (LHS, RHS), where LHS is the left circuit and
and RHS is the right circuit of the new rule.
If a LR is not possible, None is returned.

Parameters
==========

left : Gate tuple
    The left circuit of a gate rule expression.
right : Gate tuple
    The right circuit of a gate rule expression.

Examples
========

Generate a new gate rule using a LR operation:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import lr_op
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; lr_op((x, y, z), ())
((X(0), Y(0)), (Z(0),))

&gt;&gt;&gt; lr_op((x, y), (z,))
((X(0),), (Z(0), Y(0)))
</pre> 
</div>
</div>
<a id="ac61b6fa9495a902ffa84c3e34b97ac9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61b6fa9495a902ffa84c3e34b97ac9b">&#9670;&nbsp;</a></span>random_identity_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.random_identity_search </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gate_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numgates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nqubits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Randomly selects numgates from gate_list and checks if it is
a gate identity.

If the circuit is a gate identity, the circuit is returned;
Otherwise, None is returned.
</pre> 
</div>
</div>
<a id="afb78cd02cb1582e9508ded3d02067fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb78cd02cb1582e9508ded3d02067fc7">&#9670;&nbsp;</a></span>rl_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.rl_op </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a RL operation.

A RL operation multiplies both left and right circuits
with the dagger of the right circuit's leftmost gate, and
the dagger is multiplied on the left side of both circuits.

If a RL is possible, it returns the new gate rule as a
2-tuple (LHS, RHS), where LHS is the left circuit and
and RHS is the right circuit of the new rule.
If a RL is not possible, None is returned.

Parameters
==========

left : Gate tuple
    The left circuit of a gate rule expression.
right : Gate tuple
    The right circuit of a gate rule expression.

Examples
========

Generate a new gate rule using a RL operation:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import rl_op
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; rl_op((x,), (y, z))
((Y(0), X(0)), (Z(0),))

&gt;&gt;&gt; rl_op((x, y), (z,))
((Z(0), X(0), Y(0)), ())
</pre> 
</div>
</div>
<a id="a867dff4b9eda53b14d221cd1056e772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867dff4b9eda53b14d221cd1056e772e">&#9670;&nbsp;</a></span>rr_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.rr_op </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a RR operation.

A RR operation multiplies both left and right circuits
with the dagger of the right circuit's rightmost gate, and
the dagger is multiplied on the right side of both circuits.

If a RR is possible, it returns the new gate rule as a
2-tuple (LHS, RHS), where LHS is the left circuit and
and RHS is the right circuit of the new rule.
If a RR is not possible, None is returned.

Parameters
==========

left : Gate tuple
    The left circuit of a gate rule expression.
right : Gate tuple
    The right circuit of a gate rule expression.

Examples
========

Generate a new gate rule using a RR operation:

&gt;&gt;&gt; from sympy.physics.quantum.identitysearch import rr_op
&gt;&gt;&gt; from sympy.physics.quantum.gate import X, Y, Z
&gt;&gt;&gt; x = X(0); y = Y(0); z = Z(0)
&gt;&gt;&gt; rr_op((x, y), (z,))
((X(0), Y(0), Z(0)), ())

&gt;&gt;&gt; rr_op((x,), (y, z))
((X(0), Z(0)), (Y(0),))
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a51d507141c3a1ca87d88a130be34fbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d507141c3a1ca87d88a130be34fbc8">&#9670;&nbsp;</a></span>is_scalar_matrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.identitysearch.is_scalar_matrix = <a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1identitysearch.html#af8a24b17b7493b20f51905b0ce523c00">is_scalar_sparse_matrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b65ad0cfdfe4e5efcd32dbed1bd7e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b65ad0cfdfe4e5efcd32dbed1bd7e6b">&#9670;&nbsp;</a></span>np</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.physics.quantum.identitysearch.np = import_module('numpy')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24a744dec0fe5ec5256d62284d002236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a744dec0fe5ec5256d62284d002236">&#9670;&nbsp;</a></span>scipy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.physics.quantum.identitysearch.scipy = import_module('scipy', import_kwargs={'fromlist': ['sparse']})</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
