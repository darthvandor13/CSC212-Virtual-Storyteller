<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: pydantic_core.core_schema Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepydantic__core.html">pydantic_core</a></li><li class="navelem"><a class="el" href="namespacepydantic__core_1_1core__schema.html">core_schema</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pydantic_core.core_schema Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1SerializationInfo.html">SerializationInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1FieldSerializationInfo.html">FieldSerializationInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ValidationInfo.html">ValidationInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1SimpleSerSchema.html">SimpleSerSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1PlainSerializerFunctionSerSchema.html">PlainSerializerFunctionSerSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1WrapSerializerFunctionSerSchema.html">WrapSerializerFunctionSerSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1FormatSerSchema.html">FormatSerSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ToStringSerSchema.html">ToStringSerSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSerSchema.html">ModelSerSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1InvalidSchema.html">InvalidSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1AnySchema.html">AnySchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1NoneSchema.html">NoneSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1BoolSchema.html">BoolSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1IntSchema.html">IntSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1FloatSchema.html">FloatSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DecimalSchema.html">DecimalSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ComplexSchema.html">ComplexSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1StringSchema.html">StringSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1BytesSchema.html">BytesSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DateSchema.html">DateSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1TimeSchema.html">TimeSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DatetimeSchema.html">DatetimeSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1TimedeltaSchema.html">TimedeltaSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1LiteralSchema.html">LiteralSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1EnumSchema.html">EnumSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1IsSubclassSchema.html">IsSubclassSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1CallableSchema.html">CallableSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1UuidSchema.html">UuidSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1IncExSeqSerSchema.html">IncExSeqSerSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ListSchema.html">ListSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1SetSchema.html">SetSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1FrozenSetSchema.html">FrozenSetSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1GeneratorSchema.html">GeneratorSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1IncExDictSerSchema.html">IncExDictSerSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DictSchema.html">DictSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1NoInfoValidatorFunctionSchema.html">NoInfoValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1WithInfoValidatorFunctionSchema.html">WithInfoValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1__ValidatorFunctionSchema.html">_ValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ValidatorFunctionWrapHandler.html">ValidatorFunctionWrapHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1NoInfoWrapValidatorFunctionSchema.html">NoInfoWrapValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1WithInfoWrapValidatorFunctionSchema.html">WithInfoWrapValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1WithDefaultSchema.html">WithDefaultSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1NullableSchema.html">NullableSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1UnionSchema.html">UnionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1TaggedUnionSchema.html">TaggedUnionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ChainSchema.html">ChainSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1LaxOrStrictSchema.html">LaxOrStrictSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1JsonOrPythonSchema.html">JsonOrPythonSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictSchema.html">TypedDictSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelFieldsSchema.html">ModelFieldsSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSchema.html">ModelSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassArgsSchema.html">DataclassArgsSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassSchema.html">DataclassSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsParameter.html">ArgumentsParameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsSchema.html">ArgumentsSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsV3Parameter.html">ArgumentsV3Parameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsV3Schema.html">ArgumentsV3Schema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1CallSchema.html">CallSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1CustomErrorSchema.html">CustomErrorSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1JsonSchema.html">JsonSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1UrlSchema.html">UrlSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1MultiHostUrlSchema.html">MultiHostUrlSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DefinitionsSchema.html">DefinitionsSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic__core_1_1core__schema_1_1DefinitionReferenceSchema.html">DefinitionReferenceSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad6f5a84d4393b9ffa00970469bd3e3c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1SimpleSerSchema.html">SimpleSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad6f5a84d4393b9ffa00970469bd3e3c9">simple_ser_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a7bbd0412ec2de43437346c4bdb133153">ExpectedSerializationTypes</a> type)</td></tr>
<tr class="separator:ad6f5a84d4393b9ffa00970469bd3e3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ef6a81efd6e2097fe30d300489f369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1PlainSerializerFunctionSerSchema.html">PlainSerializerFunctionSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a66ef6a81efd6e2097fe30d300489f369">plain_serializer_function_ser_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a4c90031edbb2b8336ec6d1042e86b42c">SerializerFunction</a> function, *bool|None is_field_serializer=None, bool|None info_arg=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None return_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> when_used='always')</td></tr>
<tr class="separator:a66ef6a81efd6e2097fe30d300489f369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4570f8d1bcb1b642c8d5d20172653336"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1WrapSerializerFunctionSerSchema.html">WrapSerializerFunctionSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a4570f8d1bcb1b642c8d5d20172653336">wrap_serializer_function_ser_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#aa5d63a69ba9113025697eb0174ff9e07">WrapSerializerFunction</a> function, *bool|None is_field_serializer=None, bool|None info_arg=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None return_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> when_used='always')</td></tr>
<tr class="separator:a4570f8d1bcb1b642c8d5d20172653336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2339fda59373d28d41a4ff02be93673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1FormatSerSchema.html">FormatSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa2339fda59373d28d41a4ff02be93673">format_ser_schema</a> (str formatting_string, *<a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> when_used='json-unless-none')</td></tr>
<tr class="separator:aa2339fda59373d28d41a4ff02be93673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eee0dbbb33be4cc3a3e8d42a277402c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ToStringSerSchema.html">ToStringSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a2eee0dbbb33be4cc3a3e8d42a277402c">to_string_ser_schema</a> (*<a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> when_used='json-unless-none')</td></tr>
<tr class="separator:a2eee0dbbb33be4cc3a3e8d42a277402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b53bb7ac0ca68effc114a4f6af43fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSerSchema.html">ModelSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a3b53bb7ac0ca68effc114a4f6af43fd2">model_ser_schema</a> (type[Any] cls, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema)</td></tr>
<tr class="separator:a3b53bb7ac0ca68effc114a4f6af43fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8416637b9eb59ae785443a334d417e12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1InvalidSchema.html">InvalidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a8416637b9eb59ae785443a334d417e12">invalid_schema</a> (str|None ref=None, dict[str, Any]|None metadata=None)</td></tr>
<tr class="separator:a8416637b9eb59ae785443a334d417e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cc9115acd494973f5a62dea8efb1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a92cc9115acd494973f5a62dea8efb1a7">computed_field</a> (str property_name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> return_schema, *str|None alias=None, dict[str, Any]|None metadata=None)</td></tr>
<tr class="separator:a92cc9115acd494973f5a62dea8efb1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a3a9c5c91fd0477b3a8d75efd043db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1AnySchema.html">AnySchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a59a3a9c5c91fd0477b3a8d75efd043db">any_schema</a> (*str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a59a3a9c5c91fd0477b3a8d75efd043db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88db516ebdd23fa167e90527b61b9d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1NoneSchema.html">NoneSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a88db516ebdd23fa167e90527b61b9d0d">none_schema</a> (*str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a88db516ebdd23fa167e90527b61b9d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac072b3c53e61dbeec5198167e7d704f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1BoolSchema.html">BoolSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac072b3c53e61dbeec5198167e7d704f8">bool_schema</a> (bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ac072b3c53e61dbeec5198167e7d704f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4454e138f559f6872a187c769e1fd34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IntSchema.html">IntSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad4454e138f559f6872a187c769e1fd34">int_schema</a> (*int|None multiple_of=None, int|None le=None, int|None ge=None, int|None lt=None, int|None gt=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ad4454e138f559f6872a187c769e1fd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7386d71199f37d7a49166d4e898f3c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1FloatSchema.html">FloatSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7386d71199f37d7a49166d4e898f3c41">float_schema</a> (*bool|None allow_inf_nan=None, float|None multiple_of=None, float|None le=None, float|None ge=None, float|None lt=None, float|None gt=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a7386d71199f37d7a49166d4e898f3c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a936aeeaefffb03c1f9ea736d28266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DecimalSchema.html">DecimalSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a81a936aeeaefffb03c1f9ea736d28266">decimal_schema</a> (*bool|None allow_inf_nan=None, Decimal|None multiple_of=None, Decimal|None le=None, Decimal|None ge=None, Decimal|None lt=None, Decimal|None gt=None, int|None max_digits=None, int|None decimal_places=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a81a936aeeaefffb03c1f9ea736d28266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9380a36e86dab14595de17d2612cc719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ComplexSchema.html">ComplexSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a9380a36e86dab14595de17d2612cc719">complex_schema</a> (*bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a9380a36e86dab14595de17d2612cc719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888475805a304dfac734056eca6411ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1StringSchema.html">StringSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a888475805a304dfac734056eca6411ad">str_schema</a> (*str|Pattern[str]|None pattern=None, int|None max_length=None, int|None min_length=None, bool|None strip_whitespace=None, bool|None to_lower=None, bool|None to_upper=None, Literal['rust-regex', 'python-re']|None regex_engine=None, bool|None strict=None, bool|None coerce_numbers_to_str=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a888475805a304dfac734056eca6411ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6d85f529c96d61206aba7d51ed91d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1BytesSchema.html">BytesSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac0d6d85f529c96d61206aba7d51ed91d">bytes_schema</a> (*int|None max_length=None, int|None min_length=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ac0d6d85f529c96d61206aba7d51ed91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36080b42f58d0eb6b2e6814a6227c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DateSchema.html">DateSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac36080b42f58d0eb6b2e6814a6227c10">date_schema</a> (*bool|None strict=None, date|None le=None, date|None ge=None, date|None lt=None, date|None gt=None, Literal['past', 'future']|None now_op=None, int|None now_utc_offset=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ac36080b42f58d0eb6b2e6814a6227c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a5787eb52080007c2db1cc112f1dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TimeSchema.html">TimeSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a96a5787eb52080007c2db1cc112f1dd5">time_schema</a> (*bool|None strict=None, time|None le=None, time|None ge=None, time|None lt=None, time|None gt=None, Literal['aware', 'naive']|int|None tz_constraint=None, Literal['truncate', 'error'] microseconds_precision='truncate', str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a96a5787eb52080007c2db1cc112f1dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f86d72fa625d1d98a2fffe754aae8e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DatetimeSchema.html">DatetimeSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a3f86d72fa625d1d98a2fffe754aae8e4">datetime_schema</a> (*bool|None strict=None, datetime|None le=None, datetime|None ge=None, datetime|None lt=None, datetime|None gt=None, Literal['past', 'future']|None now_op=None, Literal['aware', 'naive']|int|None tz_constraint=None, int|None now_utc_offset=None, Literal['truncate', 'error'] microseconds_precision='truncate', str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a3f86d72fa625d1d98a2fffe754aae8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853b12867746b3e6ae77b7aad65ca796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TimedeltaSchema.html">TimedeltaSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a853b12867746b3e6ae77b7aad65ca796">timedelta_schema</a> (*bool|None strict=None, timedelta|None le=None, timedelta|None ge=None, timedelta|None lt=None, timedelta|None gt=None, Literal['truncate', 'error'] microseconds_precision='truncate', str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a853b12867746b3e6ae77b7aad65ca796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba274aa235f06a7eecf71645d4c0cda8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1LiteralSchema.html">LiteralSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aba274aa235f06a7eecf71645d4c0cda8">literal_schema</a> (list[Any] expected, *str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aba274aa235f06a7eecf71645d4c0cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1cc38c445fcbcb3ddf606667910d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1EnumSchema.html">EnumSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a8c1cc38c445fcbcb3ddf606667910d5a">enum_schema</a> (Any cls, list[Any] members, *Literal['str', 'int', 'float']|None sub_type=None, Callable[[Any], Any]|None missing=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a8c1cc38c445fcbcb3ddf606667910d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84ae727cf8645d15877303d784d15e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac84ae727cf8645d15877303d784d15e5">is_instance_schema</a> (Any cls, *str|None cls_repr=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ac84ae727cf8645d15877303d784d15e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b511f95de643f2f78af64e4151d6cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a84b511f95de643f2f78af64e4151d6cd">is_subclass_schema</a> (type[Any] cls, *str|None cls_repr=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a84b511f95de643f2f78af64e4151d6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab418c5711fe458d72035f3e63dcc3f1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1CallableSchema.html">CallableSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ab418c5711fe458d72035f3e63dcc3f1b">callable_schema</a> (*str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ab418c5711fe458d72035f3e63dcc3f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82443218460f42f40e5c08cb4dfde2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1UuidSchema.html">UuidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad82443218460f42f40e5c08cb4dfde2f">uuid_schema</a> (*Literal[1, 3, 4, 5, 6, 7, 8]|None version=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ad82443218460f42f40e5c08cb4dfde2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90db849e0414bcb5a13fcdd0ef8b4d14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IncExSeqSerSchema.html">IncExSeqSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a90db849e0414bcb5a13fcdd0ef8b4d14">filter_seq_schema</a> (*set[int]|None include=None, set[int]|None exclude=None)</td></tr>
<tr class="separator:a90db849e0414bcb5a13fcdd0ef8b4d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6819aa9feda8604dfd8c9380951a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ListSchema.html">ListSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a2b6819aa9feda8604dfd8c9380951a5c">list_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, bool|None fail_fast=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a2b6819aa9feda8604dfd8c9380951a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0abe3574aee54b09f75f13b37b06ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac0abe3574aee54b09f75f13b37b06ec1">tuple_positional_schema</a> (list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] items_schema, *<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None extras_schema=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ac0abe3574aee54b09f75f13b37b06ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354ed21d683bea05209bb5c219bebb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a354ed21d683bea05209bb5c219bebb47">tuple_variable_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a354ed21d683bea05209bb5c219bebb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9780b7ca45f93c1a6ca74dd6d2c4ba35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a9780b7ca45f93c1a6ca74dd6d2c4ba35">tuple_schema</a> (list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] items_schema, *int|None variadic_item_index=None, int|None min_length=None, int|None max_length=None, bool|None fail_fast=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a9780b7ca45f93c1a6ca74dd6d2c4ba35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b02adb9519360d651fd12d7b98a8fbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1SetSchema.html">SetSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5b02adb9519360d651fd12d7b98a8fbd">set_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, bool|None fail_fast=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a5b02adb9519360d651fd12d7b98a8fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e272b517025289d218bd8df9924ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1FrozenSetSchema.html">FrozenSetSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a51e272b517025289d218bd8df9924ed0">frozenset_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, bool|None fail_fast=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a51e272b517025289d218bd8df9924ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6cb5628cb3ade1875328b7245c30f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1GeneratorSchema.html">GeneratorSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7f6cb5628cb3ade1875328b7245c30f7">generator_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a7f6cb5628cb3ade1875328b7245c30f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4902289647cd4633e4dba0409d8ac5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IncExDictSerSchema.html">IncExDictSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa4902289647cd4633e4dba0409d8ac5e">filter_dict_schema</a> (*<a class="el" href="namespacepydantic__core_1_1core__schema.html#ab8c04c509c5a0e68fcb1a1c77dd8316a">IncExDict</a>|None include=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ab8c04c509c5a0e68fcb1a1c77dd8316a">IncExDict</a>|None exclude=None)</td></tr>
<tr class="separator:aa4902289647cd4633e4dba0409d8ac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfc908080615f9438264e5fd96e9ba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DictSchema.html">DictSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7bfc908080615f9438264e5fd96e9ba7">dict_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None keys_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None values_schema=None, *int|None min_length=None, int|None max_length=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a7bfc908080615f9438264e5fd96e9ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376fa8622f7e8bf91cd2cf8c6c901086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a376fa8622f7e8bf91cd2cf8c6c901086">no_info_before_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a376fa8622f7e8bf91cd2cf8c6c901086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b2462e55aae88a3e16e1df70cf5845"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a18b2462e55aae88a3e16e1df70cf5845">with_info_before_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None field_name=None, str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a18b2462e55aae88a3e16e1df70cf5845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56732ab59cd05d428223fb37ab1b8290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a56732ab59cd05d428223fb37ab1b8290">no_info_after_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a56732ab59cd05d428223fb37ab1b8290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a93679d6d74b1e84ef83092df1cc7bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a0a93679d6d74b1e84ef83092df1cc7bf">with_info_after_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None field_name=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a0a93679d6d74b1e84ef83092df1cc7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fece8fb833d6bedeabf86f37dfbbc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a3fece8fb833d6bedeabf86f37dfbbc54">no_info_wrap_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#af2ffc255b7e6d49b678053bc1902e616">NoInfoWrapValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a3fece8fb833d6bedeabf86f37dfbbc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e6c95005054619a489448f9a07f993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a27e6c95005054619a489448f9a07f993">with_info_wrap_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a896d0dc92976c139adba63e86261bc26">WithInfoWrapValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None field_name=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a27e6c95005054619a489448f9a07f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a14facde9df75b4e2603fe6062041e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a12a14facde9df75b4e2603fe6062041e">no_info_plain_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a> function, *str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a12a14facde9df75b4e2603fe6062041e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b22697c4023da20d715c0a9da0be9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a2b22697c4023da20d715c0a9da0be9ca">with_info_plain_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, *str|None field_name=None, str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a2b22697c4023da20d715c0a9da0be9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987b07fe12e0c7d4fe7c516b812c8c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1WithDefaultSchema.html">WithDefaultSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a987b07fe12e0c7d4fe7c516b812c8c0f">with_default_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *Any default=<a class="el" href="namespacepydantic__core_1_1core__schema.html#ad44474082711c0f342caf31af269622c">PydanticUndefined</a>, Union[Callable[[], Any], Callable[[dict[str, Any]], Any], None] default_factory=None, bool|None default_factory_takes_data=None, Literal['raise', 'omit', 'default']|None on_error=None, bool|None validate_default=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a987b07fe12e0c7d4fe7c516b812c8c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb93d5142bc5d7c6e3efaaa80652b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1NullableSchema.html">NullableSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a4fb93d5142bc5d7c6e3efaaa80652b1e">nullable_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a4fb93d5142bc5d7c6e3efaaa80652b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd50b324c05731092394286e95fe3804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1UnionSchema.html">UnionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acd50b324c05731092394286e95fe3804">union_schema</a> (list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|tuple[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>, str]] choices, *bool|None auto_collapse=None, str|None custom_error_type=None, str|None custom_error_message=None, dict[str, str|int]|None custom_error_context=None, Literal['smart', 'left_to_right']|None mode=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:acd50b324c05731092394286e95fe3804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c201d39d7d3c11a6617940f3e08288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TaggedUnionSchema.html">TaggedUnionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad2c201d39d7d3c11a6617940f3e08288">tagged_union_schema</a> (dict[Any, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] choices, str|list[str|int]|list[list[str|int]]|Callable[[Any], Any] discriminator, *str|None custom_error_type=None, str|None custom_error_message=None, dict[str, int|str|float]|None custom_error_context=None, bool|None strict=None, bool|None from_attributes=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ad2c201d39d7d3c11a6617940f3e08288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fe55dae0ff35e710dca8dafe9d6567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ChainSchema.html">ChainSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a11fe55dae0ff35e710dca8dafe9d6567">chain_schema</a> (list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] steps, *str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a11fe55dae0ff35e710dca8dafe9d6567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137da1f068bb7c6be1a0ad3a062475a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1LaxOrStrictSchema.html">LaxOrStrictSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a137da1f068bb7c6be1a0ad3a062475a7">lax_or_strict_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> lax_schema, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> strict_schema, *bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a137da1f068bb7c6be1a0ad3a062475a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af2bd31a34f7ca0c1066370cd8a7777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1JsonOrPythonSchema.html">JsonOrPythonSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a8af2bd31a34f7ca0c1066370cd8a7777">json_or_python_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> <a class="el" href="namespacepydantic__core_1_1core__schema.html#a6bf5d7251f63486d572348a75e8e146a">json_schema</a>, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> python_schema, *str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a8af2bd31a34f7ca0c1066370cd8a7777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ce80bcb156baffa04526a93d074ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad0ce80bcb156baffa04526a93d074ba0">typed_dict_field</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *bool|None required=None, str|list[str|int]|list[list[str|int]]|None validation_alias=None, str|None serialization_alias=None, bool|None serialization_exclude=None, dict[str, Any]|None metadata=None)</td></tr>
<tr class="separator:ad0ce80bcb156baffa04526a93d074ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270de99444e6019eece60c5f2e87ca8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictSchema.html">TypedDictSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a270de99444e6019eece60c5f2e87ca8d">typed_dict_schema</a> (dict[str, <a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a>] fields, *type[Any]|None cls=None, str|None cls_name=None, list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>]|None computed_fields=None, bool|None strict=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None extras_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a>|None extra_behavior=None, bool|None total=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None, <a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a>|None config=None)</td></tr>
<tr class="separator:a270de99444e6019eece60c5f2e87ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7527b16e2a22840adb97a43b2f9b22d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7527b16e2a22840adb97a43b2f9b22d0">model_field</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|list[str|int]|list[list[str|int]]|None validation_alias=None, str|None serialization_alias=None, bool|None serialization_exclude=None, bool|None frozen=None, dict[str, Any]|None metadata=None)</td></tr>
<tr class="separator:a7527b16e2a22840adb97a43b2f9b22d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd759f4787a71146c2bdb3782ddc8fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelFieldsSchema.html">ModelFieldsSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#abd759f4787a71146c2bdb3782ddc8fc9">model_fields_schema</a> (dict[str, <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a>] fields, *str|None model_name=None, list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>]|None computed_fields=None, bool|None strict=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None extras_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None extras_keys_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a>|None extra_behavior=None, bool|None from_attributes=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:abd759f4787a71146c2bdb3782ddc8fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434383d3f2c5c21a2b040ae6b109e4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSchema.html">ModelSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a434383d3f2c5c21a2b040ae6b109e4d7">model_schema</a> (type[Any] cls, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *type[Any]|None generic_origin=None, bool|None custom_init=None, bool|None root_model=None, str|None post_init=None, Literal['always', 'never', 'subclass-instances']|None revalidate_instances=None, bool|None strict=None, bool|None frozen=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a>|None extra_behavior=None, <a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a>|None config=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a434383d3f2c5c21a2b040ae6b109e4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a21ed9daed3d4ada8561132aa2ec2bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5a21ed9daed3d4ada8561132aa2ec2bb">dataclass_field</a> (str name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *bool|None kw_only=None, bool|None init=None, bool|None init_only=None, str|list[str|int]|list[list[str|int]]|None validation_alias=None, str|None serialization_alias=None, bool|None serialization_exclude=None, dict[str, Any]|None metadata=None, bool|None frozen=None)</td></tr>
<tr class="separator:a5a21ed9daed3d4ada8561132aa2ec2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c86460cc316d1ff4631ce5213e89f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassArgsSchema.html">DataclassArgsSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a9c86460cc316d1ff4631ce5213e89f3e">dataclass_args_schema</a> (str dataclass_name, list[<a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a>] fields, *list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>]|None computed_fields=None, bool|None collect_init_only=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a>|None extra_behavior=None)</td></tr>
<tr class="separator:a9c86460cc316d1ff4631ce5213e89f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49eac2306e9cc2bdabb09348e93a53a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassSchema.html">DataclassSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a49eac2306e9cc2bdabb09348e93a53a6">dataclass_schema</a> (type[Any] cls, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, list[str] fields, *type[Any]|None generic_origin=None, str|None cls_name=None, bool|None post_init=None, Literal['always', 'never', 'subclass-instances']|None revalidate_instances=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None, bool|None frozen=None, bool|None slots=None, <a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a>|None config=None)</td></tr>
<tr class="separator:a49eac2306e9cc2bdabb09348e93a53a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc19843082106b0d83142c9066b6ee70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsParameter.html">ArgumentsParameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acc19843082106b0d83142c9066b6ee70">arguments_parameter</a> (str name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *Literal['positional_only', 'positional_or_keyword', 'keyword_only']|None mode=None, str|list[str|int]|list[list[str|int]]|None alias=None)</td></tr>
<tr class="separator:acc19843082106b0d83142c9066b6ee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c6d763634530bdcc71e2b1e723eb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsSchema.html">ArgumentsSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa6c6d763634530bdcc71e2b1e723eb49">arguments_schema</a> (list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsParameter.html">ArgumentsParameter</a>] arguments, *bool|None validate_by_name=None, bool|None validate_by_alias=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None var_args_schema=None, VarKwargsMode|None var_kwargs_mode=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None var_kwargs_schema=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aa6c6d763634530bdcc71e2b1e723eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5bcd66ea06699fdfc2d6a0c12a0be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsV3Parameter.html">ArgumentsV3Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a9d5bcd66ea06699fdfc2d6a0c12a0be7">arguments_v3_parameter</a> (str name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *Literal['positional_only', 'positional_or_keyword', 'keyword_only', 'var_args', 'var_kwargs_uniform', 'var_kwargs_unpacked_typed_dict',]|None mode=None, str|list[str|int]|list[list[str|int]]|None alias=None)</td></tr>
<tr class="separator:a9d5bcd66ea06699fdfc2d6a0c12a0be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae353406b85bd410d2caae110df368a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsV3Schema.html">ArgumentsV3Schema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7ae353406b85bd410d2caae110df368a">arguments_v3_schema</a> (list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsV3Parameter.html">ArgumentsV3Parameter</a>] arguments, *bool|None validate_by_name=None, bool|None validate_by_alias=None, Literal['forbid', 'ignore']|None extra_behavior=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a7ae353406b85bd410d2caae110df368a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ab379c9fefb599c20c202ad9e246d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1CallSchema.html">CallSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a89ab379c9fefb599c20c202ad9e246d3">call_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> arguments, Callable[..., Any] function, *str|None function_name=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None return_schema=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a89ab379c9fefb599c20c202ad9e246d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ac917f906188624f2c65c34c5b3604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1CustomErrorSchema.html">CustomErrorSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a67ac917f906188624f2c65c34c5b3604">custom_error_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, str custom_error_type, *str|None custom_error_message=None, dict[str, Any]|None custom_error_context=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a67ac917f906188624f2c65c34c5b3604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf5d7251f63486d572348a75e8e146a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1JsonSchema.html">JsonSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a6bf5d7251f63486d572348a75e8e146a">json_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None schema=None, *str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a6bf5d7251f63486d572348a75e8e146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f78676d7c92243e87be70b63624adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1UrlSchema.html">UrlSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a88f78676d7c92243e87be70b63624adf">url_schema</a> (*int|None max_length=None, list[str]|None allowed_schemes=None, bool|None host_required=None, str|None default_host=None, int|None default_port=None, str|None default_path=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a88f78676d7c92243e87be70b63624adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47009a20cb7f680b6bf21c0173532c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1MultiHostUrlSchema.html">MultiHostUrlSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a47009a20cb7f680b6bf21c0173532c2d">multi_host_url_schema</a> (*int|None max_length=None, list[str]|None allowed_schemes=None, bool|None host_required=None, str|None default_host=None, int|None default_port=None, str|None default_path=None, bool|None strict=None, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a47009a20cb7f680b6bf21c0173532c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8f671d2e656bbb5bc304b97f061a12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DefinitionsSchema.html">DefinitionsSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a0e8f671d2e656bbb5bc304b97f061a12">definitions_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] definitions)</td></tr>
<tr class="separator:a0e8f671d2e656bbb5bc304b97f061a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff9eb2201471a44fa2f601c47c6227d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DefinitionReferenceSchema.html">DefinitionReferenceSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a3ff9eb2201471a44fa2f601c47c6227d">definition_reference_schema</a> (str schema_ref, str|None ref=None, dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a3ff9eb2201471a44fa2f601c47c6227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4617d96cd1e6eae6b0ae332a77d52693"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a4617d96cd1e6eae6b0ae332a77d52693">field_before_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, str field_name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, **kwargs)</td></tr>
<tr class="memdesc:a4617d96cd1e6eae6b0ae332a77d52693"><td class="mdescLeft">&#160;</td><td class="mdescRight">All this stuff is deprecated by #980 and will be removed eventually They're kept because some code external code will be using them.  <a href="namespacepydantic__core_1_1core__schema.html#a4617d96cd1e6eae6b0ae332a77d52693">More...</a><br /></td></tr>
<tr class="separator:a4617d96cd1e6eae6b0ae332a77d52693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178f04c08fae4b188e59ac678a908152"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a178f04c08fae4b188e59ac678a908152">general_before_validator_function</a> (*args, **kwargs)</td></tr>
<tr class="separator:a178f04c08fae4b188e59ac678a908152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed9d91870f12b69eb7b86ceaf5812f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#abed9d91870f12b69eb7b86ceaf5812f9">field_after_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, str field_name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, **kwargs)</td></tr>
<tr class="separator:abed9d91870f12b69eb7b86ceaf5812f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01943e70fdc8634379adf7ca865e17e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a01943e70fdc8634379adf7ca865e17e5">general_after_validator_function</a> (*args, **kwargs)</td></tr>
<tr class="separator:a01943e70fdc8634379adf7ca865e17e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820970dc8ec850b8cb4f700e0ad6e3c6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a820970dc8ec850b8cb4f700e0ad6e3c6">field_wrap_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a896d0dc92976c139adba63e86261bc26">WithInfoWrapValidatorFunction</a> function, str field_name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, **kwargs)</td></tr>
<tr class="separator:a820970dc8ec850b8cb4f700e0ad6e3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d7fc7f2f2871c69f44832649d961de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac1d7fc7f2f2871c69f44832649d961de">general_wrap_validator_function</a> (*args, **kwargs)</td></tr>
<tr class="separator:ac1d7fc7f2f2871c69f44832649d961de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6aeb316c19e31c3c095af042c1a85"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acea6aeb316c19e31c3c095af042c1a85">field_plain_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, str field_name, **kwargs)</td></tr>
<tr class="separator:acea6aeb316c19e31c3c095af042c1a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1f429306e49f579f74c3b63cdc412b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#afd1f429306e49f579f74c3b63cdc412b">general_plain_validator_function</a> (*args, **kwargs)</td></tr>
<tr class="separator:afd1f429306e49f579f74c3b63cdc412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434634031e268fdcfca19da70ef4f3e6"><td class="memItemLeft" align="right" valign="top">object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a434634031e268fdcfca19da70ef4f3e6">__getattr__</a> (str attr_name)</td></tr>
<tr class="separator:a434634031e268fdcfca19da70ef4f3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9efd5cba27602bb32e5e0c9b45c9cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSerSchema.html">ModelSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a0a9efd5cba27602bb32e5e0c9b45c9cc">model_ser_schema</a> (Type[Any] cls, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema)</td></tr>
<tr class="separator:a0a9efd5cba27602bb32e5e0c9b45c9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75af32cf0ba2c5122fbd9ab15e3bda0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1InvalidSchema.html">InvalidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac75af32cf0ba2c5122fbd9ab15e3bda0">invalid_schema</a> (str|None ref=None, Dict[str, Any]|None metadata=None)</td></tr>
<tr class="separator:ac75af32cf0ba2c5122fbd9ab15e3bda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2270d92eba0cc8c4b0fd16f5724269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aec2270d92eba0cc8c4b0fd16f5724269">computed_field</a> (str property_name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> return_schema, *str|None alias=None, Dict[str, Any]|None metadata=None)</td></tr>
<tr class="separator:aec2270d92eba0cc8c4b0fd16f5724269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5500ba534041fd8058fc3e0867b33dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1AnySchema.html">AnySchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5500ba534041fd8058fc3e0867b33dfb">any_schema</a> (*str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a5500ba534041fd8058fc3e0867b33dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dc71f1c71b76dc43b151dc7d83cf5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1NoneSchema.html">NoneSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a47dc71f1c71b76dc43b151dc7d83cf5f">none_schema</a> (*str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a47dc71f1c71b76dc43b151dc7d83cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0c76532272c961d3b90a018522a956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1BoolSchema.html">BoolSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aed0c76532272c961d3b90a018522a956">bool_schema</a> (bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aed0c76532272c961d3b90a018522a956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42116e74818086adb240e3bb5a0c5fe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IntSchema.html">IntSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a42116e74818086adb240e3bb5a0c5fe2">int_schema</a> (*int|None multiple_of=None, int|None le=None, int|None ge=None, int|None lt=None, int|None gt=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a42116e74818086adb240e3bb5a0c5fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0ce5d18b93fd901c720d05b007b6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1FloatSchema.html">FloatSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a9f0ce5d18b93fd901c720d05b007b6ed">float_schema</a> (*bool|None allow_inf_nan=None, float|None multiple_of=None, float|None le=None, float|None ge=None, float|None lt=None, float|None gt=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a9f0ce5d18b93fd901c720d05b007b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d52dc118aa0844cd893a8b060349596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DecimalSchema.html">DecimalSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a4d52dc118aa0844cd893a8b060349596">decimal_schema</a> (*bool|None allow_inf_nan=None, Decimal|None multiple_of=None, Decimal|None le=None, Decimal|None ge=None, Decimal|None lt=None, Decimal|None gt=None, int|None max_digits=None, int|None decimal_places=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a4d52dc118aa0844cd893a8b060349596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e08b5d406ed39c225aee1a042d4454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ComplexSchema.html">ComplexSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a45e08b5d406ed39c225aee1a042d4454">complex_schema</a> (*bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a45e08b5d406ed39c225aee1a042d4454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16e74f15602e0f29e9b28383079c484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1StringSchema.html">StringSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad16e74f15602e0f29e9b28383079c484">str_schema</a> (*str|Pattern[str]|None pattern=None, int|None max_length=None, int|None min_length=None, bool|None strip_whitespace=None, bool|None to_lower=None, bool|None to_upper=None, Literal['rust-regex', 'python-re']|None regex_engine=None, bool|None strict=None, bool|None coerce_numbers_to_str=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ad16e74f15602e0f29e9b28383079c484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594d9af56388d358e992299001059aa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1BytesSchema.html">BytesSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a594d9af56388d358e992299001059aa3">bytes_schema</a> (*int|None max_length=None, int|None min_length=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a594d9af56388d358e992299001059aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fa48de307756ea2cfafb47254a672f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DateSchema.html">DateSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a74fa48de307756ea2cfafb47254a672f">date_schema</a> (*bool|None strict=None, date|None le=None, date|None ge=None, date|None lt=None, date|None gt=None, Literal['past', 'future']|None now_op=None, int|None now_utc_offset=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a74fa48de307756ea2cfafb47254a672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b38dda47430da1e509b435f24f360d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TimeSchema.html">TimeSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa7b38dda47430da1e509b435f24f360d">time_schema</a> (*bool|None strict=None, time|None le=None, time|None ge=None, time|None lt=None, time|None gt=None, Literal['aware', 'naive']|int|None tz_constraint=None, Literal['truncate', 'error'] microseconds_precision='truncate', str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aa7b38dda47430da1e509b435f24f360d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25aa3cb99291d21255b9f7d7e213dd56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DatetimeSchema.html">DatetimeSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a25aa3cb99291d21255b9f7d7e213dd56">datetime_schema</a> (*bool|None strict=None, datetime|None le=None, datetime|None ge=None, datetime|None lt=None, datetime|None gt=None, Literal['past', 'future']|None now_op=None, Literal['aware', 'naive']|int|None tz_constraint=None, int|None now_utc_offset=None, Literal['truncate', 'error'] microseconds_precision='truncate', str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a25aa3cb99291d21255b9f7d7e213dd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fb18971cf33bb336dd3981f6f733d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TimedeltaSchema.html">TimedeltaSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a41fb18971cf33bb336dd3981f6f733d0">timedelta_schema</a> (*bool|None strict=None, timedelta|None le=None, timedelta|None ge=None, timedelta|None lt=None, timedelta|None gt=None, Literal['truncate', 'error'] microseconds_precision='truncate', str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a41fb18971cf33bb336dd3981f6f733d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a22cb43514ae3602be1667b2611bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1LiteralSchema.html">LiteralSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ab8a22cb43514ae3602be1667b2611bb2">literal_schema</a> (list[Any] expected, *str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ab8a22cb43514ae3602be1667b2611bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4d3112245c38c5070fb92200feac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1EnumSchema.html">EnumSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a4cd4d3112245c38c5070fb92200feac9">enum_schema</a> (Any cls, list[Any] members, *Literal['str', 'int', 'float']|None sub_type=None, Callable[[Any], Any]|None missing=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a4cd4d3112245c38c5070fb92200feac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b71e80667b51efdcfebeef441a8fe61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a4b71e80667b51efdcfebeef441a8fe61">is_instance_schema</a> (Any cls, *str|None cls_repr=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a4b71e80667b51efdcfebeef441a8fe61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b9337989af25481473a6b12ed0f652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a96b9337989af25481473a6b12ed0f652">is_subclass_schema</a> (Type[Any] cls, *str|None cls_repr=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a96b9337989af25481473a6b12ed0f652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0177c367c0b754d576444307bf73415b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1CallableSchema.html">CallableSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a0177c367c0b754d576444307bf73415b">callable_schema</a> (*str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a0177c367c0b754d576444307bf73415b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71083abc4fa401ba3747f4156b241380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1UuidSchema.html">UuidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a71083abc4fa401ba3747f4156b241380">uuid_schema</a> (*Literal[1, 3, 4, 5]|None version=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a71083abc4fa401ba3747f4156b241380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3128bec308ccbf7e34fb1f3d6ecae9c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1IncExSeqSerSchema.html">IncExSeqSerSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a3128bec308ccbf7e34fb1f3d6ecae9c1">filter_seq_schema</a> (*Set[int]|None include=None, Set[int]|None exclude=None)</td></tr>
<tr class="separator:a3128bec308ccbf7e34fb1f3d6ecae9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681a5370127e15c726b1aba24879b01c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ListSchema.html">ListSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a681a5370127e15c726b1aba24879b01c">list_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, bool|None fail_fast=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a681a5370127e15c726b1aba24879b01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ac5d86fdd9ae24fc060a617a0f6976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae5ac5d86fdd9ae24fc060a617a0f6976">tuple_positional_schema</a> (list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] items_schema, *<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None extras_schema=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ae5ac5d86fdd9ae24fc060a617a0f6976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2f75fc2889709798b30272098950c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a1b2f75fc2889709798b30272098950c9">tuple_variable_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a1b2f75fc2889709798b30272098950c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa777e0334df823ca9cfbc6a8a0f86de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa777e0334df823ca9cfbc6a8a0f86de4">tuple_schema</a> (list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] items_schema, *int|None variadic_item_index=None, int|None min_length=None, int|None max_length=None, bool|None fail_fast=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aa777e0334df823ca9cfbc6a8a0f86de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e9fed1ab6f9c11b56fb12d92dd4c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1SetSchema.html">SetSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a52e9fed1ab6f9c11b56fb12d92dd4c17">set_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, bool|None fail_fast=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a52e9fed1ab6f9c11b56fb12d92dd4c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb4719ed9e643f1b92f984914a2a5e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1FrozenSetSchema.html">FrozenSetSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#afbb4719ed9e643f1b92f984914a2a5e9">frozenset_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, bool|None fail_fast=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:afbb4719ed9e643f1b92f984914a2a5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd4c1858dd8e269026bfb2c06ae8c6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1GeneratorSchema.html">GeneratorSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aefd4c1858dd8e269026bfb2c06ae8c6d">generator_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None items_schema=None, *int|None min_length=None, int|None max_length=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aefd4c1858dd8e269026bfb2c06ae8c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbed9d53108be54f37feca2d92ba51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DictSchema.html">DictSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a2dbed9d53108be54f37feca2d92ba51d">dict_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None keys_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None values_schema=None, *int|None min_length=None, int|None max_length=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a2dbed9d53108be54f37feca2d92ba51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a377522ba287eac799ca9b47ecfd8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad6a377522ba287eac799ca9b47ecfd8c">no_info_before_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:ad6a377522ba287eac799ca9b47ecfd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eb24638c7e27af98ded2579ae86e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a48eb24638c7e27af98ded2579ae86e3d">with_info_before_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None field_name=None, str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a48eb24638c7e27af98ded2579ae86e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af182f4eca481fb4ecb1393b92b43e064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af182f4eca481fb4ecb1393b92b43e064">no_info_after_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:af182f4eca481fb4ecb1393b92b43e064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae441f2760861bf644bb2e1d2cd75e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a2ae441f2760861bf644bb2e1d2cd75e3">with_info_after_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None field_name=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a2ae441f2760861bf644bb2e1d2cd75e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d43296b6a5dac9a35a7160e12e198d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a27d43296b6a5dac9a35a7160e12e198d">no_info_wrap_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#af2ffc255b7e6d49b678053bc1902e616">NoInfoWrapValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a27d43296b6a5dac9a35a7160e12e198d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320cb0c8007c41932ea5aec48bf90dfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a320cb0c8007c41932ea5aec48bf90dfd">with_info_wrap_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a896d0dc92976c139adba63e86261bc26">WithInfoWrapValidatorFunction</a> function, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|None field_name=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a320cb0c8007c41932ea5aec48bf90dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305bf5025b8f806903919d645f89a647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a305bf5025b8f806903919d645f89a647">no_info_plain_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a> function, *str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a305bf5025b8f806903919d645f89a647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca39a6a955d06c278ce4dff2ae4284a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a2ca39a6a955d06c278ce4dff2ae4284a">with_info_plain_validator_function</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> function, *str|None field_name=None, str|None ref=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None json_schema_input_schema=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a2ca39a6a955d06c278ce4dff2ae4284a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463412f1242c6a21d859660105e3e710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1WithDefaultSchema.html">WithDefaultSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a463412f1242c6a21d859660105e3e710">with_default_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *Any default=<a class="el" href="namespacepydantic__core_1_1core__schema.html#ad44474082711c0f342caf31af269622c">PydanticUndefined</a>, Union[Callable[[], Any], Callable[[Dict[str, Any]], Any], None] default_factory=None, bool|None default_factory_takes_data=None, Literal['raise', 'omit', 'default']|None on_error=None, bool|None validate_default=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a463412f1242c6a21d859660105e3e710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9f86648abc860acaedb0b97ea6fc6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1NullableSchema.html">NullableSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aec9f86648abc860acaedb0b97ea6fc6e">nullable_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aec9f86648abc860acaedb0b97ea6fc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e8605d5d402373644061ca27aaad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1UnionSchema.html">UnionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5d1e8605d5d402373644061ca27aaad9">union_schema</a> (list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|tuple[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>, str]] choices, *bool|None auto_collapse=None, str|None custom_error_type=None, str|None custom_error_message=None, dict[str, str|int]|None custom_error_context=None, Literal['smart', 'left_to_right']|None mode=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a5d1e8605d5d402373644061ca27aaad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa842d1b14279e68178ff160c5e708fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TaggedUnionSchema.html">TaggedUnionSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa842d1b14279e68178ff160c5e708fbb">tagged_union_schema</a> (Dict[Any, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] choices, str|list[str|int]|list[list[str|int]]|Callable[[Any], Any] discriminator, *str|None custom_error_type=None, str|None custom_error_message=None, dict[str, int|str|float]|None custom_error_context=None, bool|None strict=None, bool|None from_attributes=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aa842d1b14279e68178ff160c5e708fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ab0084321553c1d8a4e8a893591d04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ChainSchema.html">ChainSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a83ab0084321553c1d8a4e8a893591d04">chain_schema</a> (list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>] steps, *str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a83ab0084321553c1d8a4e8a893591d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050b7319fa9a9bbef80fc14ead2c809d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1LaxOrStrictSchema.html">LaxOrStrictSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a050b7319fa9a9bbef80fc14ead2c809d">lax_or_strict_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> lax_schema, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> strict_schema, *bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a050b7319fa9a9bbef80fc14ead2c809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461b36ffbb7fb9eb09692c65a66ac7fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1JsonOrPythonSchema.html">JsonOrPythonSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a461b36ffbb7fb9eb09692c65a66ac7fa">json_or_python_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> <a class="el" href="namespacepydantic__core_1_1core__schema.html#a6bf5d7251f63486d572348a75e8e146a">json_schema</a>, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> python_schema, *str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a461b36ffbb7fb9eb09692c65a66ac7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cc782d3bb190991bffa817798eafa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae4cc782d3bb190991bffa817798eafa5">typed_dict_field</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *bool|None required=None, str|list[str|int]|list[list[str|int]]|None validation_alias=None, str|None serialization_alias=None, bool|None serialization_exclude=None, Dict[str, Any]|None metadata=None)</td></tr>
<tr class="separator:ae4cc782d3bb190991bffa817798eafa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bbc878e58121cb91121505c883bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictSchema.html">TypedDictSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a257bbc878e58121cb91121505c883bf4">typed_dict_schema</a> (Dict[str, <a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a>] fields, *Type[Any]|None cls=None, list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>]|None computed_fields=None, bool|None strict=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None extras_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a>|None extra_behavior=None, bool|None total=None, bool|None populate_by_name=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None, <a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a>|None config=None)</td></tr>
<tr class="separator:a257bbc878e58121cb91121505c883bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23e736cf44c26e2f4f964619a386612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af23e736cf44c26e2f4f964619a386612">model_field</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *str|list[str|int]|list[list[str|int]]|None validation_alias=None, str|None serialization_alias=None, bool|None serialization_exclude=None, bool|None frozen=None, Dict[str, Any]|None metadata=None)</td></tr>
<tr class="separator:af23e736cf44c26e2f4f964619a386612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5702e00c78f3664a4f2355c3c6e507b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelFieldsSchema.html">ModelFieldsSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5702e00c78f3664a4f2355c3c6e507b9">model_fields_schema</a> (Dict[str, <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a>] fields, *str|None model_name=None, list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>]|None computed_fields=None, bool|None strict=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None extras_schema=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a>|None extra_behavior=None, bool|None populate_by_name=None, bool|None from_attributes=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a5702e00c78f3664a4f2355c3c6e507b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e807b4874df3287b63c1ba754cd1ab0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSchema.html">ModelSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a3e807b4874df3287b63c1ba754cd1ab0">model_schema</a> (Type[Any] cls, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *Type[Any]|None generic_origin=None, bool|None custom_init=None, bool|None root_model=None, str|None post_init=None, Literal['always', 'never', 'subclass-instances']|None revalidate_instances=None, bool|None strict=None, bool|None frozen=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a>|None extra_behavior=None, <a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a>|None config=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a3e807b4874df3287b63c1ba754cd1ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311a39a03a49ba88d2f649ab826e07f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a311a39a03a49ba88d2f649ab826e07f4">dataclass_field</a> (str name, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, *bool|None kw_only=None, bool|None init=None, bool|None init_only=None, str|list[str|int]|list[list[str|int]]|None validation_alias=None, str|None serialization_alias=None, bool|None serialization_exclude=None, Dict[str, Any]|None metadata=None, bool|None frozen=None)</td></tr>
<tr class="separator:a311a39a03a49ba88d2f649ab826e07f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26545185096e63d9788f9d486355ed05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassArgsSchema.html">DataclassArgsSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a26545185096e63d9788f9d486355ed05">dataclass_args_schema</a> (str dataclass_name, list[<a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a>] fields, *List[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>]|None computed_fields=None, bool|None populate_by_name=None, bool|None collect_init_only=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a>|None extra_behavior=None)</td></tr>
<tr class="separator:a26545185096e63d9788f9d486355ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43365a43d1ccfa7ccbbff6561abd125b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassSchema.html">DataclassSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a43365a43d1ccfa7ccbbff6561abd125b">dataclass_schema</a> (Type[Any] cls, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, List[str] fields, *Type[Any]|None generic_origin=None, str|None cls_name=None, bool|None post_init=None, Literal['always', 'never', 'subclass-instances']|None revalidate_instances=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None, bool|None frozen=None, bool|None slots=None, <a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a>|None config=None)</td></tr>
<tr class="separator:a43365a43d1ccfa7ccbbff6561abd125b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b926b2bd714709a768fc52c99a954f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsSchema.html">ArgumentsSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af8b926b2bd714709a768fc52c99a954f">arguments_schema</a> (list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsParameter.html">ArgumentsParameter</a>] arguments, *bool|None populate_by_name=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None var_args_schema=None, VarKwargsMode|None var_kwargs_mode=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None var_kwargs_schema=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:af8b926b2bd714709a768fc52c99a954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47748ab9965939087b6c831bd0f6f2c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1CallSchema.html">CallSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a47748ab9965939087b6c831bd0f6f2c5">call_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> arguments, Callable[..., Any] function, *str|None function_name=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None return_schema=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a47748ab9965939087b6c831bd0f6f2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad2ad31f6eb7afc1fce6a8ead0e7e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1CustomErrorSchema.html">CustomErrorSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7ad2ad31f6eb7afc1fce6a8ead0e7e46">custom_error_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> schema, str custom_error_type, *str|None custom_error_message=None, dict[str, Any]|None custom_error_context=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a7ad2ad31f6eb7afc1fce6a8ead0e7e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bb8daa2645a289b27d3f2ad2d0f437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1JsonSchema.html">JsonSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa4bb8daa2645a289b27d3f2ad2d0f437">json_schema</a> (<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>|None schema=None, *str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:aa4bb8daa2645a289b27d3f2ad2d0f437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1babc11e9a13ebcd811ef95d86f08467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1UrlSchema.html">UrlSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a1babc11e9a13ebcd811ef95d86f08467">url_schema</a> (*int|None max_length=None, list[str]|None allowed_schemes=None, bool|None host_required=None, str|None default_host=None, int|None default_port=None, str|None default_path=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a1babc11e9a13ebcd811ef95d86f08467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb90105625087facf31f95e01ae323b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1MultiHostUrlSchema.html">MultiHostUrlSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acb90105625087facf31f95e01ae323b7">multi_host_url_schema</a> (*int|None max_length=None, list[str]|None allowed_schemes=None, bool|None host_required=None, str|None default_host=None, int|None default_port=None, str|None default_path=None, bool|None strict=None, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:acb90105625087facf31f95e01ae323b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7565e8fa0db5dda5156cc3aee8fac13d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic__core_1_1core__schema_1_1DefinitionReferenceSchema.html">DefinitionReferenceSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7565e8fa0db5dda5156cc3aee8fac13d">definition_reference_schema</a> (str schema_ref, str|None ref=None, Dict[str, Any]|None metadata=None, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>|None serialization=None)</td></tr>
<tr class="separator:a7565e8fa0db5dda5156cc3aee8fac13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad44474082711c0f342caf31af269622c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad44474082711c0f342caf31af269622c">PydanticUndefined</a> = object()</td></tr>
<tr class="separator:ad44474082711c0f342caf31af269622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe9638c9333cc7e5ac84efa9af70e57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> = Literal['allow', 'forbid', 'ignore']</td></tr>
<tr class="separator:acbe9638c9333cc7e5ac84efa9af70e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbd0412ec2de43437346c4bdb133153"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7bbd0412ec2de43437346c4bdb133153">ExpectedSerializationTypes</a></td></tr>
<tr class="separator:a7bbd0412ec2de43437346c4bdb133153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace46ed5d686c472d17a5b841be6da778"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ace46ed5d686c472d17a5b841be6da778">GeneralPlainNoInfoSerializerFunction</a> = Callable[[Any], Any]</td></tr>
<tr class="separator:ace46ed5d686c472d17a5b841be6da778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ca4738e230976679d29d39a5875a89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a15ca4738e230976679d29d39a5875a89">GeneralPlainInfoSerializerFunction</a> = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializationInfo.html">SerializationInfo</a>], Any]</td></tr>
<tr class="separator:a15ca4738e230976679d29d39a5875a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5421024acc475c29c68be05a10a1f05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa5421024acc475c29c68be05a10a1f05">FieldPlainNoInfoSerializerFunction</a> = Callable[[Any, Any], Any]</td></tr>
<tr class="separator:aa5421024acc475c29c68be05a10a1f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19294f90b7ab8dfdc6bebc2ecf87610f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a19294f90b7ab8dfdc6bebc2ecf87610f">FieldPlainInfoSerializerFunction</a> = Callable[[Any, Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1FieldSerializationInfo.html">FieldSerializationInfo</a>], Any]</td></tr>
<tr class="separator:a19294f90b7ab8dfdc6bebc2ecf87610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90031edbb2b8336ec6d1042e86b42c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a4c90031edbb2b8336ec6d1042e86b42c">SerializerFunction</a></td></tr>
<tr class="separator:a4c90031edbb2b8336ec6d1042e86b42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b68cb9e550df04791a0708fbb45f492"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> = Literal['always', 'unless-none', 'json', 'json-unless-none']</td></tr>
<tr class="separator:a0b68cb9e550df04791a0708fbb45f492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f4774e5e33bed2e21b12890514233d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a66f4774e5e33bed2e21b12890514233d">GeneralWrapNoInfoSerializerFunction</a> = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a>], Any]</td></tr>
<tr class="separator:a66f4774e5e33bed2e21b12890514233d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51132ba45da86c88348fa39ffa8ef5ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a51132ba45da86c88348fa39ffa8ef5ac">GeneralWrapInfoSerializerFunction</a> = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializationInfo.html">SerializationInfo</a>], Any]</td></tr>
<tr class="separator:a51132ba45da86c88348fa39ffa8ef5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461dcf40c062ec06ec9306f5add54654"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a461dcf40c062ec06ec9306f5add54654">FieldWrapNoInfoSerializerFunction</a> = Callable[[Any, Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a>], Any]</td></tr>
<tr class="separator:a461dcf40c062ec06ec9306f5add54654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2149303d23acb1fc3077e026f2b00cc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a2149303d23acb1fc3077e026f2b00cc3">FieldWrapInfoSerializerFunction</a> = Callable[[Any, Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1FieldSerializationInfo.html">FieldSerializationInfo</a>], Any]</td></tr>
<tr class="separator:a2149303d23acb1fc3077e026f2b00cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d63a69ba9113025697eb0174ff9e07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa5d63a69ba9113025697eb0174ff9e07">WrapSerializerFunction</a></td></tr>
<tr class="separator:aa5d63a69ba9113025697eb0174ff9e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5872680b347a64205c3d98a22b734cb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a></td></tr>
<tr class="separator:a5872680b347a64205c3d98a22b734cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5eea34a357669a0a090380c82cca08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#afa5eea34a357669a0a090380c82cca08">JsonType</a> = Literal['null', 'bool', 'int', 'float', 'str', 'list', 'dict']</td></tr>
<tr class="separator:afa5eea34a357669a0a090380c82cca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d30b36f99109cf3f8ae2c4b19b115b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> = Union[<a class="el" href="classpydantic__core_1_1core__schema_1_1IncExSeqSerSchema.html">IncExSeqSerSchema</a>, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>]</td></tr>
<tr class="separator:af6d30b36f99109cf3f8ae2c4b19b115b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c04c509c5a0e68fcb1a1c77dd8316a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ab8c04c509c5a0e68fcb1a1c77dd8316a">IncExDict</a> = set[Union[int, str]]</td></tr>
<tr class="separator:ab8c04c509c5a0e68fcb1a1c77dd8316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b8b7fb4c56957201d089b0ba3396bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac2b8b7fb4c56957201d089b0ba3396bc">IncExDictOrElseSerSchema</a> = Union[<a class="el" href="classpydantic__core_1_1core__schema_1_1IncExDictSerSchema.html">IncExDictSerSchema</a>, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>]</td></tr>
<tr class="separator:ac2b8b7fb4c56957201d089b0ba3396bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a51404ee4afb179fee56871a940e26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a> = Callable[[Any], Any]</td></tr>
<tr class="separator:aa3a51404ee4afb179fee56871a940e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798d67527c262e5d1745dd33b8fd1458"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a> = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidationInfo.html">ValidationInfo</a>], Any]</td></tr>
<tr class="separator:a798d67527c262e5d1745dd33b8fd1458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35372c6ef9a79fd34b96b0ecfb56c04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae35372c6ef9a79fd34b96b0ecfb56c04">ValidationFunction</a> = Union[<a class="el" href="classpydantic__core_1_1core__schema_1_1NoInfoValidatorFunctionSchema.html">NoInfoValidatorFunctionSchema</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1WithInfoValidatorFunctionSchema.html">WithInfoValidatorFunctionSchema</a>]</td></tr>
<tr class="separator:ae35372c6ef9a79fd34b96b0ecfb56c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ffc255b7e6d49b678053bc1902e616"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af2ffc255b7e6d49b678053bc1902e616">NoInfoWrapValidatorFunction</a> = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidatorFunctionWrapHandler.html">ValidatorFunctionWrapHandler</a>], Any]</td></tr>
<tr class="separator:af2ffc255b7e6d49b678053bc1902e616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896d0dc92976c139adba63e86261bc26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a896d0dc92976c139adba63e86261bc26">WithInfoWrapValidatorFunction</a> = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidatorFunctionWrapHandler.html">ValidatorFunctionWrapHandler</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidationInfo.html">ValidationInfo</a>], Any]</td></tr>
<tr class="separator:a896d0dc92976c139adba63e86261bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7572f2e2a5d1f6202194d3badece33e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7572f2e2a5d1f6202194d3badece33e3">WrapValidatorFunction</a> = Union[<a class="el" href="classpydantic__core_1_1core__schema_1_1NoInfoWrapValidatorFunctionSchema.html">NoInfoWrapValidatorFunctionSchema</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1WithInfoWrapValidatorFunctionSchema.html">WithInfoWrapValidatorFunctionSchema</a>]</td></tr>
<tr class="separator:a7572f2e2a5d1f6202194d3badece33e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9845e26657a520e448083370526075a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af9845e26657a520e448083370526075a">MYPY</a> = False</td></tr>
<tr class="separator:af9845e26657a520e448083370526075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e27232aa3bdf53839c4dd24c3e4f6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a></td></tr>
<tr class="separator:ae1e27232aa3bdf53839c4dd24c3e4f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1975a804f8d7b4fc9ea27373cf65a1ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a1975a804f8d7b4fc9ea27373cf65a1ab">TypeAlias</a></td></tr>
<tr class="separator:a1975a804f8d7b4fc9ea27373cf65a1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43da19d45322e6deb95ef84af95a5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7c43da19d45322e6deb95ef84af95a5d">CoreSchemaType</a></td></tr>
<tr class="separator:a7c43da19d45322e6deb95ef84af95a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5c62f54ec9792ffac9829093b84a18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a9e5c62f54ec9792ffac9829093b84a18">CoreSchemaFieldType</a> = Literal['model-field', 'dataclass-field', 'typed-dict-field', 'computed-field']</td></tr>
<tr class="separator:a9e5c62f54ec9792ffac9829093b84a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e4aa2f01e0325d9fd0c6368410904f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ac2e4aa2f01e0325d9fd0c6368410904f">ErrorType</a></td></tr>
<tr class="separator:ac2e4aa2f01e0325d9fd0c6368410904f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3106556b401724f19e733c874e622604"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a3106556b401724f19e733c874e622604">FieldValidationInfo</a> = <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidationInfo.html">ValidationInfo</a></td></tr>
<tr class="separator:a3106556b401724f19e733c874e622604"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module contains definitions to build schemas which `pydantic_core` can
validate and serialize.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a434634031e268fdcfca19da70ef4f3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434634031e268fdcfca19da70ef4f3e6">&#9670;&nbsp;</a></span>__getattr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">object pydantic_core.core_schema.__getattr__ </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>attr_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59a3a9c5c91fd0477b3a8d75efd043db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a3a9c5c91fd0477b3a8d75efd043db">&#9670;&nbsp;</a></span>any_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1AnySchema.html">AnySchema</a> pydantic_core.core_schema.any_schema </td>
          <td>(</td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches any value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.any_schema()
v = SchemaValidator(schema)
assert v.validate_python(1) == 1
```

Args:
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a5500ba534041fd8058fc3e0867b33dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5500ba534041fd8058fc3e0867b33dfb">&#9670;&nbsp;</a></span>any_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1AnySchema.html">AnySchema</a> pydantic_core.core_schema.any_schema </td>
          <td>(</td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches any value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.any_schema()
v = SchemaValidator(schema)
assert v.validate_python(1) == 1
```

Args:
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="acc19843082106b0d83142c9066b6ee70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc19843082106b0d83142c9066b6ee70">&#9670;&nbsp;</a></span>arguments_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsParameter.html">ArgumentsParameter</a> pydantic_core.core_schema.arguments_parameter </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None &#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str | int] | list[list[str | int]] | None &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an argument parameter, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

param = core_schema.arguments_parameter(
    name='a', schema=core_schema.str_schema(), mode='positional_only'
)
schema = core_schema.arguments_schema([param])
v = SchemaValidator(schema)
assert v.validate_python(('hello',)) == (('hello',), {})
```

Args:
    name: The name to use for the argument parameter
    schema: The schema to use for the argument parameter
    mode: The mode to use for the argument parameter
    alias: The alias to use for the argument parameter
</pre> 
</div>
</div>
<a id="af8b926b2bd714709a768fc52c99a954f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b926b2bd714709a768fc52c99a954f">&#9670;&nbsp;</a></span>arguments_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsSchema.html">ArgumentsSchema</a> pydantic_core.core_schema.arguments_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsParameter.html">ArgumentsParameter</a>]&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>populate_by_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>var_args_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarKwargsMode | None &#160;</td>
          <td class="paramname"><em>var_kwargs_mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>var_kwargs_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an arguments schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

param_a = core_schema.arguments_parameter(
    name='a', schema=core_schema.str_schema(), mode='positional_only'
)
param_b = core_schema.arguments_parameter(
    name='b', schema=core_schema.bool_schema(), mode='positional_only'
)
schema = core_schema.arguments_schema([param_a, param_b])
v = SchemaValidator(schema)
assert v.validate_python(('hello', True)) == (('hello', True), {})
```

Args:
    arguments: The arguments to use for the arguments schema
    populate_by_name: Whether to populate by name
    var_args_schema: The variable args schema to use for the arguments schema
    var_kwargs_mode: The validation mode to use for variadic keyword arguments. If `'uniform'`, every value of the
        keyword arguments will be validated against the `var_kwargs_schema` schema. If `'unpacked-typed-dict'`,
        the `var_kwargs_schema` argument must be a [`typed_dict_schema`][pydantic_core.core_schema.typed_dict_schema]
    var_kwargs_schema: The variable kwargs schema to use for the arguments schema
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aa6c6d763634530bdcc71e2b1e723eb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c6d763634530bdcc71e2b1e723eb49">&#9670;&nbsp;</a></span>arguments_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsSchema.html">ArgumentsSchema</a> pydantic_core.core_schema.arguments_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsParameter.html">ArgumentsParameter</a>]&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>validate_by_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>validate_by_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>var_args_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarKwargsMode | None &#160;</td>
          <td class="paramname"><em>var_kwargs_mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>var_kwargs_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an arguments schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

param_a = core_schema.arguments_parameter(
    name='a', schema=core_schema.str_schema(), mode='positional_only'
)
param_b = core_schema.arguments_parameter(
    name='b', schema=core_schema.bool_schema(), mode='positional_only'
)
schema = core_schema.arguments_schema([param_a, param_b])
v = SchemaValidator(schema)
assert v.validate_python(('hello', True)) == (('hello', True), {})
```

Args:
    arguments: The arguments to use for the arguments schema
    validate_by_name: Whether to populate by the parameter names, defaults to `False`.
    validate_by_alias: Whether to populate by the parameter aliases, defaults to `True`.
    var_args_schema: The variable args schema to use for the arguments schema
    var_kwargs_mode: The validation mode to use for variadic keyword arguments. If `'uniform'`, every value of the
        keyword arguments will be validated against the `var_kwargs_schema` schema. If `'unpacked-typed-dict'`,
        the `var_kwargs_schema` argument must be a [`typed_dict_schema`][pydantic_core.core_schema.typed_dict_schema]
    var_kwargs_schema: The variable kwargs schema to use for the arguments schema
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a9d5bcd66ea06699fdfc2d6a0c12a0be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5bcd66ea06699fdfc2d6a0c12a0be7">&#9670;&nbsp;</a></span>arguments_v3_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsV3Parameter.html">ArgumentsV3Parameter</a> pydantic_core.core_schema.arguments_v3_parameter </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal[
        'positional_only',
        'positional_or_keyword',
        'keyword_only',
        'var_args',
        'var_kwargs_uniform',
        'var_kwargs_unpacked_typed_dict',
    ]
    | None &#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str | int] | list[list[str | int]] | None &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an argument parameter, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

param = core_schema.arguments_v3_parameter(
    name='a', schema=core_schema.str_schema(), mode='positional_only'
)
schema = core_schema.arguments_v3_schema([param])
v = SchemaValidator(schema)
assert v.validate_python({'a': 'hello'}) == (('hello',), {})
```

Args:
    name: The name to use for the argument parameter
    schema: The schema to use for the argument parameter
    mode: The mode to use for the argument parameter
    alias: The alias to use for the argument parameter
</pre> 
</div>
</div>
<a id="a7ae353406b85bd410d2caae110df368a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae353406b85bd410d2caae110df368a">&#9670;&nbsp;</a></span>arguments_v3_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsV3Schema.html">ArgumentsV3Schema</a> pydantic_core.core_schema.arguments_v3_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ArgumentsV3Parameter.html">ArgumentsV3Parameter</a>]&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>validate_by_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>validate_by_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['forbid', 'ignore'] | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an arguments schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

param_a = core_schema.arguments_v3_parameter(
    name='a', schema=core_schema.str_schema(), mode='positional_only'
)
param_b = core_schema.arguments_v3_parameter(
    name='kwargs', schema=core_schema.bool_schema(), mode='var_kwargs_uniform'
)
schema = core_schema.arguments_v3_schema([param_a, param_b])
v = SchemaValidator(schema)
assert v.validate_python({'a': 'hi', 'kwargs': {'b': True}}) == (('hi',), {'b': True})
```

This schema is currently not used by other Pydantic components. In V3, it will most likely
become the default arguments schema for the `'call'` schema.

Args:
    arguments: The arguments to use for the arguments schema.
    validate_by_name: Whether to populate by the parameter names, defaults to `False`.
    validate_by_alias: Whether to populate by the parameter aliases, defaults to `True`.
    extra_behavior: The extra behavior to use.
    ref: optional unique identifier of the schema, used to reference the schema in other places.
    metadata: Any other information you want to include with the schema, not used by pydantic-core.
    serialization: Custom serialization schema.
</pre> 
</div>
</div>
<a id="ac072b3c53e61dbeec5198167e7d704f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac072b3c53e61dbeec5198167e7d704f8">&#9670;&nbsp;</a></span>bool_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1BoolSchema.html">BoolSchema</a> pydantic_core.core_schema.bool_schema </td>
          <td>(</td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a bool value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.bool_schema()
v = SchemaValidator(schema)
assert v.validate_python('True') is True
```

Args:
    strict: Whether the value should be a bool or a value that can be converted to a bool
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aed0c76532272c961d3b90a018522a956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0c76532272c961d3b90a018522a956">&#9670;&nbsp;</a></span>bool_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1BoolSchema.html">BoolSchema</a> pydantic_core.core_schema.bool_schema </td>
          <td>(</td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a bool value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.bool_schema()
v = SchemaValidator(schema)
assert v.validate_python('True') is True
```

Args:
    strict: Whether the value should be a bool or a value that can be converted to a bool
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ac0d6d85f529c96d61206aba7d51ed91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d6d85f529c96d61206aba7d51ed91d">&#9670;&nbsp;</a></span>bytes_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1BytesSchema.html">BytesSchema</a> pydantic_core.core_schema.bytes_schema </td>
          <td>(</td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a bytes value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.bytes_schema(max_length=10, min_length=2)
v = SchemaValidator(schema)
assert v.validate_python(b'hello') == b'hello'
```

Args:
    max_length: The value must be at most this length
    min_length: The value must be at least this length
    strict: Whether the value should be a bytes or a value that can be converted to a bytes
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a594d9af56388d358e992299001059aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594d9af56388d358e992299001059aa3">&#9670;&nbsp;</a></span>bytes_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1BytesSchema.html">BytesSchema</a> pydantic_core.core_schema.bytes_schema </td>
          <td>(</td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a bytes value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.bytes_schema(max_length=10, min_length=2)
v = SchemaValidator(schema)
assert v.validate_python(b'hello') == b'hello'
```

Args:
    max_length: The value must be at most this length
    min_length: The value must be at least this length
    strict: Whether the value should be a bytes or a value that can be converted to a bytes
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a89ab379c9fefb599c20c202ad9e246d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ab379c9fefb599c20c202ad9e246d3">&#9670;&nbsp;</a></span>call_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1CallSchema.html">CallSchema</a> pydantic_core.core_schema.call_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Any]&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>function_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>return_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an arguments schema, then calls a function, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

param_a = core_schema.arguments_parameter(
    name='a', schema=core_schema.str_schema(), mode='positional_only'
)
param_b = core_schema.arguments_parameter(
    name='b', schema=core_schema.bool_schema(), mode='positional_only'
)
args_schema = core_schema.arguments_schema([param_a, param_b])

schema = core_schema.call_schema(
    arguments=args_schema,
    function=lambda a, b: a + str(not b),
    return_schema=core_schema.str_schema(),
)
v = SchemaValidator(schema)
assert v.validate_python((('hello', True))) == 'helloFalse'
```

Args:
    arguments: The arguments to use for the arguments schema
    function: The function to use for the call schema
    function_name: The function name to use for the call schema, if not provided `function.__name__` is used
    return_schema: The return schema to use for the call schema
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a47748ab9965939087b6c831bd0f6f2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47748ab9965939087b6c831bd0f6f2c5">&#9670;&nbsp;</a></span>call_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1CallSchema.html">CallSchema</a> pydantic_core.core_schema.call_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Any]&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>function_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>return_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an arguments schema, then calls a function, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

param_a = core_schema.arguments_parameter(
    name='a', schema=core_schema.str_schema(), mode='positional_only'
)
param_b = core_schema.arguments_parameter(
    name='b', schema=core_schema.bool_schema(), mode='positional_only'
)
args_schema = core_schema.arguments_schema([param_a, param_b])

schema = core_schema.call_schema(
    arguments=args_schema,
    function=lambda a, b: a + str(not b),
    return_schema=core_schema.str_schema(),
)
v = SchemaValidator(schema)
assert v.validate_python((('hello', True))) == 'helloFalse'
```

Args:
    arguments: The arguments to use for the arguments schema
    function: The function to use for the call schema
    function_name: The function name to use for the call schema, if not provided `function.__name__` is used
    return_schema: The return schema to use for the call schema
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ab418c5711fe458d72035f3e63dcc3f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab418c5711fe458d72035f3e63dcc3f1b">&#9670;&nbsp;</a></span>callable_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1CallableSchema.html">CallableSchema</a> pydantic_core.core_schema.callable_schema </td>
          <td>(</td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that checks if a value is callable, equivalent to python's `callable` method, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.callable_schema()
v = SchemaValidator(schema)
v.validate_python(min)
```

Args:
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a0177c367c0b754d576444307bf73415b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0177c367c0b754d576444307bf73415b">&#9670;&nbsp;</a></span>callable_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1CallableSchema.html">CallableSchema</a> pydantic_core.core_schema.callable_schema </td>
          <td>(</td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that checks if a value is callable, equivalent to python's `callable` method, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.callable_schema()
v = SchemaValidator(schema)
v.validate_python(min)
```

Args:
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a11fe55dae0ff35e710dca8dafe9d6567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fe55dae0ff35e710dca8dafe9d6567">&#9670;&nbsp;</a></span>chain_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ChainSchema.html">ChainSchema</a> pydantic_core.core_schema.chain_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that chains the provided validation schemas, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:
    assert 'hello' in v
    return v + ' world'

fn_schema = core_schema.with_info_plain_validator_function(function=fn)
schema = core_schema.chain_schema(
    [fn_schema, fn_schema, fn_schema, core_schema.str_schema()]
)
v = SchemaValidator(schema)
assert v.validate_python('hello') == 'hello world world world'
```

Args:
    steps: The schemas to chain
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a83ab0084321553c1d8a4e8a893591d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ab0084321553c1d8a4e8a893591d04">&#9670;&nbsp;</a></span>chain_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ChainSchema.html">ChainSchema</a> pydantic_core.core_schema.chain_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that chains the provided validation schemas, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:
    assert 'hello' in v
    return v + ' world'

fn_schema = core_schema.with_info_plain_validator_function(function=fn)
schema = core_schema.chain_schema(
    [fn_schema, fn_schema, fn_schema, core_schema.str_schema()]
)
v = SchemaValidator(schema)
assert v.validate_python('hello') == 'hello world world world'
```

Args:
    steps: The schemas to chain
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a9380a36e86dab14595de17d2612cc719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9380a36e86dab14595de17d2612cc719">&#9670;&nbsp;</a></span>complex_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ComplexSchema.html">ComplexSchema</a> pydantic_core.core_schema.complex_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a complex value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.complex_schema()
v = SchemaValidator(schema)
assert v.validate_python('1+2j') == complex(1, 2)
assert v.validate_python(complex(1, 2)) == complex(1, 2)
```

Args:
    strict: Whether the value should be a complex object instance or a value that can be converted to a complex object
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a45e08b5d406ed39c225aee1a042d4454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e08b5d406ed39c225aee1a042d4454">&#9670;&nbsp;</a></span>complex_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ComplexSchema.html">ComplexSchema</a> pydantic_core.core_schema.complex_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a complex value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.complex_schema()
v = SchemaValidator(schema)
assert v.validate_python('1+2j') == complex(1, 2)
assert v.validate_python(complex(1, 2)) == complex(1, 2)
```

Args:
    strict: Whether the value should be a complex object instance or a value that can be converted to a complex object
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a92cc9115acd494973f5a62dea8efb1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cc9115acd494973f5a62dea8efb1a7">&#9670;&nbsp;</a></span>computed_field() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a> pydantic_core.core_schema.computed_field </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>return_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">ComputedFields are properties of a model or dataclass that are included in serialization.

Args:
    property_name: The name of the property on the model or dataclass
    return_schema: The schema used for the type returned by the computed field
    alias: The name to use in the serialized output
    metadata: Any other information you want to include with the schema, not used by pydantic-core
</pre> 
</div>
</div>
<a id="aec2270d92eba0cc8c4b0fd16f5724269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2270d92eba0cc8c4b0fd16f5724269">&#9670;&nbsp;</a></span>computed_field() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a> pydantic_core.core_schema.computed_field </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>return_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">ComputedFields are properties of a model or dataclass that are included in serialization.

Args:
    property_name: The name of the property on the model or dataclass
    return_schema: The schema used for the type returned by the computed field
    alias: The name to use in the serialized output
    metadata: Any other information you want to include with the schema, not used by pydantic-core
</pre> 
</div>
</div>
<a id="a67ac917f906188624f2c65c34c5b3604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ac917f906188624f2c65c34c5b3604">&#9670;&nbsp;</a></span>custom_error_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1CustomErrorSchema.html">CustomErrorSchema</a> pydantic_core.core_schema.custom_error_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>custom_error_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>custom_error_message</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>custom_error_context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a custom error value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.custom_error_schema(
    schema=core_schema.int_schema(),
    custom_error_type='MyError',
    custom_error_message='Error msg',
)
v = SchemaValidator(schema)
v.validate_python(1)
```

Args:
    schema: The schema to use for the custom error schema
    custom_error_type: The custom error type to use for the custom error schema
    custom_error_message: The custom error message to use for the custom error schema
    custom_error_context: The custom error context to use for the custom error schema
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a7ad2ad31f6eb7afc1fce6a8ead0e7e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad2ad31f6eb7afc1fce6a8ead0e7e46">&#9670;&nbsp;</a></span>custom_error_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1CustomErrorSchema.html">CustomErrorSchema</a> pydantic_core.core_schema.custom_error_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>custom_error_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>custom_error_message</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>custom_error_context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a custom error value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.custom_error_schema(
    schema=core_schema.int_schema(),
    custom_error_type='MyError',
    custom_error_message='Error msg',
)
v = SchemaValidator(schema)
v.validate_python(1)
```

Args:
    schema: The schema to use for the custom error schema
    custom_error_type: The custom error type to use for the custom error schema
    custom_error_message: The custom error message to use for the custom error schema
    custom_error_context: The custom error context to use for the custom error schema
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a9c86460cc316d1ff4631ce5213e89f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c86460cc316d1ff4631ce5213e89f3e">&#9670;&nbsp;</a></span>dataclass_args_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassArgsSchema.html">DataclassArgsSchema</a> pydantic_core.core_schema.dataclass_args_schema </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>dataclass_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a>]&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>] | None &#160;</td>
          <td class="paramname"><em>computed_fields</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>collect_init_only</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for validating dataclass arguments, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

field_a = core_schema.dataclass_field(
    name='a', schema=core_schema.str_schema(), kw_only=False
)
field_b = core_schema.dataclass_field(
    name='b', schema=core_schema.bool_schema(), kw_only=False
)
schema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b])
v = SchemaValidator(schema)
assert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None)
```

Args:
    dataclass_name: The name of the dataclass being validated
    fields: The fields to use for the dataclass
    computed_fields: Computed fields to use when serializing the dataclass
    collect_init_only: Whether to collect init only fields into a dict to pass to `__post_init__`
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
    extra_behavior: How to handle extra fields
</pre> 
</div>
</div>
<a id="a26545185096e63d9788f9d486355ed05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26545185096e63d9788f9d486355ed05">&#9670;&nbsp;</a></span>dataclass_args_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassArgsSchema.html">DataclassArgsSchema</a> pydantic_core.core_schema.dataclass_args_schema </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>dataclass_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a>]&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*List[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>] | None &#160;</td>
          <td class="paramname"><em>computed_fields</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>populate_by_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>collect_init_only</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for validating dataclass arguments, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

field_a = core_schema.dataclass_field(
    name='a', schema=core_schema.str_schema(), kw_only=False
)
field_b = core_schema.dataclass_field(
    name='b', schema=core_schema.bool_schema(), kw_only=False
)
schema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b])
v = SchemaValidator(schema)
assert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None)
```

Args:
    dataclass_name: The name of the dataclass being validated
    fields: The fields to use for the dataclass
    computed_fields: Computed fields to use when serializing the dataclass
    populate_by_name: Whether to populate by name
    collect_init_only: Whether to collect init only fields into a dict to pass to `__post_init__`
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
    extra_behavior: How to handle extra fields
</pre> 
</div>
</div>
<a id="a5a21ed9daed3d4ada8561132aa2ec2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a21ed9daed3d4ada8561132aa2ec2bb">&#9670;&nbsp;</a></span>dataclass_field() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a> pydantic_core.core_schema.dataclass_field </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>init_only</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str | int] | list[list[str | int]] | None &#160;</td>
          <td class="paramname"><em>validation_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>serialization_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>serialization_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>frozen</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for a dataclass field, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

field = core_schema.dataclass_field(
    name='a', schema=core_schema.str_schema(), kw_only=False
)
schema = core_schema.dataclass_args_schema('Foobar', [field])
v = SchemaValidator(schema)
assert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None)
```

Args:
    name: The name to use for the argument parameter
    schema: The schema to use for the argument parameter
    kw_only: Whether the field can be set with a positional argument as well as a keyword argument
    init: Whether the field should be validated during initialization
    init_only: Whether the field should be omitted  from `__dict__` and passed to `__post_init__`
    validation_alias: The alias(es) to use to find the field in the validation data
    serialization_alias: The alias to use as a key when serializing
    serialization_exclude: Whether to exclude the field when serializing
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    frozen: Whether the field is frozen
</pre> 
</div>
</div>
<a id="a311a39a03a49ba88d2f649ab826e07f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311a39a03a49ba88d2f649ab826e07f4">&#9670;&nbsp;</a></span>dataclass_field() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassField.html">DataclassField</a> pydantic_core.core_schema.dataclass_field </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>kw_only</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>init_only</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str | int] | list[list[str | int]] | None &#160;</td>
          <td class="paramname"><em>validation_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>serialization_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>serialization_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>frozen</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for a dataclass field, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

field = core_schema.dataclass_field(
    name='a', schema=core_schema.str_schema(), kw_only=False
)
schema = core_schema.dataclass_args_schema('Foobar', [field])
v = SchemaValidator(schema)
assert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None)
```

Args:
    name: The name to use for the argument parameter
    schema: The schema to use for the argument parameter
    kw_only: Whether the field can be set with a positional argument as well as a keyword argument
    init: Whether the field should be validated during initialization
    init_only: Whether the field should be omitted  from `__dict__` and passed to `__post_init__`
    validation_alias: The alias(es) to use to find the field in the validation data
    serialization_alias: The alias to use as a key when serializing
    serialization_exclude: Whether to exclude the field when serializing
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    frozen: Whether the field is frozen
</pre> 
</div>
</div>
<a id="a49eac2306e9cc2bdabb09348e93a53a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49eac2306e9cc2bdabb09348e93a53a6">&#9670;&nbsp;</a></span>dataclass_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassSchema.html">DataclassSchema</a> pydantic_core.core_schema.dataclass_schema </td>
          <td>(</td>
          <td class="paramtype">type[Any]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str]&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*type[Any] | None &#160;</td>
          <td class="paramname"><em>generic_origin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>cls_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>post_init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['always', 'never', 'subclass-instances'] | None &#160;</td>
          <td class="paramname"><em>revalidate_instances</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>frozen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>slots</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for a dataclass. As with `ModelSchema`, this schema can only be used as a field within
another schema, not as the root type.

Args:
    cls: The dataclass type, used to perform subclass checks
    schema: The schema to use for the dataclass fields
    fields: Fields of the dataclass, this is used in serialization and in validation during re-validation
        and while validating assignment
    generic_origin: The origin type used for this dataclass, if it's a parametrized generic. Ex,
        if this model schema represents `SomeDataclass[int]`, generic_origin is `SomeDataclass`
    cls_name: The name to use in error locs, etc; this is useful for generics (default: `cls.__name__`)
    post_init: Whether to call `__post_init__` after validation
    revalidate_instances: whether instances of models and dataclasses (including subclass instances)
        should re-validate defaults to config.revalidate_instances, else 'never'
    strict: Whether to require an exact instance of `cls`
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
    frozen: Whether the dataclass is frozen
    slots: Whether `slots=True` on the dataclass, means each field is assigned independently, rather than
        simply setting `__dict__`, default false
</pre> 
</div>
</div>
<a id="a43365a43d1ccfa7ccbbff6561abd125b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43365a43d1ccfa7ccbbff6561abd125b">&#9670;&nbsp;</a></span>dataclass_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DataclassSchema.html">DataclassSchema</a> pydantic_core.core_schema.dataclass_schema </td>
          <td>(</td>
          <td class="paramtype">Type[Any]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List[str]&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Type[Any] | None &#160;</td>
          <td class="paramname"><em>generic_origin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>cls_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>post_init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['always', 'never', 'subclass-instances'] | None &#160;</td>
          <td class="paramname"><em>revalidate_instances</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>frozen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>slots</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for a dataclass. As with `ModelSchema`, this schema can only be used as a field within
another schema, not as the root type.

Args:
    cls: The dataclass type, used to perform subclass checks
    schema: The schema to use for the dataclass fields
    fields: Fields of the dataclass, this is used in serialization and in validation during re-validation
        and while validating assignment
    generic_origin: The origin type used for this dataclass, if it's a parametrized generic. Ex,
        if this model schema represents `SomeDataclass[int]`, generic_origin is `SomeDataclass`
    cls_name: The name to use in error locs, etc; this is useful for generics (default: `cls.__name__`)
    post_init: Whether to call `__post_init__` after validation
    revalidate_instances: whether instances of models and dataclasses (including subclass instances)
        should re-validate defaults to config.revalidate_instances, else 'never'
    strict: Whether to require an exact instance of `cls`
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
    frozen: Whether the dataclass is frozen
    slots: Whether `slots=True` on the dataclass, means each field is assigned independently, rather than
        simply setting `__dict__`, default false
</pre> 
</div>
</div>
<a id="ac36080b42f58d0eb6b2e6814a6227c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36080b42f58d0eb6b2e6814a6227c10">&#9670;&nbsp;</a></span>date_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DateSchema.html">DateSchema</a> pydantic_core.core_schema.date_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">date | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">date | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">date | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">date | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['past', 'future'] | None &#160;</td>
          <td class="paramname"><em>now_op</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>now_utc_offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a date value, e.g.:

```py
from datetime import date
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1))
v = SchemaValidator(schema)
assert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1)
```

Args:
    strict: Whether the value should be a date or a value that can be converted to a date
    le: The value must be less than or equal to this date
    ge: The value must be greater than or equal to this date
    lt: The value must be strictly less than this date
    gt: The value must be strictly greater than this date
    now_op: The value must be in the past or future relative to the current date
    now_utc_offset: The value must be in the past or future relative to the current date with this utc offset
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a74fa48de307756ea2cfafb47254a672f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fa48de307756ea2cfafb47254a672f">&#9670;&nbsp;</a></span>date_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DateSchema.html">DateSchema</a> pydantic_core.core_schema.date_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">date | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">date | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">date | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">date | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['past', 'future'] | None &#160;</td>
          <td class="paramname"><em>now_op</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>now_utc_offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a date value, e.g.:

```py
from datetime import date
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1))
v = SchemaValidator(schema)
assert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1)
```

Args:
    strict: Whether the value should be a date or a value that can be converted to a date
    le: The value must be less than or equal to this date
    ge: The value must be greater than or equal to this date
    lt: The value must be strictly less than this date
    gt: The value must be strictly greater than this date
    now_op: The value must be in the past or future relative to the current date
    now_utc_offset: The value must be in the past or future relative to the current date with this utc offset
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a3f86d72fa625d1d98a2fffe754aae8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f86d72fa625d1d98a2fffe754aae8e4">&#9670;&nbsp;</a></span>datetime_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DatetimeSchema.html">DatetimeSchema</a> pydantic_core.core_schema.datetime_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datetime | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datetime | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datetime | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datetime | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['past', 'future'] | None &#160;</td>
          <td class="paramname"><em>now_op</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['aware', 'naive'] | int | None &#160;</td>
          <td class="paramname"><em>tz_constraint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>now_utc_offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['truncate', 'error'] &#160;</td>
          <td class="paramname"><em>microseconds_precision</em> = <code>'truncate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a datetime value, e.g.:

```py
from datetime import datetime
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.datetime_schema()
v = SchemaValidator(schema)
now = datetime.now()
assert v.validate_python(str(now)) == now
```

Args:
    strict: Whether the value should be a datetime or a value that can be converted to a datetime
    le: The value must be less than or equal to this datetime
    ge: The value must be greater than or equal to this datetime
    lt: The value must be strictly less than this datetime
    gt: The value must be strictly greater than this datetime
    now_op: The value must be in the past or future relative to the current datetime
    tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset
        TODO: use of a tzinfo where offset changes based on the datetime is not yet supported
    now_utc_offset: The value must be in the past or future relative to the current datetime with this utc offset
    microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a25aa3cb99291d21255b9f7d7e213dd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25aa3cb99291d21255b9f7d7e213dd56">&#9670;&nbsp;</a></span>datetime_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DatetimeSchema.html">DatetimeSchema</a> pydantic_core.core_schema.datetime_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datetime | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datetime | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datetime | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datetime | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['past', 'future'] | None &#160;</td>
          <td class="paramname"><em>now_op</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['aware', 'naive'] | int | None &#160;</td>
          <td class="paramname"><em>tz_constraint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>now_utc_offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['truncate', 'error'] &#160;</td>
          <td class="paramname"><em>microseconds_precision</em> = <code>'truncate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a datetime value, e.g.:

```py
from datetime import datetime
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.datetime_schema()
v = SchemaValidator(schema)
now = datetime.now()
assert v.validate_python(str(now)) == now
```

Args:
    strict: Whether the value should be a datetime or a value that can be converted to a datetime
    le: The value must be less than or equal to this datetime
    ge: The value must be greater than or equal to this datetime
    lt: The value must be strictly less than this datetime
    gt: The value must be strictly greater than this datetime
    now_op: The value must be in the past or future relative to the current datetime
    tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset
        TODO: use of a tzinfo where offset changes based on the datetime is not yet supported
    now_utc_offset: The value must be in the past or future relative to the current datetime with this utc offset
    microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a81a936aeeaefffb03c1f9ea736d28266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a936aeeaefffb03c1f9ea736d28266">&#9670;&nbsp;</a></span>decimal_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DecimalSchema.html">DecimalSchema</a> pydantic_core.core_schema.decimal_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>allow_inf_nan</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>multiple_of</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_digits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>decimal_places</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a decimal value, e.g.:

```py
from decimal import Decimal
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.decimal_schema(le=0.8, ge=0.2)
v = SchemaValidator(schema)
assert v.validate_python('0.5') == Decimal('0.5')
```

Args:
    allow_inf_nan: Whether to allow inf and nan values
    multiple_of: The value must be a multiple of this number
    le: The value must be less than or equal to this number
    ge: The value must be greater than or equal to this number
    lt: The value must be strictly less than this number
    gt: The value must be strictly greater than this number
    max_digits: The maximum number of decimal digits allowed
    decimal_places: The maximum number of decimal places allowed
    strict: Whether the value should be a float or a value that can be converted to a float
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a4d52dc118aa0844cd893a8b060349596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d52dc118aa0844cd893a8b060349596">&#9670;&nbsp;</a></span>decimal_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DecimalSchema.html">DecimalSchema</a> pydantic_core.core_schema.decimal_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>allow_inf_nan</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>multiple_of</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_digits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>decimal_places</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a decimal value, e.g.:

```py
from decimal import Decimal
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.decimal_schema(le=0.8, ge=0.2)
v = SchemaValidator(schema)
assert v.validate_python('0.5') == Decimal('0.5')
```

Args:
    allow_inf_nan: Whether to allow inf and nan values
    multiple_of: The value must be a multiple of this number
    le: The value must be less than or equal to this number
    ge: The value must be greater than or equal to this number
    lt: The value must be strictly less than this number
    gt: The value must be strictly greater than this number
    max_digits: The maximum number of decimal digits allowed
    decimal_places: The maximum number of decimal places allowed
    strict: Whether the value should be a float or a value that can be converted to a float
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a3ff9eb2201471a44fa2f601c47c6227d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff9eb2201471a44fa2f601c47c6227d">&#9670;&nbsp;</a></span>definition_reference_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DefinitionReferenceSchema.html">DefinitionReferenceSchema</a> pydantic_core.core_schema.definition_reference_schema </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>schema_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that points to a schema stored in "definitions", this is useful for nested recursive
models and also when you want to define validators separately from the main schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema_definition = core_schema.definition_reference_schema('list-schema')
schema = core_schema.definitions_schema(
    schema=schema_definition,
    definitions=[
        core_schema.list_schema(items_schema=schema_definition, ref='list-schema'),
    ],
)
v = SchemaValidator(schema)
assert v.validate_python([()]) == [[]]
```

Args:
    schema_ref: The schema ref to use for the definition reference schema
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a7565e8fa0db5dda5156cc3aee8fac13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7565e8fa0db5dda5156cc3aee8fac13d">&#9670;&nbsp;</a></span>definition_reference_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DefinitionReferenceSchema.html">DefinitionReferenceSchema</a> pydantic_core.core_schema.definition_reference_schema </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>schema_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that points to a schema stored in "definitions", this is useful for nested recursive
models and also when you want to define validators separately from the main schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema_definition = core_schema.definition_reference_schema('list-schema')
schema = core_schema.definitions_schema(
    schema=schema_definition,
    definitions=[
        core_schema.list_schema(items_schema=schema_definition, ref='list-schema'),
    ],
)
v = SchemaValidator(schema)
assert v.validate_python([()]) == [[]]
```

Args:
    schema_ref: The schema ref to use for the definition reference schema
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a0e8f671d2e656bbb5bc304b97f061a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8f671d2e656bbb5bc304b97f061a12">&#9670;&nbsp;</a></span>definitions_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpydantic__core_1_1core__schema_1_1DefinitionsSchema.html">DefinitionsSchema</a> pydantic_core.core_schema.definitions_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>definitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build a schema that contains both an inner schema and a list of definitions which can be used
within the inner schema.

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.definitions_schema(
    core_schema.list_schema(core_schema.definition_reference_schema('foobar')),
    [core_schema.int_schema(ref='foobar')],
)
v = SchemaValidator(schema)
assert v.validate_python([1, 2, '3']) == [1, 2, 3]
```

Args:
    schema: The inner schema
    definitions: List of definitions which can be referenced within inner schema
</pre> 
</div>
</div>
<a id="a7bfc908080615f9438264e5fd96e9ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfc908080615f9438264e5fd96e9ba7">&#9670;&nbsp;</a></span>dict_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DictSchema.html">DictSchema</a> pydantic_core.core_schema.dict_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>keys_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>values_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a dict value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.dict_schema(
    keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema()
)
v = SchemaValidator(schema)
assert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2}
```

Args:
    keys_schema: The value must be a dict with keys that match this schema
    values_schema: The value must be a dict with values that match this schema
    min_length: The value must be a dict with at least this many items
    max_length: The value must be a dict with at most this many items
    strict: Whether the keys and values should be validated with strict mode
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a2dbed9d53108be54f37feca2d92ba51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbed9d53108be54f37feca2d92ba51d">&#9670;&nbsp;</a></span>dict_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1DictSchema.html">DictSchema</a> pydantic_core.core_schema.dict_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>keys_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>values_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a dict value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.dict_schema(
    keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema()
)
v = SchemaValidator(schema)
assert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2}
```

Args:
    keys_schema: The value must be a dict with keys that match this schema
    values_schema: The value must be a dict with values that match this schema
    min_length: The value must be a dict with at least this many items
    max_length: The value must be a dict with at most this many items
    strict: Whether the keys and values should be validated with strict mode
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a8c1cc38c445fcbcb3ddf606667910d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1cc38c445fcbcb3ddf606667910d5a">&#9670;&nbsp;</a></span>enum_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1EnumSchema.html">EnumSchema</a> pydantic_core.core_schema.enum_schema </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[Any]&#160;</td>
          <td class="paramname"><em>members</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal['str', 'int', 'float'] | None &#160;</td>
          <td class="paramname"><em>sub_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[Any], Any] | None &#160;</td>
          <td class="paramname"><em>missing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an enum value, e.g.:

```py
from enum import Enum
from pydantic_core import SchemaValidator, core_schema

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

schema = core_schema.enum_schema(Color, list(Color.__members__.values()))
v = SchemaValidator(schema)
assert v.validate_python(2) is Color.GREEN
```

Args:
    cls: The enum class
    members: The members of the enum, generally `list(MyEnum.__members__.values())`
    sub_type: The type of the enum, either 'str' or 'int' or None for plain enums
    missing: A function to use when the value is not found in the enum, from `_missing_`
    strict: Whether to use strict mode, defaults to False
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a4cd4d3112245c38c5070fb92200feac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd4d3112245c38c5070fb92200feac9">&#9670;&nbsp;</a></span>enum_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1EnumSchema.html">EnumSchema</a> pydantic_core.core_schema.enum_schema </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[Any]&#160;</td>
          <td class="paramname"><em>members</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal['str', 'int', 'float'] | None &#160;</td>
          <td class="paramname"><em>sub_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[Any], Any] | None &#160;</td>
          <td class="paramname"><em>missing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches an enum value, e.g.:

```py
from enum import Enum
from pydantic_core import SchemaValidator, core_schema

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

schema = core_schema.enum_schema(Color, list(Color.__members__.values()))
v = SchemaValidator(schema)
assert v.validate_python(2) is Color.GREEN
```

Args:
    cls: The enum class
    members: The members of the enum, generally `list(MyEnum.__members__.values())`
    sub_type: The type of the enum, either 'str' or 'int' or None for plain enums
    missing: A function to use when the value is not found in the enum, from `_missing_`
    strict: Whether to use strict mode, defaults to False
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="abed9d91870f12b69eb7b86ceaf5812f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed9d91870f12b69eb7b86ceaf5812f9">&#9670;&nbsp;</a></span>field_after_validator_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pydantic_core.core_schema.field_after_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4617d96cd1e6eae6b0ae332a77d52693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4617d96cd1e6eae6b0ae332a77d52693">&#9670;&nbsp;</a></span>field_before_validator_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pydantic_core.core_schema.field_before_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All this stuff is deprecated by #980 and will be removed eventually They're kept because some code external code will be using them. </p>

</div>
</div>
<a id="acea6aeb316c19e31c3c095af042c1a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea6aeb316c19e31c3c095af042c1a85">&#9670;&nbsp;</a></span>field_plain_validator_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pydantic_core.core_schema.field_plain_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a820970dc8ec850b8cb4f700e0ad6e3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820970dc8ec850b8cb4f700e0ad6e3c6">&#9670;&nbsp;</a></span>field_wrap_validator_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pydantic_core.core_schema.field_wrap_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a896d0dc92976c139adba63e86261bc26">WithInfoWrapValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4902289647cd4633e4dba0409d8ac5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4902289647cd4633e4dba0409d8ac5e">&#9670;&nbsp;</a></span>filter_dict_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IncExDictSerSchema.html">IncExDictSerSchema</a> pydantic_core.core_schema.filter_dict_schema </td>
          <td>(</td>
          <td class="paramtype">*<a class="el" href="namespacepydantic__core_1_1core__schema.html#ab8c04c509c5a0e68fcb1a1c77dd8316a">IncExDict</a> | None &#160;</td>
          <td class="paramname"><em>include</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ab8c04c509c5a0e68fcb1a1c77dd8316a">IncExDict</a> | None &#160;</td>
          <td class="paramname"><em>exclude</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90db849e0414bcb5a13fcdd0ef8b4d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90db849e0414bcb5a13fcdd0ef8b4d14">&#9670;&nbsp;</a></span>filter_seq_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IncExSeqSerSchema.html">IncExSeqSerSchema</a> pydantic_core.core_schema.filter_seq_schema </td>
          <td>(</td>
          <td class="paramtype">*set[int] | None &#160;</td>
          <td class="paramname"><em>include</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set[int] | None &#160;</td>
          <td class="paramname"><em>exclude</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3128bec308ccbf7e34fb1f3d6ecae9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3128bec308ccbf7e34fb1f3d6ecae9c1">&#9670;&nbsp;</a></span>filter_seq_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IncExSeqSerSchema.html">IncExSeqSerSchema</a> pydantic_core.core_schema.filter_seq_schema </td>
          <td>(</td>
          <td class="paramtype">*Set[int] | None &#160;</td>
          <td class="paramname"><em>include</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[int] | None &#160;</td>
          <td class="paramname"><em>exclude</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7386d71199f37d7a49166d4e898f3c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7386d71199f37d7a49166d4e898f3c41">&#9670;&nbsp;</a></span>float_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1FloatSchema.html">FloatSchema</a> pydantic_core.core_schema.float_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>allow_inf_nan</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>multiple_of</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a float value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.float_schema(le=0.8, ge=0.2)
v = SchemaValidator(schema)
assert v.validate_python('0.5') == 0.5
```

Args:
    allow_inf_nan: Whether to allow inf and nan values
    multiple_of: The value must be a multiple of this number
    le: The value must be less than or equal to this number
    ge: The value must be greater than or equal to this number
    lt: The value must be strictly less than this number
    gt: The value must be strictly greater than this number
    strict: Whether the value should be a float or a value that can be converted to a float
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a9f0ce5d18b93fd901c720d05b007b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0ce5d18b93fd901c720d05b007b6ed">&#9670;&nbsp;</a></span>float_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1FloatSchema.html">FloatSchema</a> pydantic_core.core_schema.float_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>allow_inf_nan</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>multiple_of</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a float value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.float_schema(le=0.8, ge=0.2)
v = SchemaValidator(schema)
assert v.validate_python('0.5') == 0.5
```

Args:
    allow_inf_nan: Whether to allow inf and nan values
    multiple_of: The value must be a multiple of this number
    le: The value must be less than or equal to this number
    ge: The value must be greater than or equal to this number
    lt: The value must be strictly less than this number
    gt: The value must be strictly greater than this number
    strict: Whether the value should be a float or a value that can be converted to a float
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aa2339fda59373d28d41a4ff02be93673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2339fda59373d28d41a4ff02be93673">&#9670;&nbsp;</a></span>format_ser_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpydantic__core_1_1core__schema_1_1FormatSerSchema.html">FormatSerSchema</a> pydantic_core.core_schema.format_ser_schema </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>formatting_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> &#160;</td>
          <td class="paramname"><em>when_used</em> = <code>'json-unless-none'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for serialization using python's `format` method.

Args:
    formatting_string: String defining the format to use
    when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default
</pre> 
</div>
</div>
<a id="a51e272b517025289d218bd8df9924ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e272b517025289d218bd8df9924ed0">&#9670;&nbsp;</a></span>frozenset_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1FrozenSetSchema.html">FrozenSetSchema</a> pydantic_core.core_schema.frozenset_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>fail_fast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a frozenset of a given schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.frozenset_schema(
    items_schema=core_schema.int_schema(), min_length=0, max_length=10
)
v = SchemaValidator(schema)
assert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2})
```

Args:
    items_schema: The value must be a frozenset with items that match this schema
    min_length: The value must be a frozenset with at least this many items
    max_length: The value must be a frozenset with at most this many items
    fail_fast: Stop validation on the first error
    strict: The value must be a frozenset with exactly this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="afbb4719ed9e643f1b92f984914a2a5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb4719ed9e643f1b92f984914a2a5e9">&#9670;&nbsp;</a></span>frozenset_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1FrozenSetSchema.html">FrozenSetSchema</a> pydantic_core.core_schema.frozenset_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>fail_fast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a frozenset of a given schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.frozenset_schema(
    items_schema=core_schema.int_schema(), min_length=0, max_length=10
)
v = SchemaValidator(schema)
assert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2})
```

Args:
    items_schema: The value must be a frozenset with items that match this schema
    min_length: The value must be a frozenset with at least this many items
    max_length: The value must be a frozenset with at most this many items
    fail_fast: Stop validation on the first error
    strict: The value must be a frozenset with exactly this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a01943e70fdc8634379adf7ca865e17e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01943e70fdc8634379adf7ca865e17e5">&#9670;&nbsp;</a></span>general_after_validator_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pydantic_core.core_schema.general_after_validator_function </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a178f04c08fae4b188e59ac678a908152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178f04c08fae4b188e59ac678a908152">&#9670;&nbsp;</a></span>general_before_validator_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pydantic_core.core_schema.general_before_validator_function </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd1f429306e49f579f74c3b63cdc412b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1f429306e49f579f74c3b63cdc412b">&#9670;&nbsp;</a></span>general_plain_validator_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pydantic_core.core_schema.general_plain_validator_function </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1d7fc7f2f2871c69f44832649d961de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d7fc7f2f2871c69f44832649d961de">&#9670;&nbsp;</a></span>general_wrap_validator_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pydantic_core.core_schema.general_wrap_validator_function </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f6cb5628cb3ade1875328b7245c30f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6cb5628cb3ade1875328b7245c30f7">&#9670;&nbsp;</a></span>generator_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1GeneratorSchema.html">GeneratorSchema</a> pydantic_core.core_schema.generator_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a generator value, e.g.:

```py
from typing import Iterator
from pydantic_core import SchemaValidator, core_schema

def gen() -&gt; Iterator[int]:
    yield 1

schema = core_schema.generator_schema(items_schema=core_schema.int_schema())
v = SchemaValidator(schema)
v.validate_python(gen())
```

Unlike other types, validated generators do not raise ValidationErrors eagerly,
but instead will raise a ValidationError when a violating value is actually read from the generator.
This is to ensure that "validated" generators retain the benefit of lazy evaluation.

Args:
    items_schema: The value must be a generator with items that match this schema
    min_length: The value must be a generator that yields at least this many items
    max_length: The value must be a generator that yields at most this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aefd4c1858dd8e269026bfb2c06ae8c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd4c1858dd8e269026bfb2c06ae8c6d">&#9670;&nbsp;</a></span>generator_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1GeneratorSchema.html">GeneratorSchema</a> pydantic_core.core_schema.generator_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a generator value, e.g.:

```py
from typing import Iterator
from pydantic_core import SchemaValidator, core_schema

def gen() -&gt; Iterator[int]:
    yield 1

schema = core_schema.generator_schema(items_schema=core_schema.int_schema())
v = SchemaValidator(schema)
v.validate_python(gen())
```

Unlike other types, validated generators do not raise ValidationErrors eagerly,
but instead will raise a ValidationError when a violating value is actually read from the generator.
This is to ensure that "validated" generators retain the benefit of lazy evaluation.

Args:
    items_schema: The value must be a generator with items that match this schema
    min_length: The value must be a generator that yields at least this many items
    max_length: The value must be a generator that yields at most this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ad4454e138f559f6872a187c769e1fd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4454e138f559f6872a187c769e1fd34">&#9670;&nbsp;</a></span>int_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IntSchema.html">IntSchema</a> pydantic_core.core_schema.int_schema </td>
          <td>(</td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>multiple_of</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a int value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.int_schema(multiple_of=2, le=6, ge=2)
v = SchemaValidator(schema)
assert v.validate_python('4') == 4
```

Args:
    multiple_of: The value must be a multiple of this number
    le: The value must be less than or equal to this number
    ge: The value must be greater than or equal to this number
    lt: The value must be strictly less than this number
    gt: The value must be strictly greater than this number
    strict: Whether the value should be a int or a value that can be converted to a int
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a42116e74818086adb240e3bb5a0c5fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42116e74818086adb240e3bb5a0c5fe2">&#9670;&nbsp;</a></span>int_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IntSchema.html">IntSchema</a> pydantic_core.core_schema.int_schema </td>
          <td>(</td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>multiple_of</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a int value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.int_schema(multiple_of=2, le=6, ge=2)
v = SchemaValidator(schema)
assert v.validate_python('4') == 4
```

Args:
    multiple_of: The value must be a multiple of this number
    le: The value must be less than or equal to this number
    ge: The value must be greater than or equal to this number
    lt: The value must be strictly less than this number
    gt: The value must be strictly greater than this number
    strict: Whether the value should be a int or a value that can be converted to a int
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a8416637b9eb59ae785443a334d417e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8416637b9eb59ae785443a334d417e12">&#9670;&nbsp;</a></span>invalid_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1InvalidSchema.html">InvalidSchema</a> pydantic_core.core_schema.invalid_schema </td>
          <td>(</td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an invalid schema, used to indicate that a schema is invalid.

    Returns a schema that matches any value, e.g.:

Args:
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
</pre> 
</div>
</div>
<a id="ac75af32cf0ba2c5122fbd9ab15e3bda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75af32cf0ba2c5122fbd9ab15e3bda0">&#9670;&nbsp;</a></span>invalid_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1InvalidSchema.html">InvalidSchema</a> pydantic_core.core_schema.invalid_schema </td>
          <td>(</td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an invalid schema, used to indicate that a schema is invalid.

    Returns a schema that matches any value, e.g.:

Args:
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
</pre> 
</div>
</div>
<a id="ac84ae727cf8645d15877303d784d15e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84ae727cf8645d15877303d784d15e5">&#9670;&nbsp;</a></span>is_instance_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a> pydantic_core.core_schema.is_instance_schema </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>cls_repr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that checks if a value is an instance of a class, equivalent to python's `isinstance` method, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

class A:
    pass

schema = core_schema.is_instance_schema(cls=A)
v = SchemaValidator(schema)
v.validate_python(A())
```

Args:
    cls: The value must be an instance of this class
    cls_repr: If provided this string is used in the validator name instead of `repr(cls)`
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a4b71e80667b51efdcfebeef441a8fe61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b71e80667b51efdcfebeef441a8fe61">&#9670;&nbsp;</a></span>is_instance_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a> pydantic_core.core_schema.is_instance_schema </td>
          <td>(</td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>cls_repr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that checks if a value is an instance of a class, equivalent to python's `isinstance` method, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

class A:
    pass

schema = core_schema.is_instance_schema(cls=A)
v = SchemaValidator(schema)
v.validate_python(A())
```

Args:
    cls: The value must be an instance of this class
    cls_repr: If provided this string is used in the validator name instead of `repr(cls)`
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a84b511f95de643f2f78af64e4151d6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b511f95de643f2f78af64e4151d6cd">&#9670;&nbsp;</a></span>is_subclass_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a> pydantic_core.core_schema.is_subclass_schema </td>
          <td>(</td>
          <td class="paramtype">type[Any]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>cls_repr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that checks if a value is a subtype of a class, equivalent to python's `issubclass` method, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

class A:
    pass

class B(A):
    pass

schema = core_schema.is_subclass_schema(cls=A)
v = SchemaValidator(schema)
v.validate_python(B)
```

Args:
    cls: The value must be a subclass of this class
    cls_repr: If provided this string is used in the validator name instead of `repr(cls)`
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a96b9337989af25481473a6b12ed0f652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b9337989af25481473a6b12ed0f652">&#9670;&nbsp;</a></span>is_subclass_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1IsInstanceSchema.html">IsInstanceSchema</a> pydantic_core.core_schema.is_subclass_schema </td>
          <td>(</td>
          <td class="paramtype">Type[Any]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>cls_repr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that checks if a value is a subtype of a class, equivalent to python's `issubclass` method, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

class A:
    pass

class B(A):
    pass

schema = core_schema.is_subclass_schema(cls=A)
v = SchemaValidator(schema)
v.validate_python(B)
```

Args:
    cls: The value must be a subclass of this class
    cls_repr: If provided this string is used in the validator name instead of `repr(cls)`
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a8af2bd31a34f7ca0c1066370cd8a7777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af2bd31a34f7ca0c1066370cd8a7777">&#9670;&nbsp;</a></span>json_or_python_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1JsonOrPythonSchema.html">JsonOrPythonSchema</a> pydantic_core.core_schema.json_or_python_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>json_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>python_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that uses the Json or Python schema depending on the input:

```py
from pydantic_core import SchemaValidator, ValidationError, core_schema

v = SchemaValidator(
    core_schema.json_or_python_schema(
        json_schema=core_schema.int_schema(),
        python_schema=core_schema.int_schema(strict=True),
    )
)

assert v.validate_json('"123"') == 123

try:
    v.validate_python('123')
except ValidationError:
    pass
else:
    raise AssertionError('Validation should have failed')
```

Args:
    json_schema: The schema to use for Json inputs
    python_schema: The schema to use for Python inputs
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a461b36ffbb7fb9eb09692c65a66ac7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461b36ffbb7fb9eb09692c65a66ac7fa">&#9670;&nbsp;</a></span>json_or_python_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1JsonOrPythonSchema.html">JsonOrPythonSchema</a> pydantic_core.core_schema.json_or_python_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>json_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>python_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that uses the Json or Python schema depending on the input:

```py
from pydantic_core import SchemaValidator, ValidationError, core_schema

v = SchemaValidator(
    core_schema.json_or_python_schema(
        json_schema=core_schema.int_schema(),
        python_schema=core_schema.int_schema(strict=True),
    )
)

assert v.validate_json('"123"') == 123

try:
    v.validate_python('123')
except ValidationError:
    pass
else:
    raise AssertionError('Validation should have failed')
```

Args:
    json_schema: The schema to use for Json inputs
    python_schema: The schema to use for Python inputs
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a6bf5d7251f63486d572348a75e8e146a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf5d7251f63486d572348a75e8e146a">&#9670;&nbsp;</a></span>json_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1JsonSchema.html">JsonSchema</a> pydantic_core.core_schema.json_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a JSON value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

dict_schema = core_schema.model_fields_schema(
    {
        'field_a': core_schema.model_field(core_schema.str_schema()),
        'field_b': core_schema.model_field(core_schema.bool_schema()),
    },
)

class MyModel:
    __slots__ = (
        '__dict__',
        '__pydantic_fields_set__',
        '__pydantic_extra__',
        '__pydantic_private__',
    )
    field_a: str
    field_b: bool

json_schema = core_schema.json_schema(schema=dict_schema)
schema = core_schema.model_schema(cls=MyModel, schema=json_schema)
v = SchemaValidator(schema)
m = v.validate_python('{"field_a": "hello", "field_b": true}')
assert isinstance(m, MyModel)
```

Args:
    schema: The schema to use for the JSON schema
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aa4bb8daa2645a289b27d3f2ad2d0f437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bb8daa2645a289b27d3f2ad2d0f437">&#9670;&nbsp;</a></span>json_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1JsonSchema.html">JsonSchema</a> pydantic_core.core_schema.json_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a JSON value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

dict_schema = core_schema.model_fields_schema(
    {
        'field_a': core_schema.model_field(core_schema.str_schema()),
        'field_b': core_schema.model_field(core_schema.bool_schema()),
    },
)

class MyModel:
    __slots__ = (
        '__dict__',
        '__pydantic_fields_set__',
        '__pydantic_extra__',
        '__pydantic_private__',
    )
    field_a: str
    field_b: bool

json_schema = core_schema.json_schema(schema=dict_schema)
schema = core_schema.model_schema(cls=MyModel, schema=json_schema)
v = SchemaValidator(schema)
m = v.validate_python('{"field_a": "hello", "field_b": true}')
assert isinstance(m, MyModel)
```

Args:
    schema: The schema to use for the JSON schema
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a137da1f068bb7c6be1a0ad3a062475a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137da1f068bb7c6be1a0ad3a062475a7">&#9670;&nbsp;</a></span>lax_or_strict_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1LaxOrStrictSchema.html">LaxOrStrictSchema</a> pydantic_core.core_schema.lax_or_strict_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>lax_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>strict_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that uses the lax or strict schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:
    assert 'hello' in v
    return v + ' world'

lax_schema = core_schema.int_schema(strict=False)
strict_schema = core_schema.int_schema(strict=True)

schema = core_schema.lax_or_strict_schema(
    lax_schema=lax_schema, strict_schema=strict_schema, strict=True
)
v = SchemaValidator(schema)
assert v.validate_python(123) == 123

schema = core_schema.lax_or_strict_schema(
    lax_schema=lax_schema, strict_schema=strict_schema, strict=False
)
v = SchemaValidator(schema)
assert v.validate_python('123') == 123
```

Args:
    lax_schema: The lax schema to use
    strict_schema: The strict schema to use
    strict: Whether the strict schema should be used
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a050b7319fa9a9bbef80fc14ead2c809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050b7319fa9a9bbef80fc14ead2c809d">&#9670;&nbsp;</a></span>lax_or_strict_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1LaxOrStrictSchema.html">LaxOrStrictSchema</a> pydantic_core.core_schema.lax_or_strict_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>lax_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>strict_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that uses the lax or strict schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:
    assert 'hello' in v
    return v + ' world'

lax_schema = core_schema.int_schema(strict=False)
strict_schema = core_schema.int_schema(strict=True)

schema = core_schema.lax_or_strict_schema(
    lax_schema=lax_schema, strict_schema=strict_schema, strict=True
)
v = SchemaValidator(schema)
assert v.validate_python(123) == 123

schema = core_schema.lax_or_strict_schema(
    lax_schema=lax_schema, strict_schema=strict_schema, strict=False
)
v = SchemaValidator(schema)
assert v.validate_python('123') == 123
```

Args:
    lax_schema: The lax schema to use
    strict_schema: The strict schema to use
    strict: Whether the strict schema should be used
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a2b6819aa9feda8604dfd8c9380951a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6819aa9feda8604dfd8c9380951a5c">&#9670;&nbsp;</a></span>list_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ListSchema.html">ListSchema</a> pydantic_core.core_schema.list_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>fail_fast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a list value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10)
v = SchemaValidator(schema)
assert v.validate_python(['4']) == [4]
```

Args:
    items_schema: The value must be a list of items that match this schema
    min_length: The value must be a list with at least this many items
    max_length: The value must be a list with at most this many items
    fail_fast: Stop validation on the first error
    strict: The value must be a list with exactly this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a681a5370127e15c726b1aba24879b01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681a5370127e15c726b1aba24879b01c">&#9670;&nbsp;</a></span>list_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ListSchema.html">ListSchema</a> pydantic_core.core_schema.list_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>fail_fast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a list value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10)
v = SchemaValidator(schema)
assert v.validate_python(['4']) == [4]
```

Args:
    items_schema: The value must be a list of items that match this schema
    min_length: The value must be a list with at least this many items
    max_length: The value must be a list with at most this many items
    fail_fast: Stop validation on the first error
    strict: The value must be a list with exactly this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aba274aa235f06a7eecf71645d4c0cda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba274aa235f06a7eecf71645d4c0cda8">&#9670;&nbsp;</a></span>literal_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1LiteralSchema.html">LiteralSchema</a> pydantic_core.core_schema.literal_schema </td>
          <td>(</td>
          <td class="paramtype">list[Any]&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a literal value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.literal_schema(['hello', 'world'])
v = SchemaValidator(schema)
assert v.validate_python('hello') == 'hello'
```

Args:
    expected: The value must be one of these values
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ab8a22cb43514ae3602be1667b2611bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a22cb43514ae3602be1667b2611bb2">&#9670;&nbsp;</a></span>literal_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1LiteralSchema.html">LiteralSchema</a> pydantic_core.core_schema.literal_schema </td>
          <td>(</td>
          <td class="paramtype">list[Any]&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a literal value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.literal_schema(['hello', 'world'])
v = SchemaValidator(schema)
assert v.validate_python('hello') == 'hello'
```

Args:
    expected: The value must be one of these values
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a7527b16e2a22840adb97a43b2f9b22d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7527b16e2a22840adb97a43b2f9b22d0">&#9670;&nbsp;</a></span>model_field() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a> pydantic_core.core_schema.model_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | list[str | int] | list[list[str | int]] | None &#160;</td>
          <td class="paramname"><em>validation_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>serialization_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>serialization_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>frozen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for a model field, e.g.:

```py
from pydantic_core import core_schema

field = core_schema.model_field(schema=core_schema.int_schema())
```

Args:
    schema: The schema to use for the field
    validation_alias: The alias(es) to use to find the field in the validation data
    serialization_alias: The alias to use as a key when serializing
    serialization_exclude: Whether to exclude the field when serializing
    frozen: Whether the field is frozen
    metadata: Any other information you want to include with the schema, not used by pydantic-core
</pre> 
</div>
</div>
<a id="af23e736cf44c26e2f4f964619a386612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23e736cf44c26e2f4f964619a386612">&#9670;&nbsp;</a></span>model_field() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a> pydantic_core.core_schema.model_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | list[str | int] | list[list[str | int]] | None &#160;</td>
          <td class="paramname"><em>validation_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>serialization_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>serialization_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>frozen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for a model field, e.g.:

```py
from pydantic_core import core_schema

field = core_schema.model_field(schema=core_schema.int_schema())
```

Args:
    schema: The schema to use for the field
    validation_alias: The alias(es) to use to find the field in the validation data
    serialization_alias: The alias to use as a key when serializing
    serialization_exclude: Whether to exclude the field when serializing
    frozen: Whether the field is frozen
    metadata: Any other information you want to include with the schema, not used by pydantic-core
</pre> 
</div>
</div>
<a id="abd759f4787a71146c2bdb3782ddc8fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd759f4787a71146c2bdb3782ddc8fc9">&#9670;&nbsp;</a></span>model_fields_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelFieldsSchema.html">ModelFieldsSchema</a> pydantic_core.core_schema.model_fields_schema </td>
          <td>(</td>
          <td class="paramtype">dict[str, <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a>]&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>model_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>] | None &#160;</td>
          <td class="paramname"><em>computed_fields</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>extras_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>extras_keys_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>from_attributes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches the fields of a Pydantic model, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

wrapper_schema = core_schema.model_fields_schema(
    {'a': core_schema.model_field(core_schema.str_schema())}
)
v = SchemaValidator(wrapper_schema)
print(v.validate_python({'a': 'hello'}))
#&gt; ({'a': 'hello'}, None, {'a'})
```

Args:
    fields: The fields of the model
    model_name: The name of the model, used for error messages, defaults to "Model"
    computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model
    strict: Whether the model is strict
    extras_schema: The schema to use when validating extra input data
    extras_keys_schema: The schema to use when validating the keys of extra input data
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    extra_behavior: The extra behavior to use for the model fields
    from_attributes: Whether the model fields should be populated from attributes
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a5702e00c78f3664a4f2355c3c6e507b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5702e00c78f3664a4f2355c3c6e507b9">&#9670;&nbsp;</a></span>model_fields_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelFieldsSchema.html">ModelFieldsSchema</a> pydantic_core.core_schema.model_fields_schema </td>
          <td>(</td>
          <td class="paramtype">Dict[str, <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelField.html">ModelField</a>]&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>model_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>] | None &#160;</td>
          <td class="paramname"><em>computed_fields</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>extras_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>populate_by_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>from_attributes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a typed dict, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

wrapper_schema = core_schema.model_fields_schema(
    {'a': core_schema.model_field(core_schema.str_schema())}
)
v = SchemaValidator(wrapper_schema)
print(v.validate_python({'a': 'hello'}))
#&gt; ({'a': 'hello'}, None, {'a'})
```

Args:
    fields: The fields to use for the typed dict
    model_name: The name of the model, used for error messages, defaults to "Model"
    computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model
    strict: Whether the typed dict is strict
    extras_schema: The extra validator to use for the typed dict
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    extra_behavior: The extra behavior to use for the typed dict
    populate_by_name: Whether the typed dict should populate by name
    from_attributes: Whether the typed dict should be populated from attributes
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a434383d3f2c5c21a2b040ae6b109e4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434383d3f2c5c21a2b040ae6b109e4d7">&#9670;&nbsp;</a></span>model_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSchema.html">ModelSchema</a> pydantic_core.core_schema.model_schema </td>
          <td>(</td>
          <td class="paramtype">type[Any]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*type[Any] | None &#160;</td>
          <td class="paramname"><em>generic_origin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>custom_init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>root_model</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>post_init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['always', 'never', 'subclass-instances'] | None &#160;</td>
          <td class="paramname"><em>revalidate_instances</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>frozen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A model schema generally contains a typed-dict schema.
It will run the typed dict validator, then create a new class
and set the dict and fields set returned from the typed dict validator
to `__dict__` and `__pydantic_fields_set__` respectively.

Example:

```py
from pydantic_core import CoreConfig, SchemaValidator, core_schema

class MyModel:
    __slots__ = (
        '__dict__',
        '__pydantic_fields_set__',
        '__pydantic_extra__',
        '__pydantic_private__',
    )

schema = core_schema.model_schema(
    cls=MyModel,
    config=CoreConfig(str_max_length=5),
    schema=core_schema.model_fields_schema(
        fields={'a': core_schema.model_field(core_schema.str_schema())},
    ),
)
v = SchemaValidator(schema)
assert v.isinstance_python({'a': 'hello'}) is True
assert v.isinstance_python({'a': 'too long'}) is False
```

Args:
    cls: The class to use for the model
    schema: The schema to use for the model
    generic_origin: The origin type used for this model, if it's a parametrized generic. Ex,
        if this model schema represents `SomeModel[int]`, generic_origin is `SomeModel`
    custom_init: Whether the model has a custom init method
    root_model: Whether the model is a `RootModel`
    post_init: The call after init to use for the model
    revalidate_instances: whether instances of models and dataclasses (including subclass instances)
        should re-validate defaults to config.revalidate_instances, else 'never'
    strict: Whether the model is strict
    frozen: Whether the model is frozen
    extra_behavior: The extra behavior to use for the model, used in serialization
    config: The config to use for the model
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a3e807b4874df3287b63c1ba754cd1ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e807b4874df3287b63c1ba754cd1ab0">&#9670;&nbsp;</a></span>model_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSchema.html">ModelSchema</a> pydantic_core.core_schema.model_schema </td>
          <td>(</td>
          <td class="paramtype">Type[Any]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Type[Any] | None &#160;</td>
          <td class="paramname"><em>generic_origin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>custom_init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>root_model</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>post_init</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['always', 'never', 'subclass-instances'] | None &#160;</td>
          <td class="paramname"><em>revalidate_instances</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>frozen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A model schema generally contains a typed-dict schema.
It will run the typed dict validator, then create a new class
and set the dict and fields set returned from the typed dict validator
to `__dict__` and `__pydantic_fields_set__` respectively.

Example:

```py
from pydantic_core import CoreConfig, SchemaValidator, core_schema

class MyModel:
    __slots__ = (
        '__dict__',
        '__pydantic_fields_set__',
        '__pydantic_extra__',
        '__pydantic_private__',
    )

schema = core_schema.model_schema(
    cls=MyModel,
    config=CoreConfig(str_max_length=5),
    schema=core_schema.model_fields_schema(
        fields={'a': core_schema.model_field(core_schema.str_schema())},
    ),
)
v = SchemaValidator(schema)
assert v.isinstance_python({'a': 'hello'}) is True
assert v.isinstance_python({'a': 'too long'}) is False
```

Args:
    cls: The class to use for the model
    schema: The schema to use for the model
    generic_origin: The origin type used for this model, if it's a parametrized generic. Ex,
        if this model schema represents `SomeModel[int]`, generic_origin is `SomeModel`
    custom_init: Whether the model has a custom init method
    root_model: Whether the model is a `RootModel`
    post_init: The call after init to use for the model
    revalidate_instances: whether instances of models and dataclasses (including subclass instances)
        should re-validate defaults to config.revalidate_instances, else 'never'
    strict: Whether the model is strict
    frozen: Whether the model is frozen
    extra_behavior: The extra behavior to use for the model, used in serialization
    config: The config to use for the model
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a3b53bb7ac0ca68effc114a4f6af43fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b53bb7ac0ca68effc114a4f6af43fd2">&#9670;&nbsp;</a></span>model_ser_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSerSchema.html">ModelSerSchema</a> pydantic_core.core_schema.model_ser_schema </td>
          <td>(</td>
          <td class="paramtype">type[Any]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for serialization using a model.

Args:
    cls: The expected class type, used to generate warnings if the wrong type is passed
    schema: Internal schema to use to serialize the model dict
</pre> 
</div>
</div>
<a id="a0a9efd5cba27602bb32e5e0c9b45c9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9efd5cba27602bb32e5e0c9b45c9cc">&#9670;&nbsp;</a></span>model_ser_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ModelSerSchema.html">ModelSerSchema</a> pydantic_core.core_schema.model_ser_schema </td>
          <td>(</td>
          <td class="paramtype">Type[Any]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for serialization using a model.

Args:
    cls: The expected class type, used to generate warnings if the wrong type is passed
    schema: Internal schema to use to serialize the model dict
</pre> 
</div>
</div>
<a id="a47009a20cb7f680b6bf21c0173532c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47009a20cb7f680b6bf21c0173532c2d">&#9670;&nbsp;</a></span>multi_host_url_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1MultiHostUrlSchema.html">MultiHostUrlSchema</a> pydantic_core.core_schema.multi_host_url_schema </td>
          <td>(</td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>allowed_schemes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>host_required</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>default_host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>default_port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>default_path</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a URL value with possibly multiple hosts, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.multi_host_url_schema()
v = SchemaValidator(schema)
print(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1'))
#&gt; redis://localhost,0.0.0.0,127.0.0.1
```

Args:
    max_length: The maximum length of the URL
    allowed_schemes: The allowed URL schemes
    host_required: Whether the URL must have a host
    default_host: The default host to use if the URL does not have a host
    default_port: The default port to use if the URL does not have a port
    default_path: The default path to use if the URL does not have a path
    strict: Whether to use strict URL parsing
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="acb90105625087facf31f95e01ae323b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb90105625087facf31f95e01ae323b7">&#9670;&nbsp;</a></span>multi_host_url_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1MultiHostUrlSchema.html">MultiHostUrlSchema</a> pydantic_core.core_schema.multi_host_url_schema </td>
          <td>(</td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>allowed_schemes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>host_required</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>default_host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>default_port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>default_path</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a URL value with possibly multiple hosts, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.multi_host_url_schema()
v = SchemaValidator(schema)
print(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1'))
#&gt; redis://localhost,0.0.0.0,127.0.0.1
```

Args:
    max_length: The maximum length of the URL
    allowed_schemes: The allowed URL schemes
    host_required: Whether the URL must have a host
    default_host: The default host to use if the URL does not have a host
    default_port: The default port to use if the URL does not have a port
    default_path: The default path to use if the URL does not have a path
    strict: Whether to use strict URL parsing
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a56732ab59cd05d428223fb37ab1b8290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56732ab59cd05d428223fb37ab1b8290">&#9670;&nbsp;</a></span>no_info_after_validator_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a> pydantic_core.core_schema.no_info_after_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that calls a validator function after validating, no `info` argument is provided, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str) -&gt; str:
    return v + 'world'

func_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema())
schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})

v = SchemaValidator(schema)
assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
```

Args:
    function: The validator function to call after the schema is validated
    schema: The schema to validate before the validator function
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="af182f4eca481fb4ecb1393b92b43e064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af182f4eca481fb4ecb1393b92b43e064">&#9670;&nbsp;</a></span>no_info_after_validator_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a> pydantic_core.core_schema.no_info_after_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that calls a validator function after validating, no `info` argument is provided, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str) -&gt; str:
    return v + 'world'

func_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema())
schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})

v = SchemaValidator(schema)
assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
```

Args:
    function: The validator function to call after the schema is validated
    schema: The schema to validate before the validator function
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a376fa8622f7e8bf91cd2cf8c6c901086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376fa8622f7e8bf91cd2cf8c6c901086">&#9670;&nbsp;</a></span>no_info_before_validator_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a> pydantic_core.core_schema.no_info_before_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that calls a validator function before validating, no `info` argument is provided, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: bytes) -&gt; str:
    return v.decode() + 'world'

func_schema = core_schema.no_info_before_validator_function(
    function=fn, schema=core_schema.str_schema()
)
schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})

v = SchemaValidator(schema)
assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
```

Args:
    function: The validator function to call
    schema: The schema to validate the output of the validator function
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ad6a377522ba287eac799ca9b47ecfd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a377522ba287eac799ca9b47ecfd8c">&#9670;&nbsp;</a></span>no_info_before_validator_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a> pydantic_core.core_schema.no_info_before_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that calls a validator function before validating, no `info` argument is provided, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: bytes) -&gt; str:
    return v.decode() + 'world'

func_schema = core_schema.no_info_before_validator_function(
    function=fn, schema=core_schema.str_schema()
)
schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})

v = SchemaValidator(schema)
assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
```

Args:
    function: The validator function to call
    schema: The schema to validate the output of the validator function
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a12a14facde9df75b4e2603fe6062041e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a14facde9df75b4e2603fe6062041e">&#9670;&nbsp;</a></span>no_info_plain_validator_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a> pydantic_core.core_schema.no_info_plain_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that uses the provided function for validation, no `info` argument is passed, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str) -&gt; str:
    assert 'hello' in v
    return v + 'world'

schema = core_schema.no_info_plain_validator_function(function=fn)
v = SchemaValidator(schema)
assert v.validate_python('hello ') == 'hello world'
```

Args:
    function: The validator function to call
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a305bf5025b8f806903919d645f89a647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305bf5025b8f806903919d645f89a647">&#9670;&nbsp;</a></span>no_info_plain_validator_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a> pydantic_core.core_schema.no_info_plain_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa3a51404ee4afb179fee56871a940e26">NoInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that uses the provided function for validation, no `info` argument is passed, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str) -&gt; str:
    assert 'hello' in v
    return v + 'world'

schema = core_schema.no_info_plain_validator_function(function=fn)
v = SchemaValidator(schema)
assert v.validate_python('hello ') == 'hello world'
```

Args:
    function: The validator function to call
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a3fece8fb833d6bedeabf86f37dfbbc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fece8fb833d6bedeabf86f37dfbbc54">&#9670;&nbsp;</a></span>no_info_wrap_validator_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a> pydantic_core.core_schema.no_info_wrap_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af2ffc255b7e6d49b678053bc1902e616">NoInfoWrapValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema which calls a function with a `validator` callable argument which can
optionally be used to call inner validation with the function logic, this is much like the
"onion" implementation of middleware in many popular web frameworks, no `info` argument is passed, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(
    v: str,
    validator: core_schema.ValidatorFunctionWrapHandler,
) -&gt; str:
    return validator(input_value=v) + 'world'

schema = core_schema.no_info_wrap_validator_function(
    function=fn, schema=core_schema.str_schema()
)
v = SchemaValidator(schema)
assert v.validate_python('hello ') == 'hello world'
```

Args:
    function: The validator function to call
    schema: The schema to validate the output of the validator function
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a27d43296b6a5dac9a35a7160e12e198d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d43296b6a5dac9a35a7160e12e198d">&#9670;&nbsp;</a></span>no_info_wrap_validator_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a> pydantic_core.core_schema.no_info_wrap_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af2ffc255b7e6d49b678053bc1902e616">NoInfoWrapValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema which calls a function with a `validator` callable argument which can
optionally be used to call inner validation with the function logic, this is much like the
"onion" implementation of middleware in many popular web frameworks, no `info` argument is passed, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(
    v: str,
    validator: core_schema.ValidatorFunctionWrapHandler,
) -&gt; str:
    return validator(input_value=v) + 'world'

schema = core_schema.no_info_wrap_validator_function(
    function=fn, schema=core_schema.str_schema()
)
v = SchemaValidator(schema)
assert v.validate_python('hello ') == 'hello world'
```

Args:
    function: The validator function to call
    schema: The schema to validate the output of the validator function
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a88db516ebdd23fa167e90527b61b9d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88db516ebdd23fa167e90527b61b9d0d">&#9670;&nbsp;</a></span>none_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1NoneSchema.html">NoneSchema</a> pydantic_core.core_schema.none_schema </td>
          <td>(</td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a None value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.none_schema()
v = SchemaValidator(schema)
assert v.validate_python(None) is None
```

Args:
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a47dc71f1c71b76dc43b151dc7d83cf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dc71f1c71b76dc43b151dc7d83cf5f">&#9670;&nbsp;</a></span>none_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1NoneSchema.html">NoneSchema</a> pydantic_core.core_schema.none_schema </td>
          <td>(</td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a None value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.none_schema()
v = SchemaValidator(schema)
assert v.validate_python(None) is None
```

Args:
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a4fb93d5142bc5d7c6e3efaaa80652b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb93d5142bc5d7c6e3efaaa80652b1e">&#9670;&nbsp;</a></span>nullable_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1NullableSchema.html">NullableSchema</a> pydantic_core.core_schema.nullable_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a nullable value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.nullable_schema(core_schema.str_schema())
v = SchemaValidator(schema)
assert v.validate_python(None) is None
```

Args:
    schema: The schema to wrap
    strict: Whether the underlying schema should be validated with strict mode
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aec9f86648abc860acaedb0b97ea6fc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9f86648abc860acaedb0b97ea6fc6e">&#9670;&nbsp;</a></span>nullable_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1NullableSchema.html">NullableSchema</a> pydantic_core.core_schema.nullable_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a nullable value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.nullable_schema(core_schema.str_schema())
v = SchemaValidator(schema)
assert v.validate_python(None) is None
```

Args:
    schema: The schema to wrap
    strict: Whether the underlying schema should be validated with strict mode
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a66ef6a81efd6e2097fe30d300489f369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ef6a81efd6e2097fe30d300489f369">&#9670;&nbsp;</a></span>plain_serializer_function_ser_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpydantic__core_1_1core__schema_1_1PlainSerializerFunctionSerSchema.html">PlainSerializerFunctionSerSchema</a> pydantic_core.core_schema.plain_serializer_function_ser_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a4c90031edbb2b8336ec6d1042e86b42c">SerializerFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>is_field_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>info_arg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>return_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> &#160;</td>
          <td class="paramname"><em>when_used</em> = <code>'always'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for serialization with a function, can be either a "general" or "field" function.

Args:
    function: The function to use for serialization
    is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,
        and `info` includes `field_name`
    info_arg: Whether the function takes an `info` argument
    return_schema: Schema to use for serializing return value
    when_used: When the function should be called
</pre> 
</div>
</div>
<a id="a5b02adb9519360d651fd12d7b98a8fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b02adb9519360d651fd12d7b98a8fbd">&#9670;&nbsp;</a></span>set_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1SetSchema.html">SetSchema</a> pydantic_core.core_schema.set_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>fail_fast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a set of a given schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.set_schema(
    items_schema=core_schema.int_schema(), min_length=0, max_length=10
)
v = SchemaValidator(schema)
assert v.validate_python({1, '2', 3}) == {1, 2, 3}
```

Args:
    items_schema: The value must be a set with items that match this schema
    min_length: The value must be a set with at least this many items
    max_length: The value must be a set with at most this many items
    fail_fast: Stop validation on the first error
    strict: The value must be a set with exactly this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a52e9fed1ab6f9c11b56fb12d92dd4c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e9fed1ab6f9c11b56fb12d92dd4c17">&#9670;&nbsp;</a></span>set_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1SetSchema.html">SetSchema</a> pydantic_core.core_schema.set_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>fail_fast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a set of a given schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.set_schema(
    items_schema=core_schema.int_schema(), min_length=0, max_length=10
)
v = SchemaValidator(schema)
assert v.validate_python({1, '2', 3}) == {1, 2, 3}
```

Args:
    items_schema: The value must be a set with items that match this schema
    min_length: The value must be a set with at least this many items
    max_length: The value must be a set with at most this many items
    fail_fast: Stop validation on the first error
    strict: The value must be a set with exactly this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ad6f5a84d4393b9ffa00970469bd3e3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f5a84d4393b9ffa00970469bd3e3c9">&#9670;&nbsp;</a></span>simple_ser_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpydantic__core_1_1core__schema_1_1SimpleSerSchema.html">SimpleSerSchema</a> pydantic_core.core_schema.simple_ser_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a7bbd0412ec2de43437346c4bdb133153">ExpectedSerializationTypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for serialization with a custom type.

Args:
    type: The type to use for serialization
</pre> 
</div>
</div>
<a id="a888475805a304dfac734056eca6411ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888475805a304dfac734056eca6411ad">&#9670;&nbsp;</a></span>str_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1StringSchema.html">StringSchema</a> pydantic_core.core_schema.str_schema </td>
          <td>(</td>
          <td class="paramtype">*str | Pattern[str] | None &#160;</td>
          <td class="paramname"><em>pattern</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strip_whitespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>to_lower</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>to_upper</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['rust-regex', 'python-re'] | None &#160;</td>
          <td class="paramname"><em>regex_engine</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>coerce_numbers_to_str</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a string value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.str_schema(max_length=10, min_length=2)
v = SchemaValidator(schema)
assert v.validate_python('hello') == 'hello'
```

Args:
    pattern: A regex pattern that the value must match
    max_length: The value must be at most this length
    min_length: The value must be at least this length
    strip_whitespace: Whether to strip whitespace from the value
    to_lower: Whether to convert the value to lowercase
    to_upper: Whether to convert the value to uppercase
    regex_engine: The regex engine to use for pattern validation. Default is 'rust-regex'.
        - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust
          crate, which is non-backtracking and therefore more DDoS
          resistant, but does not support all regex features.
        - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module,
          which supports all regex features, but may be slower.
    strict: Whether the value should be a string or a value that can be converted to a string
    coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ad16e74f15602e0f29e9b28383079c484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16e74f15602e0f29e9b28383079c484">&#9670;&nbsp;</a></span>str_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1StringSchema.html">StringSchema</a> pydantic_core.core_schema.str_schema </td>
          <td>(</td>
          <td class="paramtype">*str | Pattern[str] | None &#160;</td>
          <td class="paramname"><em>pattern</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strip_whitespace</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>to_lower</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>to_upper</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['rust-regex', 'python-re'] | None &#160;</td>
          <td class="paramname"><em>regex_engine</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>coerce_numbers_to_str</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a string value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.str_schema(max_length=10, min_length=2)
v = SchemaValidator(schema)
assert v.validate_python('hello') == 'hello'
```

Args:
    pattern: A regex pattern that the value must match
    max_length: The value must be at most this length
    min_length: The value must be at least this length
    strip_whitespace: Whether to strip whitespace from the value
    to_lower: Whether to convert the value to lowercase
    to_upper: Whether to convert the value to uppercase
    regex_engine: The regex engine to use for pattern validation. Default is 'rust-regex'.
        - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust
          crate, which is non-backtracking and therefore more DDoS
          resistant, but does not support all regex features.
        - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module,
          which supports all regex features, but may be slower.
    strict: Whether the value should be a string or a value that can be converted to a string
    coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ad2c201d39d7d3c11a6617940f3e08288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c201d39d7d3c11a6617940f3e08288">&#9670;&nbsp;</a></span>tagged_union_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TaggedUnionSchema.html">TaggedUnionSchema</a> pydantic_core.core_schema.tagged_union_schema </td>
          <td>(</td>
          <td class="paramtype">dict[Any, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str | int] | list[list[str | int]] | Callable[[Any], Any]&#160;</td>
          <td class="paramname"><em>discriminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>custom_error_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>custom_error_message</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, int | str | float] | None &#160;</td>
          <td class="paramname"><em>custom_error_context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>from_attributes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a tagged union value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

apple_schema = core_schema.typed_dict_schema(
    {
        'foo': core_schema.typed_dict_field(core_schema.str_schema()),
        'bar': core_schema.typed_dict_field(core_schema.int_schema()),
    }
)
banana_schema = core_schema.typed_dict_schema(
    {
        'foo': core_schema.typed_dict_field(core_schema.str_schema()),
        'spam': core_schema.typed_dict_field(
            core_schema.list_schema(items_schema=core_schema.int_schema())
        ),
    }
)
schema = core_schema.tagged_union_schema(
    choices={
        'apple': apple_schema,
        'banana': banana_schema,
    },
    discriminator='foo',
)
v = SchemaValidator(schema)
assert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123}
assert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == {
    'foo': 'banana',
    'spam': [1, 2, 3],
}
```

Args:
    choices: The schemas to match
        When retrieving a schema from `choices` using the discriminator value, if the value is a str,
        it should be fed back into the `choices` map until a schema is obtained
        (This approach is to prevent multiple ownership of a single schema in Rust)
    discriminator: The discriminator to use to determine the schema to use
        * If `discriminator` is a str, it is the name of the attribute to use as the discriminator
        * If `discriminator` is a list of int/str, it should be used as a "path" to access the discriminator
        * If `discriminator` is a list of lists, each inner list is a path, and the first path that exists is used
        * If `discriminator` is a callable, it should return the discriminator when called on the value to validate;
          the callable can return `None` to indicate that there is no matching discriminator present on the input
    custom_error_type: The custom error type to use if the validation fails
    custom_error_message: The custom error message to use if the validation fails
    custom_error_context: The custom error context to use if the validation fails
    strict: Whether the underlying schemas should be validated with strict mode
    from_attributes: Whether to use the attributes of the object to retrieve the discriminator value
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aa842d1b14279e68178ff160c5e708fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa842d1b14279e68178ff160c5e708fbb">&#9670;&nbsp;</a></span>tagged_union_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TaggedUnionSchema.html">TaggedUnionSchema</a> pydantic_core.core_schema.tagged_union_schema </td>
          <td>(</td>
          <td class="paramtype">Dict[Any, <a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str | int] | list[list[str | int]] | Callable[[Any], Any]&#160;</td>
          <td class="paramname"><em>discriminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>custom_error_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>custom_error_message</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, int | str | float] | None &#160;</td>
          <td class="paramname"><em>custom_error_context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>from_attributes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a tagged union value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

apple_schema = core_schema.typed_dict_schema(
    {
        'foo': core_schema.typed_dict_field(core_schema.str_schema()),
        'bar': core_schema.typed_dict_field(core_schema.int_schema()),
    }
)
banana_schema = core_schema.typed_dict_schema(
    {
        'foo': core_schema.typed_dict_field(core_schema.str_schema()),
        'spam': core_schema.typed_dict_field(
            core_schema.list_schema(items_schema=core_schema.int_schema())
        ),
    }
)
schema = core_schema.tagged_union_schema(
    choices={
        'apple': apple_schema,
        'banana': banana_schema,
    },
    discriminator='foo',
)
v = SchemaValidator(schema)
assert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123}
assert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == {
    'foo': 'banana',
    'spam': [1, 2, 3],
}
```

Args:
    choices: The schemas to match
        When retrieving a schema from `choices` using the discriminator value, if the value is a str,
        it should be fed back into the `choices` map until a schema is obtained
        (This approach is to prevent multiple ownership of a single schema in Rust)
    discriminator: The discriminator to use to determine the schema to use
        * If `discriminator` is a str, it is the name of the attribute to use as the discriminator
        * If `discriminator` is a list of int/str, it should be used as a "path" to access the discriminator
        * If `discriminator` is a list of lists, each inner list is a path, and the first path that exists is used
        * If `discriminator` is a callable, it should return the discriminator when called on the value to validate;
          the callable can return `None` to indicate that there is no matching discriminator present on the input
    custom_error_type: The custom error type to use if the validation fails
    custom_error_message: The custom error message to use if the validation fails
    custom_error_context: The custom error context to use if the validation fails
    strict: Whether the underlying schemas should be validated with strict mode
    from_attributes: Whether to use the attributes of the object to retrieve the discriminator value
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a96a5787eb52080007c2db1cc112f1dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a5787eb52080007c2db1cc112f1dd5">&#9670;&nbsp;</a></span>time_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TimeSchema.html">TimeSchema</a> pydantic_core.core_schema.time_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['aware', 'naive'] | int | None &#160;</td>
          <td class="paramname"><em>tz_constraint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['truncate', 'error'] &#160;</td>
          <td class="paramname"><em>microseconds_precision</em> = <code>'truncate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a time value, e.g.:

```py
from datetime import time
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0))
v = SchemaValidator(schema)
assert v.validate_python(time(9, 0, 0)) == time(9, 0, 0)
```

Args:
    strict: Whether the value should be a time or a value that can be converted to a time
    le: The value must be less than or equal to this time
    ge: The value must be greater than or equal to this time
    lt: The value must be strictly less than this time
    gt: The value must be strictly greater than this time
    tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset
    microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aa7b38dda47430da1e509b435f24f360d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b38dda47430da1e509b435f24f360d">&#9670;&nbsp;</a></span>time_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TimeSchema.html">TimeSchema</a> pydantic_core.core_schema.time_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['aware', 'naive'] | int | None &#160;</td>
          <td class="paramname"><em>tz_constraint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['truncate', 'error'] &#160;</td>
          <td class="paramname"><em>microseconds_precision</em> = <code>'truncate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a time value, e.g.:

```py
from datetime import time
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0))
v = SchemaValidator(schema)
assert v.validate_python(time(9, 0, 0)) == time(9, 0, 0)
```

Args:
    strict: Whether the value should be a time or a value that can be converted to a time
    le: The value must be less than or equal to this time
    ge: The value must be greater than or equal to this time
    lt: The value must be strictly less than this time
    gt: The value must be strictly greater than this time
    tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset
    microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a853b12867746b3e6ae77b7aad65ca796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853b12867746b3e6ae77b7aad65ca796">&#9670;&nbsp;</a></span>timedelta_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TimedeltaSchema.html">TimedeltaSchema</a> pydantic_core.core_schema.timedelta_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timedelta | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timedelta | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timedelta | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timedelta | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['truncate', 'error'] &#160;</td>
          <td class="paramname"><em>microseconds_precision</em> = <code>'truncate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a timedelta value, e.g.:

```py
from datetime import timedelta
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0))
v = SchemaValidator(schema)
assert v.validate_python(timedelta(hours=12)) == timedelta(hours=12)
```

Args:
    strict: Whether the value should be a timedelta or a value that can be converted to a timedelta
    le: The value must be less than or equal to this timedelta
    ge: The value must be greater than or equal to this timedelta
    lt: The value must be strictly less than this timedelta
    gt: The value must be strictly greater than this timedelta
    microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a41fb18971cf33bb336dd3981f6f733d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fb18971cf33bb336dd3981f6f733d0">&#9670;&nbsp;</a></span>timedelta_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TimedeltaSchema.html">TimedeltaSchema</a> pydantic_core.core_schema.timedelta_schema </td>
          <td>(</td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timedelta | None &#160;</td>
          <td class="paramname"><em>le</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timedelta | None &#160;</td>
          <td class="paramname"><em>ge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timedelta | None &#160;</td>
          <td class="paramname"><em>lt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timedelta | None &#160;</td>
          <td class="paramname"><em>gt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['truncate', 'error'] &#160;</td>
          <td class="paramname"><em>microseconds_precision</em> = <code>'truncate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a timedelta value, e.g.:

```py
from datetime import timedelta
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0))
v = SchemaValidator(schema)
assert v.validate_python(timedelta(hours=12)) == timedelta(hours=12)
```

Args:
    strict: Whether the value should be a timedelta or a value that can be converted to a timedelta
    le: The value must be less than or equal to this timedelta
    ge: The value must be greater than or equal to this timedelta
    lt: The value must be strictly less than this timedelta
    gt: The value must be strictly greater than this timedelta
    microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a2eee0dbbb33be4cc3a3e8d42a277402c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eee0dbbb33be4cc3a3e8d42a277402c">&#9670;&nbsp;</a></span>to_string_ser_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1ToStringSerSchema.html">ToStringSerSchema</a> pydantic_core.core_schema.to_string_ser_schema </td>
          <td>(</td>
          <td class="paramtype">*<a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> &#160;</td>
          <td class="paramname"><em>when_used</em> = <code>'json-unless-none'</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for serialization using python's `str()` / `__str__` method.

Args:
    when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default
</pre> 
</div>
</div>
<a id="ac0abe3574aee54b09f75f13b37b06ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0abe3574aee54b09f75f13b37b06ec1">&#9670;&nbsp;</a></span>tuple_positional_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a> pydantic_core.core_schema.tuple_positional_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>items_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>extras_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a tuple of schemas, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.tuple_positional_schema(
    [core_schema.int_schema(), core_schema.str_schema()]
)
v = SchemaValidator(schema)
assert v.validate_python((1, 'hello')) == (1, 'hello')
```

Args:
    items_schema: The value must be a tuple with items that match these schemas
    extras_schema: The value must be a tuple with items that match this schema
        This was inspired by JSON schema's `prefixItems` and `items` fields.
        In python's `typing.Tuple`, you can't specify a type for "extra" items -- they must all be the same type
        if the length is variable. So this field won't be set from a `typing.Tuple` annotation on a pydantic model.
    strict: The value must be a tuple with exactly this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ae5ac5d86fdd9ae24fc060a617a0f6976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ac5d86fdd9ae24fc060a617a0f6976">&#9670;&nbsp;</a></span>tuple_positional_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a> pydantic_core.core_schema.tuple_positional_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>items_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>extras_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a tuple of schemas, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.tuple_positional_schema(
    [core_schema.int_schema(), core_schema.str_schema()]
)
v = SchemaValidator(schema)
assert v.validate_python((1, 'hello')) == (1, 'hello')
```

Args:
    items_schema: The value must be a tuple with items that match these schemas
    extras_schema: The value must be a tuple with items that match this schema
        This was inspired by JSON schema's `prefixItems` and `items` fields.
        In python's `typing.Tuple`, you can't specify a type for "extra" items -- they must all be the same type
        if the length is variable. So this field won't be set from a `typing.Tuple` annotation on a pydantic model.
    strict: The value must be a tuple with exactly this many items
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a9780b7ca45f93c1a6ca74dd6d2c4ba35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9780b7ca45f93c1a6ca74dd6d2c4ba35">&#9670;&nbsp;</a></span>tuple_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a> pydantic_core.core_schema.tuple_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>items_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>variadic_item_index</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>fail_fast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a tuple of schemas, with an optional variadic item, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.tuple_schema(
    [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()],
    variadic_item_index=1,
)
v = SchemaValidator(schema)
assert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5)
```

Args:
    items_schema: The value must be a tuple with items that match these schemas
    variadic_item_index: The index of the schema in `items_schema` to be treated as variadic (following PEP 646)
    min_length: The value must be a tuple with at least this many items
    max_length: The value must be a tuple with at most this many items
    fail_fast: Stop validation on the first error
    strict: The value must be a tuple with exactly this many items
    ref: Optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="aa777e0334df823ca9cfbc6a8a0f86de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa777e0334df823ca9cfbc6a8a0f86de4">&#9670;&nbsp;</a></span>tuple_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a> pydantic_core.core_schema.tuple_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>]&#160;</td>
          <td class="paramname"><em>items_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>variadic_item_index</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>fail_fast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a tuple of schemas, with an optional variadic item, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.tuple_schema(
    [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()],
    variadic_item_index=1,
)
v = SchemaValidator(schema)
assert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5)
```

Args:
    items_schema: The value must be a tuple with items that match these schemas
    variadic_item_index: The index of the schema in `items_schema` to be treated as variadic (following PEP 646)
    min_length: The value must be a tuple with at least this many items
    max_length: The value must be a tuple with at most this many items
    fail_fast: Stop validation on the first error
    strict: The value must be a tuple with exactly this many items
    ref: Optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a354ed21d683bea05209bb5c219bebb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354ed21d683bea05209bb5c219bebb47">&#9670;&nbsp;</a></span>tuple_variable_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a> pydantic_core.core_schema.tuple_variable_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a tuple of a given schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.tuple_variable_schema(
    items_schema=core_schema.int_schema(), min_length=0, max_length=10
)
v = SchemaValidator(schema)
assert v.validate_python(('1', 2, 3)) == (1, 2, 3)
```

Args:
    items_schema: The value must be a tuple with items that match this schema
    min_length: The value must be a tuple with at least this many items
    max_length: The value must be a tuple with at most this many items
    strict: The value must be a tuple with exactly this many items
    ref: Optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a1b2f75fc2889709798b30272098950c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2f75fc2889709798b30272098950c9">&#9670;&nbsp;</a></span>tuple_variable_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TupleSchema.html">TupleSchema</a> pydantic_core.core_schema.tuple_variable_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>items_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#af6d30b36f99109cf3f8ae2c4b19b115b">IncExSeqOrElseSerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a tuple of a given schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.tuple_variable_schema(
    items_schema=core_schema.int_schema(), min_length=0, max_length=10
)
v = SchemaValidator(schema)
assert v.validate_python(('1', 2, 3)) == (1, 2, 3)
```

Args:
    items_schema: The value must be a tuple with items that match this schema
    min_length: The value must be a tuple with at least this many items
    max_length: The value must be a tuple with at most this many items
    strict: The value must be a tuple with exactly this many items
    ref: Optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ad0ce80bcb156baffa04526a93d074ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ce80bcb156baffa04526a93d074ba0">&#9670;&nbsp;</a></span>typed_dict_field() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a> pydantic_core.core_schema.typed_dict_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>required</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str | int] | list[list[str | int]] | None &#160;</td>
          <td class="paramname"><em>validation_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>serialization_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>serialization_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a typed dict field, e.g.:

```py
from pydantic_core import core_schema

field = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True)
```

Args:
    schema: The schema to use for the field
    required: Whether the field is required, otherwise uses the value from `total` on the typed dict
    validation_alias: The alias(es) to use to find the field in the validation data
    serialization_alias: The alias to use as a key when serializing
    serialization_exclude: Whether to exclude the field when serializing
    metadata: Any other information you want to include with the schema, not used by pydantic-core
</pre> 
</div>
</div>
<a id="ae4cc782d3bb190991bffa817798eafa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cc782d3bb190991bffa817798eafa5">&#9670;&nbsp;</a></span>typed_dict_field() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a> pydantic_core.core_schema.typed_dict_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>required</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str | int] | list[list[str | int]] | None &#160;</td>
          <td class="paramname"><em>validation_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>serialization_alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>serialization_exclude</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a typed dict field, e.g.:

```py
from pydantic_core import core_schema

field = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True)
```

Args:
    schema: The schema to use for the field
    required: Whether the field is required, otherwise uses the value from `total` on the typed dict
    validation_alias: The alias(es) to use to find the field in the validation data
    serialization_alias: The alias to use as a key when serializing
    serialization_exclude: Whether to exclude the field when serializing
    metadata: Any other information you want to include with the schema, not used by pydantic-core
</pre> 
</div>
</div>
<a id="a257bbc878e58121cb91121505c883bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257bbc878e58121cb91121505c883bf4">&#9670;&nbsp;</a></span>typed_dict_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictSchema.html">TypedDictSchema</a> pydantic_core.core_schema.typed_dict_schema </td>
          <td>(</td>
          <td class="paramtype">Dict[str, <a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a>]&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Type[Any] | None &#160;</td>
          <td class="paramname"><em>cls</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>] | None &#160;</td>
          <td class="paramname"><em>computed_fields</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>extras_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>total</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>populate_by_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a typed dict, e.g.:

```py
from typing_extensions import TypedDict

from pydantic_core import SchemaValidator, core_schema

class MyTypedDict(TypedDict):
    a: str

wrapper_schema = core_schema.typed_dict_schema(
    {'a': core_schema.typed_dict_field(core_schema.str_schema())}, cls=MyTypedDict
)
v = SchemaValidator(wrapper_schema)
assert v.validate_python({'a': 'hello'}) == {'a': 'hello'}
```

Args:
    fields: The fields to use for the typed dict
    cls: The class to use for the typed dict
    computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model
    strict: Whether the typed dict is strict
    extras_schema: The extra validator to use for the typed dict
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    extra_behavior: The extra behavior to use for the typed dict
    total: Whether the typed dict is total, otherwise uses `typed_dict_total` from config
    populate_by_name: Whether the typed dict should populate by name
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a270de99444e6019eece60c5f2e87ca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270de99444e6019eece60c5f2e87ca8d">&#9670;&nbsp;</a></span>typed_dict_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictSchema.html">TypedDictSchema</a> pydantic_core.core_schema.typed_dict_schema </td>
          <td>(</td>
          <td class="paramtype">dict[str, <a class="el" href="classpydantic__core_1_1core__schema_1_1TypedDictField.html">TypedDictField</a>]&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*type[Any] | None &#160;</td>
          <td class="paramname"><em>cls</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>cls_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="classpydantic__core_1_1core__schema_1_1ComputedField.html">ComputedField</a>] | None &#160;</td>
          <td class="paramname"><em>computed_fields</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>extras_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#acbe9638c9333cc7e5ac84efa9af70e57">ExtraBehavior</a> | None &#160;</td>
          <td class="paramname"><em>extra_behavior</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>total</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic__core_1_1core__schema_1_1CoreConfig.html">CoreConfig</a> | None &#160;</td>
          <td class="paramname"><em>config</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a typed dict, e.g.:

```py
from typing_extensions import TypedDict

from pydantic_core import SchemaValidator, core_schema

class MyTypedDict(TypedDict):
    a: str

wrapper_schema = core_schema.typed_dict_schema(
    {'a': core_schema.typed_dict_field(core_schema.str_schema())}, cls=MyTypedDict
)
v = SchemaValidator(wrapper_schema)
assert v.validate_python({'a': 'hello'}) == {'a': 'hello'}
```

Args:
    fields: The fields to use for the typed dict
    cls: The class to use for the typed dict
    cls_name: The name to use in error locations. Falls back to `cls.__name__`, or the validator name if no class
        is provided.
    computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model
    strict: Whether the typed dict is strict
    extras_schema: The extra validator to use for the typed dict
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    extra_behavior: The extra behavior to use for the typed dict
    total: Whether the typed dict is total, otherwise uses `typed_dict_total` from config
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a5d1e8605d5d402373644061ca27aaad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1e8605d5d402373644061ca27aaad9">&#9670;&nbsp;</a></span>union_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1UnionSchema.html">UnionSchema</a> pydantic_core.core_schema.union_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | tuple[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>, str]]&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>auto_collapse</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>custom_error_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>custom_error_message</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, str | int] | None &#160;</td>
          <td class="paramname"><em>custom_error_context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['smart', 'left_to_right'] | None &#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a union value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()])
v = SchemaValidator(schema)
assert v.validate_python('hello') == 'hello'
assert v.validate_python(1) == 1
```

Args:
    choices: The schemas to match. If a tuple, the second item is used as the label for the case.
    auto_collapse: whether to automatically collapse unions with one element to the inner validator, default true
    custom_error_type: The custom error type to use if the validation fails
    custom_error_message: The custom error message to use if the validation fails
    custom_error_context: The custom error context to use if the validation fails
    mode: How to select which choice to return
        * `smart` (default) will try to return the choice which is the closest match to the input value
        * `left_to_right` will return the first choice in `choices` which succeeds validation
    strict: Whether the underlying schemas should be validated with strict mode
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="acd50b324c05731092394286e95fe3804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd50b324c05731092394286e95fe3804">&#9670;&nbsp;</a></span>union_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1UnionSchema.html">UnionSchema</a> pydantic_core.core_schema.union_schema </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | tuple[<a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>, str]]&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>auto_collapse</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>custom_error_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>custom_error_message</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, str | int] | None &#160;</td>
          <td class="paramname"><em>custom_error_context</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['smart', 'left_to_right'] | None &#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a union value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()])
v = SchemaValidator(schema)
assert v.validate_python('hello') == 'hello'
assert v.validate_python(1) == 1
```

Args:
    choices: The schemas to match. If a tuple, the second item is used as the label for the case.
    auto_collapse: whether to automatically collapse unions with one element to the inner validator, default true
    custom_error_type: The custom error type to use if the validation fails
    custom_error_message: The custom error message to use if the validation fails
    custom_error_context: The custom error context to use if the validation fails
    mode: How to select which choice to return
        * `smart` (default) will try to return the choice which is the closest match to the input value
        * `left_to_right` will return the first choice in `choices` which succeeds validation
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a88f78676d7c92243e87be70b63624adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f78676d7c92243e87be70b63624adf">&#9670;&nbsp;</a></span>url_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1UrlSchema.html">UrlSchema</a> pydantic_core.core_schema.url_schema </td>
          <td>(</td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>allowed_schemes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>host_required</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>default_host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>default_port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>default_path</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a URL value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.url_schema()
v = SchemaValidator(schema)
print(v.validate_python('https://example.com'))
#&gt; https://example.com/
```

Args:
    max_length: The maximum length of the URL
    allowed_schemes: The allowed URL schemes
    host_required: Whether the URL must have a host
    default_host: The default host to use if the URL does not have a host
    default_port: The default port to use if the URL does not have a port
    default_path: The default path to use if the URL does not have a path
    strict: Whether to use strict URL parsing
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a1babc11e9a13ebcd811ef95d86f08467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1babc11e9a13ebcd811ef95d86f08467">&#9670;&nbsp;</a></span>url_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1UrlSchema.html">UrlSchema</a> pydantic_core.core_schema.url_schema </td>
          <td>(</td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>max_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>allowed_schemes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>host_required</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>default_host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>default_port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>default_path</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that matches a URL value, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.url_schema()
v = SchemaValidator(schema)
print(v.validate_python('https://example.com'))
#&gt; https://example.com/
```

Args:
    max_length: The maximum length of the URL
    allowed_schemes: The allowed URL schemes
    host_required: Whether the URL must have a host
    default_host: The default host to use if the URL does not have a host
    default_port: The default port to use if the URL does not have a port
    default_path: The default path to use if the URL does not have a path
    strict: Whether to use strict URL parsing
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="ad82443218460f42f40e5c08cb4dfde2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82443218460f42f40e5c08cb4dfde2f">&#9670;&nbsp;</a></span>uuid_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1UuidSchema.html">UuidSchema</a> pydantic_core.core_schema.uuid_schema </td>
          <td>(</td>
          <td class="paramtype">*Literal[1, 3, 4, 5, 6, 7, 8] | None &#160;</td>
          <td class="paramname"><em>version</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71083abc4fa401ba3747f4156b241380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71083abc4fa401ba3747f4156b241380">&#9670;&nbsp;</a></span>uuid_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1UuidSchema.html">UuidSchema</a> pydantic_core.core_schema.uuid_schema </td>
          <td>(</td>
          <td class="paramtype">*Literal[1, 3, 4, 5] | None &#160;</td>
          <td class="paramname"><em>version</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a987b07fe12e0c7d4fe7c516b812c8c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987b07fe12e0c7d4fe7c516b812c8c0f">&#9670;&nbsp;</a></span>with_default_schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1WithDefaultSchema.html">WithDefaultSchema</a> pydantic_core.core_schema.with_default_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Any &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad44474082711c0f342caf31af269622c">PydanticUndefined</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[Callable[[], Any], Callable[[dict[str, Any]], Any], None] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>default_factory_takes_data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['raise', 'omit', 'default'] | None &#160;</td>
          <td class="paramname"><em>on_error</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>validate_default</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that adds a default value to the given schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.with_default_schema(core_schema.str_schema(), default='hello')
wrapper_schema = core_schema.typed_dict_schema(
    {'a': core_schema.typed_dict_field(schema)}
)
v = SchemaValidator(wrapper_schema)
assert v.validate_python({}) == v.validate_python({'a': 'hello'})
```

Args:
    schema: The schema to add a default value to
    default: The default value to use
    default_factory: A callable that returns the default value to use
    default_factory_takes_data: Whether the default factory takes a validated data argument
    on_error: What to do if the schema validation fails. One of 'raise', 'omit', 'default'
    validate_default: Whether the default value should be validated
    strict: Whether the underlying schema should be validated with strict mode
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a463412f1242c6a21d859660105e3e710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463412f1242c6a21d859660105e3e710">&#9670;&nbsp;</a></span>with_default_schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1WithDefaultSchema.html">WithDefaultSchema</a> pydantic_core.core_schema.with_default_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Any &#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="namespacepydantic__core_1_1core__schema.html#ad44474082711c0f342caf31af269622c">PydanticUndefined</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[Callable[[], Any], Callable[[Dict[str, Any]], Any], None] &#160;</td>
          <td class="paramname"><em>default_factory</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>default_factory_takes_data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal['raise', 'omit', 'default'] | None &#160;</td>
          <td class="paramname"><em>on_error</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>validate_default</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>strict</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that adds a default value to the given schema, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

schema = core_schema.with_default_schema(core_schema.str_schema(), default='hello')
wrapper_schema = core_schema.typed_dict_schema(
    {'a': core_schema.typed_dict_field(schema)}
)
v = SchemaValidator(wrapper_schema)
assert v.validate_python({}) == v.validate_python({'a': 'hello'})
```

Args:
    schema: The schema to add a default value to
    default: The default value to use
    default_factory: A callable that returns the default value to use
    default_factory_takes_data: Whether the default factory takes a validated data argument
    on_error: What to do if the schema validation fails. One of 'raise', 'omit', 'default'
    validate_default: Whether the default value should be validated
    strict: Whether the underlying schema should be validated with strict mode
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a0a93679d6d74b1e84ef83092df1cc7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a93679d6d74b1e84ef83092df1cc7bf">&#9670;&nbsp;</a></span>with_info_after_validator_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a> pydantic_core.core_schema.with_info_after_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>field_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that calls a validator function after validation, the function is called with
an `info` argument, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:
    assert info.data is not None
    assert info.field_name is not None
    return v + 'world'

func_schema = core_schema.with_info_after_validator_function(
    function=fn, schema=core_schema.str_schema(), field_name='a'
)
schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})

v = SchemaValidator(schema)
assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
```

Args:
    function: The validator function to call after the schema is validated
    schema: The schema to validate before the validator function
    field_name: The name of the field this validators is applied to, if any
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a2ae441f2760861bf644bb2e1d2cd75e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae441f2760861bf644bb2e1d2cd75e3">&#9670;&nbsp;</a></span>with_info_after_validator_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1AfterValidatorFunctionSchema.html">AfterValidatorFunctionSchema</a> pydantic_core.core_schema.with_info_after_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>field_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that calls a validator function after validation, the function is called with
an `info` argument, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:
    assert info.data is not None
    assert info.field_name is not None
    return v + 'world'

func_schema = core_schema.with_info_after_validator_function(
    function=fn, schema=core_schema.str_schema(), field_name='a'
)
schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})

v = SchemaValidator(schema)
assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
```

Args:
    function: The validator function to call after the schema is validated
    schema: The schema to validate before the validator function
    field_name: The name of the field this validators is applied to, if any
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a18b2462e55aae88a3e16e1df70cf5845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b2462e55aae88a3e16e1df70cf5845">&#9670;&nbsp;</a></span>with_info_before_validator_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a> pydantic_core.core_schema.with_info_before_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>field_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that calls a validator function before validation, the function is called with
an `info` argument, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: bytes, info: core_schema.ValidationInfo) -&gt; str:
    assert info.data is not None
    assert info.field_name is not None
    return v.decode() + 'world'

func_schema = core_schema.with_info_before_validator_function(
    function=fn, schema=core_schema.str_schema(), field_name='a'
)
schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})

v = SchemaValidator(schema)
assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
```

Args:
    function: The validator function to call
    field_name: The name of the field
    schema: The schema to validate the output of the validator function
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a48eb24638c7e27af98ded2579ae86e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48eb24638c7e27af98ded2579ae86e3d">&#9670;&nbsp;</a></span>with_info_before_validator_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1BeforeValidatorFunctionSchema.html">BeforeValidatorFunctionSchema</a> pydantic_core.core_schema.with_info_before_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>field_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that calls a validator function before validation, the function is called with
an `info` argument, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: bytes, info: core_schema.ValidationInfo) -&gt; str:
    assert info.data is not None
    assert info.field_name is not None
    return v.decode() + 'world'

func_schema = core_schema.with_info_before_validator_function(
    function=fn, schema=core_schema.str_schema(), field_name='a'
)
schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})

v = SchemaValidator(schema)
assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
```

Args:
    function: The validator function to call
    field_name: The name of the field
    schema: The schema to validate the output of the validator function
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a2b22697c4023da20d715c0a9da0be9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b22697c4023da20d715c0a9da0be9ca">&#9670;&nbsp;</a></span>with_info_plain_validator_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a> pydantic_core.core_schema.with_info_plain_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>field_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that uses the provided function for validation, an `info` argument is passed, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:
    assert 'hello' in v
    return v + 'world'

schema = core_schema.with_info_plain_validator_function(function=fn)
v = SchemaValidator(schema)
assert v.validate_python('hello ') == 'hello world'
```

Args:
    function: The validator function to call
    field_name: The name of the field this validators is applied to, if any
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a2ca39a6a955d06c278ce4dff2ae4284a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca39a6a955d06c278ce4dff2ae4284a">&#9670;&nbsp;</a></span>with_info_plain_validator_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1PlainValidatorFunctionSchema.html">PlainValidatorFunctionSchema</a> pydantic_core.core_schema.with_info_plain_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a798d67527c262e5d1745dd33b8fd1458">WithInfoValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>field_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema that uses the provided function for validation, an `info` argument is passed, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:
    assert 'hello' in v
    return v + 'world'

schema = core_schema.with_info_plain_validator_function(function=fn)
v = SchemaValidator(schema)
assert v.validate_python('hello ') == 'hello world'
```

Args:
    function: The validator function to call
    field_name: The name of the field this validators is applied to, if any
    ref: optional unique identifier of the schema, used to reference the schema in other places
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a27e6c95005054619a489448f9a07f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e6c95005054619a489448f9a07f993">&#9670;&nbsp;</a></span>with_info_wrap_validator_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a> pydantic_core.core_schema.with_info_wrap_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a896d0dc92976c139adba63e86261bc26">WithInfoWrapValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>field_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema which calls a function with a `validator` callable argument which can
optionally be used to call inner validation with the function logic, this is much like the
"onion" implementation of middleware in many popular web frameworks, an `info` argument is also passed, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(
    v: str,
    validator: core_schema.ValidatorFunctionWrapHandler,
    info: core_schema.ValidationInfo,
) -&gt; str:
    return validator(input_value=v) + 'world'

schema = core_schema.with_info_wrap_validator_function(
    function=fn, schema=core_schema.str_schema()
)
v = SchemaValidator(schema)
assert v.validate_python('hello ') == 'hello world'
```

Args:
    function: The validator function to call
    schema: The schema to validate the output of the validator function
    field_name: The name of the field this validators is applied to, if any
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a320cb0c8007c41932ea5aec48bf90dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320cb0c8007c41932ea5aec48bf90dfd">&#9670;&nbsp;</a></span>with_info_wrap_validator_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic__core_1_1core__schema_1_1WrapValidatorFunctionSchema.html">WrapValidatorFunctionSchema</a> pydantic_core.core_schema.with_info_wrap_validator_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a896d0dc92976c139adba63e86261bc26">WithInfoWrapValidatorFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a>&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | None &#160;</td>
          <td class="paramname"><em>field_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>json_schema_input_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>ref</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>metadata</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a> | None &#160;</td>
          <td class="paramname"><em>serialization</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema which calls a function with a `validator` callable argument which can
optionally be used to call inner validation with the function logic, this is much like the
"onion" implementation of middleware in many popular web frameworks, an `info` argument is also passed, e.g.:

```py
from pydantic_core import SchemaValidator, core_schema

def fn(
    v: str,
    validator: core_schema.ValidatorFunctionWrapHandler,
    info: core_schema.ValidationInfo,
) -&gt; str:
    return validator(input_value=v) + 'world'

schema = core_schema.with_info_wrap_validator_function(
    function=fn, schema=core_schema.str_schema()
)
v = SchemaValidator(schema)
assert v.validate_python('hello ') == 'hello world'
```

Args:
    function: The validator function to call
    schema: The schema to validate the output of the validator function
    field_name: The name of the field this validators is applied to, if any
    json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type
    ref: optional unique identifier of the schema, used to reference the schema in other places
    metadata: Any other information you want to include with the schema, not used by pydantic-core
    serialization: Custom serialization schema
</pre> 
</div>
</div>
<a id="a4570f8d1bcb1b642c8d5d20172653336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4570f8d1bcb1b642c8d5d20172653336">&#9670;&nbsp;</a></span>wrap_serializer_function_ser_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpydantic__core_1_1core__schema_1_1WrapSerializerFunctionSerSchema.html">WrapSerializerFunctionSerSchema</a> pydantic_core.core_schema.wrap_serializer_function_ser_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#aa5d63a69ba9113025697eb0174ff9e07">WrapSerializerFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool | None &#160;</td>
          <td class="paramname"><em>is_field_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>info_arg</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#ae1e27232aa3bdf53839c4dd24c3e4f6c">CoreSchema</a> | None &#160;</td>
          <td class="paramname"><em>return_schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepydantic__core_1_1core__schema.html#a0b68cb9e550df04791a0708fbb45f492">WhenUsed</a> &#160;</td>
          <td class="paramname"><em>when_used</em> = <code>'always'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a schema for serialization with a wrap function, can be either a "general" or "field" function.

Args:
    function: The function to use for serialization
    is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,
        and `info` includes `field_name`
    info_arg: Whether the function takes an `info` argument
    schema: The schema to use for the inner serialization
    return_schema: Schema to use for serializing return value
    when_used: When the function should be called
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae1e27232aa3bdf53839c4dd24c3e4f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e27232aa3bdf53839c4dd24c3e4f6c">&#9670;&nbsp;</a></span>CoreSchema</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.CoreSchema</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e5c62f54ec9792ffac9829093b84a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5c62f54ec9792ffac9829093b84a18">&#9670;&nbsp;</a></span>CoreSchemaFieldType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.CoreSchemaFieldType = Literal['model-field', 'dataclass-field', 'typed-dict-field', 'computed-field']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c43da19d45322e6deb95ef84af95a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c43da19d45322e6deb95ef84af95a5d">&#9670;&nbsp;</a></span>CoreSchemaType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.CoreSchemaType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2e4aa2f01e0325d9fd0c6368410904f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e4aa2f01e0325d9fd0c6368410904f">&#9670;&nbsp;</a></span>ErrorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.ErrorType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bbd0412ec2de43437346c4bdb133153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbd0412ec2de43437346c4bdb133153">&#9670;&nbsp;</a></span>ExpectedSerializationTypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.ExpectedSerializationTypes</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  Literal[</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    <span class="stringliteral">&#39;none&#39;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    <span class="stringliteral">&#39;int&#39;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    <span class="stringliteral">&#39;bool&#39;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    <span class="stringliteral">&#39;float&#39;</span>,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    <span class="stringliteral">&#39;str&#39;</span>,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    <span class="stringliteral">&#39;bytes&#39;</span>,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    <span class="stringliteral">&#39;bytearray&#39;</span>,</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    <span class="stringliteral">&#39;list&#39;</span>,</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    <span class="stringliteral">&#39;tuple&#39;</span>,</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <span class="stringliteral">&#39;set&#39;</span>,</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <span class="stringliteral">&#39;frozenset&#39;</span>,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <span class="stringliteral">&#39;generator&#39;</span>,</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <span class="stringliteral">&#39;dict&#39;</span>,</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <span class="stringliteral">&#39;datetime&#39;</span>,</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="stringliteral">&#39;date&#39;</span>,</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <span class="stringliteral">&#39;time&#39;</span>,</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <span class="stringliteral">&#39;timedelta&#39;</span>,</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="stringliteral">&#39;url&#39;</span>,</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="stringliteral">&#39;multi-host-url&#39;</span>,</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="stringliteral">&#39;json&#39;</span>,</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="stringliteral">&#39;uuid&#39;</span>,</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="stringliteral">&#39;any&#39;</span>,</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;]</div>
</div><!-- fragment -->
</div>
</div>
<a id="acbe9638c9333cc7e5ac84efa9af70e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe9638c9333cc7e5ac84efa9af70e57">&#9670;&nbsp;</a></span>ExtraBehavior</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.ExtraBehavior = Literal['allow', 'forbid', 'ignore']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19294f90b7ab8dfdc6bebc2ecf87610f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19294f90b7ab8dfdc6bebc2ecf87610f">&#9670;&nbsp;</a></span>FieldPlainInfoSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.FieldPlainInfoSerializerFunction = Callable[[Any, Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1FieldSerializationInfo.html">FieldSerializationInfo</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5421024acc475c29c68be05a10a1f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5421024acc475c29c68be05a10a1f05">&#9670;&nbsp;</a></span>FieldPlainNoInfoSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.FieldPlainNoInfoSerializerFunction = Callable[[Any, Any], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3106556b401724f19e733c874e622604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3106556b401724f19e733c874e622604">&#9670;&nbsp;</a></span>FieldValidationInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.FieldValidationInfo = <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidationInfo.html">ValidationInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2149303d23acb1fc3077e026f2b00cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2149303d23acb1fc3077e026f2b00cc3">&#9670;&nbsp;</a></span>FieldWrapInfoSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.FieldWrapInfoSerializerFunction = Callable[[Any, Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1FieldSerializationInfo.html">FieldSerializationInfo</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a461dcf40c062ec06ec9306f5add54654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461dcf40c062ec06ec9306f5add54654">&#9670;&nbsp;</a></span>FieldWrapNoInfoSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.FieldWrapNoInfoSerializerFunction = Callable[[Any, Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15ca4738e230976679d29d39a5875a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ca4738e230976679d29d39a5875a89">&#9670;&nbsp;</a></span>GeneralPlainInfoSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.GeneralPlainInfoSerializerFunction = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializationInfo.html">SerializationInfo</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace46ed5d686c472d17a5b841be6da778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace46ed5d686c472d17a5b841be6da778">&#9670;&nbsp;</a></span>GeneralPlainNoInfoSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.GeneralPlainNoInfoSerializerFunction = Callable[[Any], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51132ba45da86c88348fa39ffa8ef5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51132ba45da86c88348fa39ffa8ef5ac">&#9670;&nbsp;</a></span>GeneralWrapInfoSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.GeneralWrapInfoSerializerFunction = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializationInfo.html">SerializationInfo</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66f4774e5e33bed2e21b12890514233d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f4774e5e33bed2e21b12890514233d">&#9670;&nbsp;</a></span>GeneralWrapNoInfoSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.GeneralWrapNoInfoSerializerFunction = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1SerializerFunctionWrapHandler.html">SerializerFunctionWrapHandler</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8c04c509c5a0e68fcb1a1c77dd8316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c04c509c5a0e68fcb1a1c77dd8316a">&#9670;&nbsp;</a></span>IncExDict</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.IncExDict = set[Union[int, str]]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2b8b7fb4c56957201d089b0ba3396bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b8b7fb4c56957201d089b0ba3396bc">&#9670;&nbsp;</a></span>IncExDictOrElseSerSchema</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.IncExDictOrElseSerSchema = Union[<a class="el" href="classpydantic__core_1_1core__schema_1_1IncExDictSerSchema.html">IncExDictSerSchema</a>, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6d30b36f99109cf3f8ae2c4b19b115b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d30b36f99109cf3f8ae2c4b19b115b">&#9670;&nbsp;</a></span>IncExSeqOrElseSerSchema</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.IncExSeqOrElseSerSchema = Union[<a class="el" href="classpydantic__core_1_1core__schema_1_1IncExSeqSerSchema.html">IncExSeqSerSchema</a>, <a class="el" href="namespacepydantic__core_1_1core__schema.html#a5872680b347a64205c3d98a22b734cb2">SerSchema</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa5eea34a357669a0a090380c82cca08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5eea34a357669a0a090380c82cca08">&#9670;&nbsp;</a></span>JsonType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.JsonType = Literal['null', 'bool', 'int', 'float', 'str', 'list', 'dict']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9845e26657a520e448083370526075a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9845e26657a520e448083370526075a">&#9670;&nbsp;</a></span>MYPY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic_core.core_schema.MYPY = False</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3a51404ee4afb179fee56871a940e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a51404ee4afb179fee56871a940e26">&#9670;&nbsp;</a></span>NoInfoValidatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.NoInfoValidatorFunction = Callable[[Any], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2ffc255b7e6d49b678053bc1902e616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ffc255b7e6d49b678053bc1902e616">&#9670;&nbsp;</a></span>NoInfoWrapValidatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.NoInfoWrapValidatorFunction = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidatorFunctionWrapHandler.html">ValidatorFunctionWrapHandler</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad44474082711c0f342caf31af269622c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44474082711c0f342caf31af269622c">&#9670;&nbsp;</a></span>PydanticUndefined</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.PydanticUndefined = object()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c90031edbb2b8336ec6d1042e86b42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c90031edbb2b8336ec6d1042e86b42c">&#9670;&nbsp;</a></span>SerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.SerializerFunction</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  Union[</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    GeneralPlainNoInfoSerializerFunction,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    GeneralPlainInfoSerializerFunction,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    FieldPlainNoInfoSerializerFunction,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    FieldPlainInfoSerializerFunction,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5872680b347a64205c3d98a22b734cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5872680b347a64205c3d98a22b734cb2">&#9670;&nbsp;</a></span>SerSchema</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.SerSchema</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  Union[</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    SimpleSerSchema,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PlainSerializerFunctionSerSchema,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    WrapSerializerFunctionSerSchema,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    FormatSerSchema,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ToStringSerSchema,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ModelSerSchema,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1975a804f8d7b4fc9ea27373cf65a1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1975a804f8d7b4fc9ea27373cf65a1ab">&#9670;&nbsp;</a></span>TypeAlias</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.TypeAlias</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae35372c6ef9a79fd34b96b0ecfb56c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35372c6ef9a79fd34b96b0ecfb56c04">&#9670;&nbsp;</a></span>ValidationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.ValidationFunction = Union[<a class="el" href="classpydantic__core_1_1core__schema_1_1NoInfoValidatorFunctionSchema.html">NoInfoValidatorFunctionSchema</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1WithInfoValidatorFunctionSchema.html">WithInfoValidatorFunctionSchema</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b68cb9e550df04791a0708fbb45f492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b68cb9e550df04791a0708fbb45f492">&#9670;&nbsp;</a></span>WhenUsed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.WhenUsed = Literal['always', 'unless-none', 'json', 'json-unless-none']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a798d67527c262e5d1745dd33b8fd1458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798d67527c262e5d1745dd33b8fd1458">&#9670;&nbsp;</a></span>WithInfoValidatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.WithInfoValidatorFunction = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidationInfo.html">ValidationInfo</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a896d0dc92976c139adba63e86261bc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896d0dc92976c139adba63e86261bc26">&#9670;&nbsp;</a></span>WithInfoWrapValidatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.WithInfoWrapValidatorFunction = Callable[[Any, <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidatorFunctionWrapHandler.html">ValidatorFunctionWrapHandler</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1ValidationInfo.html">ValidationInfo</a>], Any]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5d63a69ba9113025697eb0174ff9e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d63a69ba9113025697eb0174ff9e07">&#9670;&nbsp;</a></span>WrapSerializerFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.WrapSerializerFunction</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  Union[</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    GeneralWrapNoInfoSerializerFunction,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    GeneralWrapInfoSerializerFunction,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    FieldWrapNoInfoSerializerFunction,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    FieldWrapInfoSerializerFunction,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7572f2e2a5d1f6202194d3badece33e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7572f2e2a5d1f6202194d3badece33e3">&#9670;&nbsp;</a></span>WrapValidatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic_core.core_schema.WrapValidatorFunction = Union[<a class="el" href="classpydantic__core_1_1core__schema_1_1NoInfoWrapValidatorFunctionSchema.html">NoInfoWrapValidatorFunctionSchema</a>, <a class="el" href="classpydantic__core_1_1core__schema_1_1WithInfoWrapValidatorFunctionSchema.html">WithInfoWrapValidatorFunctionSchema</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
