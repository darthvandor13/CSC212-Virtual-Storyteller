<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sqlalchemy.orm.events.MapperEvents Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesqlalchemy.html">sqlalchemy</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1orm.html">orm</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1orm_1_1events.html">events</a></li><li class="navelem"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html">MapperEvents</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sqlalchemy.orm.events.MapperEvents Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for sqlalchemy.orm.events.MapperEvents:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents__inherit__graph.png" border="0" usemap="#asqlalchemy_8orm_8events_8MapperEvents_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sqlalchemy.orm.events.MapperEvents:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents__coll__graph.png" border="0" usemap="#asqlalchemy_8orm_8events_8MapperEvents_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f9ab0bc1ee202b058ad700b59ef9058"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a9f9ab0bc1ee202b058ad700b59ef9058">instrument_class</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, Type[_O] class_)</td></tr>
<tr class="separator:a9f9ab0bc1ee202b058ad700b59ef9058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996c5afb677bcd6188121c7348b7da39"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a996c5afb677bcd6188121c7348b7da39">after_mapper_constructed</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, Type[_O] class_)</td></tr>
<tr class="separator:a996c5afb677bcd6188121c7348b7da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990a085062060be826415bab12a637e9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a990a085062060be826415bab12a637e9">before_mapper_configured</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, Type[_O] class_)</td></tr>
<tr class="separator:a990a085062060be826415bab12a637e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac864c73f5bf033366d356546b0918519"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#ac864c73f5bf033366d356546b0918519">mapper_configured</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, Type[_O] class_)</td></tr>
<tr class="separator:ac864c73f5bf033366d356546b0918519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b11df16e5e69f08264f162cc984637"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a51b11df16e5e69f08264f162cc984637">before_configured</a> (self)</td></tr>
<tr class="separator:a51b11df16e5e69f08264f162cc984637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8afa453894f332b2a411aaee87b9b9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a0f8afa453894f332b2a411aaee87b9b9">after_configured</a> (self)</td></tr>
<tr class="separator:a0f8afa453894f332b2a411aaee87b9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78899bd009ddf91b945f45af1ad9f9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a1f78899bd009ddf91b945f45af1ad9f9">before_insert</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, _O target)</td></tr>
<tr class="separator:a1f78899bd009ddf91b945f45af1ad9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cbc7756a43acdfc7b4007c8b268911"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a01cbc7756a43acdfc7b4007c8b268911">after_insert</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, _O target)</td></tr>
<tr class="separator:a01cbc7756a43acdfc7b4007c8b268911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1ce66cfba2368f8be4626b202cc728"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a8c1ce66cfba2368f8be4626b202cc728">before_update</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, _O target)</td></tr>
<tr class="separator:a8c1ce66cfba2368f8be4626b202cc728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ddf42739ec141e3a4b22df4bee9826"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#a30ddf42739ec141e3a4b22df4bee9826">after_update</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, _O target)</td></tr>
<tr class="separator:a30ddf42739ec141e3a4b22df4bee9826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad053701c31dc334163196a6cb224910"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#aad053701c31dc334163196a6cb224910">before_delete</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, _O target)</td></tr>
<tr class="separator:aad053701c31dc334163196a6cb224910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b0c59532fe7b091ab3114cae8ad083"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1events_1_1MapperEvents.html#ae1b0c59532fe7b091ab3114cae8ad083">after_delete</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O] mapper, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> connection, _O target)</td></tr>
<tr class="separator:ae1b0c59532fe7b091ab3114cae8ad083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch.html">sqlalchemy.event.base._HasEventsDispatch</a></td></tr>
<tr class="memitem:a65b8d4888511c0d8993ee246df525f0d inherit pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1event_1_1attr_1_1__InstanceLevelDispatch.html">_InstanceLevelDispatch</a>[_ET]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch.html#a65b8d4888511c0d8993ee246df525f0d">__getattr__</a> (self, str name)</td></tr>
<tr class="separator:a65b8d4888511c0d8993ee246df525f0d inherit pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9026fd04cd9a1b42239d35300c03e03b inherit pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch.html#a9026fd04cd9a1b42239d35300c03e03b">__init_subclass__</a> (cls)</td></tr>
<tr class="separator:a9026fd04cd9a1b42239d35300c03e03b inherit pub_methods_classsqlalchemy_1_1event_1_1base_1_1__HasEventsDispatch"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Define events specific to mappings.

e.g.::

    from sqlalchemy import event


    def my_before_insert_listener(mapper, connection, target):
        # execute a stored procedure upon INSERT,
        # apply the value to the row to be inserted
        target.calculated_value = connection.execute(
            text("select my_special_function(%d)" % target.special_number)
        ).scalar()


    # associate the listener function with SomeClass,
    # to execute during the "before_insert" hook
    event.listen(SomeClass, "before_insert", my_before_insert_listener)

Available targets include:

* mapped classes
* unmapped superclasses of mapped or to-be-mapped classes
  (using the ``propagate=True`` flag)
* :class:`_orm.Mapper` objects
* the :class:`_orm.Mapper` class itself indicates listening for all
  mappers.

Mapper events provide hooks into critical sections of the
mapper, including those related to object instrumentation,
object loading, and object persistence. In particular, the
persistence methods :meth:`~.MapperEvents.before_insert`,
and :meth:`~.MapperEvents.before_update` are popular
places to augment the state being persisted - however, these
methods operate with several significant restrictions. The
user is encouraged to evaluate the
:meth:`.SessionEvents.before_flush` and
:meth:`.SessionEvents.after_flush` methods as more
flexible and user-friendly hooks in which to apply
additional database state during a flush.

When using :class:`.MapperEvents`, several modifiers are
available to the :func:`.event.listen` function.

:param propagate=False: When True, the event listener should
   be applied to all inheriting mappers and/or the mappers of
   inheriting classes, as well as any
   mapper which is the target of this listener.
:param raw=False: When True, the "target" argument passed
   to applicable event listener functions will be the
   instance's :class:`.InstanceState` management
   object, rather than the mapped instance itself.
:param retval=False: when True, the user-defined event function
   must have a return value, the purpose of which is either to
   control subsequent event propagation, or to otherwise alter
   the operation in progress by the mapper.   Possible return
   values are:

   * ``sqlalchemy.orm.interfaces.EXT_CONTINUE`` - continue event
     processing normally.
   * ``sqlalchemy.orm.interfaces.EXT_STOP`` - cancel all subsequent
     event handlers in the chain.
   * other values - the return value specified by specific listeners.</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0f8afa453894f332b2a411aaee87b9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8afa453894f332b2a411aaee87b9b9">&#9670;&nbsp;</a></span>after_configured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.after_configured </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Called after a series of mappers have been configured.

The :meth:`.MapperEvents.after_configured` event is invoked
each time the :func:`_orm.configure_mappers` function is
invoked, after the function has completed its work.
:func:`_orm.configure_mappers` is typically invoked
automatically as mappings are first used, as well as each time
new mappers have been made available and new mapper use is
detected.

Contrast this event to the :meth:`.MapperEvents.mapper_configured`
event, which is called on a per-mapper basis while the configuration
operation proceeds; unlike that event, when this event is invoked,
all cross-configurations (e.g. backrefs) will also have been made
available for any mappers that were pending.
Also contrast to :meth:`.MapperEvents.before_configured`,
which is invoked before the series of mappers has been configured.

This event can **only** be applied to the :class:`_orm.Mapper` class,
and not to individual mappings or
mapped classes.  It is only invoked for all mappings as a whole::

    from sqlalchemy.orm import Mapper


    @event.listens_for(Mapper, "after_configured")
    def go(): ...

Theoretically this event is called once per
application, but is actually called any time new mappers
have been affected by a :func:`_orm.configure_mappers`
call.   If new mappings are constructed after existing ones have
already been used, this event will likely be called again.  To ensure
that a particular event is only called once and no further, the
``once=True`` argument (new in 0.9.4) can be applied::

    from sqlalchemy.orm import mapper


    @event.listens_for(mapper, "after_configured", once=True)
    def go(): ...

.. seealso::

    :meth:`.MapperEvents.before_mapper_configured`

    :meth:`.MapperEvents.mapper_configured`

    :meth:`.MapperEvents.before_configured`</pre> 
</div>
</div>
<a id="ae1b0c59532fe7b091ab3114cae8ad083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b0c59532fe7b091ab3114cae8ad083">&#9670;&nbsp;</a></span>after_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.after_delete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_O
    &#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive an object instance after a DELETE statement
has been emitted corresponding to that instance.

.. note:: this event **only** applies to the
   :ref:`session flush operation &lt;session_flushing&gt;`
   and does **not** apply to the ORM DML operations described at
   :ref:`orm_expression_update_delete`.  To intercept ORM
   DML events, use :meth:`_orm.SessionEvents.do_orm_execute`.

This event is used to emit additional SQL statements on
the given connection as well as to perform application
specific bookkeeping related to a deletion event.

The event is often called for a batch of objects of the
same class after their DELETE statements have been emitted at
once in a previous step.

.. warning::

    Mapper-level flush events only allow **very limited operations**,
    on attributes local to the row being operated upon only,
    as well as allowing any SQL to be emitted on the given
    :class:`_engine.Connection`.  **Please read fully** the notes
    at :ref:`session_persistence_mapper` for guidelines on using
    these methods; generally, the :meth:`.SessionEvents.before_flush`
    method should be preferred for general on-flush changes.

:param mapper: the :class:`_orm.Mapper` which is the target
 of this event.
:param connection: the :class:`_engine.Connection` being used to
 emit DELETE statements for this instance.  This
 provides a handle into the current transaction on the
 target database specific to this instance.
:param target: the mapped instance being deleted.  If
 the event is configured with ``raw=True``, this will
 instead be the :class:`.InstanceState` state-management
 object associated with the instance.
:return: No return value is supported by this event.

.. seealso::

    :ref:`session_persistence_events`</pre> 
</div>
</div>
<a id="a01cbc7756a43acdfc7b4007c8b268911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01cbc7756a43acdfc7b4007c8b268911">&#9670;&nbsp;</a></span>after_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.after_insert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_O
    &#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive an object instance after an INSERT statement
is emitted corresponding to that instance.

.. note:: this event **only** applies to the
   :ref:`session flush operation &lt;session_flushing&gt;`
   and does **not** apply to the ORM DML operations described at
   :ref:`orm_expression_update_delete`.  To intercept ORM
   DML events, use :meth:`_orm.SessionEvents.do_orm_execute`.

This event is used to modify in-Python-only
state on the instance after an INSERT occurs, as well
as to emit additional SQL statements on the given
connection.

The event is often called for a batch of objects of the
same class after their INSERT statements have been
emitted at once in a previous step. In the extremely
rare case that this is not desirable, the
:class:`_orm.Mapper` object can be configured with ``batch=False``,
which will cause batches of instances to be broken up
into individual (and more poorly performing)
event-&gt;persist-&gt;event steps.

.. warning::

    Mapper-level flush events only allow **very limited operations**,
    on attributes local to the row being operated upon only,
    as well as allowing any SQL to be emitted on the given
    :class:`_engine.Connection`.  **Please read fully** the notes
    at :ref:`session_persistence_mapper` for guidelines on using
    these methods; generally, the :meth:`.SessionEvents.before_flush`
    method should be preferred for general on-flush changes.

:param mapper: the :class:`_orm.Mapper` which is the target
 of this event.
:param connection: the :class:`_engine.Connection` being used to
 emit INSERT statements for this instance.  This
 provides a handle into the current transaction on the
 target database specific to this instance.
:param target: the mapped instance being persisted.  If
 the event is configured with ``raw=True``, this will
 instead be the :class:`.InstanceState` state-management
 object associated with the instance.
:return: No return value is supported by this event.

.. seealso::

    :ref:`session_persistence_events`</pre> 
</div>
</div>
<a id="a996c5afb677bcd6188121c7348b7da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996c5afb677bcd6188121c7348b7da39">&#9670;&nbsp;</a></span>after_mapper_constructed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.after_mapper_constructed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type[_O]
    &#160;</td>
          <td class="paramname"><em>class_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive a class and mapper when the :class:`_orm.Mapper` has been
fully constructed.

This event is called after the initial constructor for
:class:`_orm.Mapper` completes.  This occurs after the
:meth:`_orm.MapperEvents.instrument_class` event and after the
:class:`_orm.Mapper` has done an initial pass of its arguments
to generate its collection of :class:`_orm.MapperProperty` objects,
which are accessible via the :meth:`_orm.Mapper.get_property`
method and the :attr:`_orm.Mapper.iterate_properties` attribute.

This event differs from the
:meth:`_orm.MapperEvents.before_mapper_configured` event in that it
is invoked within the constructor for :class:`_orm.Mapper`, rather
than within the :meth:`_orm.registry.configure` process.   Currently,
this event is the only one which is appropriate for handlers that
wish to create additional mapped classes in response to the
construction of this :class:`_orm.Mapper`, which will be part of the
same configure step when :meth:`_orm.registry.configure` next runs.

.. versionadded:: 2.0.2

.. seealso::

    :ref:`examples_versioning` - an example which illustrates the use
    of the :meth:`_orm.MapperEvents.before_mapper_configured`
    event to create new mappers to record change-audit histories on
    objects.</pre> 
</div>
</div>
<a id="a30ddf42739ec141e3a4b22df4bee9826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ddf42739ec141e3a4b22df4bee9826">&#9670;&nbsp;</a></span>after_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.after_update </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_O
    &#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive an object instance after an UPDATE statement
is emitted corresponding to that instance.

.. note:: this event **only** applies to the
   :ref:`session flush operation &lt;session_flushing&gt;`
   and does **not** apply to the ORM DML operations described at
   :ref:`orm_expression_update_delete`.  To intercept ORM
   DML events, use :meth:`_orm.SessionEvents.do_orm_execute`.

This event is used to modify in-Python-only
state on the instance after an UPDATE occurs, as well
as to emit additional SQL statements on the given
connection.

This method is called for all instances that are
marked as "dirty", *even those which have no net changes
to their column-based attributes*, and for which
no UPDATE statement has proceeded. An object is marked
as dirty when any of its column-based attributes have a
"set attribute" operation called or when any of its
collections are modified. If, at update time, no
column-based attributes have any net changes, no UPDATE
statement will be issued. This means that an instance
being sent to :meth:`~.MapperEvents.after_update` is
*not* a guarantee that an UPDATE statement has been
issued.

To detect if the column-based attributes on the object have net
changes, and therefore resulted in an UPDATE statement, use
``object_session(instance).is_modified(instance,
include_collections=False)``.

The event is often called for a batch of objects of the
same class after their UPDATE statements have been emitted at
once in a previous step. In the extremely rare case that
this is not desirable, the :class:`_orm.Mapper` can be
configured with ``batch=False``, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.

.. warning::

    Mapper-level flush events only allow **very limited operations**,
    on attributes local to the row being operated upon only,
    as well as allowing any SQL to be emitted on the given
    :class:`_engine.Connection`.  **Please read fully** the notes
    at :ref:`session_persistence_mapper` for guidelines on using
    these methods; generally, the :meth:`.SessionEvents.before_flush`
    method should be preferred for general on-flush changes.

:param mapper: the :class:`_orm.Mapper` which is the target
 of this event.
:param connection: the :class:`_engine.Connection` being used to
 emit UPDATE statements for this instance.  This
 provides a handle into the current transaction on the
 target database specific to this instance.
:param target: the mapped instance being persisted.  If
 the event is configured with ``raw=True``, this will
 instead be the :class:`.InstanceState` state-management
 object associated with the instance.
:return: No return value is supported by this event.

.. seealso::

    :ref:`session_persistence_events`</pre> 
</div>
</div>
<a id="a51b11df16e5e69f08264f162cc984637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b11df16e5e69f08264f162cc984637">&#9670;&nbsp;</a></span>before_configured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.before_configured </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Called before a series of mappers have been configured.

The :meth:`.MapperEvents.before_configured` event is invoked
each time the :func:`_orm.configure_mappers` function is
invoked, before the function has done any of its work.
:func:`_orm.configure_mappers` is typically invoked
automatically as mappings are first used, as well as each time
new mappers have been made available and new mapper use is
detected.

This event can **only** be applied to the :class:`_orm.Mapper` class,
and not to individual mappings or mapped classes. It is only invoked
for all mappings as a whole::

    from sqlalchemy.orm import Mapper


    @event.listens_for(Mapper, "before_configured")
    def go(): ...

Contrast this event to :meth:`.MapperEvents.after_configured`,
which is invoked after the series of mappers has been configured,
as well as :meth:`.MapperEvents.before_mapper_configured`
and :meth:`.MapperEvents.mapper_configured`, which are both invoked
on a per-mapper basis.

Theoretically this event is called once per
application, but is actually called any time new mappers
are to be affected by a :func:`_orm.configure_mappers`
call.   If new mappings are constructed after existing ones have
already been used, this event will likely be called again.  To ensure
that a particular event is only called once and no further, the
``once=True`` argument (new in 0.9.4) can be applied::

    from sqlalchemy.orm import mapper


    @event.listens_for(mapper, "before_configured", once=True)
    def go(): ...

.. seealso::

    :meth:`.MapperEvents.before_mapper_configured`

    :meth:`.MapperEvents.mapper_configured`

    :meth:`.MapperEvents.after_configured`</pre> 
</div>
</div>
<a id="aad053701c31dc334163196a6cb224910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad053701c31dc334163196a6cb224910">&#9670;&nbsp;</a></span>before_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.before_delete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_O
    &#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive an object instance before a DELETE statement
is emitted corresponding to that instance.

.. note:: this event **only** applies to the
   :ref:`session flush operation &lt;session_flushing&gt;`
   and does **not** apply to the ORM DML operations described at
   :ref:`orm_expression_update_delete`.  To intercept ORM
   DML events, use :meth:`_orm.SessionEvents.do_orm_execute`.

This event is used to emit additional SQL statements on
the given connection as well as to perform application
specific bookkeeping related to a deletion event.

The event is often called for a batch of objects of the
same class before their DELETE statements are emitted at
once in a later step.

.. warning::

    Mapper-level flush events only allow **very limited operations**,
    on attributes local to the row being operated upon only,
    as well as allowing any SQL to be emitted on the given
    :class:`_engine.Connection`.  **Please read fully** the notes
    at :ref:`session_persistence_mapper` for guidelines on using
    these methods; generally, the :meth:`.SessionEvents.before_flush`
    method should be preferred for general on-flush changes.

:param mapper: the :class:`_orm.Mapper` which is the target
 of this event.
:param connection: the :class:`_engine.Connection` being used to
 emit DELETE statements for this instance.  This
 provides a handle into the current transaction on the
 target database specific to this instance.
:param target: the mapped instance being deleted.  If
 the event is configured with ``raw=True``, this will
 instead be the :class:`.InstanceState` state-management
 object associated with the instance.
:return: No return value is supported by this event.

.. seealso::

    :ref:`session_persistence_events`</pre> 
</div>
</div>
<a id="a1f78899bd009ddf91b945f45af1ad9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f78899bd009ddf91b945f45af1ad9f9">&#9670;&nbsp;</a></span>before_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.before_insert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_O
    &#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive an object instance before an INSERT statement
is emitted corresponding to that instance.

.. note:: this event **only** applies to the
   :ref:`session flush operation &lt;session_flushing&gt;`
   and does **not** apply to the ORM DML operations described at
   :ref:`orm_expression_update_delete`.  To intercept ORM
   DML events, use :meth:`_orm.SessionEvents.do_orm_execute`.

This event is used to modify local, non-object related
attributes on the instance before an INSERT occurs, as well
as to emit additional SQL statements on the given
connection.

The event is often called for a batch of objects of the
same class before their INSERT statements are emitted at
once in a later step. In the extremely rare case that
this is not desirable, the :class:`_orm.Mapper` object can be
configured with ``batch=False``, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.

.. warning::

    Mapper-level flush events only allow **very limited operations**,
    on attributes local to the row being operated upon only,
    as well as allowing any SQL to be emitted on the given
    :class:`_engine.Connection`.  **Please read fully** the notes
    at :ref:`session_persistence_mapper` for guidelines on using
    these methods; generally, the :meth:`.SessionEvents.before_flush`
    method should be preferred for general on-flush changes.

:param mapper: the :class:`_orm.Mapper` which is the target
 of this event.
:param connection: the :class:`_engine.Connection` being used to
 emit INSERT statements for this instance.  This
 provides a handle into the current transaction on the
 target database specific to this instance.
:param target: the mapped instance being persisted.  If
 the event is configured with ``raw=True``, this will
 instead be the :class:`.InstanceState` state-management
 object associated with the instance.
:return: No return value is supported by this event.

.. seealso::

    :ref:`session_persistence_events`</pre> 
</div>
</div>
<a id="a990a085062060be826415bab12a637e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990a085062060be826415bab12a637e9">&#9670;&nbsp;</a></span>before_mapper_configured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.before_mapper_configured </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type[_O]
    &#160;</td>
          <td class="paramname"><em>class_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Called right before a specific mapper is to be configured.

This event is intended to allow a specific mapper to be skipped during
the configure step, by returning the :attr:`.orm.interfaces.EXT_SKIP`
symbol which indicates to the :func:`.configure_mappers` call that this
particular mapper (or hierarchy of mappers, if ``propagate=True`` is
used) should be skipped in the current configuration run. When one or
more mappers are skipped, the "new mappers" flag will remain set,
meaning the :func:`.configure_mappers` function will continue to be
called when mappers are used, to continue to try to configure all
available mappers.

In comparison to the other configure-level events,
:meth:`.MapperEvents.before_configured`,
:meth:`.MapperEvents.after_configured`, and
:meth:`.MapperEvents.mapper_configured`, the
:meth:`.MapperEvents.before_mapper_configured` event provides for a
meaningful return value when it is registered with the ``retval=True``
parameter.

.. versionadded:: 1.3

e.g.::

    from sqlalchemy.orm import EXT_SKIP

    Base = declarative_base()

    DontConfigureBase = declarative_base()


    @event.listens_for(
        DontConfigureBase,
        "before_mapper_configured",
        retval=True,
        propagate=True,
    )
    def dont_configure(mapper, cls):
        return EXT_SKIP

.. seealso::

    :meth:`.MapperEvents.before_configured`

    :meth:`.MapperEvents.after_configured`

    :meth:`.MapperEvents.mapper_configured`</pre> 
</div>
</div>
<a id="a8c1ce66cfba2368f8be4626b202cc728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1ce66cfba2368f8be4626b202cc728">&#9670;&nbsp;</a></span>before_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.before_update </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td>
          <td class="paramname"><em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_O
    &#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive an object instance before an UPDATE statement
is emitted corresponding to that instance.

.. note:: this event **only** applies to the
   :ref:`session flush operation &lt;session_flushing&gt;`
   and does **not** apply to the ORM DML operations described at
   :ref:`orm_expression_update_delete`.  To intercept ORM
   DML events, use :meth:`_orm.SessionEvents.do_orm_execute`.

This event is used to modify local, non-object related
attributes on the instance before an UPDATE occurs, as well
as to emit additional SQL statements on the given
connection.

This method is called for all instances that are
marked as "dirty", *even those which have no net changes
to their column-based attributes*. An object is marked
as dirty when any of its column-based attributes have a
"set attribute" operation called or when any of its
collections are modified. If, at update time, no
column-based attributes have any net changes, no UPDATE
statement will be issued. This means that an instance
being sent to :meth:`~.MapperEvents.before_update` is
*not* a guarantee that an UPDATE statement will be
issued, although you can affect the outcome here by
modifying attributes so that a net change in value does
exist.

To detect if the column-based attributes on the object have net
changes, and will therefore generate an UPDATE statement, use
``object_session(instance).is_modified(instance,
include_collections=False)``.

The event is often called for a batch of objects of the
same class before their UPDATE statements are emitted at
once in a later step. In the extremely rare case that
this is not desirable, the :class:`_orm.Mapper` can be
configured with ``batch=False``, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.

.. warning::

    Mapper-level flush events only allow **very limited operations**,
    on attributes local to the row being operated upon only,
    as well as allowing any SQL to be emitted on the given
    :class:`_engine.Connection`.  **Please read fully** the notes
    at :ref:`session_persistence_mapper` for guidelines on using
    these methods; generally, the :meth:`.SessionEvents.before_flush`
    method should be preferred for general on-flush changes.

:param mapper: the :class:`_orm.Mapper` which is the target
 of this event.
:param connection: the :class:`_engine.Connection` being used to
 emit UPDATE statements for this instance.  This
 provides a handle into the current transaction on the
 target database specific to this instance.
:param target: the mapped instance being persisted.  If
 the event is configured with ``raw=True``, this will
 instead be the :class:`.InstanceState` state-management
 object associated with the instance.
:return: No return value is supported by this event.

.. seealso::

    :ref:`session_persistence_events`</pre> 
</div>
</div>
<a id="a9f9ab0bc1ee202b058ad700b59ef9058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9ab0bc1ee202b058ad700b59ef9058">&#9670;&nbsp;</a></span>instrument_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.instrument_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type[_O]&#160;</td>
          <td class="paramname"><em>class_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive a class when the mapper is first constructed,
before instrumentation is applied to the mapped class.

This event is the earliest phase of mapper construction.
Most attributes of the mapper are not yet initialized.   To
receive an event within initial mapper construction where basic
state is available such as the :attr:`_orm.Mapper.attrs` collection,
the :meth:`_orm.MapperEvents.after_mapper_constructed` event may
be a better choice.

This listener can either be applied to the :class:`_orm.Mapper`
class overall, or to any un-mapped class which serves as a base
for classes that will be mapped (using the ``propagate=True`` flag)::

    Base = declarative_base()


    @event.listens_for(Base, "instrument_class", propagate=True)
    def on_new_class(mapper, cls_):
        "..."

:param mapper: the :class:`_orm.Mapper` which is the target
 of this event.
:param class\_: the mapped class.

.. seealso::

    :meth:`_orm.MapperEvents.after_mapper_constructed`</pre> 
</div>
</div>
<a id="ac864c73f5bf033366d356546b0918519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac864c73f5bf033366d356546b0918519">&#9670;&nbsp;</a></span>mapper_configured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.events.MapperEvents.mapper_configured </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type[_O]&#160;</td>
          <td class="paramname"><em>class_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Called when a specific mapper has completed its own configuration
within the scope of the :func:`.configure_mappers` call.

The :meth:`.MapperEvents.mapper_configured` event is invoked
for each mapper that is encountered when the
:func:`_orm.configure_mappers` function proceeds through the current
list of not-yet-configured mappers.
:func:`_orm.configure_mappers` is typically invoked
automatically as mappings are first used, as well as each time
new mappers have been made available and new mapper use is
detected.

When the event is called, the mapper should be in its final
state, but **not including backrefs** that may be invoked from
other mappers; they might still be pending within the
configuration operation.    Bidirectional relationships that
are instead configured via the
:paramref:`.orm.relationship.back_populates` argument
*will* be fully available, since this style of relationship does not
rely upon other possibly-not-configured mappers to know that they
exist.

For an event that is guaranteed to have **all** mappers ready
to go including backrefs that are defined only on other
mappings, use the :meth:`.MapperEvents.after_configured`
event; this event invokes only after all known mappings have been
fully configured.

The :meth:`.MapperEvents.mapper_configured` event, unlike
:meth:`.MapperEvents.before_configured` or
:meth:`.MapperEvents.after_configured`,
is called for each mapper/class individually, and the mapper is
passed to the event itself.  It also is called exactly once for
a particular mapper.  The event is therefore useful for
configurational steps that benefit from being invoked just once
on a specific mapper basis, which don't require that "backref"
configurations are necessarily ready yet.

:param mapper: the :class:`_orm.Mapper` which is the target
 of this event.
:param class\_: the mapped class.

.. seealso::

    :meth:`.MapperEvents.before_configured`

    :meth:`.MapperEvents.after_configured`

    :meth:`.MapperEvents.before_mapper_configured`</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>py3_env/lib/python3.10/site-packages/sqlalchemy/orm/<a class="el" href="py3__env_2lib_2python3_810_2site-packages_2sqlalchemy_2orm_2events_8py.html">events.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
