<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sqlalchemy.orm.strategy_options._AbstractLoad Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesqlalchemy.html">sqlalchemy</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1orm.html">orm</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1orm_1_1strategy__options.html">strategy_options</a></li><li class="navelem"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html">_AbstractLoad</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sqlalchemy.orm.strategy_options._AbstractLoad Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for sqlalchemy.orm.strategy_options._AbstractLoad:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad__inherit__graph.png" border="0" usemap="#asqlalchemy_8orm_8strategy__options_8__AbstractLoad_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sqlalchemy.orm.strategy_options._AbstractLoad:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad__coll__graph.png" border="0" usemap="#asqlalchemy_8orm_8strategy__options_8__AbstractLoad_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a476b3a08d8699672b2d9e1d9ed42f05c"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a476b3a08d8699672b2d9e1d9ed42f05c">contains_eager</a> (self, _AttrType attr, Optional[_FromClauseArgument] alias=None, <a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> _is_chain=False, <a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> _propagate_to_loaders=False)</td></tr>
<tr class="separator:a476b3a08d8699672b2d9e1d9ed42f05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf6f11ec852df76ba2142c2b5d7d706"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a8bf6f11ec852df76ba2142c2b5d7d706">load_only</a> (self, *_AttrType attrs, <a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> <a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#ab5cb845b805260e6f7ffc7a9e1498ed6">raiseload</a>=False)</td></tr>
<tr class="separator:a8bf6f11ec852df76ba2142c2b5d7d706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711ccba2f648dc5268fcefe55a4c94c6"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a711ccba2f648dc5268fcefe55a4c94c6">joinedload</a> (self, _AttrType attr, Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a>] innerjoin=None)</td></tr>
<tr class="separator:a711ccba2f648dc5268fcefe55a4c94c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9eb929328cb8536519f19e361dd287"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a1d9eb929328cb8536519f19e361dd287">subqueryload</a> (self, _AttrType attr)</td></tr>
<tr class="separator:a1d9eb929328cb8536519f19e361dd287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4126aeae0a304c901e494822888de9a"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#aa4126aeae0a304c901e494822888de9a">selectinload</a> (self, _AttrType attr, Optional[int] recursion_depth=None)</td></tr>
<tr class="separator:aa4126aeae0a304c901e494822888de9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a837784e9ae4d2a49ef2e19bde66f3b"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a7a837784e9ae4d2a49ef2e19bde66f3b">lazyload</a> (self, _AttrType attr)</td></tr>
<tr class="separator:a7a837784e9ae4d2a49ef2e19bde66f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3092614b50d63673296daf38863ab84f"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a3092614b50d63673296daf38863ab84f">immediateload</a> (self, _AttrType attr, Optional[int] recursion_depth=None)</td></tr>
<tr class="separator:a3092614b50d63673296daf38863ab84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03aed1c772edbf0fff4a924eb2b9e7b"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#ab03aed1c772edbf0fff4a924eb2b9e7b">noload</a> (self, _AttrType attr)</td></tr>
<tr class="separator:ab03aed1c772edbf0fff4a924eb2b9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cb845b805260e6f7ffc7a9e1498ed6"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#ab5cb845b805260e6f7ffc7a9e1498ed6">raiseload</a> (self, _AttrType attr, <a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> sql_only=False)</td></tr>
<tr class="separator:ab5cb845b805260e6f7ffc7a9e1498ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4775f24134b0163f95d2c59cb25e5821"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a4775f24134b0163f95d2c59cb25e5821">defaultload</a> (self, _AttrType attr)</td></tr>
<tr class="separator:a4775f24134b0163f95d2c59cb25e5821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1877e9f34fd9ed54c983df3b755c33"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#aaf1877e9f34fd9ed54c983df3b755c33">defer</a> (self, _AttrType key, <a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> <a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#ab5cb845b805260e6f7ffc7a9e1498ed6">raiseload</a>=False)</td></tr>
<tr class="separator:aaf1877e9f34fd9ed54c983df3b755c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e70c8b8e1df95905e46493e1bff67d"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a01e70c8b8e1df95905e46493e1bff67d">undefer</a> (self, _AttrType key)</td></tr>
<tr class="separator:a01e70c8b8e1df95905e46493e1bff67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71709e64ec4a862a4250dcba2db74074"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a71709e64ec4a862a4250dcba2db74074">undefer_group</a> (self, str name)</td></tr>
<tr class="separator:a71709e64ec4a862a4250dcba2db74074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b56b2d25dd77fa639b9486e155be03"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a57b56b2d25dd77fa639b9486e155be03">with_expression</a> (self, _AttrType key, _ColumnExpressionArgument[Any] expression)</td></tr>
<tr class="separator:a57b56b2d25dd77fa639b9486e155be03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bcaf8d49b28fbd19ae0dc2f8aabcde"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#af1bcaf8d49b28fbd19ae0dc2f8aabcde">selectin_polymorphic</a> (self, Iterable[Type[Any]] classes)</td></tr>
<tr class="separator:af1bcaf8d49b28fbd19ae0dc2f8aabcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12451ae5fe6bed19ead8d1a60a9845e9"><td class="memItemLeft" align="right" valign="top">Self&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a12451ae5fe6bed19ead8d1a60a9845e9">options</a> (self, *<a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html">_AbstractLoad</a> opts)</td></tr>
<tr class="separator:a12451ae5fe6bed19ead8d1a60a9845e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70aedb066ca6ec6e6da8e3bdeae1209"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#ac70aedb066ca6ec6e6da8e3bdeae1209">process_compile_state_replaced_entities</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1context_1_1ORMCompileState.html">ORMCompileState</a> compile_state, Sequence[<a class="el" href="classsqlalchemy_1_1orm_1_1context_1_1__MapperEntity.html">_MapperEntity</a>] mapper_entities)</td></tr>
<tr class="separator:ac70aedb066ca6ec6e6da8e3bdeae1209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189a131ea5564ec5f61667b9846b5260"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html#a189a131ea5564ec5f61667b9846b5260">process_compile_state</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1context_1_1ORMCompileState.html">ORMCompileState</a> compile_state)</td></tr>
<tr class="separator:a189a131ea5564ec5f61667b9846b5260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html">sqlalchemy.sql.visitors.HasTraverseInternals</a></td></tr>
<tr class="memitem:a3e8f0b9d578e1d7e0a1dc83df0f78f0e inherit pub_methods_classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals"><td class="memItemLeft" align="right" valign="top">Iterable[<a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html">HasTraverseInternals</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#a3e8f0b9d578e1d7e0a1dc83df0f78f0e">get_children</a> (self, *Tuple[str,...] omit_attrs=(), **Any kw)</td></tr>
<tr class="separator:a3e8f0b9d578e1d7e0a1dc83df0f78f0e inherit pub_methods_classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption.html">sqlalchemy.orm.interfaces.ORMOption</a></td></tr>
<tr class="memitem:a298a1ee92d3ee90b0919ab82d76931e7 inherit pub_static_attribs_classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption.html#a298a1ee92d3ee90b0919ab82d76931e7">propagate_to_loaders</a> = False</td></tr>
<tr class="separator:a298a1ee92d3ee90b0919ab82d76931e7 inherit pub_static_attribs_classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html">sqlalchemy.sql.visitors.HasTraverseInternals</a></td></tr>
<tr class="memitem:ad109107c4b478895bdfb78dadbd4ecc0 inherit pub_static_attribs_classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a></td></tr>
<tr class="separator:ad109107c4b478895bdfb78dadbd4ecc0 inherit pub_static_attribs_classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a476b3a08d8699672b2d9e1d9ed42f05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476b3a08d8699672b2d9e1d9ed42f05c">&#9670;&nbsp;</a></span>contains_eager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.contains_eager </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_FromClauseArgument] &#160;</td>
          <td class="paramname"><em>alias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> &#160;</td>
          <td class="paramname"><em>_is_chain</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> &#160;</td>
          <td class="paramname"><em>_propagate_to_loaders</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given attribute should be eagerly loaded from
columns stated manually in the query.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

The option is used in conjunction with an explicit join that loads
the desired rows, i.e.::

    sess.query(Order).join(Order.user).options(contains_eager(Order.user))

The above query would join from the ``Order`` entity to its related
``User`` entity, and the returned ``Order`` objects would have the
``Order.user`` attribute pre-populated.

It may also be used for customizing the entries in an eagerly loaded
collection; queries will normally want to use the
:ref:`orm_queryguide_populate_existing` execution option assuming the
primary collection of parent objects may already have been loaded::

    sess.query(User).join(User.addresses).filter(
        Address.email_address.like("%@aol.com")
    ).options(contains_eager(User.addresses)).populate_existing()

See the section :ref:`contains_eager` for complete usage details.

.. seealso::

    :ref:`loading_toplevel`

    :ref:`contains_eager`</pre> 
</div>
</div>
<a id="a4775f24134b0163f95d2c59cb25e5821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4775f24134b0163f95d2c59cb25e5821">&#9670;&nbsp;</a></span>defaultload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.defaultload </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate an attribute should load using its predefined loader style.

The behavior of this loading option is to not change the current
loading style of the attribute, meaning that the previously configured
one is used or, if no previous style was selected, the default
loading will be used.

This method is used to link to other loader options further into
a chain of attributes without altering the loader style of the links
along the chain.  For example, to set joined eager loading for an
element of an element::

    session.query(MyClass).options(
        defaultload(MyClass.someattribute).joinedload(
            MyOtherClass.someotherattribute
        )
    )

:func:`.defaultload` is also useful for setting column-level options on
a related class, namely that of :func:`.defer` and :func:`.undefer`::

    session.scalars(
        select(MyClass).options(
            defaultload(MyClass.someattribute)
            .defer("some_column")
            .undefer("some_other_column")
        )
    )

.. seealso::

    :ref:`orm_queryguide_relationship_sub_options`

    :meth:`_orm.Load.options`</pre> 
</div>
</div>
<a id="aaf1877e9f34fd9ed54c983df3b755c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1877e9f34fd9ed54c983df3b755c33">&#9670;&nbsp;</a></span>defer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.defer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> &#160;</td>
          <td class="paramname"><em>raiseload</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given column-oriented attribute should be
deferred, e.g. not loaded until accessed.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

e.g.::

    from sqlalchemy.orm import defer

    session.query(MyClass).options(
        defer(MyClass.attribute_one), defer(MyClass.attribute_two)
    )

To specify a deferred load of an attribute on a related class,
the path can be specified one token at a time, specifying the loading
style for each link along the chain.  To leave the loading style
for a link unchanged, use :func:`_orm.defaultload`::

    session.query(MyClass).options(
        defaultload(MyClass.someattr).defer(RelatedClass.some_column)
    )

Multiple deferral options related to a relationship can be bundled
at once using :meth:`_orm.Load.options`::


    select(MyClass).options(
        defaultload(MyClass.someattr).options(
            defer(RelatedClass.some_column),
            defer(RelatedClass.some_other_column),
            defer(RelatedClass.another_column),
        )
    )

:param key: Attribute to be deferred.

:param raiseload: raise :class:`.InvalidRequestError` rather than
 lazy loading a value when the deferred attribute is accessed. Used
 to prevent unwanted SQL from being emitted.

.. versionadded:: 1.4

.. seealso::

    :ref:`orm_queryguide_column_deferral` - in the
    :ref:`queryguide_toplevel`

    :func:`_orm.load_only`

    :func:`_orm.undefer`</pre> 
</div>
</div>
<a id="a3092614b50d63673296daf38863ab84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3092614b50d63673296daf38863ab84f">&#9670;&nbsp;</a></span>immediateload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.immediateload </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int] &#160;</td>
          <td class="paramname"><em>recursion_depth</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given attribute should be loaded using
an immediate load with a per-attribute SELECT statement.

The load is achieved using the "lazyloader" strategy and does not
fire off any additional eager loaders.

The :func:`.immediateload` option is superseded in general
by the :func:`.selectinload` option, which performs the same task
more efficiently by emitting a SELECT for all loaded objects.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

:param recursion_depth: optional int; when set to a positive integer
 in conjunction with a self-referential relationship,
 indicates "selectin" loading will continue that many levels deep
 automatically until no items are found.

 .. note:: The :paramref:`_orm.immediateload.recursion_depth` option
    currently supports only self-referential relationships.  There
    is not yet an option to automatically traverse recursive structures
    with more than one relationship involved.

 .. warning:: This parameter is new and experimental and should be
    treated as "alpha" status

 .. versionadded:: 2.0 added
    :paramref:`_orm.immediateload.recursion_depth`


.. seealso::

    :ref:`loading_toplevel`

    :ref:`selectin_eager_loading`</pre> 
</div>
</div>
<a id="a711ccba2f648dc5268fcefe55a4c94c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711ccba2f648dc5268fcefe55a4c94c6">&#9670;&nbsp;</a></span>joinedload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.joinedload </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a>] &#160;</td>
          <td class="paramname"><em>innerjoin</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given attribute should be loaded using joined
eager loading.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

examples::

    # joined-load the "orders" collection on "User"
    select(User).options(joinedload(User.orders))

    # joined-load Order.items and then Item.keywords
    select(Order).options(joinedload(Order.items).joinedload(Item.keywords))

    # lazily load Order.items, but when Items are loaded,
    # joined-load the keywords collection
    select(Order).options(lazyload(Order.items).joinedload(Item.keywords))

:param innerjoin: if ``True``, indicates that the joined eager load
 should use an inner join instead of the default of left outer join::

    select(Order).options(joinedload(Order.user, innerjoin=True))

In order to chain multiple eager joins together where some may be
OUTER and others INNER, right-nested joins are used to link them::

    select(A).options(
        joinedload(A.bs, innerjoin=False).joinedload(B.cs, innerjoin=True)
    )

The above query, linking A.bs via "outer" join and B.cs via "inner"
join would render the joins as "a LEFT OUTER JOIN (b JOIN c)". When
using older versions of SQLite (&lt; 3.7.16), this form of JOIN is
translated to use full subqueries as this syntax is otherwise not
directly supported.

The ``innerjoin`` flag can also be stated with the term ``"unnested"``.
This indicates that an INNER JOIN should be used, *unless* the join
is linked to a LEFT OUTER JOIN to the left, in which case it
will render as LEFT OUTER JOIN.  For example, supposing ``A.bs``
is an outerjoin::

    select(A).options(joinedload(A.bs).joinedload(B.cs, innerjoin="unnested"))

The above join will render as "a LEFT OUTER JOIN b LEFT OUTER JOIN c",
rather than as "a LEFT OUTER JOIN (b JOIN c)".

.. note:: The "unnested" flag does **not** affect the JOIN rendered
    from a many-to-many association table, e.g. a table configured as
    :paramref:`_orm.relationship.secondary`, to the target table; for
    correctness of results, these joins are always INNER and are
    therefore right-nested if linked to an OUTER join.

.. note::

    The joins produced by :func:`_orm.joinedload` are **anonymously
    aliased**. The criteria by which the join proceeds cannot be
    modified, nor can the ORM-enabled :class:`_sql.Select` or legacy
    :class:`_query.Query` refer to these joins in any way, including
    ordering. See :ref:`zen_of_eager_loading` for further detail.

    To produce a specific SQL JOIN which is explicitly available, use
    :meth:`_sql.Select.join` and :meth:`_query.Query.join`. To combine
    explicit JOINs with eager loading of collections, use
    :func:`_orm.contains_eager`; see :ref:`contains_eager`.

.. seealso::

    :ref:`loading_toplevel`

    :ref:`joined_eager_loading`</pre> 
</div>
</div>
<a id="a7a837784e9ae4d2a49ef2e19bde66f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a837784e9ae4d2a49ef2e19bde66f3b">&#9670;&nbsp;</a></span>lazyload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.lazyload </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given attribute should be loaded using "lazy"
loading.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

.. seealso::

    :ref:`loading_toplevel`

    :ref:`lazy_loading`</pre> 
</div>
</div>
<a id="a8bf6f11ec852df76ba2142c2b5d7d706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf6f11ec852df76ba2142c2b5d7d706">&#9670;&nbsp;</a></span>load_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.load_only </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_AttrType&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> &#160;</td>
          <td class="paramname"><em>raiseload</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that for a particular entity, only the given list
of column-based attribute names should be loaded; all others will be
deferred.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

Example - given a class ``User``, load only the ``name`` and
``fullname`` attributes::

    session.query(User).options(load_only(User.name, User.fullname))

Example - given a relationship ``User.addresses -&gt; Address``, specify
subquery loading for the ``User.addresses`` collection, but on each
``Address`` object load only the ``email_address`` attribute::

    session.query(User).options(
        subqueryload(User.addresses).load_only(Address.email_address)
    )

For a statement that has multiple entities,
the lead entity can be
specifically referred to using the :class:`_orm.Load` constructor::

    stmt = (
        select(User, Address)
        .join(User.addresses)
        .options(
            Load(User).load_only(User.name, User.fullname),
            Load(Address).load_only(Address.email_address),
        )
    )

When used together with the
:ref:`populate_existing &lt;orm_queryguide_populate_existing&gt;`
execution option only the attributes listed will be refreshed.

:param \*attrs: Attributes to be loaded, all others will be deferred.

:param raiseload: raise :class:`.InvalidRequestError` rather than
 lazy loading a value when a deferred attribute is accessed. Used
 to prevent unwanted SQL from being emitted.

 .. versionadded:: 2.0

.. seealso::

    :ref:`orm_queryguide_column_deferral` - in the
    :ref:`queryguide_toplevel`

:param \*attrs: Attributes to be loaded, all others will be deferred.

:param raiseload: raise :class:`.InvalidRequestError` rather than
 lazy loading a value when a deferred attribute is accessed. Used
 to prevent unwanted SQL from being emitted.

 .. versionadded:: 2.0</pre> 
</div>
</div>
<a id="ab03aed1c772edbf0fff4a924eb2b9e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03aed1c772edbf0fff4a924eb2b9e7b">&#9670;&nbsp;</a></span>noload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.noload </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given relationship attribute should remain
unloaded.

The relationship attribute will return ``None`` when accessed without
producing any loading effect.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

:func:`_orm.noload` applies to :func:`_orm.relationship` attributes
only.

.. legacy:: The :func:`_orm.noload` option is **legacy**.  As it
   forces collections to be empty, which invariably leads to
   non-intuitive and difficult to predict results.  There are no
   legitimate uses for this option in modern SQLAlchemy.

.. seealso::

    :ref:`loading_toplevel`</pre> 
</div>
</div>
<a id="a12451ae5fe6bed19ead8d1a60a9845e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12451ae5fe6bed19ead8d1a60a9845e9">&#9670;&nbsp;</a></span>options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.options </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__AbstractLoad.html">_AbstractLoad</a>&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply a series of options as sub-options to this
:class:`_orm._AbstractLoad` object.

Implementation is provided by subclasses.</pre> 
<p>Reimplemented in <a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1__WildcardLoad.html#a23c3d3f2efaff2be1dc7186f6ff2039a">sqlalchemy.orm.strategy_options._WildcardLoad</a>, and <a class="el" href="classsqlalchemy_1_1orm_1_1strategy__options_1_1Load.html#a46776096ae46fb8a56efe950162fb3bc">sqlalchemy.orm.strategy_options.Load</a>.</p>

</div>
</div>
<a id="a189a131ea5564ec5f61667b9846b5260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189a131ea5564ec5f61667b9846b5260">&#9670;&nbsp;</a></span>process_compile_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1context_1_1ORMCompileState.html">ORMCompileState</a>&#160;</td>
          <td class="paramname"><em>compile_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply a modification to a given :class:`.ORMCompileState`.

This method is part of the implementation of a particular
:class:`.CompileStateOption` and is only invoked internally
when an ORM query is compiled.</pre> 
<p>Reimplemented from <a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1CompileStateOption.html#adb5ce1cb05cba6c3839bdbd09a0c0091">sqlalchemy.orm.interfaces.CompileStateOption</a>.</p>

</div>
</div>
<a id="ac70aedb066ca6ec6e6da8e3bdeae1209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70aedb066ca6ec6e6da8e3bdeae1209">&#9670;&nbsp;</a></span>process_compile_state_replaced_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state_replaced_entities </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1context_1_1ORMCompileState.html">ORMCompileState</a>&#160;</td>
          <td class="paramname"><em>compile_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[<a class="el" href="classsqlalchemy_1_1orm_1_1context_1_1__MapperEntity.html">_MapperEntity</a>]&#160;</td>
          <td class="paramname"><em>mapper_entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply a modification to a given :class:`.ORMCompileState`,
given entities that were replaced by with_only_columns() or
with_entities().

This method is part of the implementation of a particular
:class:`.CompileStateOption` and is only invoked internally
when an ORM query is compiled.

.. versionadded:: 1.4.19</pre> 
<p>Reimplemented from <a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1LoaderOption.html#aadf84ee2a2c92dfddd1edd747a076e5b">sqlalchemy.orm.interfaces.LoaderOption</a>.</p>

</div>
</div>
<a id="ab5cb845b805260e6f7ffc7a9e1498ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cb845b805260e6f7ffc7a9e1498ed6">&#9670;&nbsp;</a></span>raiseload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.raiseload </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1visitors_1_1HasTraverseInternals.html#ad109107c4b478895bdfb78dadbd4ecc0">bool</a> &#160;</td>
          <td class="paramname"><em>sql_only</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given attribute should raise an error if accessed.

A relationship attribute configured with :func:`_orm.raiseload` will
raise an :exc:`~sqlalchemy.exc.InvalidRequestError` upon access. The
typical way this is useful is when an application is attempting to
ensure that all relationship attributes that are accessed in a
particular context would have been already loaded via eager loading.
Instead of having to read through SQL logs to ensure lazy loads aren't
occurring, this strategy will cause them to raise immediately.

:func:`_orm.raiseload` applies to :func:`_orm.relationship` attributes
only. In order to apply raise-on-SQL behavior to a column-based
attribute, use the :paramref:`.orm.defer.raiseload` parameter on the
:func:`.defer` loader option.

:param sql_only: if True, raise only if the lazy load would emit SQL,
 but not if it is only checking the identity map, or determining that
 the related value should just be None due to missing keys. When False,
 the strategy will raise for all varieties of relationship loading.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

.. seealso::

    :ref:`loading_toplevel`

    :ref:`prevent_lazy_with_raiseload`

    :ref:`orm_queryguide_deferred_raiseload`</pre> 
</div>
</div>
<a id="af1bcaf8d49b28fbd19ae0dc2f8aabcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bcaf8d49b28fbd19ae0dc2f8aabcde">&#9670;&nbsp;</a></span>selectin_polymorphic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.selectin_polymorphic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[Type[Any]]&#160;</td>
          <td class="paramname"><em>classes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate an eager load should take place for all attributes
specific to a subclass.

This uses an additional SELECT with IN against all matched primary
key values, and is the per-query analogue to the ``"selectin"``
setting on the :paramref:`.mapper.polymorphic_load` parameter.

.. versionadded:: 1.2

.. seealso::

    :ref:`polymorphic_selectin`</pre> 
</div>
</div>
<a id="aa4126aeae0a304c901e494822888de9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4126aeae0a304c901e494822888de9a">&#9670;&nbsp;</a></span>selectinload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.selectinload </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int] &#160;</td>
          <td class="paramname"><em>recursion_depth</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given attribute should be loaded using
SELECT IN eager loading.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

examples::

    # selectin-load the "orders" collection on "User"
    select(User).options(selectinload(User.orders))

    # selectin-load Order.items and then Item.keywords
    select(Order).options(
        selectinload(Order.items).selectinload(Item.keywords)
    )

    # lazily load Order.items, but when Items are loaded,
    # selectin-load the keywords collection
    select(Order).options(lazyload(Order.items).selectinload(Item.keywords))

:param recursion_depth: optional int; when set to a positive integer
 in conjunction with a self-referential relationship,
 indicates "selectin" loading will continue that many levels deep
 automatically until no items are found.

 .. note:: The :paramref:`_orm.selectinload.recursion_depth` option
    currently supports only self-referential relationships.  There
    is not yet an option to automatically traverse recursive structures
    with more than one relationship involved.

    Additionally, the :paramref:`_orm.selectinload.recursion_depth`
    parameter is new and experimental and should be treated as "alpha"
    status for the 2.0 series.

 .. versionadded:: 2.0 added
    :paramref:`_orm.selectinload.recursion_depth`


.. seealso::

    :ref:`loading_toplevel`

    :ref:`selectin_eager_loading`</pre> 
</div>
</div>
<a id="a1d9eb929328cb8536519f19e361dd287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9eb929328cb8536519f19e361dd287">&#9670;&nbsp;</a></span>subqueryload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.subqueryload </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given attribute should be loaded using
subquery eager loading.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

examples::

    # subquery-load the "orders" collection on "User"
    select(User).options(subqueryload(User.orders))

    # subquery-load Order.items and then Item.keywords
    select(Order).options(
        subqueryload(Order.items).subqueryload(Item.keywords)
    )

    # lazily load Order.items, but when Items are loaded,
    # subquery-load the keywords collection
    select(Order).options(lazyload(Order.items).subqueryload(Item.keywords))

.. seealso::

    :ref:`loading_toplevel`

    :ref:`subquery_eager_loading`</pre> 
</div>
</div>
<a id="a01e70c8b8e1df95905e46493e1bff67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e70c8b8e1df95905e46493e1bff67d">&#9670;&nbsp;</a></span>undefer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.undefer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that the given column-oriented attribute should be
undeferred, e.g. specified within the SELECT statement of the entity
as a whole.

The column being undeferred is typically set up on the mapping as a
:func:`.deferred` attribute.

This function is part of the :class:`_orm.Load` interface and supports
both method-chained and standalone operation.

Examples::

    # undefer two columns
    session.query(MyClass).options(
        undefer(MyClass.col1), undefer(MyClass.col2)
    )

    # undefer all columns specific to a single class using Load + *
    session.query(MyClass, MyOtherClass).options(Load(MyClass).undefer("*"))

    # undefer a column on a related object
    select(MyClass).options(defaultload(MyClass.items).undefer(MyClass.text))

:param key: Attribute to be undeferred.

.. seealso::

    :ref:`orm_queryguide_column_deferral` - in the
    :ref:`queryguide_toplevel`

    :func:`_orm.defer`

    :func:`_orm.undefer_group`</pre> 
</div>
</div>
<a id="a71709e64ec4a862a4250dcba2db74074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71709e64ec4a862a4250dcba2db74074">&#9670;&nbsp;</a></span>undefer_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.undefer_group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate that columns within the given deferred group name should be
undeferred.

The columns being undeferred are set up on the mapping as
:func:`.deferred` attributes and include a "group" name.

E.g::

    session.query(MyClass).options(undefer_group("large_attrs"))

To undefer a group of attributes on a related entity, the path can be
spelled out using relationship loader options, such as
:func:`_orm.defaultload`::

    select(MyClass).options(
        defaultload("someattr").undefer_group("large_attrs")
    )

.. seealso::

    :ref:`orm_queryguide_column_deferral` - in the
    :ref:`queryguide_toplevel`

    :func:`_orm.defer`

    :func:`_orm.undefer`</pre> 
</div>
</div>
<a id="a57b56b2d25dd77fa639b9486e155be03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b56b2d25dd77fa639b9486e155be03">&#9670;&nbsp;</a></span>with_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Self sqlalchemy.orm.strategy_options._AbstractLoad.with_expression </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_AttrType&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ColumnExpressionArgument[Any]&#160;</td>
          <td class="paramname"><em>expression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply an ad-hoc SQL expression to a "deferred expression"
attribute.

This option is used in conjunction with the
:func:`_orm.query_expression` mapper-level construct that indicates an
attribute which should be the target of an ad-hoc SQL expression.

E.g.::

    stmt = select(SomeClass).options(
        with_expression(SomeClass.x_y_expr, SomeClass.x + SomeClass.y)
    )

.. versionadded:: 1.2

:param key: Attribute to be populated

:param expr: SQL expression to be applied to the attribute.

.. seealso::

    :ref:`orm_queryguide_with_expression` - background and usage
    examples</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>py3_env/lib/python3.10/site-packages/sqlalchemy/orm/<a class="el" href="strategy__options_8py.html">strategy_options.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
