<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.solvers.solveset Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html">solveset</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.solvers.solveset Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1solveset_1_1NonlinearError.html">NonlinearError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1solvers_1_1solveset_1_1__SolveTrig1Error.html">_SolveTrig1Error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a815e912ddc73b20b51028ed336bf9b85"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#a815e912ddc73b20b51028ed336bf9b85">invert_real</a> (f_x, y, x)</td></tr>
<tr class="separator:a815e912ddc73b20b51028ed336bf9b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa39e80126954160557e76fa58cbbce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#acaa39e80126954160557e76fa58cbbce">domain_check</a> (f, symbol, p)</td></tr>
<tr class="separator:acaa39e80126954160557e76fa58cbbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c5064d744564ef84a0e87cf982fcca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#a74c5064d744564ef84a0e87cf982fcca">solve_decomposition</a> (f, symbol, domain)</td></tr>
<tr class="separator:a74c5064d744564ef84a0e87cf982fcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1901d1fc32e3afbaeb03ab52dd2d56f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#ad1901d1fc32e3afbaeb03ab52dd2d56f">solveset</a> (f, symbol=None, domain=S.Complexes)</td></tr>
<tr class="separator:ad1901d1fc32e3afbaeb03ab52dd2d56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb38a40dc4b5994a93bfbbf126680aa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#a9bb38a40dc4b5994a93bfbbf126680aa">solveset_real</a> (f, symbol)</td></tr>
<tr class="separator:a9bb38a40dc4b5994a93bfbbf126680aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bed75958108e83e04e57555bb54952"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#aa4bed75958108e83e04e57555bb54952">solveset_complex</a> (f, symbol)</td></tr>
<tr class="separator:aa4bed75958108e83e04e57555bb54952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f9fdbce8b94ee2c04cec47e0bd9721"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#ab4f9fdbce8b94ee2c04cec47e0bd9721">solvify</a> (f, symbol, domain)</td></tr>
<tr class="separator:ab4f9fdbce8b94ee2c04cec47e0bd9721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf433032de82ecec0d4ce51a14641f66"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#aaf433032de82ecec0d4ce51a14641f66">linear_coeffs</a> (eq, *syms, dict=False)</td></tr>
<tr class="memdesc:aaf433032de82ecec0d4ce51a14641f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">LINSOLVE #####################################.  <a href="namespacesympy_1_1solvers_1_1solveset.html#aaf433032de82ecec0d4ce51a14641f66">More...</a><br /></td></tr>
<tr class="separator:aaf433032de82ecec0d4ce51a14641f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d962a4f6eeee5114dd7f3f7032671f5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#a6d962a4f6eeee5114dd7f3f7032671f5">linear_eq_to_matrix</a> (equations, *symbols)</td></tr>
<tr class="separator:a6d962a4f6eeee5114dd7f3f7032671f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b6a313d0206e3bbbcb5eb0296309a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#ac7b6a313d0206e3bbbcb5eb0296309a8">linsolve</a> (system, *symbols)</td></tr>
<tr class="separator:ac7b6a313d0206e3bbbcb5eb0296309a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5888b318bc79e0d7a117461d75a2ec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#a0b5888b318bc79e0d7a117461d75a2ec">substitution</a> (system, symbols, result=[{}], known_symbols=[], exclude=[], all_symbols=None)</td></tr>
<tr class="separator:a0b5888b318bc79e0d7a117461d75a2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae88009fead93f103ce056d8736d08e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#aae88009fead93f103ce056d8736d08e7">nonlinsolve</a> (system, *symbols)</td></tr>
<tr class="separator:aae88009fead93f103ce056d8736d08e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae35c382abed761a541ee635ed740ae61"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1solvers_1_1solveset.html#ae35c382abed761a541ee635ed740ae61">invert_complex</a> = _invert</td></tr>
<tr class="separator:ae35c382abed761a541ee635ed740ae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module contains functions to:

    - solve a single equation for a single variable, in any domain either real or complex.

    - solve a single transcendental equation for a single variable in any domain either real or complex.
      (currently supports solving in real domain only)

    - solve a system of linear equations with N variables and M equations.

    - solve a system of Non Linear Equations with N variables and M equations
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="acaa39e80126954160557e76fa58cbbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa39e80126954160557e76fa58cbbce">&#9670;&nbsp;</a></span>domain_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.domain_check </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns False if point p is infinite or any subexpression of f
is infinite or becomes so after replacing symbol with p. If none of
these conditions is met then True will be returned.

Examples
========

&gt;&gt;&gt; from sympy import Mul, oo
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; from sympy.solvers.solveset import domain_check
&gt;&gt;&gt; g = 1/(1 + (1/(x + 1))**2)
&gt;&gt;&gt; domain_check(g, x, -1)
False
&gt;&gt;&gt; domain_check(x**2, x, 0)
True
&gt;&gt;&gt; domain_check(1/x, x, oo)
False

* The function relies on the assumption that the original form
  of the equation has not been changed by automatic simplification.

&gt;&gt;&gt; domain_check(x/x, x, 0) # x/x is automatically simplified to 1
True

* To deal with automatic evaluations use evaluate=False:

&gt;&gt;&gt; domain_check(Mul(x, 1/x, evaluate=False), x, 0)
False
</pre> 
</div>
</div>
<a id="a815e912ddc73b20b51028ed336bf9b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815e912ddc73b20b51028ed336bf9b85">&#9670;&nbsp;</a></span>invert_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.invert_real </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Inverts a real-valued function. Same as :func:`invert_complex`, but sets
the domain to ``S.Reals`` before inverting.
</pre> 
</div>
</div>
<a id="aaf433032de82ecec0d4ce51a14641f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf433032de82ecec0d4ce51a14641f66">&#9670;&nbsp;</a></span>linear_coeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.linear_coeffs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LINSOLVE #####################################. </p>
<pre class="fragment">Return a list whose elements are the coefficients of the
corresponding symbols in the sum of terms in  ``eq``.
The additive constant is returned as the last element of the
list.

Raises
======

NonlinearError
    The equation contains a nonlinear term
ValueError
    duplicate or unordered symbols are passed

Parameters
==========

dict - (default False) when True, return coefficients as a
    dictionary with coefficients keyed to syms that were present;
    key 1 gives the constant term

Examples
========

&gt;&gt;&gt; from sympy.solvers.solveset import linear_coeffs
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; linear_coeffs(3*x + 2*y - 1, x, y)
[3, 2, -1]

It is not necessary to expand the expression:

    &gt;&gt;&gt; linear_coeffs(x + y*(z*(x*3 + 2) + 3), x)
    [3*y*z + 1, y*(2*z + 3)]

When nonlinear is detected, an error will be raised:

    * even if they would cancel after expansion (so the
    situation does not pass silently past the caller's
    attention)

    &gt;&gt;&gt; eq = 1/x*(x - 1) + 1/x
    &gt;&gt;&gt; linear_coeffs(eq.expand(), x)
    [0, 1]
    &gt;&gt;&gt; linear_coeffs(eq, x)
    Traceback (most recent call last):
    ...
    NonlinearError:
    nonlinear in given generators

    * when there are cross terms

    &gt;&gt;&gt; linear_coeffs(x*(y + 1), x, y)
    Traceback (most recent call last):
    ...
    NonlinearError:
    symbol-dependent cross-terms encountered

    * when there are terms that contain an expression
    dependent on the symbols that is not linear

    &gt;&gt;&gt; linear_coeffs(x**2, x)
    Traceback (most recent call last):
    ...
    NonlinearError:
    nonlinear in given generators
</pre> 
</div>
</div>
<a id="a6d962a4f6eeee5114dd7f3f7032671f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d962a4f6eeee5114dd7f3f7032671f5">&#9670;&nbsp;</a></span>linear_eq_to_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.linear_eq_to_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts a given System of Equations into Matrix form.
Here `equations` must be a linear system of equations in
`symbols`. Element ``M[i, j]`` corresponds to the coefficient
of the jth symbol in the ith equation.

The Matrix form corresponds to the augmented matrix form.
For example:

.. math:: 4x + 2y + 3z  = 1
.. math:: 3x +  y +  z  = -6
.. math:: 2x + 4y + 9z  = 2

This system will return $A$ and $b$ as:

$$ A = \left[\begin{array}{ccc}
    4 &amp; 2 &amp; 3 \\
    3 &amp; 1 &amp; 1 \\
    2 &amp; 4 &amp; 9
    \end{array}\right] \ \  b = \left[\begin{array}{c}
    1 \\ -6 \\ 2
    \end{array}\right] $$

The only simplification performed is to convert
``Eq(a, b)`` $\Rightarrow a - b$.

Raises
======

NonlinearError
    The equations contain a nonlinear term.
ValueError
    The symbols are not given or are not unique.

Examples
========

&gt;&gt;&gt; from sympy import linear_eq_to_matrix, symbols
&gt;&gt;&gt; c, x, y, z = symbols('c, x, y, z')

The coefficients (numerical or symbolic) of the symbols will
be returned as matrices:

    &gt;&gt;&gt; eqns = [c*x + z - 1 - c, y + z, x - y]
    &gt;&gt;&gt; A, b = linear_eq_to_matrix(eqns, [x, y, z])
    &gt;&gt;&gt; A
    Matrix([
    [c,  0, 1],
    [0,  1, 1],
    [1, -1, 0]])
    &gt;&gt;&gt; b
    Matrix([
    [c + 1],
    [    0],
    [    0]])

This routine does not simplify expressions and will raise an error
if nonlinearity is encountered:

        &gt;&gt;&gt; eqns = [
        ...     (x**2 - 3*x)/(x - 3) - 3,
        ...     y**2 - 3*y - y*(y - 4) + x - 4]
        &gt;&gt;&gt; linear_eq_to_matrix(eqns, [x, y])
        Traceback (most recent call last):
        ...
        NonlinearError:
        symbol-dependent term can be ignored using `strict=False`

    Simplifying these equations will discard the removable singularity
    in the first and reveal the linear structure of the second:

        &gt;&gt;&gt; [e.simplify() for e in eqns]
        [x - 3, x + y - 4]

    Any such simplification needed to eliminate nonlinear terms must
    be done *before* calling this routine.
</pre> 
</div>
</div>
<a id="ac7b6a313d0206e3bbbcb5eb0296309a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b6a313d0206e3bbbcb5eb0296309a8">&#9670;&nbsp;</a></span>linsolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.linsolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve system of $N$ linear equations with $M$ variables; both
underdetermined and overdetermined systems are supported.
The possible number of solutions is zero, one or infinite.
Zero solutions throws a ValueError, whereas infinite
solutions are represented parametrically in terms of the given
symbols. For unique solution a :class:`~.FiniteSet` of ordered tuples
is returned.

All standard input formats are supported:
For the given set of equations, the respective input types
are given below:

.. math:: 3x + 2y -   z = 1
.. math:: 2x - 2y + 4z = -2
.. math:: 2x -   y + 2z = 0

* Augmented matrix form, ``system`` given below:

$$ \text{system} = \left[{array}{cccc}
    3 &amp;  2 &amp; -1 &amp;  1\\
    2 &amp; -2 &amp;  4 &amp; -2\\
    2 &amp; -1 &amp;  2 &amp;  0
    \end{array}\right] $$

::

    system = Matrix([[3, 2, -1, 1], [2, -2, 4, -2], [2, -1, 2, 0]])

* List of equations form

::

    system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]

* Input $A$ and $b$ in matrix form (from $Ax = b$) are given as:

$$ A = \left[\begin{array}{ccc}
    3 &amp;  2 &amp; -1 \\
    2 &amp; -2 &amp;  4 \\
    2 &amp; -1 &amp;  2
    \end{array}\right] \ \  b = \left[\begin{array}{c}
    1 \\ -2 \\ 0
    \end{array}\right] $$

::

    A = Matrix([[3, 2, -1], [2, -2, 4], [2, -1, 2]])
    b = Matrix([[1], [-2], [0]])
    system = (A, b)

Symbols can always be passed but are actually only needed
when 1) a system of equations is being passed and 2) the
system is passed as an underdetermined matrix and one wants
to control the name of the free variables in the result.
An error is raised if no symbols are used for case 1, but if
no symbols are provided for case 2, internally generated symbols
will be provided. When providing symbols for case 2, there should
be at least as many symbols are there are columns in matrix A.

The algorithm used here is Gauss-Jordan elimination, which
results, after elimination, in a row echelon form matrix.

Returns
=======

A FiniteSet containing an ordered tuple of values for the
unknowns for which the `system` has a solution. (Wrapping
the tuple in FiniteSet is used to maintain a consistent
output format throughout solveset.)

Returns EmptySet, if the linear system is inconsistent.

Raises
======

ValueError
    The input is not valid.
    The symbols are not given.

Examples
========

&gt;&gt;&gt; from sympy import Matrix, linsolve, symbols
&gt;&gt;&gt; x, y, z = symbols("x, y, z")
&gt;&gt;&gt; A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])
&gt;&gt;&gt; b = Matrix([3, 6, 9])
&gt;&gt;&gt; A
Matrix([
[1, 2,  3],
[4, 5,  6],
[7, 8, 10]])
&gt;&gt;&gt; b
Matrix([
[3],
[6],
[9]])
&gt;&gt;&gt; linsolve((A, b), [x, y, z])
{(-1, 2, 0)}

* Parametric Solution: In case the system is underdetermined, the
  function will return a parametric solution in terms of the given
  symbols. Those that are free will be returned unchanged. e.g. in
  the system below, `z` is returned as the solution for variable z;
  it can take on any value.

&gt;&gt;&gt; A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; b = Matrix([3, 6, 9])
&gt;&gt;&gt; linsolve((A, b), x, y, z)
{(z - 1, 2 - 2*z, z)}

If no symbols are given, internally generated symbols will be used.
The ``tau0`` in the third position indicates (as before) that the third
variable -- whatever it is named -- can take on any value:

&gt;&gt;&gt; linsolve((A, b))
{(tau0 - 1, 2 - 2*tau0, tau0)}

* List of equations as input

&gt;&gt;&gt; Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]
&gt;&gt;&gt; linsolve(Eqns, x, y, z)
{(1, -2, -2)}

* Augmented matrix as input

&gt;&gt;&gt; aug = Matrix([[2, 1, 3, 1], [2, 6, 8, 3], [6, 8, 18, 5]])
&gt;&gt;&gt; aug
Matrix([
[2, 1,  3, 1],
[2, 6,  8, 3],
[6, 8, 18, 5]])
&gt;&gt;&gt; linsolve(aug, x, y, z)
{(3/10, 2/5, 0)}

* Solve for symbolic coefficients

&gt;&gt;&gt; a, b, c, d, e, f = symbols('a, b, c, d, e, f')
&gt;&gt;&gt; eqns = [a*x + b*y - c, d*x + e*y - f]
&gt;&gt;&gt; linsolve(eqns, x, y)
{((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}

* A degenerate system returns solution as set of given
  symbols.

&gt;&gt;&gt; system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))
&gt;&gt;&gt; linsolve(system, x, y)
{(x, y)}

* For an empty system linsolve returns empty set

&gt;&gt;&gt; linsolve([], x)
EmptySet

* An error is raised if any nonlinearity is detected, even
  if it could be removed with expansion

&gt;&gt;&gt; linsolve([x*(1/x - 1)], x)
Traceback (most recent call last):
...
NonlinearError: nonlinear term: 1/x

&gt;&gt;&gt; linsolve([x*(y + 1)], x, y)
Traceback (most recent call last):
...
NonlinearError: nonlinear cross-term: x*(y + 1)

&gt;&gt;&gt; linsolve([x**2 - 1], x)
Traceback (most recent call last):
...
NonlinearError: nonlinear term: x**2
</pre> 
</div>
</div>
<a id="aae88009fead93f103ce056d8736d08e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae88009fead93f103ce056d8736d08e7">&#9670;&nbsp;</a></span>nonlinsolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.nonlinsolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve system of $N$ nonlinear equations with $M$ variables, which means both
under and overdetermined systems are supported. Positive dimensional
system is also supported (A system with infinitely many solutions is said
to be positive-dimensional). In a positive dimensional system the solution will
be dependent on at least one symbol. Returns both real solution
and complex solution (if they exist).

Parameters
==========

system : list of equations
    The target system of equations
symbols : list of Symbols
    symbols should be given as a sequence eg. list

Returns
=======

A :class:`~.FiniteSet` of ordered tuple of values of `symbols` for which the `system`
has solution. Order of values in the tuple is same as symbols present in
the parameter `symbols`.

Please note that general :class:`~.FiniteSet` is unordered, the solution
returned here is not simply a :class:`~.FiniteSet` of solutions, rather it
is a :class:`~.FiniteSet` of ordered tuple, i.e. the first and only
argument to :class:`~.FiniteSet` is a tuple of solutions, which is
ordered, and, hence ,the returned solution is ordered.

Also note that solution could also have been returned as an ordered tuple,
FiniteSet is just a wrapper ``{}`` around the tuple. It has no other
significance except for the fact it is just used to maintain a consistent
output format throughout the solveset.

For the given set of equations, the respective input types
are given below:

.. math:: xy - 1 = 0
.. math:: 4x^2 + y^2 - 5 = 0

::

   system  = [x*y - 1, 4*x**2 + y**2 - 5]
   symbols = [x, y]

Raises
======

ValueError
    The input is not valid.
    The symbols are not given.
AttributeError
    The input symbols are not `Symbol` type.

Examples
========

&gt;&gt;&gt; from sympy import symbols, nonlinsolve
&gt;&gt;&gt; x, y, z = symbols('x, y, z', real=True)
&gt;&gt;&gt; nonlinsolve([x*y - 1, 4*x**2 + y**2 - 5], [x, y])
{(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)}

1. Positive dimensional system and complements:

&gt;&gt;&gt; from sympy import pprint
&gt;&gt;&gt; from sympy.polys.polytools import is_zero_dimensional
&gt;&gt;&gt; a, b, c, d = symbols('a, b, c, d', extended_real=True)
&gt;&gt;&gt; eq1 =  a + b + c + d
&gt;&gt;&gt; eq2 = a*b + b*c + c*d + d*a
&gt;&gt;&gt; eq3 = a*b*c + b*c*d + c*d*a + d*a*b
&gt;&gt;&gt; eq4 = a*b*c*d - 1
&gt;&gt;&gt; system = [eq1, eq2, eq3, eq4]
&gt;&gt;&gt; is_zero_dimensional(system)
False
&gt;&gt;&gt; pprint(nonlinsolve(system, [a, b, c, d]), use_unicode=False)
  -1       1               1      -1
{(---, -d, -, {d} \ {0}), (-, -d, ---, {d} \ {0})}
   d       d               d       d
&gt;&gt;&gt; nonlinsolve([(x+y)**2 - 4, x + y - 2], [x, y])
{(2 - y, y)}

2. If some of the equations are non-polynomial then `nonlinsolve`
will call the ``substitution`` function and return real and complex solutions,
if present.

&gt;&gt;&gt; from sympy import exp, sin
&gt;&gt;&gt; nonlinsolve([exp(x) - sin(y), y**2 - 4], [x, y])
{(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),
 (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}

3. If system is non-linear polynomial and zero-dimensional then it
returns both solution (real and complex solutions, if present) using
:func:`~.solve_poly_system`:

&gt;&gt;&gt; from sympy import sqrt
&gt;&gt;&gt; nonlinsolve([x**2 - 2*y**2 -2, x*y - 2], [x, y])
{(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)}

4. ``nonlinsolve`` can solve some linear (zero or positive dimensional)
system (because it uses the :func:`sympy.polys.polytools.groebner` function to get the
groebner basis and then uses the ``substitution`` function basis as the
new `system`). But it is not recommended to solve linear system using
``nonlinsolve``, because :func:`~.linsolve` is better for general linear systems.

&gt;&gt;&gt; nonlinsolve([x + 2*y -z - 3, x - y - 4*z + 9, y + z - 4], [x, y, z])
{(3*z - 5, 4 - z, z)}

5. System having polynomial equations and only real solution is
solved using :func:`~.solve_poly_system`:

&gt;&gt;&gt; e1 = sqrt(x**2 + y**2) - 10
&gt;&gt;&gt; e2 = sqrt(y**2 + (-x + 10)**2) - 3
&gt;&gt;&gt; nonlinsolve((e1, e2), (x, y))
{(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}
&gt;&gt;&gt; nonlinsolve([x**2 + 2/y - 2, x + y - 3], [x, y])
{(1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5))}
&gt;&gt;&gt; nonlinsolve([x**2 + 2/y - 2, x + y - 3], [y, x])
{(2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5))}

6. It is better to use symbols instead of trigonometric functions or
:class:`~.Function`. For example, replace $\sin(x)$ with a symbol, replace
$f(x)$ with a symbol and so on. Get a solution from ``nonlinsolve`` and then
use :func:`~.solveset` to get the value of $x$.

How nonlinsolve is better than old solver ``_solve_system`` :
=============================================================

1. A positive dimensional system solver: nonlinsolve can return
solution for positive dimensional system. It finds the
Groebner Basis of the positive dimensional system(calling it as
basis) then we can start solving equation(having least number of
variable first in the basis) using solveset and substituting that
solved solutions into other equation(of basis) to get solution in
terms of minimum variables. Here the important thing is how we
are substituting the known values and in which equations.

2. Real and complex solutions: nonlinsolve returns both real
and complex solution. If all the equations in the system are polynomial
then using :func:`~.solve_poly_system` both real and complex solution is returned.
If all the equations in the system are not polynomial equation then goes to
``substitution`` method with this polynomial and non polynomial equation(s),
to solve for unsolved variables. Here to solve for particular variable
solveset_real and solveset_complex is used. For both real and complex
solution ``_solve_using_known_values`` is used inside ``substitution``
(``substitution`` will be called when any non-polynomial equation is present).
If a solution is valid its general solution is added to the final result.

3. :class:`~.Complement` and :class:`~.Intersection` will be added:
nonlinsolve maintains dict for complements and intersections. If solveset
find complements or/and intersections with any interval or set during the
execution of ``substitution`` function, then complement or/and
intersection for that variable is added before returning final solution.</pre> 
</div>
</div>
<a id="a74c5064d744564ef84a0e87cf982fcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c5064d744564ef84a0e87cf982fcca">&#9670;&nbsp;</a></span>solve_decomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.solve_decomposition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to solve equations via the principle of "Decomposition
and Rewriting".

Examples
========
&gt;&gt;&gt; from sympy import exp, sin, Symbol, pprint, S
&gt;&gt;&gt; from sympy.solvers.solveset import solve_decomposition as sd
&gt;&gt;&gt; x = Symbol('x')
&gt;&gt;&gt; f1 = exp(2*x) - 3*exp(x) + 2
&gt;&gt;&gt; sd(f1, x, S.Reals)
{0, log(2)}
&gt;&gt;&gt; f2 = sin(x)**2 + 2*sin(x) + 1
&gt;&gt;&gt; pprint(sd(f2, x, S.Reals), use_unicode=False)
          3*pi
{2*n*pi + ---- | n in Integers}
           2
&gt;&gt;&gt; f3 = sin(x + 2)
&gt;&gt;&gt; pprint(sd(f3, x, S.Reals), use_unicode=False)
{2*n*pi - 2 | n in Integers} U {2*n*pi - 2 + pi | n in Integers}</pre> 
</div>
</div>
<a id="ad1901d1fc32e3afbaeb03ab52dd2d56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1901d1fc32e3afbaeb03ab52dd2d56f">&#9670;&nbsp;</a></span>solveset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.solveset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>S.Complexes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves a given inequality or equation with set as output

Parameters
==========

f : Expr or a relational.
    The target equation or inequality
symbol : Symbol
    The variable for which the equation is solved
domain : Set
    The domain over which the equation is solved

Returns
=======

Set
    A set of values for `symbol` for which `f` is True or is equal to
    zero. An :class:`~.EmptySet` is returned if `f` is False or nonzero.
    A :class:`~.ConditionSet` is returned as unsolved object if algorithms
    to evaluate complete solution are not yet implemented.

``solveset`` claims to be complete in the solution set that it returns.

Raises
======

NotImplementedError
    The algorithms to solve inequalities in complex domain  are
    not yet implemented.
ValueError
    The input is not valid.
RuntimeError
    It is a bug, please report to the github issue tracker.


Notes
=====

Python interprets 0 and 1 as False and True, respectively, but
in this function they refer to solutions of an expression. So 0 and 1
return the domain and EmptySet, respectively, while True and False
return the opposite (as they are assumed to be solutions of relational
expressions).


See Also
========

solveset_real: solver for real domain
solveset_complex: solver for complex domain

Examples
========

&gt;&gt;&gt; from sympy import exp, sin, Symbol, pprint, S, Eq
&gt;&gt;&gt; from sympy.solvers.solveset import solveset, solveset_real

* The default domain is complex. Not specifying a domain will lead
  to the solving of the equation in the complex domain (and this
  is not affected by the assumptions on the symbol):

&gt;&gt;&gt; x = Symbol('x')
&gt;&gt;&gt; pprint(solveset(exp(x) - 1, x), use_unicode=False)
{2*n*I*pi | n in Integers}

&gt;&gt;&gt; x = Symbol('x', real=True)
&gt;&gt;&gt; pprint(solveset(exp(x) - 1, x), use_unicode=False)
{2*n*I*pi | n in Integers}

* If you want to use ``solveset`` to solve the equation in the
  real domain, provide a real domain. (Using ``solveset_real``
  does this automatically.)

&gt;&gt;&gt; R = S.Reals
&gt;&gt;&gt; x = Symbol('x')
&gt;&gt;&gt; solveset(exp(x) - 1, x, R)
{0}
&gt;&gt;&gt; solveset_real(exp(x) - 1, x)
{0}

The solution is unaffected by assumptions on the symbol:

&gt;&gt;&gt; p = Symbol('p', positive=True)
&gt;&gt;&gt; pprint(solveset(p**2 - 4))
{-2, 2}

When a :class:`~.ConditionSet` is returned, symbols with assumptions that
would alter the set are replaced with more generic symbols:

&gt;&gt;&gt; i = Symbol('i', imaginary=True)
&gt;&gt;&gt; solveset(Eq(i**2 + i*sin(i), 1), i, domain=S.Reals)
ConditionSet(_R, Eq(_R**2 + _R*sin(_R) - 1, 0), Reals)

* Inequalities can be solved over the real domain only. Use of a complex
  domain leads to a NotImplementedError.

&gt;&gt;&gt; solveset(exp(x) &gt; 1, x, R)
Interval.open(0, oo)</pre> 
</div>
</div>
<a id="aa4bed75958108e83e04e57555bb54952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bed75958108e83e04e57555bb54952">&#9670;&nbsp;</a></span>solveset_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.solveset_complex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bb38a40dc4b5994a93bfbbf126680aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb38a40dc4b5994a93bfbbf126680aa">&#9670;&nbsp;</a></span>solveset_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.solveset_real </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4f9fdbce8b94ee2c04cec47e0bd9721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f9fdbce8b94ee2c04cec47e0bd9721">&#9670;&nbsp;</a></span>solvify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.solvify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves an equation using solveset and returns the solution in accordance
with the `solve` output API.

Returns
=======

We classify the output based on the type of solution returned by `solveset`.

Solution    |    Output
----------------------------------------
FiniteSet   | list

ImageSet,   | list (if `f` is periodic)
Union       |

Union       | list (with FiniteSet)

EmptySet    | empty list

Others      | None


Raises
======

NotImplementedError
    A ConditionSet is the input.

Examples
========

&gt;&gt;&gt; from sympy.solvers.solveset import solvify
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; from sympy import S, tan, sin, exp
&gt;&gt;&gt; solvify(x**2 - 9, x, S.Reals)
[-3, 3]
&gt;&gt;&gt; solvify(sin(x) - 1, x, S.Reals)
[pi/2]
&gt;&gt;&gt; solvify(tan(x), x, S.Reals)
[0]
&gt;&gt;&gt; solvify(exp(x) - 1, x, S.Complexes)

&gt;&gt;&gt; solvify(exp(x) - 1, x, S.Reals)
[0]</pre> 
</div>
</div>
<a id="a0b5888b318bc79e0d7a117461d75a2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5888b318bc79e0d7a117461d75a2ec">&#9670;&nbsp;</a></span>substitution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.substitution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em> = <code>[{}]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>known_symbols</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exclude</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all_symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the `system` using substitution method. It is used in
:func:`~.nonlinsolve`. This will be called from :func:`~.nonlinsolve` when any
equation(s) is non polynomial equation.

Parameters
==========

system : list of equations
    The target system of equations
symbols : list of symbols to be solved.
    The variable(s) for which the system is solved
known_symbols : list of solved symbols
    Values are known for these variable(s)
result : An empty list or list of dict
    If No symbol values is known then empty list otherwise
    symbol as keys and corresponding value in dict.
exclude : Set of expression.
    Mostly denominator expression(s) of the equations of the system.
    Final solution should not satisfy these expressions.
all_symbols : known_symbols + symbols(unsolved).

Returns
=======

A FiniteSet of ordered tuple of values of `all_symbols` for which the
`system` has solution. Order of values in the tuple is same as symbols
present in the parameter `all_symbols`. If parameter `all_symbols` is None
then same as symbols present in the parameter `symbols`.

Please note that general FiniteSet is unordered, the solution returned
here is not simply a FiniteSet of solutions, rather it is a FiniteSet of
ordered tuple, i.e. the first &amp; only argument to FiniteSet is a tuple of
solutions, which is ordered, &amp; hence the returned solution is ordered.

Also note that solution could also have been returned as an ordered tuple,
FiniteSet is just a wrapper `{}` around the tuple. It has no other
significance except for the fact it is just used to maintain a consistent
output format throughout the solveset.

Raises
======

ValueError
    The input is not valid.
    The symbols are not given.
AttributeError
    The input symbols are not :class:`~.Symbol` type.

Examples
========

&gt;&gt;&gt; from sympy import symbols, substitution
&gt;&gt;&gt; x, y = symbols('x, y', real=True)
&gt;&gt;&gt; substitution([x + y], [x], [{y: 1}], [y], set([]), [x, y])
{(-1, 1)}

* When you want a soln not satisfying $x + 1 = 0$

&gt;&gt;&gt; substitution([x + y], [x], [{y: 1}], [y], set([x + 1]), [y, x])
EmptySet
&gt;&gt;&gt; substitution([x + y], [x], [{y: 1}], [y], set([x - 1]), [y, x])
{(1, -1)}
&gt;&gt;&gt; substitution([x + y - 1, y - x**2 + 5], [x, y])
{(-3, 4), (2, -1)}

* Returns both real and complex solution

&gt;&gt;&gt; x, y, z = symbols('x, y, z')
&gt;&gt;&gt; from sympy import exp, sin
&gt;&gt;&gt; substitution([exp(x) - sin(y), y**2 - 4], [x, y])
{(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),
 (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}

&gt;&gt;&gt; eqs = [z**2 + exp(2*x) - sin(y), -3 + exp(-y)]
&gt;&gt;&gt; substitution(eqs, [y, z])
{(-log(3), -sqrt(-exp(2*x) - sin(log(3)))),
 (-log(3), sqrt(-exp(2*x) - sin(log(3)))),
 (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),
  ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),
 (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),
  ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers))}</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae35c382abed761a541ee635ed740ae61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35c382abed761a541ee635ed740ae61">&#9670;&nbsp;</a></span>invert_complex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.solvers.solveset.invert_complex = _invert</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
