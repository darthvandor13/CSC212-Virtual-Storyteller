<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: zstandard.backend_cffi.ZstdCompressor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacezstandard.html">zstandard</a></li><li class="navelem"><a class="el" href="namespacezstandard_1_1backend__cffi.html">backend_cffi</a></li><li class="navelem"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html">ZstdCompressor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classzstandard_1_1backend__cffi_1_1ZstdCompressor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">zstandard.backend_cffi.ZstdCompressor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for zstandard.backend_cffi.ZstdCompressor:</div>
<div class="dyncontent">
<div class="center"><img src="classzstandard_1_1backend__cffi_1_1ZstdCompressor__inherit__graph.png" border="0" usemap="#azstandard_8backend__cffi_8ZstdCompressor_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for zstandard.backend_cffi.ZstdCompressor:</div>
<div class="dyncontent">
<div class="center"><img src="classzstandard_1_1backend__cffi_1_1ZstdCompressor__coll__graph.png" border="0" usemap="#azstandard_8backend__cffi_8ZstdCompressor_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb7b95043284db2995d93529e3b512b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#afb7b95043284db2995d93529e3b512b3">__init__</a> (self, level=3, dict_data=None, compression_params=None, write_checksum=None, write_content_size=None, write_dict_id=None, threads=0)</td></tr>
<tr class="separator:afb7b95043284db2995d93529e3b512b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f0efd650b21c692239f9b259da0fbe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#a99f0efd650b21c692239f9b259da0fbe">memory_size</a> (self)</td></tr>
<tr class="separator:a99f0efd650b21c692239f9b259da0fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a40bf35cbe75dcff884787de2c86b93"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#a7a40bf35cbe75dcff884787de2c86b93">compress</a> (self, data)</td></tr>
<tr class="separator:a7a40bf35cbe75dcff884787de2c86b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7ff252f1106f725cd880b32bd0b46b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#a4c7ff252f1106f725cd880b32bd0b46b">compressobj</a> (self, size=-1)</td></tr>
<tr class="separator:a4c7ff252f1106f725cd880b32bd0b46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd4a87ea10791481a4e4578ec09b1ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#afdd4a87ea10791481a4e4578ec09b1ff">chunker</a> (self, size=-1, chunk_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a9c853b81f911a950f328d50cee41a3ba">COMPRESSION_RECOMMENDED_OUTPUT_SIZE</a>)</td></tr>
<tr class="separator:afdd4a87ea10791481a4e4578ec09b1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5347564a0d057329bffa2b6fb3c7b6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#a4c5347564a0d057329bffa2b6fb3c7b6">copy_stream</a> (self, ifh, ofh, size=-1, read_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a674f4a3aae24438f217faeea23a0eb65">COMPRESSION_RECOMMENDED_INPUT_SIZE</a>, write_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a9c853b81f911a950f328d50cee41a3ba">COMPRESSION_RECOMMENDED_OUTPUT_SIZE</a>)</td></tr>
<tr class="separator:a4c5347564a0d057329bffa2b6fb3c7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fff43585be46f31e99e54f6488815f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#a93fff43585be46f31e99e54f6488815f">stream_reader</a> (self, source, size=-1, read_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a674f4a3aae24438f217faeea23a0eb65">COMPRESSION_RECOMMENDED_INPUT_SIZE</a>, closefd=True)</td></tr>
<tr class="separator:a93fff43585be46f31e99e54f6488815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae195071d96ed556b4c02b382d3e5bc11"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#ae195071d96ed556b4c02b382d3e5bc11">stream_writer</a> (self, writer, size=-1, write_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a9c853b81f911a950f328d50cee41a3ba">COMPRESSION_RECOMMENDED_OUTPUT_SIZE</a>, write_return_read=True, closefd=True)</td></tr>
<tr class="separator:ae195071d96ed556b4c02b382d3e5bc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da403357030ce329da503db70b566d0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#a0da403357030ce329da503db70b566d0">read_to_iter</a> (self, reader, size=-1, read_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a674f4a3aae24438f217faeea23a0eb65">COMPRESSION_RECOMMENDED_INPUT_SIZE</a>, write_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a9c853b81f911a950f328d50cee41a3ba">COMPRESSION_RECOMMENDED_OUTPUT_SIZE</a>)</td></tr>
<tr class="separator:a0da403357030ce329da503db70b566d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9a60c2fa55075bfbce4171a5a97fe1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#acd9a60c2fa55075bfbce4171a5a97fe1">multi_compress_to_buffer</a> (self, data, threads=-1)</td></tr>
<tr class="separator:acd9a60c2fa55075bfbce4171a5a97fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad118d77239a2114c8e29720f35503564"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdCompressor.html#ad118d77239a2114c8e29720f35503564">frame_progression</a> (self)</td></tr>
<tr class="separator:ad118d77239a2114c8e29720f35503564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Create an object used to perform Zstandard compression.

Each instance is essentially a wrapper around a ``ZSTD_CCtx`` from
zstd's C API.

An instance can compress data various ways. Instances can be used
multiple times. Each compression operation will use the compression
parameters defined at construction time.

.. note:

   When using a compression dictionary and multiple compression
   operations are performed, the ``ZstdCompressionParameters`` derived
   from an integer compression ``level`` and the first compressed data's
   size will be reused for all subsequent operations. This may not be
   desirable if source data sizes vary significantly.

``compression_params`` is mutually exclusive with ``level``,
``write_checksum``, ``write_content_size``, ``write_dict_id``, and
``threads``.

Assume that each ``ZstdCompressor`` instance can only handle a single
logical compression operation at the same time. i.e. if you call a method
like ``stream_reader()`` to obtain multiple objects derived from the same
``ZstdCompressor`` instance and attempt to use them simultaneously, errors
will likely occur.

If you need to perform multiple logical compression operations and you
can't guarantee those operations are temporally non-overlapping, you need
to obtain multiple ``ZstdCompressor`` instances.

Unless specified otherwise, assume that no two methods of
``ZstdCompressor`` instances can be called from multiple Python
threads simultaneously. In other words, assume instances are not thread safe
unless stated otherwise.

:param level:
   Integer compression level. Valid values are all negative integers
   through 22. Lower values generally yield faster operations with lower
   compression ratios. Higher values are generally slower but compress
   better. The default is 3, which is what the ``zstd`` CLI uses. Negative
   levels effectively engage ``--fast`` mode from the ``zstd`` CLI.
:param dict_data:
   A ``ZstdCompressionDict`` to be used to compress with dictionary
    data.
:param compression_params:
   A ``ZstdCompressionParameters`` instance defining low-level compression
   parameters. If defined, this will overwrite the ``level`` argument.
:param write_checksum:
   If True, a 4 byte content checksum will be written with the compressed
   data, allowing the decompressor to perform content verification.
:param write_content_size:
   If True (the default), the decompressed content size will be included
   in the header of the compressed data. This data will only be written if
   the compressor knows the size of the input data.
:param write_dict_id:
   Determines whether the dictionary ID will be written into the compressed
   data. Defaults to True. Only adds content to the compressed data if
   a dictionary is being used.
:param threads:
   Number of threads to use to compress data concurrently. When set,
   compression operations are performed on multiple threads. The default
   value (0) disables multi-threaded compression. A value of ``-1`` means
   to set the number of threads to the number of detected logical CPUs.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afb7b95043284db2995d93529e3b512b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7b95043284db2995d93529e3b512b3">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict_data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compression_params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_checksum</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_content_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_dict_id</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afdd4a87ea10791481a4e4578ec09b1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd4a87ea10791481a4e4578ec09b1ff">&#9670;&nbsp;</a></span>chunker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.chunker </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a9c853b81f911a950f328d50cee41a3ba">COMPRESSION_RECOMMENDED_OUTPUT_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create an object for iterative compressing to same-sized chunks.

This API is similar to :py:meth:`ZstdCompressor.compressobj` but has
better performance properties.

:param size:
   Size in bytes of data that will be compressed.
:param chunk_size:
   Size of compressed chunks.
:return:
   :py:class:`ZstdCompressionChunker`
</pre> 
</div>
</div>
<a id="a7a40bf35cbe75dcff884787de2c86b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a40bf35cbe75dcff884787de2c86b93">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.compress </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compress data in a single operation.

This is the simplest mechanism to perform compression: simply pass in a
value and get a compressed value back. It is almost the most prone to
abuse.

The input and output values must fit in memory, so passing in very large
values can result in excessive memory usage. For this reason, one of the
streaming based APIs is preferred for larger values.

:param data:
   Source data to compress
:return:
   Compressed data

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; compressed = cctx.compress(b"data to compress")
</pre> 
</div>
</div>
<a id="a4c7ff252f1106f725cd880b32bd0b46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7ff252f1106f725cd880b32bd0b46b">&#9670;&nbsp;</a></span>compressobj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.compressobj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Obtain a compressor exposing the Python standard library compression API.

See :py:class:`ZstdCompressionObj` for the full documentation.

:param size:
   Size in bytes of data that will be compressed.
:return:
   :py:class:`ZstdCompressionObj`
</pre> 
</div>
</div>
<a id="a4c5347564a0d057329bffa2b6fb3c7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5347564a0d057329bffa2b6fb3c7b6">&#9670;&nbsp;</a></span>copy_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.copy_stream </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ifh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ofh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a674f4a3aae24438f217faeea23a0eb65">COMPRESSION_RECOMMENDED_INPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a9c853b81f911a950f328d50cee41a3ba">COMPRESSION_RECOMMENDED_OUTPUT_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Copy data between 2 streams while compressing it.

Data will be read from ``ifh``, compressed, and written to ``ofh``.
``ifh`` must have a ``read(size)`` method. ``ofh`` must have a
``write(data)``
method.

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; with open(input_path, "rb") as ifh, open(output_path, "wb") as ofh:
...     cctx.copy_stream(ifh, ofh)

It is also possible to declare the size of the source stream:

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; cctx.copy_stream(ifh, ofh, size=len_of_input)

You can also specify how large the chunks that are ``read()``
and ``write()`` from and to the streams:

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; cctx.copy_stream(ifh, ofh, read_size=32768, write_size=16384)

The stream copier returns a 2-tuple of bytes read and written:

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; read_count, write_count = cctx.copy_stream(ifh, ofh)

:param ifh:
   Source stream to read from
:param ofh:
   Destination stream to write to
:param size:
   Size in bytes of the source stream. If defined, compression
   parameters will be tuned for this size.
:param read_size:
   Chunk sizes that source stream should be ``read()`` from.
:param write_size:
   Chunk sizes that destination stream should be ``write()`` to.
:return:
   2-tuple of ints of bytes read and written, respectively.
</pre> 
</div>
</div>
<a id="ad118d77239a2114c8e29720f35503564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad118d77239a2114c8e29720f35503564">&#9670;&nbsp;</a></span>frame_progression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.frame_progression </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return information on how much work the compressor has done.

Returns a 3-tuple of (ingested, consumed, produced).

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; (ingested, consumed, produced) = cctx.frame_progression()
</pre> 
</div>
</div>
<a id="a99f0efd650b21c692239f9b259da0fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f0efd650b21c692239f9b259da0fbe">&#9670;&nbsp;</a></span>memory_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.memory_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Obtain the memory usage of this compressor, in bytes.

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; memory = cctx.memory_size()
</pre> 
</div>
</div>
<a id="acd9a60c2fa55075bfbce4171a5a97fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9a60c2fa55075bfbce4171a5a97fe1">&#9670;&nbsp;</a></span>multi_compress_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.multi_compress_to_buffer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threads</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compress multiple pieces of data as a single function call.

(Experimental. Not yet supported by CFFI backend.)

This function is optimized to perform multiple compression operations
as as possible with as little overhead as possible.

Data to be compressed can be passed as a ``BufferWithSegmentsCollection``,
a ``BufferWithSegments``, or a list containing byte like objects. Each
element of the container will be compressed individually using the
configured parameters on the ``ZstdCompressor`` instance.

The ``threads`` argument controls how many threads to use for
compression. The default is ``0`` which means to use a single thread.
Negative values use the number of logical CPUs in the machine.

The function returns a ``BufferWithSegmentsCollection``. This type
represents N discrete memory allocations, each holding 1 or more
compressed frames.

Output data is written to shared memory buffers. This means that unlike
regular Python objects, a reference to *any* object within the collection
keeps the shared buffer and therefore memory backing it alive. This can
have undesirable effects on process memory usage.

The API and behavior of this function is experimental and will likely
change. Known deficiencies include:

* If asked to use multiple threads, it will always spawn that many
  threads, even if the input is too small to use them. It should
  automatically lower the thread count when the extra threads would
  just add overhead.
* The buffer allocation strategy is fixed. There is room to make it
  dynamic, perhaps even to allow one output buffer per input,
  facilitating a variation of the API to return a list without the
  adverse effects of shared memory buffers.

:param data:
   Source to read discrete pieces of data to compress.

   Can be a ``BufferWithSegmentsCollection``, a ``BufferWithSegments``,
   or a ``list[bytes]``.
:return:
   BufferWithSegmentsCollection holding compressed data.
</pre> 
</div>
</div>
<a id="a0da403357030ce329da503db70b566d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da403357030ce329da503db70b566d0">&#9670;&nbsp;</a></span>read_to_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.read_to_iter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a674f4a3aae24438f217faeea23a0eb65">COMPRESSION_RECOMMENDED_INPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a9c853b81f911a950f328d50cee41a3ba">COMPRESSION_RECOMMENDED_OUTPUT_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read uncompressed data from a reader and return an iterator

Returns an iterator of compressed data produced from reading from
``reader``.

This method provides a mechanism to stream compressed data out of a
source as an iterator of data chunks.

Uncompressed data will be obtained from ``reader`` by calling the
``read(size)`` method of it or by reading a slice (if ``reader``
conforms to the *buffer protocol*). The source data will be streamed
into a compressor. As compressed data is available, it will be exposed
to the iterator.

Data is read from the source in chunks of ``read_size``. Compressed
chunks are at most ``write_size`` bytes. Both values default to the
zstd input and and output defaults, respectively.

If reading from the source via ``read()``, ``read()`` will be called
until it raises or returns an empty bytes (``b""``). It is perfectly
valid for the source to deliver fewer bytes than were what requested
by ``read(size)``.

The caller is partially in control of how fast data is fed into the
compressor by how it consumes the returned iterator. The compressor
will not consume from the reader unless the caller consumes from the
iterator.

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; for chunk in cctx.read_to_iter(fh):
...     # Do something with emitted data.

``read_to_iter()`` accepts a ``size`` argument declaring the size of
the input stream:

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; for chunk in cctx.read_to_iter(fh, size=some_int):
&gt;&gt;&gt;     pass

You can also control the size that data is ``read()`` from the source
and the ideal size of output chunks:

&gt;&gt;&gt; cctx = zstandard.ZstdCompressor()
&gt;&gt;&gt; for chunk in cctx.read_to_iter(fh, read_size=16384, write_size=8192):
&gt;&gt;&gt;     pass

``read_to_iter()`` does not give direct control over the sizes of chunks
fed into the compressor. Instead, chunk sizes will be whatever the object
being read from delivers. These will often be of a uniform size.

:param reader:
   Stream providing data to be compressed.
:param size:
   Size in bytes of input data.
:param read_size:
   Controls how many bytes are ``read()`` from the source.
:param write_size:
   Controls the output size of emitted chunks.
:return:
   Iterator of ``bytes``.
</pre> 
</div>
</div>
<a id="a93fff43585be46f31e99e54f6488815f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fff43585be46f31e99e54f6488815f">&#9670;&nbsp;</a></span>stream_reader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.stream_reader </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a674f4a3aae24438f217faeea23a0eb65">COMPRESSION_RECOMMENDED_INPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>closefd</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrap a readable source with a stream that can read compressed data.

This will produce an object conforming to the ``io.RawIOBase``
interface which can be ``read()`` from to retrieve compressed data
from a source.

The source object can be any object with a ``read(size)`` method
or an object that conforms to the buffer protocol.

See :py:class:`ZstdCompressionReader` for type documentation and usage
examples.

:param source:
   Object to read source data from
:param size:
   Size in bytes of source object.
:param read_size:
   How many bytes to request when ``read()``'ing from the source.
:param closefd:
   Whether to close the source stream when the returned stream is
   closed.
:return:
   :py:class:`ZstdCompressionReader`
</pre> 
</div>
</div>
<a id="ae195071d96ed556b4c02b382d3e5bc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae195071d96ed556b4c02b382d3e5bc11">&#9670;&nbsp;</a></span>stream_writer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdCompressor.stream_writer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a9c853b81f911a950f328d50cee41a3ba">COMPRESSION_RECOMMENDED_OUTPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_return_read</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>closefd</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a stream that will write compressed data into another stream.

The argument to ``stream_writer()`` must have a ``write(data)`` method.
As compressed data is available, ``write()`` will be called with the
compressed data as its argument. Many common Python types implement
``write()``, including open file handles and ``io.BytesIO``.

See :py:class:`ZstdCompressionWriter` for more documentation, including
usage examples.

:param writer:
   Stream to write compressed data to.
:param size:
   Size in bytes of data to be compressed. If set, it will be used
   to influence compression parameter tuning and could result in the
   size being written into the header of the compressed data.
:param write_size:
   How much data to ``write()`` to ``writer`` at a time.
:param write_return_read:
   Whether ``write()`` should return the number of bytes that were
   consumed from the input.
:param closefd:
   Whether to ``close`` the ``writer`` when this stream is closed.
:return:
   :py:class:`ZstdCompressionWriter`
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>py3_env/lib/python3.10/site-packages/zstandard/<a class="el" href="backend__cffi_8py.html">backend_cffi.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
