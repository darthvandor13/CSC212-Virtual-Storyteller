<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: oauthlib.oauth1.rfc5849.request_validator.RequestValidator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoauthlib.html">oauthlib</a></li><li class="navelem"><a class="el" href="namespaceoauthlib_1_1oauth1.html">oauth1</a></li><li class="navelem"><a class="el" href="namespaceoauthlib_1_1oauth1_1_1rfc5849.html">rfc5849</a></li><li class="navelem"><a class="el" href="namespaceoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator.html">request_validator</a></li><li class="navelem"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html">RequestValidator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">oauthlib.oauth1.rfc5849.request_validator.RequestValidator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aec05957f8cc98842500b2195ea5d0591"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aec05957f8cc98842500b2195ea5d0591">__init__</a> (self)</td></tr>
<tr class="separator:aec05957f8cc98842500b2195ea5d0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1c906215be886c8ca1bb67c2450937"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a7f1c906215be886c8ca1bb67c2450937">allowed_signature_methods</a> (self)</td></tr>
<tr class="separator:a7f1c906215be886c8ca1bb67c2450937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc161b00ca193d582ecdb807997b4bb8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#abc161b00ca193d582ecdb807997b4bb8">safe_characters</a> (self)</td></tr>
<tr class="separator:abc161b00ca193d582ecdb807997b4bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4562effade8c30d2de8b37d3f4ee444f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a4562effade8c30d2de8b37d3f4ee444f">client_key_length</a> (self)</td></tr>
<tr class="separator:a4562effade8c30d2de8b37d3f4ee444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b72440a9e02b16f4888e62a03e8ce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a620b72440a9e02b16f4888e62a03e8ce">request_token_length</a> (self)</td></tr>
<tr class="separator:a620b72440a9e02b16f4888e62a03e8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b4f5b6b33875a25d9b1fe1ae00943c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a48b4f5b6b33875a25d9b1fe1ae00943c">access_token_length</a> (self)</td></tr>
<tr class="separator:a48b4f5b6b33875a25d9b1fe1ae00943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fae5c06e32d15b55a7d659b466e5cf0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a4fae5c06e32d15b55a7d659b466e5cf0">timestamp_lifetime</a> (self)</td></tr>
<tr class="separator:a4fae5c06e32d15b55a7d659b466e5cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6894ad6e629e457f1f3b81bcd17301"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#afc6894ad6e629e457f1f3b81bcd17301">nonce_length</a> (self)</td></tr>
<tr class="separator:afc6894ad6e629e457f1f3b81bcd17301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a9bac5b272211f7afeddddd0f61cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a416a9bac5b272211f7afeddddd0f61cd">verifier_length</a> (self)</td></tr>
<tr class="separator:a416a9bac5b272211f7afeddddd0f61cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec3b65c526be9201e967f738a81d708"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a> (self)</td></tr>
<tr class="separator:aaec3b65c526be9201e967f738a81d708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee5ea60c1a0576ae8d2ea35470b056a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a0ee5ea60c1a0576ae8d2ea35470b056a">enforce_ssl</a> (self)</td></tr>
<tr class="separator:a0ee5ea60c1a0576ae8d2ea35470b056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418a52c3a5ea2d9c17cf07a2d3c362c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a418a52c3a5ea2d9c17cf07a2d3c362c1">check_client_key</a> (self, client_key)</td></tr>
<tr class="separator:a418a52c3a5ea2d9c17cf07a2d3c362c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbdc034833272d5d46798ea08945034"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#adbbdc034833272d5d46798ea08945034">check_request_token</a> (self, request_token)</td></tr>
<tr class="separator:adbbdc034833272d5d46798ea08945034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cba875d0a054241f906bc2609ae482"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a74cba875d0a054241f906bc2609ae482">check_access_token</a> (self, request_token)</td></tr>
<tr class="separator:a74cba875d0a054241f906bc2609ae482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7ebc8c0a4cadee71a78247b9f1894a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a2e7ebc8c0a4cadee71a78247b9f1894a">check_nonce</a> (self, nonce)</td></tr>
<tr class="separator:a2e7ebc8c0a4cadee71a78247b9f1894a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd43b67225e1290b375d5316f887a9aa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#afd43b67225e1290b375d5316f887a9aa">check_verifier</a> (self, verifier)</td></tr>
<tr class="separator:afd43b67225e1290b375d5316f887a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f302d7a4024b437bab53ee7ad6a3fb8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a7f302d7a4024b437bab53ee7ad6a3fb8">check_realms</a> (self, <a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a>)</td></tr>
<tr class="separator:a7f302d7a4024b437bab53ee7ad6a3fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee3601940b592f49ffaecfe72d43c64"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a5ee3601940b592f49ffaecfe72d43c64">dummy_client</a> (self)</td></tr>
<tr class="separator:a5ee3601940b592f49ffaecfe72d43c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65085d171a4288de220901a044a7ca30"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a65085d171a4288de220901a044a7ca30">dummy_request_token</a> (self)</td></tr>
<tr class="separator:a65085d171a4288de220901a044a7ca30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae282cb3105b52a137191e7214bf954bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#ae282cb3105b52a137191e7214bf954bf">dummy_access_token</a> (self)</td></tr>
<tr class="separator:ae282cb3105b52a137191e7214bf954bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b8e0de1c95696c0075174ec7e85e77"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aa7b8e0de1c95696c0075174ec7e85e77">get_client_secret</a> (self, client_key, request)</td></tr>
<tr class="separator:aa7b8e0de1c95696c0075174ec7e85e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202ab99288c517692eb86274bdb12ce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a1202ab99288c517692eb86274bdb12ce">get_request_token_secret</a> (self, client_key, token, request)</td></tr>
<tr class="separator:a1202ab99288c517692eb86274bdb12ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2d3bf66b5dead0023abcd6f8920f8d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a5a2d3bf66b5dead0023abcd6f8920f8d">get_access_token_secret</a> (self, client_key, token, request)</td></tr>
<tr class="separator:a5a2d3bf66b5dead0023abcd6f8920f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489e3e17d399bdbc2b4313031309147f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a489e3e17d399bdbc2b4313031309147f">get_default_realms</a> (self, client_key, request)</td></tr>
<tr class="separator:a489e3e17d399bdbc2b4313031309147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e81703cfb6da278d9805a809385f3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a97e81703cfb6da278d9805a809385f3f">get_realms</a> (self, token, request)</td></tr>
<tr class="separator:a97e81703cfb6da278d9805a809385f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25865a5f408687b36d955e4d48e34e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#ac25865a5f408687b36d955e4d48e34e1">get_redirect_uri</a> (self, token, request)</td></tr>
<tr class="separator:ac25865a5f408687b36d955e4d48e34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9fcd9156cdade37c890a1b4c5e679"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a98a9fcd9156cdade37c890a1b4c5e679">get_rsa_key</a> (self, client_key, request)</td></tr>
<tr class="separator:a98a9fcd9156cdade37c890a1b4c5e679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b05ed744470e5d5e4566649aa248561"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a6b05ed744470e5d5e4566649aa248561">invalidate_request_token</a> (self, client_key, request_token, request)</td></tr>
<tr class="separator:a6b05ed744470e5d5e4566649aa248561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c2d9ab51b9609479295727f21dc743"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a40c2d9ab51b9609479295727f21dc743">validate_client_key</a> (self, client_key, request)</td></tr>
<tr class="separator:a40c2d9ab51b9609479295727f21dc743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ab35bf6b1fa73200bc123bad4cc7cf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#ac6ab35bf6b1fa73200bc123bad4cc7cf">validate_request_token</a> (self, client_key, token, request)</td></tr>
<tr class="separator:ac6ab35bf6b1fa73200bc123bad4cc7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8211f35e0c09e0990f36e6eea79d04"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaf8211f35e0c09e0990f36e6eea79d04">validate_access_token</a> (self, client_key, token, request)</td></tr>
<tr class="separator:aaf8211f35e0c09e0990f36e6eea79d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f79ea3032c6de80284686b53c3fdc10"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a7f79ea3032c6de80284686b53c3fdc10">validate_timestamp_and_nonce</a> (self, client_key, timestamp, nonce, request, request_token=None, access_token=None)</td></tr>
<tr class="separator:a7f79ea3032c6de80284686b53c3fdc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67031f5f29237314038a8eba01a8d26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#af67031f5f29237314038a8eba01a8d26">validate_redirect_uri</a> (self, client_key, redirect_uri, request)</td></tr>
<tr class="separator:af67031f5f29237314038a8eba01a8d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766d63b940ec185df7749f4c9d0e50e0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a766d63b940ec185df7749f4c9d0e50e0">validate_requested_realms</a> (self, client_key, <a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a>, request)</td></tr>
<tr class="separator:a766d63b940ec185df7749f4c9d0e50e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564651e7227063044c72ead44ea932ac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a564651e7227063044c72ead44ea932ac">validate_realms</a> (self, client_key, token, request, uri=None, <a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a>=None)</td></tr>
<tr class="separator:a564651e7227063044c72ead44ea932ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8d184e352b8225d8679ad6e7fd5477"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a7e8d184e352b8225d8679ad6e7fd5477">validate_verifier</a> (self, client_key, token, verifier, request)</td></tr>
<tr class="separator:a7e8d184e352b8225d8679ad6e7fd5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bb6dd690c09fea83530fd9a027e825"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a74bb6dd690c09fea83530fd9a027e825">verify_request_token</a> (self, token, request)</td></tr>
<tr class="separator:a74bb6dd690c09fea83530fd9a027e825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8b93ea65b1941167a8b67ce4ea2da2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a5c8b93ea65b1941167a8b67ce4ea2da2">verify_realms</a> (self, token, <a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a>, request)</td></tr>
<tr class="separator:a5c8b93ea65b1941167a8b67ce4ea2da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6382fc40fa23e9af58ec9d92ec3ecd0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#af6382fc40fa23e9af58ec9d92ec3ecd0">save_access_token</a> (self, token, request)</td></tr>
<tr class="separator:af6382fc40fa23e9af58ec9d92ec3ecd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43326affc15d8fb5071d2b6e96533914"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a43326affc15d8fb5071d2b6e96533914">save_request_token</a> (self, token, request)</td></tr>
<tr class="separator:a43326affc15d8fb5071d2b6e96533914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffcf919daedcc049c38b65a13ce4f26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a2ffcf919daedcc049c38b65a13ce4f26">save_verifier</a> (self, token, verifier, request)</td></tr>
<tr class="separator:a2ffcf919daedcc049c38b65a13ce4f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec05957f8cc98842500b2195ea5d0591"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aec05957f8cc98842500b2195ea5d0591">__init__</a> (self)</td></tr>
<tr class="separator:aec05957f8cc98842500b2195ea5d0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1c906215be886c8ca1bb67c2450937"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a7f1c906215be886c8ca1bb67c2450937">allowed_signature_methods</a> (self)</td></tr>
<tr class="separator:a7f1c906215be886c8ca1bb67c2450937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc161b00ca193d582ecdb807997b4bb8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#abc161b00ca193d582ecdb807997b4bb8">safe_characters</a> (self)</td></tr>
<tr class="separator:abc161b00ca193d582ecdb807997b4bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4562effade8c30d2de8b37d3f4ee444f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a4562effade8c30d2de8b37d3f4ee444f">client_key_length</a> (self)</td></tr>
<tr class="separator:a4562effade8c30d2de8b37d3f4ee444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b72440a9e02b16f4888e62a03e8ce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a620b72440a9e02b16f4888e62a03e8ce">request_token_length</a> (self)</td></tr>
<tr class="separator:a620b72440a9e02b16f4888e62a03e8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b4f5b6b33875a25d9b1fe1ae00943c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a48b4f5b6b33875a25d9b1fe1ae00943c">access_token_length</a> (self)</td></tr>
<tr class="separator:a48b4f5b6b33875a25d9b1fe1ae00943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fae5c06e32d15b55a7d659b466e5cf0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a4fae5c06e32d15b55a7d659b466e5cf0">timestamp_lifetime</a> (self)</td></tr>
<tr class="separator:a4fae5c06e32d15b55a7d659b466e5cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6894ad6e629e457f1f3b81bcd17301"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#afc6894ad6e629e457f1f3b81bcd17301">nonce_length</a> (self)</td></tr>
<tr class="separator:afc6894ad6e629e457f1f3b81bcd17301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a9bac5b272211f7afeddddd0f61cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a416a9bac5b272211f7afeddddd0f61cd">verifier_length</a> (self)</td></tr>
<tr class="separator:a416a9bac5b272211f7afeddddd0f61cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec3b65c526be9201e967f738a81d708"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a> (self)</td></tr>
<tr class="separator:aaec3b65c526be9201e967f738a81d708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee5ea60c1a0576ae8d2ea35470b056a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a0ee5ea60c1a0576ae8d2ea35470b056a">enforce_ssl</a> (self)</td></tr>
<tr class="separator:a0ee5ea60c1a0576ae8d2ea35470b056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418a52c3a5ea2d9c17cf07a2d3c362c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a418a52c3a5ea2d9c17cf07a2d3c362c1">check_client_key</a> (self, client_key)</td></tr>
<tr class="separator:a418a52c3a5ea2d9c17cf07a2d3c362c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbdc034833272d5d46798ea08945034"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#adbbdc034833272d5d46798ea08945034">check_request_token</a> (self, request_token)</td></tr>
<tr class="separator:adbbdc034833272d5d46798ea08945034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cba875d0a054241f906bc2609ae482"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a74cba875d0a054241f906bc2609ae482">check_access_token</a> (self, request_token)</td></tr>
<tr class="separator:a74cba875d0a054241f906bc2609ae482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7ebc8c0a4cadee71a78247b9f1894a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a2e7ebc8c0a4cadee71a78247b9f1894a">check_nonce</a> (self, nonce)</td></tr>
<tr class="separator:a2e7ebc8c0a4cadee71a78247b9f1894a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd43b67225e1290b375d5316f887a9aa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#afd43b67225e1290b375d5316f887a9aa">check_verifier</a> (self, verifier)</td></tr>
<tr class="separator:afd43b67225e1290b375d5316f887a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f302d7a4024b437bab53ee7ad6a3fb8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a7f302d7a4024b437bab53ee7ad6a3fb8">check_realms</a> (self, <a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a>)</td></tr>
<tr class="separator:a7f302d7a4024b437bab53ee7ad6a3fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee3601940b592f49ffaecfe72d43c64"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a5ee3601940b592f49ffaecfe72d43c64">dummy_client</a> (self)</td></tr>
<tr class="separator:a5ee3601940b592f49ffaecfe72d43c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65085d171a4288de220901a044a7ca30"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a65085d171a4288de220901a044a7ca30">dummy_request_token</a> (self)</td></tr>
<tr class="separator:a65085d171a4288de220901a044a7ca30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae282cb3105b52a137191e7214bf954bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#ae282cb3105b52a137191e7214bf954bf">dummy_access_token</a> (self)</td></tr>
<tr class="separator:ae282cb3105b52a137191e7214bf954bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b8e0de1c95696c0075174ec7e85e77"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aa7b8e0de1c95696c0075174ec7e85e77">get_client_secret</a> (self, client_key, request)</td></tr>
<tr class="separator:aa7b8e0de1c95696c0075174ec7e85e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202ab99288c517692eb86274bdb12ce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a1202ab99288c517692eb86274bdb12ce">get_request_token_secret</a> (self, client_key, token, request)</td></tr>
<tr class="separator:a1202ab99288c517692eb86274bdb12ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2d3bf66b5dead0023abcd6f8920f8d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a5a2d3bf66b5dead0023abcd6f8920f8d">get_access_token_secret</a> (self, client_key, token, request)</td></tr>
<tr class="separator:a5a2d3bf66b5dead0023abcd6f8920f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489e3e17d399bdbc2b4313031309147f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a489e3e17d399bdbc2b4313031309147f">get_default_realms</a> (self, client_key, request)</td></tr>
<tr class="separator:a489e3e17d399bdbc2b4313031309147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e81703cfb6da278d9805a809385f3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a97e81703cfb6da278d9805a809385f3f">get_realms</a> (self, token, request)</td></tr>
<tr class="separator:a97e81703cfb6da278d9805a809385f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25865a5f408687b36d955e4d48e34e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#ac25865a5f408687b36d955e4d48e34e1">get_redirect_uri</a> (self, token, request)</td></tr>
<tr class="separator:ac25865a5f408687b36d955e4d48e34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9fcd9156cdade37c890a1b4c5e679"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a98a9fcd9156cdade37c890a1b4c5e679">get_rsa_key</a> (self, client_key, request)</td></tr>
<tr class="separator:a98a9fcd9156cdade37c890a1b4c5e679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b05ed744470e5d5e4566649aa248561"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a6b05ed744470e5d5e4566649aa248561">invalidate_request_token</a> (self, client_key, request_token, request)</td></tr>
<tr class="separator:a6b05ed744470e5d5e4566649aa248561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c2d9ab51b9609479295727f21dc743"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a40c2d9ab51b9609479295727f21dc743">validate_client_key</a> (self, client_key, request)</td></tr>
<tr class="separator:a40c2d9ab51b9609479295727f21dc743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ab35bf6b1fa73200bc123bad4cc7cf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#ac6ab35bf6b1fa73200bc123bad4cc7cf">validate_request_token</a> (self, client_key, token, request)</td></tr>
<tr class="separator:ac6ab35bf6b1fa73200bc123bad4cc7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8211f35e0c09e0990f36e6eea79d04"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaf8211f35e0c09e0990f36e6eea79d04">validate_access_token</a> (self, client_key, token, request)</td></tr>
<tr class="separator:aaf8211f35e0c09e0990f36e6eea79d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f79ea3032c6de80284686b53c3fdc10"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a7f79ea3032c6de80284686b53c3fdc10">validate_timestamp_and_nonce</a> (self, client_key, timestamp, nonce, request, request_token=None, access_token=None)</td></tr>
<tr class="separator:a7f79ea3032c6de80284686b53c3fdc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67031f5f29237314038a8eba01a8d26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#af67031f5f29237314038a8eba01a8d26">validate_redirect_uri</a> (self, client_key, redirect_uri, request)</td></tr>
<tr class="separator:af67031f5f29237314038a8eba01a8d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766d63b940ec185df7749f4c9d0e50e0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a766d63b940ec185df7749f4c9d0e50e0">validate_requested_realms</a> (self, client_key, <a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a>, request)</td></tr>
<tr class="separator:a766d63b940ec185df7749f4c9d0e50e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564651e7227063044c72ead44ea932ac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a564651e7227063044c72ead44ea932ac">validate_realms</a> (self, client_key, token, request, uri=None, <a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a>=None)</td></tr>
<tr class="separator:a564651e7227063044c72ead44ea932ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8d184e352b8225d8679ad6e7fd5477"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a7e8d184e352b8225d8679ad6e7fd5477">validate_verifier</a> (self, client_key, token, verifier, request)</td></tr>
<tr class="separator:a7e8d184e352b8225d8679ad6e7fd5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bb6dd690c09fea83530fd9a027e825"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a74bb6dd690c09fea83530fd9a027e825">verify_request_token</a> (self, token, request)</td></tr>
<tr class="separator:a74bb6dd690c09fea83530fd9a027e825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8b93ea65b1941167a8b67ce4ea2da2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a5c8b93ea65b1941167a8b67ce4ea2da2">verify_realms</a> (self, token, <a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#aaec3b65c526be9201e967f738a81d708">realms</a>, request)</td></tr>
<tr class="separator:a5c8b93ea65b1941167a8b67ce4ea2da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6382fc40fa23e9af58ec9d92ec3ecd0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#af6382fc40fa23e9af58ec9d92ec3ecd0">save_access_token</a> (self, token, request)</td></tr>
<tr class="separator:af6382fc40fa23e9af58ec9d92ec3ecd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43326affc15d8fb5071d2b6e96533914"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a43326affc15d8fb5071d2b6e96533914">save_request_token</a> (self, token, request)</td></tr>
<tr class="separator:a43326affc15d8fb5071d2b6e96533914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffcf919daedcc049c38b65a13ce4f26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoauthlib_1_1oauth1_1_1rfc5849_1_1request__validator_1_1RequestValidator.html#a2ffcf919daedcc049c38b65a13ce4f26">save_verifier</a> (self, token, verifier, request)</td></tr>
<tr class="separator:a2ffcf919daedcc049c38b65a13ce4f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">A validator/datastore interaction base class for OAuth 1 providers.

OAuth providers should inherit from RequestValidator and implement the
methods and properties outlined below. Further details are provided in the
documentation for each method and property.

Methods used to check the format of input parameters. Common tests include
length, character set, membership, range or pattern. These tests are
referred to as `whitelisting or blacklisting`_. Whitelisting is better
but blacklisting can be useful to spot malicious activity.
The following have methods a default implementation:

- check_client_key
- check_request_token
- check_access_token
- check_nonce
- check_verifier
- check_realms

The methods above default to whitelist input parameters, checking that they
are alphanumerical and between a minimum and maximum length. Rather than
overloading the methods a few properties can be used to configure these
methods.

* @safe_characters -&gt; (character set)
* @client_key_length -&gt; (min, max)
* @request_token_length -&gt; (min, max)
* @access_token_length -&gt; (min, max)
* @nonce_length -&gt; (min, max)
* @verifier_length -&gt; (min, max)
* @realms -&gt; [list, of, realms]

Methods used to validate/invalidate input parameters. These checks usually
hit either persistent or temporary storage such as databases or the
filesystem. See each methods documentation for detailed usage.
The following methods must be implemented:

- validate_client_key
- validate_request_token
- validate_access_token
- validate_timestamp_and_nonce
- validate_redirect_uri
- validate_requested_realms
- validate_realms
- validate_verifier
- invalidate_request_token

Methods used to retrieve sensitive information from storage.
The following methods must be implemented:

- get_client_secret
- get_request_token_secret
- get_access_token_secret
- get_rsa_key
- get_realms
- get_default_realms
- get_redirect_uri

Methods used to save credentials.
The following methods must be implemented:

- save_request_token
- save_verifier
- save_access_token

Methods used to verify input parameters. This methods are used during
authorizing request token by user (AuthorizationEndpoint), to check if
parameters are valid. During token authorization request is not signed,
thus 'validation' methods can not be used. The following methods must be
implemented:

- verify_realms
- verify_request_token

To prevent timing attacks it is necessary to not exit early even if the
client key or resource owner key is invalid. Instead dummy values should
be used during the remaining verification process. It is very important
that the dummy client and token are valid input parameters to the methods
get_client_secret, get_rsa_key and get_(access/request)_token_secret and
that the running time of those methods when given a dummy value remain
equivalent to the running time when given a valid client/resource owner.
The following properties must be implemented:

* @dummy_client
* @dummy_request_token
* @dummy_access_token

Example implementations have been provided, note that the database used is
a simple dictionary and serves only an illustrative purpose. Use whichever
database suits your project and how to access it is entirely up to you.
The methods are introduced in an order which should make understanding
their use more straightforward and as such it could be worth reading what
follows in chronological order.

.. _`whitelisting or blacklisting`: https://www.schneier.com/blog/archives/2011/01/whitelisting_vs.html
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aec05957f8cc98842500b2195ea5d0591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec05957f8cc98842500b2195ea5d0591">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec05957f8cc98842500b2195ea5d0591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec05957f8cc98842500b2195ea5d0591">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a48b4f5b6b33875a25d9b1fe1ae00943c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b4f5b6b33875a25d9b1fe1ae00943c">&#9670;&nbsp;</a></span>access_token_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.access_token_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b4f5b6b33875a25d9b1fe1ae00943c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b4f5b6b33875a25d9b1fe1ae00943c">&#9670;&nbsp;</a></span>access_token_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.access_token_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f1c906215be886c8ca1bb67c2450937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1c906215be886c8ca1bb67c2450937">&#9670;&nbsp;</a></span>allowed_signature_methods() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.allowed_signature_methods </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f1c906215be886c8ca1bb67c2450937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1c906215be886c8ca1bb67c2450937">&#9670;&nbsp;</a></span>allowed_signature_methods() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.allowed_signature_methods </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74cba875d0a054241f906bc2609ae482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cba875d0a054241f906bc2609ae482">&#9670;&nbsp;</a></span>check_access_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_access_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks that the token contains only safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="a74cba875d0a054241f906bc2609ae482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cba875d0a054241f906bc2609ae482">&#9670;&nbsp;</a></span>check_access_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_access_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks that the token contains only safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="a418a52c3a5ea2d9c17cf07a2d3c362c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418a52c3a5ea2d9c17cf07a2d3c362c1">&#9670;&nbsp;</a></span>check_client_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_client_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the client key only contains safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="a418a52c3a5ea2d9c17cf07a2d3c362c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418a52c3a5ea2d9c17cf07a2d3c362c1">&#9670;&nbsp;</a></span>check_client_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_client_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the client key only contains safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="a2e7ebc8c0a4cadee71a78247b9f1894a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7ebc8c0a4cadee71a78247b9f1894a">&#9670;&nbsp;</a></span>check_nonce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_nonce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks that the nonce only contains only safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="a2e7ebc8c0a4cadee71a78247b9f1894a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7ebc8c0a4cadee71a78247b9f1894a">&#9670;&nbsp;</a></span>check_nonce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_nonce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks that the nonce only contains only safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="a7f302d7a4024b437bab53ee7ad6a3fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f302d7a4024b437bab53ee7ad6a3fb8">&#9670;&nbsp;</a></span>check_realms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>realms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the realm is one of a set allowed realms.</pre> 
</div>
</div>
<a id="a7f302d7a4024b437bab53ee7ad6a3fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f302d7a4024b437bab53ee7ad6a3fb8">&#9670;&nbsp;</a></span>check_realms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>realms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the realm is one of a set allowed realms.</pre> 
</div>
</div>
<a id="adbbdc034833272d5d46798ea08945034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbdc034833272d5d46798ea08945034">&#9670;&nbsp;</a></span>check_request_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks that the request token contains only safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="adbbdc034833272d5d46798ea08945034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbdc034833272d5d46798ea08945034">&#9670;&nbsp;</a></span>check_request_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks that the request token contains only safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="afd43b67225e1290b375d5316f887a9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd43b67225e1290b375d5316f887a9aa">&#9670;&nbsp;</a></span>check_verifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_verifier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks that the verifier contains only safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="afd43b67225e1290b375d5316f887a9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd43b67225e1290b375d5316f887a9aa">&#9670;&nbsp;</a></span>check_verifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.check_verifier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks that the verifier contains only safe characters
and is no shorter than lower and no longer than upper.
</pre> 
</div>
</div>
<a id="a4562effade8c30d2de8b37d3f4ee444f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4562effade8c30d2de8b37d3f4ee444f">&#9670;&nbsp;</a></span>client_key_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.client_key_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4562effade8c30d2de8b37d3f4ee444f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4562effade8c30d2de8b37d3f4ee444f">&#9670;&nbsp;</a></span>client_key_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.client_key_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae282cb3105b52a137191e7214bf954bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae282cb3105b52a137191e7214bf954bf">&#9670;&nbsp;</a></span>dummy_access_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.dummy_access_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dummy access token used when an invalid token was supplied.

:returns: The dummy access token string.

The dummy access token should be associated with an access token
secret such that get_access_token_secret(.., dummy_access_token)
returns a valid secret.

This method is used by

* ResourceEndpoint
</pre> 
</div>
</div>
<a id="ae282cb3105b52a137191e7214bf954bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae282cb3105b52a137191e7214bf954bf">&#9670;&nbsp;</a></span>dummy_access_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.dummy_access_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dummy access token used when an invalid token was supplied.

:returns: The dummy access token string.

The dummy access token should be associated with an access token
secret such that get_access_token_secret(.., dummy_access_token)
returns a valid secret.

This method is used by

* ResourceEndpoint
</pre> 
</div>
</div>
<a id="a5ee3601940b592f49ffaecfe72d43c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee3601940b592f49ffaecfe72d43c64">&#9670;&nbsp;</a></span>dummy_client() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.dummy_client </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dummy client used when an invalid client key is supplied.

:returns: The dummy client key string.

The dummy client should be associated with either a client secret,
a rsa key or both depending on which signature methods are supported.
Providers should make sure that

get_client_secret(dummy_client)
get_rsa_key(dummy_client)

return a valid secret or key for the dummy client.

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a5ee3601940b592f49ffaecfe72d43c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee3601940b592f49ffaecfe72d43c64">&#9670;&nbsp;</a></span>dummy_client() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.dummy_client </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dummy client used when an invalid client key is supplied.

:returns: The dummy client key string.

The dummy client should be associated with either a client secret,
a rsa key or both depending on which signature methods are supported.
Providers should make sure that

get_client_secret(dummy_client)
get_rsa_key(dummy_client)

return a valid secret or key for the dummy client.

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a65085d171a4288de220901a044a7ca30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65085d171a4288de220901a044a7ca30">&#9670;&nbsp;</a></span>dummy_request_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.dummy_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dummy request token used when an invalid token was supplied.

:returns: The dummy request token string.

The dummy request token should be associated with a request token
secret such that get_request_token_secret(.., dummy_request_token)
returns a valid secret.

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a65085d171a4288de220901a044a7ca30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65085d171a4288de220901a044a7ca30">&#9670;&nbsp;</a></span>dummy_request_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.dummy_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dummy request token used when an invalid token was supplied.

:returns: The dummy request token string.

The dummy request token should be associated with a request token
secret such that get_request_token_secret(.., dummy_request_token)
returns a valid secret.

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a0ee5ea60c1a0576ae8d2ea35470b056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee5ea60c1a0576ae8d2ea35470b056a">&#9670;&nbsp;</a></span>enforce_ssl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.enforce_ssl </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ee5ea60c1a0576ae8d2ea35470b056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee5ea60c1a0576ae8d2ea35470b056a">&#9670;&nbsp;</a></span>enforce_ssl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.enforce_ssl </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a2d3bf66b5dead0023abcd6f8920f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2d3bf66b5dead0023abcd6f8920f8d">&#9670;&nbsp;</a></span>get_access_token_secret() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_access_token_secret </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieves the shared secret associated with the access token.

:param client_key: The client/consumer key.
:param token: The access token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The token secret as a string.

This method must allow the use of a dummy values and the running time
must be roughly equivalent to that of the running time of valid values::

    # Unlikely to be near constant time as it uses two database
    # lookups for a valid client, and only one for an invalid.
    from your_datastore import AccessTokenSecret
    if AccessTokenSecret.has(client_key):
        return AccessTokenSecret.get((client_key, request_token))
    else:
        return 'dummy'

    # Aim to mimic number of latency inducing operations no matter
    # whether the client is valid or not.
    from your_datastore import AccessTokenSecret
    return ClientSecret.get((client_key, request_token), 'dummy')

Note that the returned key must be in plaintext.

This method is used by

* ResourceEndpoint
</pre> 
</div>
</div>
<a id="a5a2d3bf66b5dead0023abcd6f8920f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2d3bf66b5dead0023abcd6f8920f8d">&#9670;&nbsp;</a></span>get_access_token_secret() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_access_token_secret </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieves the shared secret associated with the access token.

:param client_key: The client/consumer key.
:param token: The access token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The token secret as a string.

This method must allow the use of a dummy values and the running time
must be roughly equivalent to that of the running time of valid values::

    # Unlikely to be near constant time as it uses two database
    # lookups for a valid client, and only one for an invalid.
    from your_datastore import AccessTokenSecret
    if AccessTokenSecret.has(client_key):
        return AccessTokenSecret.get((client_key, request_token))
    else:
        return 'dummy'

    # Aim to mimic number of latency inducing operations no matter
    # whether the client is valid or not.
    from your_datastore import AccessTokenSecret
    return ClientSecret.get((client_key, request_token), 'dummy')

Note that the returned key must be in plaintext.

This method is used by

* ResourceEndpoint
</pre> 
</div>
</div>
<a id="aa7b8e0de1c95696c0075174ec7e85e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b8e0de1c95696c0075174ec7e85e77">&#9670;&nbsp;</a></span>get_client_secret() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_client_secret </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieves the client secret associated with the client key.

:param client_key: The client/consumer key.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The client secret as a string.

This method must allow the use of a dummy client_key value.
Fetching the secret using the dummy key must take the same amount of
time as fetching a secret for a valid client::

    # Unlikely to be near constant time as it uses two database
    # lookups for a valid client, and only one for an invalid.
    from your_datastore import ClientSecret
    if ClientSecret.has(client_key):
        return ClientSecret.get(client_key)
    else:
        return 'dummy'

    # Aim to mimic number of latency inducing operations no matter
    # whether the client is valid or not.
    from your_datastore import ClientSecret
    return ClientSecret.get(client_key, 'dummy')

Note that the returned key must be in plaintext.

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="aa7b8e0de1c95696c0075174ec7e85e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b8e0de1c95696c0075174ec7e85e77">&#9670;&nbsp;</a></span>get_client_secret() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_client_secret </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieves the client secret associated with the client key.

:param client_key: The client/consumer key.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The client secret as a string.

This method must allow the use of a dummy client_key value.
Fetching the secret using the dummy key must take the same amount of
time as fetching a secret for a valid client::

    # Unlikely to be near constant time as it uses two database
    # lookups for a valid client, and only one for an invalid.
    from your_datastore import ClientSecret
    if ClientSecret.has(client_key):
        return ClientSecret.get(client_key)
    else:
        return 'dummy'

    # Aim to mimic number of latency inducing operations no matter
    # whether the client is valid or not.
    from your_datastore import ClientSecret
    return ClientSecret.get(client_key, 'dummy')

Note that the returned key must be in plaintext.

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a489e3e17d399bdbc2b4313031309147f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489e3e17d399bdbc2b4313031309147f">&#9670;&nbsp;</a></span>get_default_realms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_default_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the default realms for a client.

:param client_key: The client/consumer key.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The list of default realms associated with the client.

The list of default realms will be set during client registration and
is outside the scope of OAuthLib.

This method is used by

* RequestTokenEndpoint
</pre> 
</div>
</div>
<a id="a489e3e17d399bdbc2b4313031309147f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489e3e17d399bdbc2b4313031309147f">&#9670;&nbsp;</a></span>get_default_realms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_default_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the default realms for a client.

:param client_key: The client/consumer key.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The list of default realms associated with the client.

The list of default realms will be set during client registration and
is outside the scope of OAuthLib.

This method is used by

* RequestTokenEndpoint
</pre> 
</div>
</div>
<a id="a97e81703cfb6da278d9805a809385f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e81703cfb6da278d9805a809385f3f">&#9670;&nbsp;</a></span>get_realms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get realms associated with a request token.

:param token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The list of realms associated with the request token.

This method is used by

* AuthorizationEndpoint
* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a97e81703cfb6da278d9805a809385f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e81703cfb6da278d9805a809385f3f">&#9670;&nbsp;</a></span>get_realms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get realms associated with a request token.

:param token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The list of realms associated with the request token.

This method is used by

* AuthorizationEndpoint
* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="ac25865a5f408687b36d955e4d48e34e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25865a5f408687b36d955e4d48e34e1">&#9670;&nbsp;</a></span>get_redirect_uri() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_redirect_uri </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the redirect URI associated with a request token.

:param token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The redirect URI associated with the request token.

It may be desirable to return a custom URI if the redirect is set to "oob".
In this case, the user will be redirected to the returned URI and at that
endpoint the verifier can be displayed.

This method is used by

* AuthorizationEndpoint
</pre> 
</div>
</div>
<a id="ac25865a5f408687b36d955e4d48e34e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25865a5f408687b36d955e4d48e34e1">&#9670;&nbsp;</a></span>get_redirect_uri() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_redirect_uri </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the redirect URI associated with a request token.

:param token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The redirect URI associated with the request token.

It may be desirable to return a custom URI if the redirect is set to "oob".
In this case, the user will be redirected to the returned URI and at that
endpoint the verifier can be displayed.

This method is used by

* AuthorizationEndpoint
</pre> 
</div>
</div>
<a id="a1202ab99288c517692eb86274bdb12ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1202ab99288c517692eb86274bdb12ce">&#9670;&nbsp;</a></span>get_request_token_secret() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_request_token_secret </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieves the shared secret associated with the request token.

:param client_key: The client/consumer key.
:param token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The token secret as a string.

This method must allow the use of a dummy values and the running time
must be roughly equivalent to that of the running time of valid values::

    # Unlikely to be near constant time as it uses two database
    # lookups for a valid client, and only one for an invalid.
    from your_datastore import RequestTokenSecret
    if RequestTokenSecret.has(client_key):
        return RequestTokenSecret.get((client_key, request_token))
    else:
        return 'dummy'

    # Aim to mimic number of latency inducing operations no matter
    # whether the client is valid or not.
    from your_datastore import RequestTokenSecret
    return ClientSecret.get((client_key, request_token), 'dummy')

Note that the returned key must be in plaintext.

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a1202ab99288c517692eb86274bdb12ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1202ab99288c517692eb86274bdb12ce">&#9670;&nbsp;</a></span>get_request_token_secret() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_request_token_secret </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieves the shared secret associated with the request token.

:param client_key: The client/consumer key.
:param token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The token secret as a string.

This method must allow the use of a dummy values and the running time
must be roughly equivalent to that of the running time of valid values::

    # Unlikely to be near constant time as it uses two database
    # lookups for a valid client, and only one for an invalid.
    from your_datastore import RequestTokenSecret
    if RequestTokenSecret.has(client_key):
        return RequestTokenSecret.get((client_key, request_token))
    else:
        return 'dummy'

    # Aim to mimic number of latency inducing operations no matter
    # whether the client is valid or not.
    from your_datastore import RequestTokenSecret
    return ClientSecret.get((client_key, request_token), 'dummy')

Note that the returned key must be in plaintext.

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a98a9fcd9156cdade37c890a1b4c5e679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a9fcd9156cdade37c890a1b4c5e679">&#9670;&nbsp;</a></span>get_rsa_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_rsa_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieves a previously stored client provided RSA key.

:param client_key: The client/consumer key.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The rsa public key as a string.

This method must allow the use of a dummy client_key value. Fetching
the rsa key using the dummy key must take the same amount of time
as fetching a key for a valid client. The dummy key must also be of
the same bit length as client keys.

Note that the key must be returned in plaintext.

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a98a9fcd9156cdade37c890a1b4c5e679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a9fcd9156cdade37c890a1b4c5e679">&#9670;&nbsp;</a></span>get_rsa_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.get_rsa_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Retrieves a previously stored client provided RSA key.

:param client_key: The client/consumer key.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: The rsa public key as a string.

This method must allow the use of a dummy client_key value. Fetching
the rsa key using the dummy key must take the same amount of time
as fetching a key for a valid client. The dummy key must also be of
the same bit length as client keys.

Note that the key must be returned in plaintext.

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a6b05ed744470e5d5e4566649aa248561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b05ed744470e5d5e4566649aa248561">&#9670;&nbsp;</a></span>invalidate_request_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.invalidate_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Invalidates a used request token.

:param client_key: The client/consumer key.
:param request_token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: None

Per `Section 2.3`_ of the spec:

"The server MUST (...) ensure that the temporary
credentials have not expired or been used before."

.. _`Section 2.3`: https://tools.ietf.org/html/rfc5849#section-2.3

This method should ensure that provided token won't validate anymore.
It can be simply removing RequestToken from storage or setting
specific flag that makes it invalid (note that such flag should be
also validated during request token validation).

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a6b05ed744470e5d5e4566649aa248561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b05ed744470e5d5e4566649aa248561">&#9670;&nbsp;</a></span>invalidate_request_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.invalidate_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Invalidates a used request token.

:param client_key: The client/consumer key.
:param request_token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: None

Per `Section 2.3`_ of the spec:

"The server MUST (...) ensure that the temporary
credentials have not expired or been used before."

.. _`Section 2.3`: https://tools.ietf.org/html/rfc5849#section-2.3

This method should ensure that provided token won't validate anymore.
It can be simply removing RequestToken from storage or setting
specific flag that makes it invalid (note that such flag should be
also validated during request token validation).

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="afc6894ad6e629e457f1f3b81bcd17301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6894ad6e629e457f1f3b81bcd17301">&#9670;&nbsp;</a></span>nonce_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.nonce_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc6894ad6e629e457f1f3b81bcd17301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6894ad6e629e457f1f3b81bcd17301">&#9670;&nbsp;</a></span>nonce_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.nonce_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaec3b65c526be9201e967f738a81d708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec3b65c526be9201e967f738a81d708">&#9670;&nbsp;</a></span>realms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaec3b65c526be9201e967f738a81d708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec3b65c526be9201e967f738a81d708">&#9670;&nbsp;</a></span>realms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a620b72440a9e02b16f4888e62a03e8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620b72440a9e02b16f4888e62a03e8ce">&#9670;&nbsp;</a></span>request_token_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.request_token_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a620b72440a9e02b16f4888e62a03e8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620b72440a9e02b16f4888e62a03e8ce">&#9670;&nbsp;</a></span>request_token_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.request_token_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc161b00ca193d582ecdb807997b4bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc161b00ca193d582ecdb807997b4bb8">&#9670;&nbsp;</a></span>safe_characters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.safe_characters </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc161b00ca193d582ecdb807997b4bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc161b00ca193d582ecdb807997b4bb8">&#9670;&nbsp;</a></span>safe_characters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.safe_characters </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6382fc40fa23e9af58ec9d92ec3ecd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6382fc40fa23e9af58ec9d92ec3ecd0">&#9670;&nbsp;</a></span>save_access_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.save_access_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Save an OAuth1 access token.

:param token: A dict with token credentials.
:param request: OAuthlib request.
:type request: oauthlib.common.Request

The token dictionary will at minimum include

* ``oauth_token`` the access token string.
* ``oauth_token_secret`` the token specific secret used in signing.
* ``oauth_authorized_realms`` a space separated list of realms.

Client key can be obtained from ``request.client_key``.

The list of realms (not joined string) can be obtained from
``request.realm``.

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="af6382fc40fa23e9af58ec9d92ec3ecd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6382fc40fa23e9af58ec9d92ec3ecd0">&#9670;&nbsp;</a></span>save_access_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.save_access_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Save an OAuth1 access token.

:param token: A dict with token credentials.
:param request: OAuthlib request.
:type request: oauthlib.common.Request

The token dictionary will at minimum include

* ``oauth_token`` the access token string.
* ``oauth_token_secret`` the token specific secret used in signing.
* ``oauth_authorized_realms`` a space separated list of realms.

Client key can be obtained from ``request.client_key``.

The list of realms (not joined string) can be obtained from
``request.realm``.

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a43326affc15d8fb5071d2b6e96533914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43326affc15d8fb5071d2b6e96533914">&#9670;&nbsp;</a></span>save_request_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.save_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Save an OAuth1 request token.

:param token: A dict with token credentials.
:param request: OAuthlib request.
:type request: oauthlib.common.Request

The token dictionary will at minimum include

* ``oauth_token`` the request token string.
* ``oauth_token_secret`` the token specific secret used in signing.
* ``oauth_callback_confirmed`` the string ``true``.

Client key can be obtained from ``request.client_key``.

This method is used by

* RequestTokenEndpoint
</pre> 
</div>
</div>
<a id="a43326affc15d8fb5071d2b6e96533914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43326affc15d8fb5071d2b6e96533914">&#9670;&nbsp;</a></span>save_request_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.save_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Save an OAuth1 request token.

:param token: A dict with token credentials.
:param request: OAuthlib request.
:type request: oauthlib.common.Request

The token dictionary will at minimum include

* ``oauth_token`` the request token string.
* ``oauth_token_secret`` the token specific secret used in signing.
* ``oauth_callback_confirmed`` the string ``true``.

Client key can be obtained from ``request.client_key``.

This method is used by

* RequestTokenEndpoint
</pre> 
</div>
</div>
<a id="a2ffcf919daedcc049c38b65a13ce4f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffcf919daedcc049c38b65a13ce4f26">&#9670;&nbsp;</a></span>save_verifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.save_verifier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Associate an authorization verifier with a request token.

:param token: A request token string.
:param verifier: A dictionary containing the oauth_verifier and
                oauth_token
:param request: OAuthlib request.
:type request: oauthlib.common.Request

We need to associate verifiers with tokens for validation during the
access token request.

Note that unlike save_x_token token here is the ``oauth_token`` token
string from the request token saved previously.

This method is used by

* AuthorizationEndpoint
</pre> 
</div>
</div>
<a id="a2ffcf919daedcc049c38b65a13ce4f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffcf919daedcc049c38b65a13ce4f26">&#9670;&nbsp;</a></span>save_verifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.save_verifier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Associate an authorization verifier with a request token.

:param token: A request token string.
:param verifier: A dictionary containing the oauth_verifier and
                oauth_token
:param request: OAuthlib request.
:type request: oauthlib.common.Request

We need to associate verifiers with tokens for validation during the
access token request.

Note that unlike save_x_token token here is the ``oauth_token`` token
string from the request token saved previously.

This method is used by

* AuthorizationEndpoint
</pre> 
</div>
</div>
<a id="a4fae5c06e32d15b55a7d659b466e5cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fae5c06e32d15b55a7d659b466e5cf0">&#9670;&nbsp;</a></span>timestamp_lifetime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.timestamp_lifetime </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fae5c06e32d15b55a7d659b466e5cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fae5c06e32d15b55a7d659b466e5cf0">&#9670;&nbsp;</a></span>timestamp_lifetime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.timestamp_lifetime </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf8211f35e0c09e0990f36e6eea79d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8211f35e0c09e0990f36e6eea79d04">&#9670;&nbsp;</a></span>validate_access_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_access_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that supplied access token is registered and valid.

:param client_key: The client/consumer key.
:param token: The access token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

Note that if the dummy access token is supplied it should validate in
the same or nearly the same amount of time as a valid one.

Ensure latency inducing tasks are mimiced even for dummy clients.
For example, use::

    from your_datastore import AccessToken
    try:
        return AccessToken.exists(client_key, access_token)
    except DoesNotExist:
        return False

Rather than::

    from your_datastore import AccessToken
    if access_token == self.dummy_access_token:
        return False
    else:
        return AccessToken.exists(client_key, access_token)

This method is used by

* ResourceEndpoint
</pre> 
</div>
</div>
<a id="aaf8211f35e0c09e0990f36e6eea79d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8211f35e0c09e0990f36e6eea79d04">&#9670;&nbsp;</a></span>validate_access_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_access_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that supplied access token is registered and valid.

:param client_key: The client/consumer key.
:param token: The access token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

Note that if the dummy access token is supplied it should validate in
the same or nearly the same amount of time as a valid one.

Ensure latency inducing tasks are mimiced even for dummy clients.
For example, use::

    from your_datastore import AccessToken
    try:
        return AccessToken.exists(client_key, access_token)
    except DoesNotExist:
        return False

Rather than::

    from your_datastore import AccessToken
    if access_token == self.dummy_access_token:
        return False
    else:
        return AccessToken.exists(client_key, access_token)

This method is used by

* ResourceEndpoint
</pre> 
</div>
</div>
<a id="a40c2d9ab51b9609479295727f21dc743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c2d9ab51b9609479295727f21dc743">&#9670;&nbsp;</a></span>validate_client_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_client_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that supplied client key is a registered and valid client.

:param client_key: The client/consumer key.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

Note that if the dummy client is supplied it should validate in same
or nearly the same amount of time as a valid one.

Ensure latency inducing tasks are mimiced even for dummy clients.
For example, use::

    from your_datastore import Client
    try:
        return Client.exists(client_key, access_token)
    except DoesNotExist:
        return False

Rather than::

    from your_datastore import Client
    if access_token == self.dummy_access_token:
        return False
    else:
        return Client.exists(client_key, access_token)

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a40c2d9ab51b9609479295727f21dc743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c2d9ab51b9609479295727f21dc743">&#9670;&nbsp;</a></span>validate_client_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_client_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that supplied client key is a registered and valid client.

:param client_key: The client/consumer key.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

Note that if the dummy client is supplied it should validate in same
or nearly the same amount of time as a valid one.

Ensure latency inducing tasks are mimiced even for dummy clients.
For example, use::

    from your_datastore import Client
    try:
        return Client.exists(client_key, access_token)
    except DoesNotExist:
        return False

Rather than::

    from your_datastore import Client
    if access_token == self.dummy_access_token:
        return False
    else:
        return Client.exists(client_key, access_token)

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a564651e7227063044c72ead44ea932ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564651e7227063044c72ead44ea932ac">&#9670;&nbsp;</a></span>validate_realms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>uri</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>realms</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates access to the request realm.

:param client_key: The client/consumer key.
:param token: A request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:param uri: The URI the realms is protecting.
:param realms: A list of realms that must have been granted to
               the access token.
:returns: True or False

How providers choose to use the realm parameter is outside the OAuth
specification but it is commonly used to restrict access to a subset
of protected resources such as "photos".

realms is a convenience parameter which can be used to provide
a per view method pre-defined list of allowed realms.

Can be as simple as::

    from your_datastore import RequestToken
    request_token = RequestToken.get(token, None)

    if not request_token:
        return False
    return set(request_token.realms).issuperset(set(realms))

This method is used by

* ResourceEndpoint
</pre> 
</div>
</div>
<a id="a564651e7227063044c72ead44ea932ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564651e7227063044c72ead44ea932ac">&#9670;&nbsp;</a></span>validate_realms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>uri</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>realms</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates access to the request realm.

:param client_key: The client/consumer key.
:param token: A request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:param uri: The URI the realms is protecting.
:param realms: A list of realms that must have been granted to
               the access token.
:returns: True or False

How providers choose to use the realm parameter is outside the OAuth
specification but it is commonly used to restrict access to a subset
of protected resources such as "photos".

realms is a convenience parameter which can be used to provide
a per view method pre-defined list of allowed realms.

Can be as simple as::

    from your_datastore import RequestToken
    request_token = RequestToken.get(token, None)

    if not request_token:
        return False
    return set(request_token.realms).issuperset(set(realms))

This method is used by

* ResourceEndpoint
</pre> 
</div>
</div>
<a id="af67031f5f29237314038a8eba01a8d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67031f5f29237314038a8eba01a8d26">&#9670;&nbsp;</a></span>validate_redirect_uri() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_redirect_uri </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>redirect_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates the client supplied redirection URI.

:param client_key: The client/consumer key.
:param redirect_uri: The URI the client which to redirect back to after
                     authorization is successful.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

It is highly recommended that OAuth providers require their clients
to register all redirection URIs prior to using them in requests and
register them as absolute URIs. See `CWE-601`_ for more information
about open redirection attacks.

By requiring registration of all redirection URIs it should be
straightforward for the provider to verify whether the supplied
redirect_uri is valid or not.

Alternatively per `Section 2.1`_ of the spec:

"If the client is unable to receive callbacks or a callback URI has
been established via other means, the parameter value MUST be set to
"oob" (case sensitive), to indicate an out-of-band configuration."

.. _`CWE-601`: http://cwe.mitre.org/top25/index.html#CWE-601
.. _`Section 2.1`: https://tools.ietf.org/html/rfc5849#section-2.1

This method is used by

* RequestTokenEndpoint
</pre> 
</div>
</div>
<a id="af67031f5f29237314038a8eba01a8d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67031f5f29237314038a8eba01a8d26">&#9670;&nbsp;</a></span>validate_redirect_uri() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_redirect_uri </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>redirect_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates the client supplied redirection URI.

:param client_key: The client/consumer key.
:param redirect_uri: The URI the client which to redirect back to after
                     authorization is successful.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

It is highly recommended that OAuth providers require their clients
to register all redirection URIs prior to using them in requests and
register them as absolute URIs. See `CWE-601`_ for more information
about open redirection attacks.

By requiring registration of all redirection URIs it should be
straightforward for the provider to verify whether the supplied
redirect_uri is valid or not.

Alternatively per `Section 2.1`_ of the spec:

"If the client is unable to receive callbacks or a callback URI has
been established via other means, the parameter value MUST be set to
"oob" (case sensitive), to indicate an out-of-band configuration."

.. _`CWE-601`: http://cwe.mitre.org/top25/index.html#CWE-601
.. _`Section 2.1`: https://tools.ietf.org/html/rfc5849#section-2.1

This method is used by

* RequestTokenEndpoint
</pre> 
</div>
</div>
<a id="ac6ab35bf6b1fa73200bc123bad4cc7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ab35bf6b1fa73200bc123bad4cc7cf">&#9670;&nbsp;</a></span>validate_request_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that supplied request token is registered and valid.

:param client_key: The client/consumer key.
:param token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

Note that if the dummy request_token is supplied it should validate in
the same nearly the same amount of time as a valid one.

Ensure latency inducing tasks are mimiced even for dummy clients.
For example, use::

    from your_datastore import RequestToken
    try:
        return RequestToken.exists(client_key, access_token)
    except DoesNotExist:
        return False

Rather than::

    from your_datastore import RequestToken
    if access_token == self.dummy_access_token:
        return False
    else:
        return RequestToken.exists(client_key, access_token)

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="ac6ab35bf6b1fa73200bc123bad4cc7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ab35bf6b1fa73200bc123bad4cc7cf">&#9670;&nbsp;</a></span>validate_request_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that supplied request token is registered and valid.

:param client_key: The client/consumer key.
:param token: The request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

Note that if the dummy request_token is supplied it should validate in
the same nearly the same amount of time as a valid one.

Ensure latency inducing tasks are mimiced even for dummy clients.
For example, use::

    from your_datastore import RequestToken
    try:
        return RequestToken.exists(client_key, access_token)
    except DoesNotExist:
        return False

Rather than::

    from your_datastore import RequestToken
    if access_token == self.dummy_access_token:
        return False
    else:
        return RequestToken.exists(client_key, access_token)

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a766d63b940ec185df7749f4c9d0e50e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766d63b940ec185df7749f4c9d0e50e0">&#9670;&nbsp;</a></span>validate_requested_realms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_requested_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>realms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that the client may request access to the realm.

:param client_key: The client/consumer key.
:param realms: The list of realms that client is requesting access to.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

This method is invoked when obtaining a request token and should
tie a realm to the request token and after user authorization
this realm restriction should transfer to the access token.

This method is used by

* RequestTokenEndpoint
</pre> 
</div>
</div>
<a id="a766d63b940ec185df7749f4c9d0e50e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766d63b940ec185df7749f4c9d0e50e0">&#9670;&nbsp;</a></span>validate_requested_realms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_requested_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>realms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that the client may request access to the realm.

:param client_key: The client/consumer key.
:param realms: The list of realms that client is requesting access to.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

This method is invoked when obtaining a request token and should
tie a realm to the request token and after user authorization
this realm restriction should transfer to the access token.

This method is used by

* RequestTokenEndpoint
</pre> 
</div>
</div>
<a id="a7f79ea3032c6de80284686b53c3fdc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f79ea3032c6de80284686b53c3fdc10">&#9670;&nbsp;</a></span>validate_timestamp_and_nonce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_timestamp_and_nonce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nonce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request_token</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>access_token</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that the nonce has not been used before.

:param client_key: The client/consumer key.
:param timestamp: The ``oauth_timestamp`` parameter.
:param nonce: The ``oauth_nonce`` parameter.
:param request_token: Request token string, if any.
:param access_token: Access token string, if any.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

Per `Section 3.3`_ of the spec.

"A nonce is a random string, uniquely generated by the client to allow
the server to verify that a request has never been made before and
helps prevent replay attacks when requests are made over a non-secure
channel.  The nonce value MUST be unique across all requests with the
same timestamp, client credentials, and token combinations."

.. _`Section 3.3`: https://tools.ietf.org/html/rfc5849#section-3.3

One of the first validation checks that will be made is for the validity
of the nonce and timestamp, which are associated with a client key and
possibly a token. If invalid then immediately fail the request
by returning False. If the nonce/timestamp pair has been used before and
you may just have detected a replay attack. Therefore it is an essential
part of OAuth security that you not allow nonce/timestamp reuse.
Note that this validation check is done before checking the validity of
the client and token.::

   nonces_and_timestamps_database = [
      (u'foo', 1234567890, u'rannoMstrInghere', u'bar')
   ]

   def validate_timestamp_and_nonce(self, client_key, timestamp, nonce,
      request_token=None, access_token=None):

      return ((client_key, timestamp, nonce, request_token or access_token)
               not in self.nonces_and_timestamps_database)

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a7f79ea3032c6de80284686b53c3fdc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f79ea3032c6de80284686b53c3fdc10">&#9670;&nbsp;</a></span>validate_timestamp_and_nonce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_timestamp_and_nonce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nonce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request_token</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>access_token</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates that the nonce has not been used before.

:param client_key: The client/consumer key.
:param timestamp: The ``oauth_timestamp`` parameter.
:param nonce: The ``oauth_nonce`` parameter.
:param request_token: Request token string, if any.
:param access_token: Access token string, if any.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

Per `Section 3.3`_ of the spec.

"A nonce is a random string, uniquely generated by the client to allow
the server to verify that a request has never been made before and
helps prevent replay attacks when requests are made over a non-secure
channel.  The nonce value MUST be unique across all requests with the
same timestamp, client credentials, and token combinations."

.. _`Section 3.3`: https://tools.ietf.org/html/rfc5849#section-3.3

One of the first validation checks that will be made is for the validity
of the nonce and timestamp, which are associated with a client key and
possibly a token. If invalid then immediately fail the request
by returning False. If the nonce/timestamp pair has been used before and
you may just have detected a replay attack. Therefore it is an essential
part of OAuth security that you not allow nonce/timestamp reuse.
Note that this validation check is done before checking the validity of
the client and token.::

   nonces_and_timestamps_database = [
      (u'foo', 1234567890, u'rannoMstrInghere', u'bar')
   ]

   def validate_timestamp_and_nonce(self, client_key, timestamp, nonce,
      request_token=None, access_token=None):

      return ((client_key, timestamp, nonce, request_token or access_token)
               not in self.nonces_and_timestamps_database)

This method is used by

* AccessTokenEndpoint
* RequestTokenEndpoint
* ResourceEndpoint
* SignatureOnlyEndpoint
</pre> 
</div>
</div>
<a id="a7e8d184e352b8225d8679ad6e7fd5477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8d184e352b8225d8679ad6e7fd5477">&#9670;&nbsp;</a></span>validate_verifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_verifier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates a verification code.

:param client_key: The client/consumer key.
:param token: A request token string.
:param verifier: The authorization verifier string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

OAuth providers issue a verification code to clients after the
resource owner authorizes access. This code is used by the client to
obtain token credentials and the provider must verify that the
verifier is valid and associated with the client as well as the
resource owner.

Verifier validation should be done in near constant time
(to avoid verifier enumeration). To achieve this we need a
constant time string comparison which is provided by OAuthLib
in ``oauthlib.common.safe_string_equals``::

    from your_datastore import Verifier
    correct_verifier = Verifier.get(client_key, request_token)
    from oauthlib.common import safe_string_equals
    return safe_string_equals(verifier, correct_verifier)

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a7e8d184e352b8225d8679ad6e7fd5477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8d184e352b8225d8679ad6e7fd5477">&#9670;&nbsp;</a></span>validate_verifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.validate_verifier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validates a verification code.

:param client_key: The client/consumer key.
:param token: A request token string.
:param verifier: The authorization verifier string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

OAuth providers issue a verification code to clients after the
resource owner authorizes access. This code is used by the client to
obtain token credentials and the provider must verify that the
verifier is valid and associated with the client as well as the
resource owner.

Verifier validation should be done in near constant time
(to avoid verifier enumeration). To achieve this we need a
constant time string comparison which is provided by OAuthLib
in ``oauthlib.common.safe_string_equals``::

    from your_datastore import Verifier
    correct_verifier = Verifier.get(client_key, request_token)
    from oauthlib.common import safe_string_equals
    return safe_string_equals(verifier, correct_verifier)

This method is used by

* AccessTokenEndpoint
</pre> 
</div>
</div>
<a id="a416a9bac5b272211f7afeddddd0f61cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416a9bac5b272211f7afeddddd0f61cd">&#9670;&nbsp;</a></span>verifier_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.verifier_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a416a9bac5b272211f7afeddddd0f61cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416a9bac5b272211f7afeddddd0f61cd">&#9670;&nbsp;</a></span>verifier_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.verifier_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c8b93ea65b1941167a8b67ce4ea2da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8b93ea65b1941167a8b67ce4ea2da2">&#9670;&nbsp;</a></span>verify_realms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.verify_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>realms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Verify authorized realms to see if they match those given to token.

:param token: An access token string.
:param realms: A list of realms the client attempts to access.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

This prevents the list of authorized realms sent by the client during
the authorization step to be altered to include realms outside what
was bound with the request token.

Can be as simple as::

    valid_realms = self.get_realms(token)
    return all((r in valid_realms for r in realms))

This method is used by

* AuthorizationEndpoint
</pre> 
</div>
</div>
<a id="a5c8b93ea65b1941167a8b67ce4ea2da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8b93ea65b1941167a8b67ce4ea2da2">&#9670;&nbsp;</a></span>verify_realms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.verify_realms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>realms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Verify authorized realms to see if they match those given to token.

:param token: An access token string.
:param realms: A list of realms the client attempts to access.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

This prevents the list of authorized realms sent by the client during
the authorization step to be altered to include realms outside what
was bound with the request token.

Can be as simple as::

    valid_realms = self.get_realms(token)
    return all((r in valid_realms for r in realms))

This method is used by

* AuthorizationEndpoint
</pre> 
</div>
</div>
<a id="a74bb6dd690c09fea83530fd9a027e825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bb6dd690c09fea83530fd9a027e825">&#9670;&nbsp;</a></span>verify_request_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.verify_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Verify that the given OAuth1 request token is valid.

:param token: A request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

This method is used only in AuthorizationEndpoint to check whether the
oauth_token given in the authorization URL is valid or not.
This request is not signed and thus similar ``validate_request_token``
method can not be used.

This method is used by

* AuthorizationEndpoint
</pre> 
</div>
</div>
<a id="a74bb6dd690c09fea83530fd9a027e825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bb6dd690c09fea83530fd9a027e825">&#9670;&nbsp;</a></span>verify_request_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def oauthlib.oauth1.rfc5849.request_validator.RequestValidator.verify_request_token </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Verify that the given OAuth1 request token is valid.

:param token: A request token string.
:param request: OAuthlib request.
:type request: oauthlib.common.Request
:returns: True or False

This method is used only in AuthorizationEndpoint to check whether the
oauth_token given in the authorization URL is valid or not.
This request is not signed and thus similar ``validate_request_token``
method can not be used.

This method is used by

* AuthorizationEndpoint
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/oauthlib/oauth1/rfc5849/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2oauthlib_2oauth1_2rfc5849_2request__validator_8py.html">request_validator.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
