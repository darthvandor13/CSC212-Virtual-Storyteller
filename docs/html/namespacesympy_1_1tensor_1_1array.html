<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.tensor.array Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1tensor.html">tensor</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1tensor_1_1array.html">array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.tensor.array Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1array__comprehension"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1array__comprehension.html">array_comprehension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1array__derivatives"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1array__derivatives.html">array_derivatives</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1arrayop"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1arrayop.html">arrayop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1dense__ndim__array"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1dense__ndim__array.html">dense_ndim_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1expressions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1expressions.html">expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1mutable__ndim__array"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1mutable__ndim__array.html">mutable_ndim_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1ndim__array"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1ndim__array.html">ndim_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1sparse__ndim__array"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1sparse__ndim__array.html">sparse_ndim_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesympy_1_1tensor_1_1array_1_1tests"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array_1_1tests.html">tests</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a37fd5a5277dfc0c6e8620cd4e3994cdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1array.html#a37fd5a5277dfc0c6e8620cd4e3994cdc">Array</a> = <a class="el" href="classsympy_1_1tensor_1_1array_1_1dense__ndim__array_1_1ImmutableDenseNDimArray.html">ImmutableDenseNDimArray</a></td></tr>
<tr class="separator:a37fd5a5277dfc0c6e8620cd4e3994cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">N-dim array module for SymPy.

Four classes are provided to handle N-dim arrays, given by the combinations
dense/sparse (i.e. whether to store all elements or only the non-zero ones in
memory) and mutable/immutable (immutable classes are SymPy objects, but cannot
change after they have been created).

Examples
========

The following examples show the usage of ``Array``. This is an abbreviation for
``ImmutableDenseNDimArray``, that is an immutable and dense N-dim array, the
other classes are analogous. For mutable classes it is also possible to change
element values after the object has been constructed.

Array construction can detect the shape of nested lists and tuples:

&gt;&gt;&gt; from sympy import Array
&gt;&gt;&gt; a1 = Array([[1, 2], [3, 4], [5, 6]])
&gt;&gt;&gt; a1
[[1, 2], [3, 4], [5, 6]]
&gt;&gt;&gt; a1.shape
(3, 2)
&gt;&gt;&gt; a1.rank()
2
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; a2 = Array([[[x, y], [z, x*z]], [[1, x*y], [1/x, x/y]]])
&gt;&gt;&gt; a2
[[[x, y], [z, x*z]], [[1, x*y], [1/x, x/y]]]
&gt;&gt;&gt; a2.shape
(2, 2, 2)
&gt;&gt;&gt; a2.rank()
3

Otherwise one could pass a 1-dim array followed by a shape tuple:

&gt;&gt;&gt; m1 = Array(range(12), (3, 4))
&gt;&gt;&gt; m1
[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]
&gt;&gt;&gt; m2 = Array(range(12), (3, 2, 2))
&gt;&gt;&gt; m2
[[[0, 1], [2, 3]], [[4, 5], [6, 7]], [[8, 9], [10, 11]]]
&gt;&gt;&gt; m2[1,1,1]
7
&gt;&gt;&gt; m2.reshape(4, 3)
[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]

Slice support:

&gt;&gt;&gt; m2[:, 1, 1]
[3, 7, 11]

Elementwise derivative:

&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; m3 = Array([x**3, x*y, z])
&gt;&gt;&gt; m3.diff(x)
[3*x**2, y, 0]
&gt;&gt;&gt; m3.diff(z)
[0, 0, 1]

Multiplication with other SymPy expressions is applied elementwisely:

&gt;&gt;&gt; (1+x)*m3
[x**3*(x + 1), x*y*(x + 1), z*(x + 1)]

To apply a function to each element of the N-dim array, use ``applyfunc``:

&gt;&gt;&gt; m3.applyfunc(lambda x: x/2)
[x**3/2, x*y/2, z/2]

N-dim arrays can be converted to nested lists by the ``tolist()`` method:

&gt;&gt;&gt; m2.tolist()
[[[0, 1], [2, 3]], [[4, 5], [6, 7]], [[8, 9], [10, 11]]]
&gt;&gt;&gt; isinstance(m2.tolist(), list)
True

If the rank is 2, it is possible to convert them to matrices with ``tomatrix()``:

&gt;&gt;&gt; m1.tomatrix()
Matrix([
[0, 1,  2,  3],
[4, 5,  6,  7],
[8, 9, 10, 11]])

Products and contractions
-------------------------

Tensor product between arrays `A_{i_1,\ldots,i_n}` and `B_{j_1,\ldots,j_m}`
creates the combined array `P = A \otimes B` defined as

`P_{i_1,\ldots,i_n,j_1,\ldots,j_m} := A_{i_1,\ldots,i_n}\cdot B_{j_1,\ldots,j_m}.`

It is available through ``tensorproduct(...)``:

&gt;&gt;&gt; from sympy import Array, tensorproduct
&gt;&gt;&gt; from sympy.abc import x,y,z,t
&gt;&gt;&gt; A = Array([x, y, z, t])
&gt;&gt;&gt; B = Array([1, 2, 3, 4])
&gt;&gt;&gt; tensorproduct(A, B)
[[x, 2*x, 3*x, 4*x], [y, 2*y, 3*y, 4*y], [z, 2*z, 3*z, 4*z], [t, 2*t, 3*t, 4*t]]

In case you don't want to evaluate the tensor product immediately, you can use
``ArrayTensorProduct``, which creates an unevaluated tensor product expression:

&gt;&gt;&gt; from sympy.tensor.array.expressions import ArrayTensorProduct
&gt;&gt;&gt; ArrayTensorProduct(A, B)
ArrayTensorProduct([x, y, z, t], [1, 2, 3, 4])

Calling ``.as_explicit()`` on ``ArrayTensorProduct`` is equivalent to just calling
``tensorproduct(...)``:

&gt;&gt;&gt; ArrayTensorProduct(A, B).as_explicit()
[[x, 2*x, 3*x, 4*x], [y, 2*y, 3*y, 4*y], [z, 2*z, 3*z, 4*z], [t, 2*t, 3*t, 4*t]]

Tensor product between a rank-1 array and a matrix creates a rank-3 array:

&gt;&gt;&gt; from sympy import eye
&gt;&gt;&gt; p1 = tensorproduct(A, eye(4))
&gt;&gt;&gt; p1
[[[x, 0, 0, 0], [0, x, 0, 0], [0, 0, x, 0], [0, 0, 0, x]], [[y, 0, 0, 0], [0, y, 0, 0], [0, 0, y, 0], [0, 0, 0, y]], [[z, 0, 0, 0], [0, z, 0, 0], [0, 0, z, 0], [0, 0, 0, z]], [[t, 0, 0, 0], [0, t, 0, 0], [0, 0, t, 0], [0, 0, 0, t]]]

Now, to get back `A_0 \otimes \mathbf{1}` one can access `p_{0,m,n}` by slicing:

&gt;&gt;&gt; p1[0,:,:]
[[x, 0, 0, 0], [0, x, 0, 0], [0, 0, x, 0], [0, 0, 0, x]]

Tensor contraction sums over the specified axes, for example contracting
positions `a` and `b` means

`A_{i_1,\ldots,i_a,\ldots,i_b,\ldots,i_n} \implies \sum_k A_{i_1,\ldots,k,\ldots,k,\ldots,i_n}`

Remember that Python indexing is zero starting, to contract the a-th and b-th
axes it is therefore necessary to specify `a-1` and `b-1`

&gt;&gt;&gt; from sympy import tensorcontraction
&gt;&gt;&gt; C = Array([[x, y], [z, t]])

The matrix trace is equivalent to the contraction of a rank-2 array:

`A_{m,n} \implies \sum_k A_{k,k}`

&gt;&gt;&gt; tensorcontraction(C, (0, 1))
t + x

To create an expression representing a tensor contraction that does not get
evaluated immediately, use ``ArrayContraction``, which is equivalent to
``tensorcontraction(...)`` if it is followed by ``.as_explicit()``:

&gt;&gt;&gt; from sympy.tensor.array.expressions import ArrayContraction
&gt;&gt;&gt; ArrayContraction(C, (0, 1))
ArrayContraction([[x, y], [z, t]], (0, 1))
&gt;&gt;&gt; ArrayContraction(C, (0, 1)).as_explicit()
t + x

Matrix product is equivalent to a tensor product of two rank-2 arrays, followed
by a contraction of the 2nd and 3rd axes (in Python indexing axes number 1, 2).

`A_{m,n}\cdot B_{i,j} \implies \sum_k A_{m, k}\cdot B_{k, j}`

&gt;&gt;&gt; D = Array([[2, 1], [0, -1]])
&gt;&gt;&gt; tensorcontraction(tensorproduct(C, D), (1, 2))
[[2*x, x - y], [2*z, -t + z]]

One may verify that the matrix product is equivalent:

&gt;&gt;&gt; from sympy import Matrix
&gt;&gt;&gt; Matrix([[x, y], [z, t]])*Matrix([[2, 1], [0, -1]])
Matrix([
[2*x,  x - y],
[2*z, -t + z]])

or equivalently

&gt;&gt;&gt; C.tomatrix()*D.tomatrix()
Matrix([
[2*x,  x - y],
[2*z, -t + z]])

Diagonal operator
-----------------

The ``tensordiagonal`` function acts in a similar manner as ``tensorcontraction``,
but the joined indices are not summed over, for example diagonalizing
positions `a` and `b` means

`A_{i_1,\ldots,i_a,\ldots,i_b,\ldots,i_n} \implies A_{i_1,\ldots,k,\ldots,k,\ldots,i_n}
\implies \tilde{A}_{i_1,\ldots,i_{a-1},i_{a+1},\ldots,i_{b-1},i_{b+1},\ldots,i_n,k}`

where `\tilde{A}` is the array equivalent to the diagonal of `A` at positions
`a` and `b` moved to the last index slot.

Compare the difference between contraction and diagonal operators:

&gt;&gt;&gt; from sympy import tensordiagonal
&gt;&gt;&gt; from sympy.abc import a, b, c, d
&gt;&gt;&gt; m = Matrix([[a, b], [c, d]])
&gt;&gt;&gt; tensorcontraction(m, [0, 1])
a + d
&gt;&gt;&gt; tensordiagonal(m, [0, 1])
[a, d]

In short, no summation occurs with ``tensordiagonal``.


Derivatives by array
--------------------

The usual derivative operation may be extended to support derivation with
respect to arrays, provided that all elements in the that array are symbols or
expressions suitable for derivations.

The definition of a derivative by an array is as follows: given the array
`A_{i_1, \ldots, i_N}` and the array `X_{j_1, \ldots, j_M}`
the derivative of arrays will return a new array `B` defined by

`B_{j_1,\ldots,j_M,i_1,\ldots,i_N} := \frac{\partial A_{i_1,\ldots,i_N}}{\partial X_{j_1,\ldots,j_M}}`

The function ``derive_by_array`` performs such an operation:

&gt;&gt;&gt; from sympy import derive_by_array
&gt;&gt;&gt; from sympy.abc import x, y, z, t
&gt;&gt;&gt; from sympy import sin, exp

With scalars, it behaves exactly as the ordinary derivative:

&gt;&gt;&gt; derive_by_array(sin(x*y), x)
y*cos(x*y)

Scalar derived by an array basis:

&gt;&gt;&gt; derive_by_array(sin(x*y), [x, y, z])
[y*cos(x*y), x*cos(x*y), 0]

Deriving array by an array basis: `B^{nm} := \frac{\partial A^m}{\partial x^n}`

&gt;&gt;&gt; basis = [x, y, z]
&gt;&gt;&gt; ax = derive_by_array([exp(x), sin(y*z), t], basis)
&gt;&gt;&gt; ax
[[exp(x), 0, 0], [0, z*cos(y*z), 0], [0, y*cos(y*z), 0]]

Contraction of the resulting array: `\sum_m \frac{\partial A^m}{\partial x^m}`

&gt;&gt;&gt; tensorcontraction(ax, (0, 1))
z*cos(y*z) + exp(x)</pre> </div><h2 class="groupheader">Variable Documentation</h2>
<a id="a37fd5a5277dfc0c6e8620cd4e3994cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fd5a5277dfc0c6e8620cd4e3994cdc">&#9670;&nbsp;</a></span>Array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.tensor.array.Array = <a class="el" href="classsympy_1_1tensor_1_1array_1_1dense__ndim__array_1_1ImmutableDenseNDimArray.html">ImmutableDenseNDimArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
