<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.calculus.quadrature.QuadratureMethods Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus_1_1quadrature.html">quadrature</a></li><li class="navelem"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html">QuadratureMethods</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.calculus.quadrature.QuadratureMethods Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for mpmath.calculus.quadrature.QuadratureMethods:</div>
<div class="dyncontent">
<div class="center"><img src="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods__inherit__graph.png" border="0" usemap="#ampmath_8calculus_8quadrature_8QuadratureMethods_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mpmath.calculus.quadrature.QuadratureMethods:</div>
<div class="dyncontent">
<div class="center"><img src="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods__coll__graph.png" border="0" usemap="#ampmath_8calculus_8quadrature_8QuadratureMethods_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c7fd34efec9d346fe747266d0e6f0d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#a3c7fd34efec9d346fe747266d0e6f0d2">__init__</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:a3c7fd34efec9d346fe747266d0e6f0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f4260e3fa85ec9f177a04e6752f944"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#a33f4260e3fa85ec9f177a04e6752f944">quad</a> (ctx, f, *points, **kwargs)</td></tr>
<tr class="separator:a33f4260e3fa85ec9f177a04e6752f944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469e280ff07b6ba9df024472f6985e50"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#a469e280ff07b6ba9df024472f6985e50">quadts</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:a469e280ff07b6ba9df024472f6985e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b327c3f7cdebcff981230ac153a153"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#ac3b327c3f7cdebcff981230ac153a153">quadgl</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:ac3b327c3f7cdebcff981230ac153a153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c810ca92b343c3be6215f73ee93fe3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#aa1c810ca92b343c3be6215f73ee93fe3">quadosc</a> (ctx, f, interval, omega=None, period=None, <a class="el" href="namespacempmath.html#aba8149c2326c2d6e0383e42da4ec811e">zeros</a>=None)</td></tr>
<tr class="separator:aa1c810ca92b343c3be6215f73ee93fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac626ff7ec937d0561628faab46f714c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#ac626ff7ec937d0561628faab46f714c3">quadsubdiv</a> (ctx, f, interval, tol=None, maxintervals=None, **kwargs)</td></tr>
<tr class="separator:ac626ff7ec937d0561628faab46f714c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7fd34efec9d346fe747266d0e6f0d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#a3c7fd34efec9d346fe747266d0e6f0d2">__init__</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:a3c7fd34efec9d346fe747266d0e6f0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f4260e3fa85ec9f177a04e6752f944"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#a33f4260e3fa85ec9f177a04e6752f944">quad</a> (ctx, f, *points, **kwargs)</td></tr>
<tr class="separator:a33f4260e3fa85ec9f177a04e6752f944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469e280ff07b6ba9df024472f6985e50"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#a469e280ff07b6ba9df024472f6985e50">quadts</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:a469e280ff07b6ba9df024472f6985e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b327c3f7cdebcff981230ac153a153"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#ac3b327c3f7cdebcff981230ac153a153">quadgl</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:ac3b327c3f7cdebcff981230ac153a153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c810ca92b343c3be6215f73ee93fe3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#aa1c810ca92b343c3be6215f73ee93fe3">quadosc</a> (ctx, f, interval, omega=None, period=None, <a class="el" href="namespacempmath.html#aba8149c2326c2d6e0383e42da4ec811e">zeros</a>=None)</td></tr>
<tr class="separator:aa1c810ca92b343c3be6215f73ee93fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac626ff7ec937d0561628faab46f714c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1quadrature_1_1QuadratureMethods.html#ac626ff7ec937d0561628faab46f714c3">quadsubdiv</a> (ctx, f, interval, tol=None, maxintervals=None, **kwargs)</td></tr>
<tr class="separator:ac626ff7ec937d0561628faab46f714c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3c7fd34efec9d346fe747266d0e6f0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7fd34efec9d346fe747266d0e6f0d2">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c7fd34efec9d346fe747266d0e6f0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7fd34efec9d346fe747266d0e6f0d2">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a33f4260e3fa85ec9f177a04e6752f944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f4260e3fa85ec9f177a04e6752f944">&#9670;&nbsp;</a></span>quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a single, double or triple integral over a given
1D interval, 2D rectangle, or 3D cuboid. A basic example::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; quad(sin, [0, pi])
    2.0

A basic 2D integral::

    &gt;&gt;&gt; f = lambda x, y: cos(x+y/2)
    &gt;&gt;&gt; quad(f, [-pi/2, pi/2], [0, pi])
    4.0

**Interval format**

The integration range for each dimension may be specified
using a list or tuple. Arguments are interpreted as follows:

``quad(f, [x1, x2])`` -- calculates
`\int_{x_1}^{x_2} f(x) \, dx`

``quad(f, [x1, x2], [y1, y2])`` -- calculates
`\int_{x_1}^{x_2} \int_{y_1}^{y_2} f(x,y) \, dy \, dx`

``quad(f, [x1, x2], [y1, y2], [z1, z2])`` -- calculates
`\int_{x_1}^{x_2} \int_{y_1}^{y_2} \int_{z_1}^{z_2} f(x,y,z)
\, dz \, dy \, dx`

Endpoints may be finite or infinite. An interval descriptor
may also contain more than two points. In this
case, the integration is split into subintervals, between
each pair of consecutive points. This is useful for
dealing with mid-interval discontinuities, or integrating
over large intervals where the function is irregular or
oscillates.

**Options**

:func:`~mpmath.quad` recognizes the following keyword arguments:

*method*
    Chooses integration algorithm (described below).
*error*
    If set to true, :func:`~mpmath.quad` returns `(v, e)` where `v` is the
    integral and `e` is the estimated error.
*maxdegree*
    Maximum degree of the quadrature rule to try before
    quitting.
*verbose*
    Print details about progress.

**Algorithms**

Mpmath presently implements two integration algorithms: tanh-sinh
quadrature and Gauss-Legendre quadrature. These can be selected
using *method='tanh-sinh'* or *method='gauss-legendre'* or by
passing the classes *method=TanhSinh*, *method=GaussLegendre*.
The functions :func:`~mpmath.quadts` and :func:`~mpmath.quadgl` are also available
as shortcuts.

Both algorithms have the property that doubling the number of
evaluation points roughly doubles the accuracy, so both are ideal
for high precision quadrature (hundreds or thousands of digits).

At high precision, computing the nodes and weights for the
integration can be expensive (more expensive than computing the
function values). To make repeated integrations fast, nodes
are automatically cached.

The advantages of the tanh-sinh algorithm are that it tends to
handle endpoint singularities well, and that the nodes are cheap
to compute on the first run. For these reasons, it is used by
:func:`~mpmath.quad` as the default algorithm.

Gauss-Legendre quadrature often requires fewer function
evaluations, and is therefore often faster for repeated use, but
the algorithm does not handle endpoint singularities as well and
the nodes are more expensive to compute. Gauss-Legendre quadrature
can be a better choice if the integrand is smooth and repeated
integrations are required (e.g. for multiple integrals).

See the documentation for :class:`TanhSinh` and
:class:`GaussLegendre` for additional details.

**Examples of 1D integrals**

Intervals may be infinite or half-infinite. The following two
examples evaluate the limits of the inverse tangent function
(`\int 1/(1+x^2) = \tan^{-1} x`), and the Gaussian integral
`\int_{\infty}^{\infty} \exp(-x^2)\,dx = \sqrt{\pi}`::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; quad(lambda x: 2/(x**2+1), [0, inf])
    3.14159265358979
    &gt;&gt;&gt; quad(lambda x: exp(-x**2), [-inf, inf])**2
    3.14159265358979

Integrals can typically be resolved to high precision.
The following computes 50 digits of `\pi` by integrating the
area of the half-circle defined by `x^2 + y^2 \le 1`,
`-1 \le x \le 1`, `y \ge 0`::

    &gt;&gt;&gt; mp.dps = 50
    &gt;&gt;&gt; 2*quad(lambda x: sqrt(1-x**2), [-1, 1])
    3.1415926535897932384626433832795028841971693993751

One can just as well compute 1000 digits (output truncated)::

    &gt;&gt;&gt; mp.dps = 1000
    &gt;&gt;&gt; 2*quad(lambda x: sqrt(1-x**2), [-1, 1])  #doctest:+ELLIPSIS
    3.141592653589793238462643383279502884...216420199

Complex integrals are supported. The following computes
a residue at `z = 0` by integrating counterclockwise along the
diamond-shaped path from `1` to `+i` to `-1` to `-i` to `1`::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; chop(quad(lambda z: 1/z, [1,j,-1,-j,1]))
    (0.0 + 6.28318530717959j)

**Examples of 2D and 3D integrals**

Here are several nice examples of analytically solvable
2D integrals (taken from MathWorld [1]) that can be evaluated
to high precision fairly rapidly by :func:`~mpmath.quad`::

    &gt;&gt;&gt; mp.dps = 30
    &gt;&gt;&gt; f = lambda x, y: (x-1)/((1-x*y)*log(x*y))
    &gt;&gt;&gt; quad(f, [0, 1], [0, 1])
    0.577215664901532860606512090082
    &gt;&gt;&gt; +euler
    0.577215664901532860606512090082

    &gt;&gt;&gt; f = lambda x, y: 1/sqrt(1+x**2+y**2)
    &gt;&gt;&gt; quad(f, [-1, 1], [-1, 1])
    3.17343648530607134219175646705
    &gt;&gt;&gt; 4*log(2+sqrt(3))-2*pi/3
    3.17343648530607134219175646705

    &gt;&gt;&gt; f = lambda x, y: 1/(1-x**2 * y**2)
    &gt;&gt;&gt; quad(f, [0, 1], [0, 1])
    1.23370055013616982735431137498
    &gt;&gt;&gt; pi**2 / 8
    1.23370055013616982735431137498

    &gt;&gt;&gt; quad(lambda x, y: 1/(1-x*y), [0, 1], [0, 1])
    1.64493406684822643647241516665
    &gt;&gt;&gt; pi**2 / 6
    1.64493406684822643647241516665

Multiple integrals may be done over infinite ranges::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; print(quad(lambda x,y: exp(-x-y), [0, inf], [1, inf]))
    0.367879441171442
    &gt;&gt;&gt; print(1/e)
    0.367879441171442

For nonrectangular areas, one can call :func:`~mpmath.quad` recursively.
For example, we can replicate the earlier example of calculating
`\pi` by integrating over the unit-circle, and actually use double
quadrature to actually measure the area circle::

    &gt;&gt;&gt; f = lambda x: quad(lambda y: 1, [-sqrt(1-x**2), sqrt(1-x**2)])
    &gt;&gt;&gt; quad(f, [-1, 1])
    3.14159265358979

Here is a simple triple integral::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; f = lambda x,y,z: x*y/(1+z)
    &gt;&gt;&gt; quad(f, [0,1], [0,1], [1,2], method='gauss-legendre')
    0.101366277027041
    &gt;&gt;&gt; (log(3)-log(2))/4
    0.101366277027041

**Singularities**

Both tanh-sinh and Gauss-Legendre quadrature are designed to
integrate smooth (infinitely differentiable) functions. Neither
algorithm copes well with mid-interval singularities (such as
mid-interval discontinuities in `f(x)` or `f'(x)`).
The best solution is to split the integral into parts::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; quad(lambda x: abs(sin(x)), [0, 2*pi])   # Bad
    3.99900894176779
    &gt;&gt;&gt; quad(lambda x: abs(sin(x)), [0, pi, 2*pi])  # Good
    4.0

The tanh-sinh rule often works well for integrands having a
singularity at one or both endpoints::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; quad(log, [0, 1], method='tanh-sinh')  # Good
    -1.0
    &gt;&gt;&gt; quad(log, [0, 1], method='gauss-legendre')  # Bad
    -0.999932197413801

However, the result may still be inaccurate for some functions::

    &gt;&gt;&gt; quad(lambda x: 1/sqrt(x), [0, 1], method='tanh-sinh')
    1.99999999946942

This problem is not due to the quadrature rule per se, but to
numerical amplification of errors in the nodes. The problem can be
circumvented by temporarily increasing the precision::

    &gt;&gt;&gt; mp.dps = 30
    &gt;&gt;&gt; a = quad(lambda x: 1/sqrt(x), [0, 1], method='tanh-sinh')
    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; +a
    2.0

**Highly variable functions**

For functions that are smooth (in the sense of being infinitely
differentiable) but contain sharp mid-interval peaks or many
"bumps", :func:`~mpmath.quad` may fail to provide full accuracy. For
example, with default settings, :func:`~mpmath.quad` is able to integrate
`\sin(x)` accurately over an interval of length 100 but not over
length 1000::

    &gt;&gt;&gt; quad(sin, [0, 100]); 1-cos(100)   # Good
    0.137681127712316
    0.137681127712316
    &gt;&gt;&gt; quad(sin, [0, 1000]); 1-cos(1000)   # Bad
    -37.8587612408485
    0.437620923709297

One solution is to break the integration into 10 intervals of
length 100::

    &gt;&gt;&gt; quad(sin, linspace(0, 1000, 10))   # Good
    0.437620923709297

Another is to increase the degree of the quadrature::

    &gt;&gt;&gt; quad(sin, [0, 1000], maxdegree=10)   # Also good
    0.437620923709297

Whether splitting the interval or increasing the degree is
more efficient differs from case to case. Another example is the
function `1/(1+x^2)`, which has a sharp peak centered around
`x = 0`::

    &gt;&gt;&gt; f = lambda x: 1/(1+x**2)
    &gt;&gt;&gt; quad(f, [-100, 100])   # Bad
    3.64804647105268
    &gt;&gt;&gt; quad(f, [-100, 100], maxdegree=10)   # Good
    3.12159332021646
    &gt;&gt;&gt; quad(f, [-100, 0, 100])   # Also good
    3.12159332021646

**References**

1. http://mathworld.wolfram.com/DoubleIntegral.html</pre> 
</div>
</div>
<a id="a33f4260e3fa85ec9f177a04e6752f944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f4260e3fa85ec9f177a04e6752f944">&#9670;&nbsp;</a></span>quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a single, double or triple integral over a given
1D interval, 2D rectangle, or 3D cuboid. A basic example::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; quad(sin, [0, pi])
    2.0

A basic 2D integral::

    &gt;&gt;&gt; f = lambda x, y: cos(x+y/2)
    &gt;&gt;&gt; quad(f, [-pi/2, pi/2], [0, pi])
    4.0

**Interval format**

The integration range for each dimension may be specified
using a list or tuple. Arguments are interpreted as follows:

``quad(f, [x1, x2])`` -- calculates
`\int_{x_1}^{x_2} f(x) \, dx`

``quad(f, [x1, x2], [y1, y2])`` -- calculates
`\int_{x_1}^{x_2} \int_{y_1}^{y_2} f(x,y) \, dy \, dx`

``quad(f, [x1, x2], [y1, y2], [z1, z2])`` -- calculates
`\int_{x_1}^{x_2} \int_{y_1}^{y_2} \int_{z_1}^{z_2} f(x,y,z)
\, dz \, dy \, dx`

Endpoints may be finite or infinite. An interval descriptor
may also contain more than two points. In this
case, the integration is split into subintervals, between
each pair of consecutive points. This is useful for
dealing with mid-interval discontinuities, or integrating
over large intervals where the function is irregular or
oscillates.

**Options**

:func:`~mpmath.quad` recognizes the following keyword arguments:

*method*
    Chooses integration algorithm (described below).
*error*
    If set to true, :func:`~mpmath.quad` returns `(v, e)` where `v` is the
    integral and `e` is the estimated error.
*maxdegree*
    Maximum degree of the quadrature rule to try before
    quitting.
*verbose*
    Print details about progress.

**Algorithms**

Mpmath presently implements two integration algorithms: tanh-sinh
quadrature and Gauss-Legendre quadrature. These can be selected
using *method='tanh-sinh'* or *method='gauss-legendre'* or by
passing the classes *method=TanhSinh*, *method=GaussLegendre*.
The functions :func:`~mpmath.quadts` and :func:`~mpmath.quadgl` are also available
as shortcuts.

Both algorithms have the property that doubling the number of
evaluation points roughly doubles the accuracy, so both are ideal
for high precision quadrature (hundreds or thousands of digits).

At high precision, computing the nodes and weights for the
integration can be expensive (more expensive than computing the
function values). To make repeated integrations fast, nodes
are automatically cached.

The advantages of the tanh-sinh algorithm are that it tends to
handle endpoint singularities well, and that the nodes are cheap
to compute on the first run. For these reasons, it is used by
:func:`~mpmath.quad` as the default algorithm.

Gauss-Legendre quadrature often requires fewer function
evaluations, and is therefore often faster for repeated use, but
the algorithm does not handle endpoint singularities as well and
the nodes are more expensive to compute. Gauss-Legendre quadrature
can be a better choice if the integrand is smooth and repeated
integrations are required (e.g. for multiple integrals).

See the documentation for :class:`TanhSinh` and
:class:`GaussLegendre` for additional details.

**Examples of 1D integrals**

Intervals may be infinite or half-infinite. The following two
examples evaluate the limits of the inverse tangent function
(`\int 1/(1+x^2) = \tan^{-1} x`), and the Gaussian integral
`\int_{\infty}^{\infty} \exp(-x^2)\,dx = \sqrt{\pi}`::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; quad(lambda x: 2/(x**2+1), [0, inf])
    3.14159265358979
    &gt;&gt;&gt; quad(lambda x: exp(-x**2), [-inf, inf])**2
    3.14159265358979

Integrals can typically be resolved to high precision.
The following computes 50 digits of `\pi` by integrating the
area of the half-circle defined by `x^2 + y^2 \le 1`,
`-1 \le x \le 1`, `y \ge 0`::

    &gt;&gt;&gt; mp.dps = 50
    &gt;&gt;&gt; 2*quad(lambda x: sqrt(1-x**2), [-1, 1])
    3.1415926535897932384626433832795028841971693993751

One can just as well compute 1000 digits (output truncated)::

    &gt;&gt;&gt; mp.dps = 1000
    &gt;&gt;&gt; 2*quad(lambda x: sqrt(1-x**2), [-1, 1])  #doctest:+ELLIPSIS
    3.141592653589793238462643383279502884...216420199

Complex integrals are supported. The following computes
a residue at `z = 0` by integrating counterclockwise along the
diamond-shaped path from `1` to `+i` to `-1` to `-i` to `1`::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; chop(quad(lambda z: 1/z, [1,j,-1,-j,1]))
    (0.0 + 6.28318530717959j)

**Examples of 2D and 3D integrals**

Here are several nice examples of analytically solvable
2D integrals (taken from MathWorld [1]) that can be evaluated
to high precision fairly rapidly by :func:`~mpmath.quad`::

    &gt;&gt;&gt; mp.dps = 30
    &gt;&gt;&gt; f = lambda x, y: (x-1)/((1-x*y)*log(x*y))
    &gt;&gt;&gt; quad(f, [0, 1], [0, 1])
    0.577215664901532860606512090082
    &gt;&gt;&gt; +euler
    0.577215664901532860606512090082

    &gt;&gt;&gt; f = lambda x, y: 1/sqrt(1+x**2+y**2)
    &gt;&gt;&gt; quad(f, [-1, 1], [-1, 1])
    3.17343648530607134219175646705
    &gt;&gt;&gt; 4*log(2+sqrt(3))-2*pi/3
    3.17343648530607134219175646705

    &gt;&gt;&gt; f = lambda x, y: 1/(1-x**2 * y**2)
    &gt;&gt;&gt; quad(f, [0, 1], [0, 1])
    1.23370055013616982735431137498
    &gt;&gt;&gt; pi**2 / 8
    1.23370055013616982735431137498

    &gt;&gt;&gt; quad(lambda x, y: 1/(1-x*y), [0, 1], [0, 1])
    1.64493406684822643647241516665
    &gt;&gt;&gt; pi**2 / 6
    1.64493406684822643647241516665

Multiple integrals may be done over infinite ranges::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; print(quad(lambda x,y: exp(-x-y), [0, inf], [1, inf]))
    0.367879441171442
    &gt;&gt;&gt; print(1/e)
    0.367879441171442

For nonrectangular areas, one can call :func:`~mpmath.quad` recursively.
For example, we can replicate the earlier example of calculating
`\pi` by integrating over the unit-circle, and actually use double
quadrature to actually measure the area circle::

    &gt;&gt;&gt; f = lambda x: quad(lambda y: 1, [-sqrt(1-x**2), sqrt(1-x**2)])
    &gt;&gt;&gt; quad(f, [-1, 1])
    3.14159265358979

Here is a simple triple integral::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; f = lambda x,y,z: x*y/(1+z)
    &gt;&gt;&gt; quad(f, [0,1], [0,1], [1,2], method='gauss-legendre')
    0.101366277027041
    &gt;&gt;&gt; (log(3)-log(2))/4
    0.101366277027041

**Singularities**

Both tanh-sinh and Gauss-Legendre quadrature are designed to
integrate smooth (infinitely differentiable) functions. Neither
algorithm copes well with mid-interval singularities (such as
mid-interval discontinuities in `f(x)` or `f'(x)`).
The best solution is to split the integral into parts::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; quad(lambda x: abs(sin(x)), [0, 2*pi])   # Bad
    3.99900894176779
    &gt;&gt;&gt; quad(lambda x: abs(sin(x)), [0, pi, 2*pi])  # Good
    4.0

The tanh-sinh rule often works well for integrands having a
singularity at one or both endpoints::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; quad(log, [0, 1], method='tanh-sinh')  # Good
    -1.0
    &gt;&gt;&gt; quad(log, [0, 1], method='gauss-legendre')  # Bad
    -0.999932197413801

However, the result may still be inaccurate for some functions::

    &gt;&gt;&gt; quad(lambda x: 1/sqrt(x), [0, 1], method='tanh-sinh')
    1.99999999946942

This problem is not due to the quadrature rule per se, but to
numerical amplification of errors in the nodes. The problem can be
circumvented by temporarily increasing the precision::

    &gt;&gt;&gt; mp.dps = 30
    &gt;&gt;&gt; a = quad(lambda x: 1/sqrt(x), [0, 1], method='tanh-sinh')
    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; +a
    2.0

**Highly variable functions**

For functions that are smooth (in the sense of being infinitely
differentiable) but contain sharp mid-interval peaks or many
"bumps", :func:`~mpmath.quad` may fail to provide full accuracy. For
example, with default settings, :func:`~mpmath.quad` is able to integrate
`\sin(x)` accurately over an interval of length 100 but not over
length 1000::

    &gt;&gt;&gt; quad(sin, [0, 100]); 1-cos(100)   # Good
    0.137681127712316
    0.137681127712316
    &gt;&gt;&gt; quad(sin, [0, 1000]); 1-cos(1000)   # Bad
    -37.8587612408485
    0.437620923709297

One solution is to break the integration into 10 intervals of
length 100::

    &gt;&gt;&gt; quad(sin, linspace(0, 1000, 10))   # Good
    0.437620923709297

Another is to increase the degree of the quadrature::

    &gt;&gt;&gt; quad(sin, [0, 1000], maxdegree=10)   # Also good
    0.437620923709297

Whether splitting the interval or increasing the degree is
more efficient differs from case to case. Another example is the
function `1/(1+x^2)`, which has a sharp peak centered around
`x = 0`::

    &gt;&gt;&gt; f = lambda x: 1/(1+x**2)
    &gt;&gt;&gt; quad(f, [-100, 100])   # Bad
    3.64804647105268
    &gt;&gt;&gt; quad(f, [-100, 100], maxdegree=10)   # Good
    3.12159332021646
    &gt;&gt;&gt; quad(f, [-100, 0, 100])   # Also good
    3.12159332021646

**References**

1. http://mathworld.wolfram.com/DoubleIntegral.html</pre> 
</div>
</div>
<a id="ac3b327c3f7cdebcff981230ac153a153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b327c3f7cdebcff981230ac153a153">&#9670;&nbsp;</a></span>quadgl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quadgl </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs Gauss-Legendre quadrature. The call

    quadgl(func, *points, ...)

is simply a shortcut for:

    quad(func, *points, ..., method=GaussLegendre)

For example, a single integral and a double integral:

    quadgl(lambda x: exp(cos(x)), [0, 1])
    quadgl(lambda x, y: exp(cos(x+y)), [0, 1], [0, 1])

See the documentation for quad for information about how points
arguments and keyword arguments are parsed.

See documentation for TanhSinh for algorithmic information about
tanh-sinh quadrature.
</pre> 
</div>
</div>
<a id="ac3b327c3f7cdebcff981230ac153a153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b327c3f7cdebcff981230ac153a153">&#9670;&nbsp;</a></span>quadgl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quadgl </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs Gauss-Legendre quadrature. The call

    quadgl(func, *points, ...)

is simply a shortcut for:

    quad(func, *points, ..., method=GaussLegendre)

For example, a single integral and a double integral:

    quadgl(lambda x: exp(cos(x)), [0, 1])
    quadgl(lambda x, y: exp(cos(x+y)), [0, 1], [0, 1])

See the documentation for quad for information about how points
arguments and keyword arguments are parsed.

See documentation for TanhSinh for algorithmic information about
tanh-sinh quadrature.
</pre> 
</div>
</div>
<a id="aa1c810ca92b343c3be6215f73ee93fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c810ca92b343c3be6215f73ee93fe3">&#9670;&nbsp;</a></span>quadosc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quadosc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>omega</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>period</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeros</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates

.. math ::

    I = \int_a^b f(x) dx

where at least one of `a` and `b` is infinite and where
`f(x) = g(x) \cos(\omega x  + \phi)` for some slowly
decreasing function `g(x)`. With proper input, :func:`~mpmath.quadosc`
can also handle oscillatory integrals where the oscillation
rate is different from a pure sine or cosine wave.

In the standard case when `|a| &lt; \infty, b = \infty`,
:func:`~mpmath.quadosc` works by evaluating the infinite series

.. math ::

    I = \int_a^{x_1} f(x) dx +
    \sum_{k=1}^{\infty} \int_{x_k}^{x_{k+1}} f(x) dx

where `x_k` are consecutive zeros (alternatively
some other periodic reference point) of `f(x)`.
Accordingly, :func:`~mpmath.quadosc` requires information about the
zeros of `f(x)`. For a periodic function, you can specify
the zeros by either providing the angular frequency `\omega`
(*omega*) or the *period* `2 \pi/\omega`. In general, you can
specify the `n`-th zero by providing the *zeros* arguments.
Below is an example of each::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; f = lambda x: sin(3*x)/(x**2+1)
    &gt;&gt;&gt; quadosc(f, [0,inf], omega=3)
    0.37833007080198
    &gt;&gt;&gt; quadosc(f, [0,inf], period=2*pi/3)
    0.37833007080198
    &gt;&gt;&gt; quadosc(f, [0,inf], zeros=lambda n: pi*n/3)
    0.37833007080198
    &gt;&gt;&gt; (ei(3)*exp(-3)-exp(3)*ei(-3))/2  # Computed by Mathematica
    0.37833007080198

Note that *zeros* was specified to multiply `n` by the
*half-period*, not the full period. In theory, it does not matter
whether each partial integral is done over a half period or a full
period. However, if done over half-periods, the infinite series
passed to :func:`~mpmath.nsum` becomes an *alternating series* and this
typically makes the extrapolation much more efficient.

Here is an example of an integration over the entire real line,
and a half-infinite integration starting at `-\infty`::

    &gt;&gt;&gt; quadosc(lambda x: cos(x)/(1+x**2), [-inf, inf], omega=1)
    1.15572734979092
    &gt;&gt;&gt; pi/e
    1.15572734979092
    &gt;&gt;&gt; quadosc(lambda x: cos(x)/x**2, [-inf, -1], period=2*pi)
    -0.0844109505595739
    &gt;&gt;&gt; cos(1)+si(1)-pi/2
    -0.0844109505595738

Of course, the integrand may contain a complex exponential just as
well as a real sine or cosine::

    &gt;&gt;&gt; quadosc(lambda x: exp(3*j*x)/(1+x**2), [-inf,inf], omega=3)
    (0.156410688228254 + 0.0j)
    &gt;&gt;&gt; pi/e**3
    0.156410688228254
    &gt;&gt;&gt; quadosc(lambda x: exp(3*j*x)/(2+x+x**2), [-inf,inf], omega=3)
    (0.00317486988463794 - 0.0447701735209082j)
    &gt;&gt;&gt; 2*pi/sqrt(7)/exp(3*(j+sqrt(7))/2)
    (0.00317486988463794 - 0.0447701735209082j)

**Non-periodic functions**

If `f(x) = g(x) h(x)` for some function `h(x)` that is not
strictly periodic, *omega* or *period* might not work, and it might
be necessary to use *zeros*.

A notable exception can be made for Bessel functions which, though not
periodic, are "asymptotically periodic" in a sufficiently strong sense
that the sum extrapolation will work out::

    &gt;&gt;&gt; quadosc(j0, [0, inf], period=2*pi)
    1.0
    &gt;&gt;&gt; quadosc(j1, [0, inf], period=2*pi)
    1.0

More properly, one should provide the exact Bessel function zeros::

    &gt;&gt;&gt; j0zero = lambda n: findroot(j0, pi*(n-0.25))
    &gt;&gt;&gt; quadosc(j0, [0, inf], zeros=j0zero)
    1.0

For an example where *zeros* becomes necessary, consider the
complete Fresnel integrals

.. math ::

    \int_0^{\infty} \cos x^2\,dx = \int_0^{\infty} \sin x^2\,dx
    = \sqrt{\frac{\pi}{8}}.

Although the integrands do not decrease in magnitude as
`x \to \infty`, the integrals are convergent since the oscillation
rate increases (causing consecutive periods to asymptotically
cancel out). These integrals are virtually impossible to calculate
to any kind of accuracy using standard quadrature rules. However,
if one provides the correct asymptotic distribution of zeros
(`x_n \sim \sqrt{n}`), :func:`~mpmath.quadosc` works::

    &gt;&gt;&gt; mp.dps = 30
    &gt;&gt;&gt; f = lambda x: cos(x**2)
    &gt;&gt;&gt; quadosc(f, [0,inf], zeros=lambda n:sqrt(pi*n))
    0.626657068657750125603941321203
    &gt;&gt;&gt; f = lambda x: sin(x**2)
    &gt;&gt;&gt; quadosc(f, [0,inf], zeros=lambda n:sqrt(pi*n))
    0.626657068657750125603941321203
    &gt;&gt;&gt; sqrt(pi/8)
    0.626657068657750125603941321203

(Interestingly, these integrals can still be evaluated if one
places some other constant than `\pi` in the square root sign.)

In general, if `f(x) \sim g(x) \cos(h(x))`, the zeros follow
the inverse-function distribution `h^{-1}(x)`::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; f = lambda x: sin(exp(x))
    &gt;&gt;&gt; quadosc(f, [1,inf], zeros=lambda n: log(n))
    -0.25024394235267
    &gt;&gt;&gt; pi/2-si(e)
    -0.250243942352671

**Non-alternating functions**

If the integrand oscillates around a positive value, without
alternating signs, the extrapolation might fail. A simple trick
that sometimes works is to multiply or divide the frequency by 2::

    &gt;&gt;&gt; f = lambda x: 1/x**2+sin(x)/x**4
    &gt;&gt;&gt; quadosc(f, [1,inf], omega=1)  # Bad
    1.28642190869861
    &gt;&gt;&gt; quadosc(f, [1,inf], omega=0.5)  # Perfect
    1.28652953559617
    &gt;&gt;&gt; 1+(cos(1)+ci(1)+sin(1))/6
    1.28652953559617

**Fast decay**

:func:`~mpmath.quadosc` is primarily useful for slowly decaying
integrands. If the integrand decreases exponentially or faster,
:func:`~mpmath.quad` will likely handle it without trouble (and generally be
much faster than :func:`~mpmath.quadosc`)::

    &gt;&gt;&gt; quadosc(lambda x: cos(x)/exp(x), [0, inf], omega=1)
    0.5
    &gt;&gt;&gt; quad(lambda x: cos(x)/exp(x), [0, inf])
    0.5</pre> 
</div>
</div>
<a id="aa1c810ca92b343c3be6215f73ee93fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c810ca92b343c3be6215f73ee93fe3">&#9670;&nbsp;</a></span>quadosc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quadosc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>omega</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>period</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeros</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates

.. math ::

    I = \int_a^b f(x) dx

where at least one of `a` and `b` is infinite and where
`f(x) = g(x) \cos(\omega x  + \phi)` for some slowly
decreasing function `g(x)`. With proper input, :func:`~mpmath.quadosc`
can also handle oscillatory integrals where the oscillation
rate is different from a pure sine or cosine wave.

In the standard case when `|a| &lt; \infty, b = \infty`,
:func:`~mpmath.quadosc` works by evaluating the infinite series

.. math ::

    I = \int_a^{x_1} f(x) dx +
    \sum_{k=1}^{\infty} \int_{x_k}^{x_{k+1}} f(x) dx

where `x_k` are consecutive zeros (alternatively
some other periodic reference point) of `f(x)`.
Accordingly, :func:`~mpmath.quadosc` requires information about the
zeros of `f(x)`. For a periodic function, you can specify
the zeros by either providing the angular frequency `\omega`
(*omega*) or the *period* `2 \pi/\omega`. In general, you can
specify the `n`-th zero by providing the *zeros* arguments.
Below is an example of each::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; f = lambda x: sin(3*x)/(x**2+1)
    &gt;&gt;&gt; quadosc(f, [0,inf], omega=3)
    0.37833007080198
    &gt;&gt;&gt; quadosc(f, [0,inf], period=2*pi/3)
    0.37833007080198
    &gt;&gt;&gt; quadosc(f, [0,inf], zeros=lambda n: pi*n/3)
    0.37833007080198
    &gt;&gt;&gt; (ei(3)*exp(-3)-exp(3)*ei(-3))/2  # Computed by Mathematica
    0.37833007080198

Note that *zeros* was specified to multiply `n` by the
*half-period*, not the full period. In theory, it does not matter
whether each partial integral is done over a half period or a full
period. However, if done over half-periods, the infinite series
passed to :func:`~mpmath.nsum` becomes an *alternating series* and this
typically makes the extrapolation much more efficient.

Here is an example of an integration over the entire real line,
and a half-infinite integration starting at `-\infty`::

    &gt;&gt;&gt; quadosc(lambda x: cos(x)/(1+x**2), [-inf, inf], omega=1)
    1.15572734979092
    &gt;&gt;&gt; pi/e
    1.15572734979092
    &gt;&gt;&gt; quadosc(lambda x: cos(x)/x**2, [-inf, -1], period=2*pi)
    -0.0844109505595739
    &gt;&gt;&gt; cos(1)+si(1)-pi/2
    -0.0844109505595738

Of course, the integrand may contain a complex exponential just as
well as a real sine or cosine::

    &gt;&gt;&gt; quadosc(lambda x: exp(3*j*x)/(1+x**2), [-inf,inf], omega=3)
    (0.156410688228254 + 0.0j)
    &gt;&gt;&gt; pi/e**3
    0.156410688228254
    &gt;&gt;&gt; quadosc(lambda x: exp(3*j*x)/(2+x+x**2), [-inf,inf], omega=3)
    (0.00317486988463794 - 0.0447701735209082j)
    &gt;&gt;&gt; 2*pi/sqrt(7)/exp(3*(j+sqrt(7))/2)
    (0.00317486988463794 - 0.0447701735209082j)

**Non-periodic functions**

If `f(x) = g(x) h(x)` for some function `h(x)` that is not
strictly periodic, *omega* or *period* might not work, and it might
be necessary to use *zeros*.

A notable exception can be made for Bessel functions which, though not
periodic, are "asymptotically periodic" in a sufficiently strong sense
that the sum extrapolation will work out::

    &gt;&gt;&gt; quadosc(j0, [0, inf], period=2*pi)
    1.0
    &gt;&gt;&gt; quadosc(j1, [0, inf], period=2*pi)
    1.0

More properly, one should provide the exact Bessel function zeros::

    &gt;&gt;&gt; j0zero = lambda n: findroot(j0, pi*(n-0.25))
    &gt;&gt;&gt; quadosc(j0, [0, inf], zeros=j0zero)
    1.0

For an example where *zeros* becomes necessary, consider the
complete Fresnel integrals

.. math ::

    \int_0^{\infty} \cos x^2\,dx = \int_0^{\infty} \sin x^2\,dx
    = \sqrt{\frac{\pi}{8}}.

Although the integrands do not decrease in magnitude as
`x \to \infty`, the integrals are convergent since the oscillation
rate increases (causing consecutive periods to asymptotically
cancel out). These integrals are virtually impossible to calculate
to any kind of accuracy using standard quadrature rules. However,
if one provides the correct asymptotic distribution of zeros
(`x_n \sim \sqrt{n}`), :func:`~mpmath.quadosc` works::

    &gt;&gt;&gt; mp.dps = 30
    &gt;&gt;&gt; f = lambda x: cos(x**2)
    &gt;&gt;&gt; quadosc(f, [0,inf], zeros=lambda n:sqrt(pi*n))
    0.626657068657750125603941321203
    &gt;&gt;&gt; f = lambda x: sin(x**2)
    &gt;&gt;&gt; quadosc(f, [0,inf], zeros=lambda n:sqrt(pi*n))
    0.626657068657750125603941321203
    &gt;&gt;&gt; sqrt(pi/8)
    0.626657068657750125603941321203

(Interestingly, these integrals can still be evaluated if one
places some other constant than `\pi` in the square root sign.)

In general, if `f(x) \sim g(x) \cos(h(x))`, the zeros follow
the inverse-function distribution `h^{-1}(x)`::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; f = lambda x: sin(exp(x))
    &gt;&gt;&gt; quadosc(f, [1,inf], zeros=lambda n: log(n))
    -0.25024394235267
    &gt;&gt;&gt; pi/2-si(e)
    -0.250243942352671

**Non-alternating functions**

If the integrand oscillates around a positive value, without
alternating signs, the extrapolation might fail. A simple trick
that sometimes works is to multiply or divide the frequency by 2::

    &gt;&gt;&gt; f = lambda x: 1/x**2+sin(x)/x**4
    &gt;&gt;&gt; quadosc(f, [1,inf], omega=1)  # Bad
    1.28642190869861
    &gt;&gt;&gt; quadosc(f, [1,inf], omega=0.5)  # Perfect
    1.28652953559617
    &gt;&gt;&gt; 1+(cos(1)+ci(1)+sin(1))/6
    1.28652953559617

**Fast decay**

:func:`~mpmath.quadosc` is primarily useful for slowly decaying
integrands. If the integrand decreases exponentially or faster,
:func:`~mpmath.quad` will likely handle it without trouble (and generally be
much faster than :func:`~mpmath.quadosc`)::

    &gt;&gt;&gt; quadosc(lambda x: cos(x)/exp(x), [0, inf], omega=1)
    0.5
    &gt;&gt;&gt; quad(lambda x: cos(x)/exp(x), [0, inf])
    0.5</pre> 
</div>
</div>
<a id="ac626ff7ec937d0561628faab46f714c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac626ff7ec937d0561628faab46f714c3">&#9670;&nbsp;</a></span>quadsubdiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quadsubdiv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxintervals</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the integral of *f* over the interval or path specified
by *interval*, using :func:`~mpmath.quad` together with adaptive
subdivision of the interval.

This function gives an accurate answer for some integrals where
:func:`~mpmath.quad` fails::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; quad(lambda x: abs(sin(x)), [0, 2*pi])
    3.99900894176779
    &gt;&gt;&gt; quadsubdiv(lambda x: abs(sin(x)), [0, 2*pi])
    4.0
    &gt;&gt;&gt; quadsubdiv(sin, [0, 1000])
    0.437620923709297
    &gt;&gt;&gt; quadsubdiv(lambda x: 1/(1+x**2), [-100, 100])
    3.12159332021646
    &gt;&gt;&gt; quadsubdiv(lambda x: ceil(x), [0, 100])
    5050.0
    &gt;&gt;&gt; quadsubdiv(lambda x: sin(x+exp(x)), [0,8])
    0.347400172657248

The argument *maxintervals* can be set to limit the permissible
subdivision::

    &gt;&gt;&gt; quadsubdiv(lambda x: sin(x**2), [0,100], maxintervals=5, error=True)
    (-5.40487904307774, 5.011)
    &gt;&gt;&gt; quadsubdiv(lambda x: sin(x**2), [0,100], maxintervals=100, error=True)
    (0.631417921866934, 1.10101120134116e-17)

Subdivision does not guarantee a correct answer since, the error
estimate on subintervals may be inaccurate::

    &gt;&gt;&gt; quadsubdiv(lambda x: sech(10*x-2)**2 + sech(100*x-40)**4 + sech(1000*x-600)**6, [0,1], error=True)
    (0.210802735500549, 1.0001111101e-17)
    &gt;&gt;&gt; mp.dps = 20
    &gt;&gt;&gt; quadsubdiv(lambda x: sech(10*x-2)**2 + sech(100*x-40)**4 + sech(1000*x-600)**6, [0,1], error=True)
    (0.21080273550054927738, 2.200000001e-24)

The second answer is correct. We can get an accurate result at lower
precision by forcing a finer initial subdivision::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; quadsubdiv(lambda x: sech(10*x-2)**2 + sech(100*x-40)**4 + sech(1000*x-600)**6, linspace(0,1,5))
    0.210802735500549

The following integral is too oscillatory for convergence, but we can get a
reasonable estimate::

    &gt;&gt;&gt; v, err = fp.quadsubdiv(lambda x: fp.sin(1/x), [0,1], error=True)
    &gt;&gt;&gt; round(v, 6), round(err, 6)
    (0.504067, 1e-06)
    &gt;&gt;&gt; sin(1) - ci(1)
    0.504067061906928</pre> 
</div>
</div>
<a id="ac626ff7ec937d0561628faab46f714c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac626ff7ec937d0561628faab46f714c3">&#9670;&nbsp;</a></span>quadsubdiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quadsubdiv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxintervals</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the integral of *f* over the interval or path specified
by *interval*, using :func:`~mpmath.quad` together with adaptive
subdivision of the interval.

This function gives an accurate answer for some integrals where
:func:`~mpmath.quad` fails::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; quad(lambda x: abs(sin(x)), [0, 2*pi])
    3.99900894176779
    &gt;&gt;&gt; quadsubdiv(lambda x: abs(sin(x)), [0, 2*pi])
    4.0
    &gt;&gt;&gt; quadsubdiv(sin, [0, 1000])
    0.437620923709297
    &gt;&gt;&gt; quadsubdiv(lambda x: 1/(1+x**2), [-100, 100])
    3.12159332021646
    &gt;&gt;&gt; quadsubdiv(lambda x: ceil(x), [0, 100])
    5050.0
    &gt;&gt;&gt; quadsubdiv(lambda x: sin(x+exp(x)), [0,8])
    0.347400172657248

The argument *maxintervals* can be set to limit the permissible
subdivision::

    &gt;&gt;&gt; quadsubdiv(lambda x: sin(x**2), [0,100], maxintervals=5, error=True)
    (-5.40487904307774, 5.011)
    &gt;&gt;&gt; quadsubdiv(lambda x: sin(x**2), [0,100], maxintervals=100, error=True)
    (0.631417921866934, 1.10101120134116e-17)

Subdivision does not guarantee a correct answer since, the error
estimate on subintervals may be inaccurate::

    &gt;&gt;&gt; quadsubdiv(lambda x: sech(10*x-2)**2 + sech(100*x-40)**4 + sech(1000*x-600)**6, [0,1], error=True)
    (0.210802735500549, 1.0001111101e-17)
    &gt;&gt;&gt; mp.dps = 20
    &gt;&gt;&gt; quadsubdiv(lambda x: sech(10*x-2)**2 + sech(100*x-40)**4 + sech(1000*x-600)**6, [0,1], error=True)
    (0.21080273550054927738, 2.200000001e-24)

The second answer is correct. We can get an accurate result at lower
precision by forcing a finer initial subdivision::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; quadsubdiv(lambda x: sech(10*x-2)**2 + sech(100*x-40)**4 + sech(1000*x-600)**6, linspace(0,1,5))
    0.210802735500549

The following integral is too oscillatory for convergence, but we can get a
reasonable estimate::

    &gt;&gt;&gt; v, err = fp.quadsubdiv(lambda x: fp.sin(1/x), [0,1], error=True)
    &gt;&gt;&gt; round(v, 6), round(err, 6)
    (0.504067, 1e-06)
    &gt;&gt;&gt; sin(1) - ci(1)
    0.504067061906928</pre> 
</div>
</div>
<a id="a469e280ff07b6ba9df024472f6985e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469e280ff07b6ba9df024472f6985e50">&#9670;&nbsp;</a></span>quadts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quadts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs tanh-sinh quadrature. The call

    quadts(func, *points, ...)

is simply a shortcut for:

    quad(func, *points, ..., method=TanhSinh)

For example, a single integral and a double integral:

    quadts(lambda x: exp(cos(x)), [0, 1])
    quadts(lambda x, y: exp(cos(x+y)), [0, 1], [0, 1])

See the documentation for quad for information about how points
arguments and keyword arguments are parsed.

See documentation for TanhSinh for algorithmic information about
tanh-sinh quadrature.
</pre> 
</div>
</div>
<a id="a469e280ff07b6ba9df024472f6985e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469e280ff07b6ba9df024472f6985e50">&#9670;&nbsp;</a></span>quadts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.quadrature.QuadratureMethods.quadts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs tanh-sinh quadrature. The call

    quadts(func, *points, ...)

is simply a shortcut for:

    quad(func, *points, ..., method=TanhSinh)

For example, a single integral and a double integral:

    quadts(lambda x: exp(cos(x)), [0, 1])
    quadts(lambda x, y: exp(cos(x+y)), [0, 1], [0, 1])

See the documentation for quad for information about how points
arguments and keyword arguments are parsed.

See documentation for TanhSinh for algorithmic information about
tanh-sinh quadrature.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/mpmath/calculus/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2mpmath_2calculus_2quadrature_8py.html">quadrature.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
