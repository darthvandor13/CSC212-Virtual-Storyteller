<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.physics.quantum.represent Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics.html">physics</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics_1_1quantum.html">quantum</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1represent.html">represent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.physics.quantum.represent Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8c1a1b9d9b7f9e294fa173ae2f29c3ee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1represent.html#a8c1a1b9d9b7f9e294fa173ae2f29c3ee">represent</a> (expr, **options)</td></tr>
<tr class="separator:a8c1a1b9d9b7f9e294fa173ae2f29c3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f0e29a674eeb4ecb99733edab7b1b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1represent.html#a80f0e29a674eeb4ecb99733edab7b1b2">rep_innerproduct</a> (expr, **options)</td></tr>
<tr class="separator:a80f0e29a674eeb4ecb99733edab7b1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b31e55f358d55aa035a44744374ab81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1represent.html#a9b31e55f358d55aa035a44744374ab81">rep_expectation</a> (expr, **options)</td></tr>
<tr class="separator:a9b31e55f358d55aa035a44744374ab81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7323d73ca1741c4b78f82c42080803a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1represent.html#a7323d73ca1741c4b78f82c42080803a5">integrate_result</a> (orig_expr, result, **options)</td></tr>
<tr class="separator:a7323d73ca1741c4b78f82c42080803a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfe7640fa1e9ae558bd7f3e04776443"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1represent.html#a9cfe7640fa1e9ae558bd7f3e04776443">get_basis</a> (expr, *basis=None, replace_none=True, **options)</td></tr>
<tr class="separator:a9cfe7640fa1e9ae558bd7f3e04776443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974be3a47c2b5d33ee68093ef799b6f4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1physics_1_1quantum_1_1represent.html#a974be3a47c2b5d33ee68093ef799b6f4">enumerate_states</a> (*args, **options)</td></tr>
<tr class="separator:a974be3a47c2b5d33ee68093ef799b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Logic for representing operators in state in various bases.

TODO:

* Get represent working with continuous hilbert spaces.
* Document default basis functionality.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a974be3a47c2b5d33ee68093ef799b6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974be3a47c2b5d33ee68093ef799b6f4">&#9670;&nbsp;</a></span>enumerate_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.represent.enumerate_states </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns instances of the given state with dummy indices appended

Operates in two different modes:

1. Two arguments are passed to it. The first is the base state which is to
   be indexed, and the second argument is a list of indices to append.

2. Three arguments are passed. The first is again the base state to be
   indexed. The second is the start index for counting.  The final argument
   is the number of kets you wish to receive.

Tries to call state._enumerate_state. If this fails, returns an empty list

Parameters
==========

args : list
    See list of operation modes above for explanation

Examples
========

&gt;&gt;&gt; from sympy.physics.quantum.cartesian import XBra, XKet
&gt;&gt;&gt; from sympy.physics.quantum.represent import enumerate_states
&gt;&gt;&gt; test = XKet('foo')
&gt;&gt;&gt; enumerate_states(test, 1, 3)
[|foo_1&gt;, |foo_2&gt;, |foo_3&gt;]
&gt;&gt;&gt; test2 = XBra('bar')
&gt;&gt;&gt; enumerate_states(test2, [4, 5, 10])
[&lt;bar_4|, &lt;bar_5|, &lt;bar_10|]</pre> 
</div>
</div>
<a id="a9cfe7640fa1e9ae558bd7f3e04776443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cfe7640fa1e9ae558bd7f3e04776443">&#9670;&nbsp;</a></span>get_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.represent.get_basis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>basis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>replace_none</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a basis state instance corresponding to the basis specified in
options=s. If no basis is specified, the function tries to form a default
basis state of the given expression.

There are three behaviors:

1. The basis specified in options is already an instance of StateBase. If
   this is the case, it is simply returned. If the class is specified but
   not an instance, a default instance is returned.

2. The basis specified is an operator or set of operators. If this
   is the case, the operator_to_state mapping method is used.

3. No basis is specified. If expr is a state, then a default instance of
   its class is returned.  If expr is an operator, then it is mapped to the
   corresponding state.  If it is neither, then we cannot obtain the basis
   state.

If the basis cannot be mapped, then it is not changed.

This will be called from within represent, and represent will
only pass QExpr's.

TODO (?): Support for Muls and other types of expressions?

Parameters
==========

expr : Operator or StateBase
    Expression whose basis is sought

Examples
========

&gt;&gt;&gt; from sympy.physics.quantum.represent import get_basis
&gt;&gt;&gt; from sympy.physics.quantum.cartesian import XOp, XKet, PxOp, PxKet
&gt;&gt;&gt; x = XKet()
&gt;&gt;&gt; X = XOp()
&gt;&gt;&gt; get_basis(x)
|x&gt;
&gt;&gt;&gt; get_basis(X)
|x&gt;
&gt;&gt;&gt; get_basis(x, basis=PxOp())
|px&gt;
&gt;&gt;&gt; get_basis(x, basis=PxKet)
|px&gt;</pre> 
</div>
</div>
<a id="a7323d73ca1741c4b78f82c42080803a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7323d73ca1741c4b78f82c42080803a5">&#9670;&nbsp;</a></span>integrate_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.represent.integrate_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orig_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the result of integrating over any unities ``(|x&gt;&lt;x|)`` in
the given expression. Intended for integrating over the result of
representations in continuous bases.

This function integrates over any unities that may have been
inserted into the quantum expression and returns the result.
It uses the interval of the Hilbert space of the basis state
passed to it in order to figure out the limits of integration.
The unities option must be
specified for this to work.

Note: This is mostly used internally by represent(). Examples are
given merely to show the use cases.

Parameters
==========

orig_expr : quantum expression
    The original expression which was to be represented

result: Expr
    The resulting representation that we wish to integrate over

Examples
========

&gt;&gt;&gt; from sympy import symbols, DiracDelta
&gt;&gt;&gt; from sympy.physics.quantum.represent import integrate_result
&gt;&gt;&gt; from sympy.physics.quantum.cartesian import XOp, XKet
&gt;&gt;&gt; x_ket = XKet()
&gt;&gt;&gt; X_op = XOp()
&gt;&gt;&gt; x, x_1, x_2 = symbols('x, x_1, x_2')
&gt;&gt;&gt; integrate_result(X_op*x_ket, x*DiracDelta(x-x_1)*DiracDelta(x_1-x_2))
x*DiracDelta(x - x_1)*DiracDelta(x_1 - x_2)
&gt;&gt;&gt; integrate_result(X_op*x_ket, x*DiracDelta(x-x_1)*DiracDelta(x_1-x_2),
...     unities=[1])
x*DiracDelta(x - x_2)</pre> 
</div>
</div>
<a id="a9b31e55f358d55aa035a44744374ab81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b31e55f358d55aa035a44744374ab81">&#9670;&nbsp;</a></span>rep_expectation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.represent.rep_expectation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an ``&lt;x'|A|x&gt;`` type representation for the given operator.

Parameters
==========

expr : Operator
    Operator to be represented in the specified basis

Examples
========

&gt;&gt;&gt; from sympy.physics.quantum.cartesian import XOp, PxOp, PxKet
&gt;&gt;&gt; from sympy.physics.quantum.represent import rep_expectation
&gt;&gt;&gt; rep_expectation(XOp())
x_1*DiracDelta(x_1 - x_2)
&gt;&gt;&gt; rep_expectation(XOp(), basis=PxOp())
&lt;px_2|*X*|px_1&gt;
&gt;&gt;&gt; rep_expectation(XOp(), basis=PxKet())
&lt;px_2|*X*|px_1&gt;</pre> 
</div>
</div>
<a id="a80f0e29a674eeb4ecb99733edab7b1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f0e29a674eeb4ecb99733edab7b1b2">&#9670;&nbsp;</a></span>rep_innerproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.represent.rep_innerproduct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an innerproduct like representation (e.g. ``&lt;x'|x&gt;``) for the
given state.

Attempts to calculate inner product with a bra from the specified
basis. Should only be passed an instance of KetBase or BraBase

Parameters
==========

expr : KetBase or BraBase
    The expression to be represented

Examples
========

&gt;&gt;&gt; from sympy.physics.quantum.represent import rep_innerproduct
&gt;&gt;&gt; from sympy.physics.quantum.cartesian import XOp, XKet, PxOp, PxKet
&gt;&gt;&gt; rep_innerproduct(XKet())
DiracDelta(x - x_1)
&gt;&gt;&gt; rep_innerproduct(XKet(), basis=PxOp())
sqrt(2)*exp(-I*px_1*x/hbar)/(2*sqrt(hbar)*sqrt(pi))
&gt;&gt;&gt; rep_innerproduct(PxKet(), basis=XOp())
sqrt(2)*exp(I*px*x_1/hbar)/(2*sqrt(hbar)*sqrt(pi))</pre> 
</div>
</div>
<a id="a8c1a1b9d9b7f9e294fa173ae2f29c3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1a1b9d9b7f9e294fa173ae2f29c3ee">&#9670;&nbsp;</a></span>represent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.physics.quantum.represent.represent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Represent the quantum expression in the given basis.

In quantum mechanics abstract states and operators can be represented in
various basis sets. Under this operation the follow transforms happen:

* Ket -&gt; column vector or function
* Bra -&gt; row vector of function
* Operator -&gt; matrix or differential operator

This function is the top-level interface for this action.

This function walks the SymPy expression tree looking for ``QExpr``
instances that have a ``_represent`` method. This method is then called
and the object is replaced by the representation returned by this method.
By default, the ``_represent`` method will dispatch to other methods
that handle the representation logic for a particular basis set. The
naming convention for these methods is the following::

    def _represent_FooBasis(self, e, basis, **options)

This function will have the logic for representing instances of its class
in the basis set having a class named ``FooBasis``.

Parameters
==========

expr  : Expr
    The expression to represent.
basis : Operator, basis set
    An object that contains the information about the basis set. If an
    operator is used, the basis is assumed to be the orthonormal
    eigenvectors of that operator. In general though, the basis argument
    can be any object that contains the basis set information.
options : dict
    Key/value pairs of options that are passed to the underlying method
    that finds the representation. These options can be used to
    control how the representation is done. For example, this is where
    the size of the basis set would be set.

Returns
=======

e : Expr
    The SymPy expression of the represented quantum expression.

Examples
========

Here we subclass ``Operator`` and ``Ket`` to create the z-spin operator
and its spin 1/2 up eigenstate. By defining the ``_represent_SzOp``
method, the ket can be represented in the z-spin basis.

&gt;&gt;&gt; from sympy.physics.quantum import Operator, represent, Ket
&gt;&gt;&gt; from sympy import Matrix

&gt;&gt;&gt; class SzUpKet(Ket):
...     def _represent_SzOp(self, basis, **options):
...         return Matrix([1,0])
...
&gt;&gt;&gt; class SzOp(Operator):
...     pass
...
&gt;&gt;&gt; sz = SzOp('Sz')
&gt;&gt;&gt; up = SzUpKet('up')
&gt;&gt;&gt; represent(up, basis=sz)
Matrix([
[1],
[0]])

Here we see an example of representations in a continuous
basis. We see that the result of representing various combinations
of cartesian position operators and kets give us continuous
expressions involving DiracDelta functions.

&gt;&gt;&gt; from sympy.physics.quantum.cartesian import XOp, XKet, XBra
&gt;&gt;&gt; X = XOp()
&gt;&gt;&gt; x = XKet()
&gt;&gt;&gt; y = XBra('y')
&gt;&gt;&gt; represent(X*x)
x*DiracDelta(x - x_2)
&gt;&gt;&gt; represent(X*x*y)
x*DiracDelta(x - x_3)*DiracDelta(x_1 - y)</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
