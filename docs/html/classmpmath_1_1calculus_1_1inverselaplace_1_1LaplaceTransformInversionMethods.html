<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus_1_1inverselaplace.html">inverselaplace</a></li><li class="navelem"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html">LaplaceTransformInversionMethods</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods:</div>
<div class="dyncontent">
<div class="center"><img src="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods__inherit__graph.png" border="0" usemap="#ampmath_8calculus_8inverselaplace_8LaplaceTransformInversionMethods_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods:</div>
<div class="dyncontent">
<div class="center"><img src="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods__coll__graph.png" border="0" usemap="#ampmath_8calculus_8inverselaplace_8LaplaceTransformInversionMethods_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbcb33d914d4fe5cca20037f9e828ccb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#adbcb33d914d4fe5cca20037f9e828ccb">__init__</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:adbcb33d914d4fe5cca20037f9e828ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d97cba8dd7cb74071df1d74e44e7bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#af2d97cba8dd7cb74071df1d74e44e7bb">invertlaplace</a> (ctx, f, t, **kwargs)</td></tr>
<tr class="separator:af2d97cba8dd7cb74071df1d74e44e7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d5b2898ac6e7ef7692bc6e6932932b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#ac2d5b2898ac6e7ef7692bc6e6932932b">invlaptalbot</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:ac2d5b2898ac6e7ef7692bc6e6932932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c6f6b1f540f544343491bc3ded8552"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#ac0c6f6b1f540f544343491bc3ded8552">invlapstehfest</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:ac0c6f6b1f540f544343491bc3ded8552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aad5d16dc236288aafc39b83e29720b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#a4aad5d16dc236288aafc39b83e29720b">invlapdehoog</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:a4aad5d16dc236288aafc39b83e29720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc752224ee787ea49e0f5568e2b3501"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#a6dc752224ee787ea49e0f5568e2b3501">invlapcohen</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:a6dc752224ee787ea49e0f5568e2b3501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcb33d914d4fe5cca20037f9e828ccb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#adbcb33d914d4fe5cca20037f9e828ccb">__init__</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:adbcb33d914d4fe5cca20037f9e828ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d97cba8dd7cb74071df1d74e44e7bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#af2d97cba8dd7cb74071df1d74e44e7bb">invertlaplace</a> (ctx, f, t, **kwargs)</td></tr>
<tr class="separator:af2d97cba8dd7cb74071df1d74e44e7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d5b2898ac6e7ef7692bc6e6932932b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#ac2d5b2898ac6e7ef7692bc6e6932932b">invlaptalbot</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:ac2d5b2898ac6e7ef7692bc6e6932932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c6f6b1f540f544343491bc3ded8552"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#ac0c6f6b1f540f544343491bc3ded8552">invlapstehfest</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:ac0c6f6b1f540f544343491bc3ded8552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aad5d16dc236288aafc39b83e29720b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#a4aad5d16dc236288aafc39b83e29720b">invlapdehoog</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:a4aad5d16dc236288aafc39b83e29720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc752224ee787ea49e0f5568e2b3501"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1inverselaplace_1_1LaplaceTransformInversionMethods.html#a6dc752224ee787ea49e0f5568e2b3501">invlapcohen</a> (ctx, *args, **kwargs)</td></tr>
<tr class="separator:a6dc752224ee787ea49e0f5568e2b3501"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adbcb33d914d4fe5cca20037f9e828ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcb33d914d4fe5cca20037f9e828ccb">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbcb33d914d4fe5cca20037f9e828ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcb33d914d4fe5cca20037f9e828ccb">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af2d97cba8dd7cb74071df1d74e44e7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d97cba8dd7cb74071df1d74e44e7bb">&#9670;&nbsp;</a></span>invertlaplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invertlaplace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the numerical inverse Laplace transform for a
Laplace-space function at a given time.  The function being
evaluated is assumed to be a real-valued function of time.

The user must supply a Laplace-space function `\bar{f}(p)`,
and a desired time at which to estimate the time-domain
solution `f(t)`.

A few basic examples of Laplace-space functions with known
inverses (see references [1,2]) :

.. math ::

    \mathcal{L}\left\lbrace f(t) \right\rbrace=\bar{f}(p)

.. math ::

    \mathcal{L}^{-1}\left\lbrace \bar{f}(p) \right\rbrace = f(t)

.. math ::

    \bar{f}(p) = \frac{1}{(p+1)^2}

.. math ::

    f(t) = t e^{-t}

&gt;&gt;&gt; from mpmath import *
&gt;&gt;&gt; mp.dps = 15; mp.pretty = True
&gt;&gt;&gt; tt = [0.001, 0.01, 0.1, 1, 10]
&gt;&gt;&gt; fp = lambda p: 1/(p+1)**2
&gt;&gt;&gt; ft = lambda t: t*exp(-t)
&gt;&gt;&gt; ft(tt[0]),ft(tt[0])-invertlaplace(fp,tt[0],method='talbot')
(0.000999000499833375, 8.57923043561212e-20)
&gt;&gt;&gt; ft(tt[1]),ft(tt[1])-invertlaplace(fp,tt[1],method='talbot')
(0.00990049833749168, 3.27007646698047e-19)
&gt;&gt;&gt; ft(tt[2]),ft(tt[2])-invertlaplace(fp,tt[2],method='talbot')
(0.090483741803596, -1.75215800052168e-18)
&gt;&gt;&gt; ft(tt[3]),ft(tt[3])-invertlaplace(fp,tt[3],method='talbot')
(0.367879441171442, 1.2428864009344e-17)
&gt;&gt;&gt; ft(tt[4]),ft(tt[4])-invertlaplace(fp,tt[4],method='talbot')
(0.000453999297624849, 4.04513489306658e-20)

The methods also work for higher precision:

&gt;&gt;&gt; mp.dps = 100; mp.pretty = True
&gt;&gt;&gt; nstr(ft(tt[0]),15),nstr(ft(tt[0])-invertlaplace(fp,tt[0],method='talbot'),15)
('0.000999000499833375', '-4.96868310693356e-105')
&gt;&gt;&gt; nstr(ft(tt[1]),15),nstr(ft(tt[1])-invertlaplace(fp,tt[1],method='talbot'),15)
('0.00990049833749168', '1.23032291513122e-104')

.. math ::

    \bar{f}(p) = \frac{1}{p^2+1}

.. math ::

    f(t) = \mathrm{J}_0(t)

&gt;&gt;&gt; mp.dps = 15; mp.pretty = True
&gt;&gt;&gt; fp = lambda p: 1/sqrt(p*p + 1)
&gt;&gt;&gt; ft = lambda t: besselj(0,t)
&gt;&gt;&gt; ft(tt[0]),ft(tt[0])-invertlaplace(fp,tt[0],method='dehoog')
(0.999999750000016, -6.09717765032273e-18)
&gt;&gt;&gt; ft(tt[1]),ft(tt[1])-invertlaplace(fp,tt[1],method='dehoog')
(0.99997500015625, -5.61756281076169e-17)

.. math ::

    \bar{f}(p) = \frac{\log p}{p}

.. math ::

    f(t) = -\gamma -\log t

&gt;&gt;&gt; mp.dps = 15; mp.pretty = True
&gt;&gt;&gt; fp = lambda p: log(p)/p
&gt;&gt;&gt; ft = lambda t: -euler-log(t)
&gt;&gt;&gt; ft(tt[0]),ft(tt[0])-invertlaplace(fp,tt[0],method='stehfest')
(6.3305396140806, -1.92126634837863e-16)
&gt;&gt;&gt; ft(tt[1]),ft(tt[1])-invertlaplace(fp,tt[1],method='stehfest')
(4.02795452108656, -4.81486093200704e-16)

**Options**

:func:`~mpmath.invertlaplace` recognizes the following optional
keywords valid for all methods:

*method*
    Chooses numerical inverse Laplace transform algorithm
    (described below).
*degree*
    Number of terms used in the approximation

**Algorithms**

Mpmath implements four numerical inverse Laplace transform
algorithms, attributed to: Talbot, Stehfest, and de Hoog,
Knight and Stokes. These can be selected by using
*method='talbot'*, *method='stehfest'*, *method='dehoog'* or
*method='cohen'* or by passing the classes *method=FixedTalbot*,
*method=Stehfest*, *method=deHoog*, or *method=Cohen*. The functions
:func:`~mpmath.invlaptalbot`, :func:`~mpmath.invlapstehfest`,
:func:`~mpmath.invlapdehoog`, and :func:`~mpmath.invlapcohen`
are also available as shortcuts.

All four algorithms implement a heuristic balance between the
requested precision and the precision used internally for the
calculations. This has been tuned for a typical exponentially
decaying function and precision up to few hundred decimal
digits.

The Laplace transform converts the variable time (i.e., along
a line) into a parameter given by the right half of the
complex `p`-plane.  Singularities, poles, and branch cuts in
the complex `p`-plane contain all the information regarding
the time behavior of the corresponding function. Any numerical
method must therefore sample `p`-plane "close enough" to the
singularities to accurately characterize them, while not
getting too close to have catastrophic cancellation, overflow,
or underflow issues. Most significantly, if one or more of the
singularities in the `p`-plane is not on the left side of the
Bromwich contour, its effects will be left out of the computed
solution, and the answer will be completely wrong.

*Talbot*

The fixed Talbot method is high accuracy and fast, but the
method can catastrophically fail for certain classes of time-domain
behavior, including a Heaviside step function for positive
time (e.g., `H(t-2)`), or some oscillatory behaviors. The
Talbot method usually has adjustable parameters, but the
"fixed" variety implemented here does not. This method
deforms the Bromwich integral contour in the shape of a
parabola towards `-\infty`, which leads to problems
when the solution has a decaying exponential in it (e.g., a
Heaviside step function is equivalent to multiplying by a
decaying exponential in Laplace space).

*Stehfest*

The Stehfest algorithm only uses abscissa along the real axis
of the complex `p`-plane to estimate the time-domain
function. Oscillatory time-domain functions have poles away
from the real axis, so this method does not work well with
oscillatory functions, especially high-frequency ones. This
method also depends on summation of terms in a series that
grows very large, and will have catastrophic cancellation
during summation if the working precision is too low.

*de Hoog et al.*

The de Hoog, Knight, and Stokes method is essentially a
Fourier-series quadrature-type approximation to the Bromwich
contour integral, with non-linear series acceleration and an
analytical expression for the remainder term. This method is
typically one of the most robust. This method also involves the
greatest amount of overhead, so it is typically the slowest of the
four methods at high precision.

*Cohen*

The Cohen method is a trapezoidal rule approximation to the Bromwich
contour integral, with linear acceleration for alternating
series. This method is as robust as the de Hoog et al method and the
fastest of the four methods at high precision, and is therefore the
default method.

**Singularities**

All numerical inverse Laplace transform methods have problems
at large time when the Laplace-space function has poles,
singularities, or branch cuts to the right of the origin in
the complex plane. For simple poles in `\bar{f}(p)` at the
`p`-plane origin, the time function is constant in time (e.g.,
`\mathcal{L}\left\lbrace 1 \right\rbrace=1/p` has a pole at
`p=0`). A pole in `\bar{f}(p)` to the left of the origin is a
decreasing function of time (e.g., `\mathcal{L}\left\lbrace
e^{-t/2} \right\rbrace=1/(p+1/2)` has a pole at `p=-1/2`), and
a pole to the right of the origin leads to an increasing
function in time (e.g., `\mathcal{L}\left\lbrace t e^{t/4}
\right\rbrace = 1/(p-1/4)^2` has a pole at `p=1/4`).  When
singularities occur off the real `p` axis, the time-domain
function is oscillatory. For example `\mathcal{L}\left\lbrace
\mathrm{J}_0(t) \right\rbrace=1/\sqrt{p^2+1}` has a branch cut
starting at `p=j=\sqrt{-1}` and is a decaying oscillatory
function, This range of behaviors is illustrated in Duffy [3]
Figure 4.10.4, p. 228.

In general as `p \rightarrow \infty` `t \rightarrow 0` and
vice-versa. All numerical inverse Laplace transform methods
require their abscissa to shift closer to the origin for
larger times. If the abscissa shift left of the rightmost
singularity in the Laplace domain, the answer will be
completely wrong (the effect of singularities to the right of
the Bromwich contour are not included in the results).

For example, the following exponentially growing function has
a pole at `p=3`:

.. math ::

    \bar{f}(p)=\frac{1}{p^2-9}

.. math ::

    f(t)=\frac{1}{3}\sinh 3t

&gt;&gt;&gt; mp.dps = 15; mp.pretty = True
&gt;&gt;&gt; fp = lambda p: 1/(p*p-9)
&gt;&gt;&gt; ft = lambda t: sinh(3*t)/3
&gt;&gt;&gt; tt = [0.01,0.1,1.0,10.0]
&gt;&gt;&gt; ft(tt[0]),invertlaplace(fp,tt[0],method='talbot')
(0.0100015000675014, 0.0100015000675014)
&gt;&gt;&gt; ft(tt[1]),invertlaplace(fp,tt[1],method='talbot')
(0.101506764482381, 0.101506764482381)
&gt;&gt;&gt; ft(tt[2]),invertlaplace(fp,tt[2],method='talbot')
(3.33929164246997, 3.33929164246997)
&gt;&gt;&gt; ft(tt[3]),invertlaplace(fp,tt[3],method='talbot')
(1781079096920.74, -1.61331069624091e-14)

**References**

1. [DLMF]_ section 1.14 (http://dlmf.nist.gov/1.14T4)
2. Cohen, A.M. (2007). Numerical Methods for Laplace Transform
   Inversion, Springer.
3. Duffy, D.G. (1998). Advanced Engineering Mathematics, CRC Press.

**Numerical Inverse Laplace Transform Reviews**

1. Bellman, R., R.E. Kalaba, J.A. Lockett (1966). *Numerical
   inversion of the Laplace transform: Applications to Biology,
   Economics, Engineering, and Physics*. Elsevier.
2. Davies, B., B. Martin (1979). Numerical inversion of the
   Laplace transform: a survey and comparison of methods. *Journal
   of Computational Physics* 33:1-32,
   http://dx.doi.org/10.1016/0021-9991(79)90025-1
3. Duffy, D.G. (1993). On the numerical inversion of Laplace
   transforms: Comparison of three new methods on characteristic
   problems from applications. *ACM Transactions on Mathematical
   Software* 19(3):333-359, http://dx.doi.org/10.1145/155743.155788
4. Kuhlman, K.L., (2013). Review of Inverse Laplace Transform
   Algorithms for Laplace-Space Numerical Approaches, *Numerical
   Algorithms*, 63(2):339-355.
   http://dx.doi.org/10.1007/s11075-012-9625-3</pre> 
</div>
</div>
<a id="af2d97cba8dd7cb74071df1d74e44e7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d97cba8dd7cb74071df1d74e44e7bb">&#9670;&nbsp;</a></span>invertlaplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invertlaplace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the numerical inverse Laplace transform for a
Laplace-space function at a given time.  The function being
evaluated is assumed to be a real-valued function of time.

The user must supply a Laplace-space function `\bar{f}(p)`,
and a desired time at which to estimate the time-domain
solution `f(t)`.

A few basic examples of Laplace-space functions with known
inverses (see references [1,2]) :

.. math ::

    \mathcal{L}\left\lbrace f(t) \right\rbrace=\bar{f}(p)

.. math ::

    \mathcal{L}^{-1}\left\lbrace \bar{f}(p) \right\rbrace = f(t)

.. math ::

    \bar{f}(p) = \frac{1}{(p+1)^2}

.. math ::

    f(t) = t e^{-t}

&gt;&gt;&gt; from mpmath import *
&gt;&gt;&gt; mp.dps = 15; mp.pretty = True
&gt;&gt;&gt; tt = [0.001, 0.01, 0.1, 1, 10]
&gt;&gt;&gt; fp = lambda p: 1/(p+1)**2
&gt;&gt;&gt; ft = lambda t: t*exp(-t)
&gt;&gt;&gt; ft(tt[0]),ft(tt[0])-invertlaplace(fp,tt[0],method='talbot')
(0.000999000499833375, 8.57923043561212e-20)
&gt;&gt;&gt; ft(tt[1]),ft(tt[1])-invertlaplace(fp,tt[1],method='talbot')
(0.00990049833749168, 3.27007646698047e-19)
&gt;&gt;&gt; ft(tt[2]),ft(tt[2])-invertlaplace(fp,tt[2],method='talbot')
(0.090483741803596, -1.75215800052168e-18)
&gt;&gt;&gt; ft(tt[3]),ft(tt[3])-invertlaplace(fp,tt[3],method='talbot')
(0.367879441171442, 1.2428864009344e-17)
&gt;&gt;&gt; ft(tt[4]),ft(tt[4])-invertlaplace(fp,tt[4],method='talbot')
(0.000453999297624849, 4.04513489306658e-20)

The methods also work for higher precision:

&gt;&gt;&gt; mp.dps = 100; mp.pretty = True
&gt;&gt;&gt; nstr(ft(tt[0]),15),nstr(ft(tt[0])-invertlaplace(fp,tt[0],method='talbot'),15)
('0.000999000499833375', '-4.96868310693356e-105')
&gt;&gt;&gt; nstr(ft(tt[1]),15),nstr(ft(tt[1])-invertlaplace(fp,tt[1],method='talbot'),15)
('0.00990049833749168', '1.23032291513122e-104')

.. math ::

    \bar{f}(p) = \frac{1}{p^2+1}

.. math ::

    f(t) = \mathrm{J}_0(t)

&gt;&gt;&gt; mp.dps = 15; mp.pretty = True
&gt;&gt;&gt; fp = lambda p: 1/sqrt(p*p + 1)
&gt;&gt;&gt; ft = lambda t: besselj(0,t)
&gt;&gt;&gt; ft(tt[0]),ft(tt[0])-invertlaplace(fp,tt[0],method='dehoog')
(0.999999750000016, -6.09717765032273e-18)
&gt;&gt;&gt; ft(tt[1]),ft(tt[1])-invertlaplace(fp,tt[1],method='dehoog')
(0.99997500015625, -5.61756281076169e-17)

.. math ::

    \bar{f}(p) = \frac{\log p}{p}

.. math ::

    f(t) = -\gamma -\log t

&gt;&gt;&gt; mp.dps = 15; mp.pretty = True
&gt;&gt;&gt; fp = lambda p: log(p)/p
&gt;&gt;&gt; ft = lambda t: -euler-log(t)
&gt;&gt;&gt; ft(tt[0]),ft(tt[0])-invertlaplace(fp,tt[0],method='stehfest')
(6.3305396140806, -1.92126634837863e-16)
&gt;&gt;&gt; ft(tt[1]),ft(tt[1])-invertlaplace(fp,tt[1],method='stehfest')
(4.02795452108656, -4.81486093200704e-16)

**Options**

:func:`~mpmath.invertlaplace` recognizes the following optional
keywords valid for all methods:

*method*
    Chooses numerical inverse Laplace transform algorithm
    (described below).
*degree*
    Number of terms used in the approximation

**Algorithms**

Mpmath implements four numerical inverse Laplace transform
algorithms, attributed to: Talbot, Stehfest, and de Hoog,
Knight and Stokes. These can be selected by using
*method='talbot'*, *method='stehfest'*, *method='dehoog'* or
*method='cohen'* or by passing the classes *method=FixedTalbot*,
*method=Stehfest*, *method=deHoog*, or *method=Cohen*. The functions
:func:`~mpmath.invlaptalbot`, :func:`~mpmath.invlapstehfest`,
:func:`~mpmath.invlapdehoog`, and :func:`~mpmath.invlapcohen`
are also available as shortcuts.

All four algorithms implement a heuristic balance between the
requested precision and the precision used internally for the
calculations. This has been tuned for a typical exponentially
decaying function and precision up to few hundred decimal
digits.

The Laplace transform converts the variable time (i.e., along
a line) into a parameter given by the right half of the
complex `p`-plane.  Singularities, poles, and branch cuts in
the complex `p`-plane contain all the information regarding
the time behavior of the corresponding function. Any numerical
method must therefore sample `p`-plane "close enough" to the
singularities to accurately characterize them, while not
getting too close to have catastrophic cancellation, overflow,
or underflow issues. Most significantly, if one or more of the
singularities in the `p`-plane is not on the left side of the
Bromwich contour, its effects will be left out of the computed
solution, and the answer will be completely wrong.

*Talbot*

The fixed Talbot method is high accuracy and fast, but the
method can catastrophically fail for certain classes of time-domain
behavior, including a Heaviside step function for positive
time (e.g., `H(t-2)`), or some oscillatory behaviors. The
Talbot method usually has adjustable parameters, but the
"fixed" variety implemented here does not. This method
deforms the Bromwich integral contour in the shape of a
parabola towards `-\infty`, which leads to problems
when the solution has a decaying exponential in it (e.g., a
Heaviside step function is equivalent to multiplying by a
decaying exponential in Laplace space).

*Stehfest*

The Stehfest algorithm only uses abscissa along the real axis
of the complex `p`-plane to estimate the time-domain
function. Oscillatory time-domain functions have poles away
from the real axis, so this method does not work well with
oscillatory functions, especially high-frequency ones. This
method also depends on summation of terms in a series that
grows very large, and will have catastrophic cancellation
during summation if the working precision is too low.

*de Hoog et al.*

The de Hoog, Knight, and Stokes method is essentially a
Fourier-series quadrature-type approximation to the Bromwich
contour integral, with non-linear series acceleration and an
analytical expression for the remainder term. This method is
typically one of the most robust. This method also involves the
greatest amount of overhead, so it is typically the slowest of the
four methods at high precision.

*Cohen*

The Cohen method is a trapezoidal rule approximation to the Bromwich
contour integral, with linear acceleration for alternating
series. This method is as robust as the de Hoog et al method and the
fastest of the four methods at high precision, and is therefore the
default method.

**Singularities**

All numerical inverse Laplace transform methods have problems
at large time when the Laplace-space function has poles,
singularities, or branch cuts to the right of the origin in
the complex plane. For simple poles in `\bar{f}(p)` at the
`p`-plane origin, the time function is constant in time (e.g.,
`\mathcal{L}\left\lbrace 1 \right\rbrace=1/p` has a pole at
`p=0`). A pole in `\bar{f}(p)` to the left of the origin is a
decreasing function of time (e.g., `\mathcal{L}\left\lbrace
e^{-t/2} \right\rbrace=1/(p+1/2)` has a pole at `p=-1/2`), and
a pole to the right of the origin leads to an increasing
function in time (e.g., `\mathcal{L}\left\lbrace t e^{t/4}
\right\rbrace = 1/(p-1/4)^2` has a pole at `p=1/4`).  When
singularities occur off the real `p` axis, the time-domain
function is oscillatory. For example `\mathcal{L}\left\lbrace
\mathrm{J}_0(t) \right\rbrace=1/\sqrt{p^2+1}` has a branch cut
starting at `p=j=\sqrt{-1}` and is a decaying oscillatory
function, This range of behaviors is illustrated in Duffy [3]
Figure 4.10.4, p. 228.

In general as `p \rightarrow \infty` `t \rightarrow 0` and
vice-versa. All numerical inverse Laplace transform methods
require their abscissa to shift closer to the origin for
larger times. If the abscissa shift left of the rightmost
singularity in the Laplace domain, the answer will be
completely wrong (the effect of singularities to the right of
the Bromwich contour are not included in the results).

For example, the following exponentially growing function has
a pole at `p=3`:

.. math ::

    \bar{f}(p)=\frac{1}{p^2-9}

.. math ::

    f(t)=\frac{1}{3}\sinh 3t

&gt;&gt;&gt; mp.dps = 15; mp.pretty = True
&gt;&gt;&gt; fp = lambda p: 1/(p*p-9)
&gt;&gt;&gt; ft = lambda t: sinh(3*t)/3
&gt;&gt;&gt; tt = [0.01,0.1,1.0,10.0]
&gt;&gt;&gt; ft(tt[0]),invertlaplace(fp,tt[0],method='talbot')
(0.0100015000675014, 0.0100015000675014)
&gt;&gt;&gt; ft(tt[1]),invertlaplace(fp,tt[1],method='talbot')
(0.101506764482381, 0.101506764482381)
&gt;&gt;&gt; ft(tt[2]),invertlaplace(fp,tt[2],method='talbot')
(3.33929164246997, 3.33929164246997)
&gt;&gt;&gt; ft(tt[3]),invertlaplace(fp,tt[3],method='talbot')
(1781079096920.74, -1.61331069624091e-14)

**References**

1. [DLMF]_ section 1.14 (http://dlmf.nist.gov/1.14T4)
2. Cohen, A.M. (2007). Numerical Methods for Laplace Transform
   Inversion, Springer.
3. Duffy, D.G. (1998). Advanced Engineering Mathematics, CRC Press.

**Numerical Inverse Laplace Transform Reviews**

1. Bellman, R., R.E. Kalaba, J.A. Lockett (1966). *Numerical
   inversion of the Laplace transform: Applications to Biology,
   Economics, Engineering, and Physics*. Elsevier.
2. Davies, B., B. Martin (1979). Numerical inversion of the
   Laplace transform: a survey and comparison of methods. *Journal
   of Computational Physics* 33:1-32,
   http://dx.doi.org/10.1016/0021-9991(79)90025-1
3. Duffy, D.G. (1993). On the numerical inversion of Laplace
   transforms: Comparison of three new methods on characteristic
   problems from applications. *ACM Transactions on Mathematical
   Software* 19(3):333-359, http://dx.doi.org/10.1145/155743.155788
4. Kuhlman, K.L., (2013). Review of Inverse Laplace Transform
   Algorithms for Laplace-Space Numerical Approaches, *Numerical
   Algorithms*, 63(2):339-355.
   http://dx.doi.org/10.1007/s11075-012-9625-3</pre> 
</div>
</div>
<a id="a6dc752224ee787ea49e0f5568e2b3501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc752224ee787ea49e0f5568e2b3501">&#9670;&nbsp;</a></span>invlapcohen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invlapcohen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dc752224ee787ea49e0f5568e2b3501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc752224ee787ea49e0f5568e2b3501">&#9670;&nbsp;</a></span>invlapcohen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invlapcohen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aad5d16dc236288aafc39b83e29720b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aad5d16dc236288aafc39b83e29720b">&#9670;&nbsp;</a></span>invlapdehoog() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invlapdehoog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aad5d16dc236288aafc39b83e29720b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aad5d16dc236288aafc39b83e29720b">&#9670;&nbsp;</a></span>invlapdehoog() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invlapdehoog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0c6f6b1f540f544343491bc3ded8552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c6f6b1f540f544343491bc3ded8552">&#9670;&nbsp;</a></span>invlapstehfest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invlapstehfest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0c6f6b1f540f544343491bc3ded8552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c6f6b1f540f544343491bc3ded8552">&#9670;&nbsp;</a></span>invlapstehfest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invlapstehfest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2d5b2898ac6e7ef7692bc6e6932932b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d5b2898ac6e7ef7692bc6e6932932b">&#9670;&nbsp;</a></span>invlaptalbot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invlaptalbot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2d5b2898ac6e7ef7692bc6e6932932b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d5b2898ac6e7ef7692bc6e6932932b">&#9670;&nbsp;</a></span>invlaptalbot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.inverselaplace.LaplaceTransformInversionMethods.invlaptalbot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/mpmath/calculus/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2mpmath_2calculus_2inverselaplace_8py.html">inverselaplace.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
