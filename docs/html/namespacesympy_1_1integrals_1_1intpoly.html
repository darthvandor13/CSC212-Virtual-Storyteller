<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.integrals.intpoly Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1integrals.html">integrals</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html">intpoly</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.integrals.intpoly Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a947051a4456d5bc1c59b8651ce91dd15"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a947051a4456d5bc1c59b8651ce91dd15">polytope_integrate</a> (poly, expr=None, *clockwise=False, max_degree=None)</td></tr>
<tr class="separator:a947051a4456d5bc1c59b8651ce91dd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c03dfe44ac5e04304a890585a253e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a15c03dfe44ac5e04304a890585a253e8">strip</a> (monom)</td></tr>
<tr class="separator:a15c03dfe44ac5e04304a890585a253e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1836eeaa1477ffe83cd20e0a5e8536"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#aee1836eeaa1477ffe83cd20e0a5e8536">main_integrate3d</a> (expr, facets, vertices, hp_params, max_degree=None)</td></tr>
<tr class="separator:aee1836eeaa1477ffe83cd20e0a5e8536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2941bb096f6da3e9312afd54aae2fc57"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a2941bb096f6da3e9312afd54aae2fc57">main_integrate</a> (expr, facets, hp_params, max_degree=None)</td></tr>
<tr class="separator:a2941bb096f6da3e9312afd54aae2fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cdf683eaf6a10671855fd89f82763d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#af8cdf683eaf6a10671855fd89f82763d">polygon_integrate</a> (facet, hp_param, index, facets, vertices, expr, degree)</td></tr>
<tr class="separator:af8cdf683eaf6a10671855fd89f82763d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd85e09e8a6e9a1e5bf38aab298bf91c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#acd85e09e8a6e9a1e5bf38aab298bf91c">distance_to_side</a> (point, line_seg, A)</td></tr>
<tr class="separator:acd85e09e8a6e9a1e5bf38aab298bf91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac717d15bb1e6defdf27ba3c4453f0bdc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#ac717d15bb1e6defdf27ba3c4453f0bdc">lineseg_integrate</a> (polygon, index, line_seg, expr, degree)</td></tr>
<tr class="separator:ac717d15bb1e6defdf27ba3c4453f0bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee1fc61608bf59399f5ea11f3734016"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a1ee1fc61608bf59399f5ea11f3734016">integration_reduction</a> (facets, index, a, b, expr, dims, degree)</td></tr>
<tr class="separator:a1ee1fc61608bf59399f5ea11f3734016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051c8c034d7f1d598490b151aa3f958a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a051c8c034d7f1d598490b151aa3f958a">left_integral2D</a> (m, index, facets, x0, expr, gens)</td></tr>
<tr class="separator:a051c8c034d7f1d598490b151aa3f958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d080d98fa9c1caf1c52300f905b139"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#af4d080d98fa9c1caf1c52300f905b139">integration_reduction_dynamic</a> (facets, index, a, b, expr, degree, dims, x_index, y_index, max_index, x0, monomial_values, monom_index, vertices=None, hp_param=None)</td></tr>
<tr class="separator:af4d080d98fa9c1caf1c52300f905b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5084505e4715b73d80a2b752b21796"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#adc5084505e4715b73d80a2b752b21796">left_integral3D</a> (facets, index, expr, vertices, hp_param, degree)</td></tr>
<tr class="separator:adc5084505e4715b73d80a2b752b21796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a384bbc77ff38e7bfe324a4de642ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a24a384bbc77ff38e7bfe324a4de642ff">gradient_terms</a> (binomial_power=0, no_of_gens=2)</td></tr>
<tr class="separator:a24a384bbc77ff38e7bfe324a4de642ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f3a907b6d1eb84e8be3fb95f885aa8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#aa5f3a907b6d1eb84e8be3fb95f885aa8">hyperplane_parameters</a> (poly, vertices=None)</td></tr>
<tr class="separator:aa5f3a907b6d1eb84e8be3fb95f885aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691271affc9ba284e5e57404f68fdc76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a691271affc9ba284e5e57404f68fdc76">cross_product</a> (v1, v2, v3)</td></tr>
<tr class="separator:a691271affc9ba284e5e57404f68fdc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88ff3acd178cdc5debbbcad5f0beee4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#ab88ff3acd178cdc5debbbcad5f0beee4">best_origin</a> (a, b, lineseg, expr)</td></tr>
<tr class="separator:ab88ff3acd178cdc5debbbcad5f0beee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccb8707661fb5dbbf027146a517c197"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a3ccb8707661fb5dbbf027146a517c197">decompose</a> (expr, separate=False)</td></tr>
<tr class="separator:a3ccb8707661fb5dbbf027146a517c197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e49b8c6578fa0fb1ca3737738bd722c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a5e49b8c6578fa0fb1ca3737738bd722c">point_sort</a> (poly, normal=None, clockwise=True)</td></tr>
<tr class="separator:a5e49b8c6578fa0fb1ca3737738bd722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c5e389beda7b526254f9faeef16de7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a96c5e389beda7b526254f9faeef16de7">norm</a> (point)</td></tr>
<tr class="separator:a96c5e389beda7b526254f9faeef16de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3647af695717cbc522ae61e451ba7733"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a3647af695717cbc522ae61e451ba7733">intersection</a> (geom_1, geom_2, intersection_type)</td></tr>
<tr class="separator:a3647af695717cbc522ae61e451ba7733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d223e158c6e72cee1f3fd920d64888e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a2d223e158c6e72cee1f3fd920d64888e">is_vertex</a> (ent)</td></tr>
<tr class="separator:a2d223e158c6e72cee1f3fd920d64888e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaa01d8ce19ecae9ae375e90a4061b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#aedaa01d8ce19ecae9ae375e90a4061b3">plot_polytope</a> (poly)</td></tr>
<tr class="separator:aedaa01d8ce19ecae9ae375e90a4061b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14932df97765acbc40eeb3baa2099e50"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1integrals_1_1intpoly.html#a14932df97765acbc40eeb3baa2099e50">plot_polynomial</a> (expr)</td></tr>
<tr class="separator:a14932df97765acbc40eeb3baa2099e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Module to implement integration of uni/bivariate polynomials over
2D Polytopes and uni/bi/trivariate polynomials over 3D Polytopes.

Uses evaluation techniques as described in Chin et al. (2015) [1].


References
===========

.. [1] Chin, Eric B., Jean B. Lasserre, and N. Sukumar. "Numerical integration
of homogeneous functions on convex and nonconvex polygons and polyhedra."
Computational Mechanics 56.6 (2015): 967-981

PDF link : http://dilbert.engr.ucdavis.edu/~suku/quadrature/cls-integration.pdf
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ab88ff3acd178cdc5debbbcad5f0beee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88ff3acd178cdc5debbbcad5f0beee4">&#9670;&nbsp;</a></span>best_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.best_origin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lineseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper method for polytope_integrate. Currently not used in the main
algorithm.

Explanation
===========

Returns a point on the lineseg whose vector inner product with the
divergence of `expr` yields an expression with the least maximum
total power.

Parameters
==========

a :
    Hyperplane parameter denoting direction.
b :
    Hyperplane parameter denoting distance.
lineseg :
    Line segment on which to find the origin.
expr :
    The expression which determines the best point.

Algorithm(currently works only for 2D use case)
===============================================

1 &gt; Firstly, check for edge cases. Here that would refer to vertical
    or horizontal lines.

2 &gt; If input expression is a polynomial containing more than one generator
    then find out the total power of each of the generators.

    x**2 + 3 + x*y + x**4*y**5 ---&gt; {x: 7, y: 6}

    If expression is a constant value then pick the first boundary point
    of the line segment.

3 &gt; First check if a point exists on the line segment where the value of
    the highest power generator becomes 0. If not check if the value of
    the next highest becomes 0. If none becomes 0 within line segment
    constraints then pick the first boundary point of the line segment.
    Actually, any point lying on the segment can be picked as best origin
    in the last case.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import best_origin
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy import Point, Segment2D
&gt;&gt;&gt; l = Segment2D(Point(0, 3), Point(1, 1))
&gt;&gt;&gt; expr = x**3*y**7
&gt;&gt;&gt; best_origin((2, 1), 3, l, expr)
(0, 3.0)
</pre> 
</div>
</div>
<a id="a691271affc9ba284e5e57404f68fdc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691271affc9ba284e5e57404f68fdc76">&#9670;&nbsp;</a></span>cross_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.cross_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the cross-product of vectors (v2 - v1) and (v3 - v1)
That is : (v2 - v1) X (v3 - v1)
</pre> 
</div>
</div>
<a id="a3ccb8707661fb5dbbf027146a517c197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccb8707661fb5dbbf027146a517c197">&#9670;&nbsp;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.decompose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>separate</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decomposes an input polynomial into homogeneous ones of
smaller or equal degree.

Explanation
===========

Returns a dictionary with keys as the degree of the smaller
constituting polynomials. Values are the constituting polynomials.

Parameters
==========

expr : Expr
    Polynomial(SymPy expression).
separate : bool
    If True then simply return a list of the constituent monomials
    If not then break up the polynomial into constituent homogeneous
    polynomials.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.integrals.intpoly import decompose
&gt;&gt;&gt; decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)
{1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}
&gt;&gt;&gt; decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)
{x, x**2, y, y**5, x*y, x**3*y**2}
</pre> 
</div>
</div>
<a id="acd85e09e8a6e9a1e5bf38aab298bf91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd85e09e8a6e9a1e5bf38aab298bf91c">&#9670;&nbsp;</a></span>distance_to_side()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.distance_to_side </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>line_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function to compute the signed distance between given 3D point
and a line segment.

Parameters
==========

point : 3D Point
line_seg : Line Segment

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import distance_to_side
&gt;&gt;&gt; point = (0, 0, 0)
&gt;&gt;&gt; distance_to_side(point, [(0, 0, 1), (0, 1, 0)], (1, 0, 0))
-sqrt(2)/2
</pre> 
</div>
</div>
<a id="a24a384bbc77ff38e7bfe324a4de642ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a384bbc77ff38e7bfe324a4de642ff">&#9670;&nbsp;</a></span>gradient_terms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.gradient_terms </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>binomial_power</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>no_of_gens</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of all the possible monomials between
0 and y**binomial_power for 2D case and z**binomial_power
for 3D case.

Parameters
==========

binomial_power :
    Power upto which terms are generated.
no_of_gens :
    Denotes whether terms are being generated for 2D or 3D case.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import gradient_terms
&gt;&gt;&gt; gradient_terms(2)
[[1, 0, 0, 0], [y, 0, 1, 0], [y**2, 0, 2, 0], [x, 1, 0, 0],
[x*y, 1, 1, 0], [x**2, 2, 0, 0]]
&gt;&gt;&gt; gradient_terms(2, 3)
[[[[1, 0, 0, 0, 0, 0, 0, 0]]], [[[y, 0, 1, 0, 1, 0, 0, 0],
[z, 0, 0, 1, 1, 0, 1, 0]], [[x, 1, 0, 0, 1, 1, 0, 0]]],
[[[y**2, 0, 2, 0, 2, 0, 0, 0], [y*z, 0, 1, 1, 2, 0, 1, 0],
[z**2, 0, 0, 2, 2, 0, 2, 0]], [[x*y, 1, 1, 0, 2, 1, 0, 0],
[x*z, 1, 0, 1, 2, 1, 1, 0]], [[x**2, 2, 0, 0, 2, 2, 0, 0]]]]
</pre> 
</div>
</div>
<a id="aa5f3a907b6d1eb84e8be3fb95f885aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f3a907b6d1eb84e8be3fb95f885aa8">&#9670;&nbsp;</a></span>hyperplane_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.hyperplane_parameters </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vertices</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A helper function to return the hyperplane parameters
of which the facets of the polytope are a part of.

Parameters
==========

poly :
    The input 2/3-Polytope.
vertices :
    Vertex indices of 3-Polytope.

Examples
========

&gt;&gt;&gt; from sympy import Point, Polygon
&gt;&gt;&gt; from sympy.integrals.intpoly import hyperplane_parameters
&gt;&gt;&gt; hyperplane_parameters(Polygon(Point(0, 3), Point(5, 3), Point(1, 1)))
[((0, 1), 3), ((1, -2), -1), ((-2, -1), -3)]
&gt;&gt;&gt; cube = [[(0, 0, 0), (0, 0, 5), (0, 5, 0), (0, 5, 5), (5, 0, 0),\
            (5, 0, 5), (5, 5, 0), (5, 5, 5)],\
            [2, 6, 7, 3], [3, 7, 5, 1], [7, 6, 4, 5], [1, 5, 4, 0],\
            [3, 1, 0, 2], [0, 4, 6, 2]]
&gt;&gt;&gt; hyperplane_parameters(cube[1:], cube[0])
[([0, -1, 0], -5), ([0, 0, -1], -5), ([-1, 0, 0], -5),
([0, 1, 0], 0), ([1, 0, 0], 0), ([0, 0, 1], 0)]
</pre> 
</div>
</div>
<a id="a1ee1fc61608bf59399f5ea11f3734016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee1fc61608bf59399f5ea11f3734016">&#9670;&nbsp;</a></span>integration_reduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.integration_reduction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper method for main_integrate. Returns the value of the input
expression evaluated over the polytope facet referenced by a given index.

Parameters
===========

facets :
    List of facets of the polytope.
index :
    Index referencing the facet to integrate the expression over.
a :
    Hyperplane parameter denoting direction.
b :
    Hyperplane parameter denoting distance.
expr :
    The expression to integrate over the facet.
dims :
    List of symbols denoting axes.
degree :
    Degree of the homogeneous polynomial.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.integrals.intpoly import integration_reduction,\
hyperplane_parameters
&gt;&gt;&gt; from sympy import Point, Polygon
&gt;&gt;&gt; triangle = Polygon(Point(0, 3), Point(5, 3), Point(1, 1))
&gt;&gt;&gt; facets = triangle.sides
&gt;&gt;&gt; a, b = hyperplane_parameters(triangle)[0]
&gt;&gt;&gt; integration_reduction(facets, 0, a, b, 1, (x, y), 0)
5
</pre> 
</div>
</div>
<a id="af4d080d98fa9c1caf1c52300f905b139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d080d98fa9c1caf1c52300f905b139">&#9670;&nbsp;</a></span>integration_reduction_dynamic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.integration_reduction_dynamic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>monomial_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>monom_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vertices</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hp_param</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The same integration_reduction function which uses a dynamic
programming approach to compute terms by using the values of the integral
of previously computed terms.

Parameters
==========

facets :
    Facets of the Polytope.
index :
    Index of facet to find intersections with.(Used in left_integral()).
a, b :
    Hyperplane parameters.
expr :
    Input monomial.
degree :
    Total degree of ``expr``.
dims :
    Tuple denoting axes variables.
x_index :
    Exponent of 'x' in ``expr``.
y_index :
    Exponent of 'y' in ``expr``.
max_index :
    Maximum exponent of any monomial in ``monomial_values``.
x0 :
    First point on ``facets[index]``.
monomial_values :
    List of monomial values constituting the polynomial.
monom_index :
    Index of monomial whose integration is being found.
vertices : optional
    Coordinates of vertices constituting the 3-Polytope.
hp_param : optional
    Hyperplane Parameter of the face of the facets[index].

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.integrals.intpoly import (integration_reduction_dynamic, \
        hyperplane_parameters)
&gt;&gt;&gt; from sympy import Point, Polygon
&gt;&gt;&gt; triangle = Polygon(Point(0, 3), Point(5, 3), Point(1, 1))
&gt;&gt;&gt; facets = triangle.sides
&gt;&gt;&gt; a, b = hyperplane_parameters(triangle)[0]
&gt;&gt;&gt; x0 = facets[0].points[0]
&gt;&gt;&gt; monomial_values = [[0, 0, 0, 0], [1, 0, 0, 5],\
                       [y, 0, 1, 15], [x, 1, 0, None]]
&gt;&gt;&gt; integration_reduction_dynamic(facets, 0, a, b, x, 1, (x, y), 1, 0, 1,\
                                  x0, monomial_values, 3)
25/2
</pre> 
</div>
</div>
<a id="a3647af695717cbc522ae61e451ba7733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3647af695717cbc522ae61e451ba7733">&#9670;&nbsp;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>geom_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>geom_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>intersection_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns intersection between geometric objects.

Explanation
===========

Note that this function is meant for use in integration_reduction and
at that point in the calling function the lines denoted by the segments
surely intersect within segment boundaries. Coincident lines are taken
to be non-intersecting. Also, the hyperplane intersection for 2D case is
also implemented.

Parameters
==========

geom_1, geom_2:
    The input line segments.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import intersection
&gt;&gt;&gt; from sympy import Point, Segment2D
&gt;&gt;&gt; l1 = Segment2D(Point(1, 1), Point(3, 5))
&gt;&gt;&gt; l2 = Segment2D(Point(2, 0), Point(2, 5))
&gt;&gt;&gt; intersection(l1, l2, "segment2D")
(2, 3)
&gt;&gt;&gt; p1 = ((-1, 0), 0)
&gt;&gt;&gt; p2 = ((0, 1), 1)
&gt;&gt;&gt; intersection(p1, p2, "plane2D")
(0, 1)
</pre> 
</div>
</div>
<a id="a2d223e158c6e72cee1f3fd920d64888e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d223e158c6e72cee1f3fd920d64888e">&#9670;&nbsp;</a></span>is_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.is_vertex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If the input entity is a vertex return True.

Parameter
=========

ent :
    Denotes a geometric entity representing a point.

Examples
========

&gt;&gt;&gt; from sympy import Point
&gt;&gt;&gt; from sympy.integrals.intpoly import is_vertex
&gt;&gt;&gt; is_vertex((2, 3))
True
&gt;&gt;&gt; is_vertex((2, 3, 6))
True
&gt;&gt;&gt; is_vertex(Point(2, 3))
True
</pre> 
</div>
</div>
<a id="a051c8c034d7f1d598490b151aa3f958a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051c8c034d7f1d598490b151aa3f958a">&#9670;&nbsp;</a></span>left_integral2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.left_integral2D </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the left integral of Eq 10 in Chin et al.
For the 2D case, the integral is just an evaluation of the polynomial
at the intersection of two facets which is multiplied by the distance
between the first point of facet and that intersection.

Parameters
==========

m :
    No. of hyperplanes.
index :
    Index of facet to find intersections with.
facets :
    List of facets(Line Segments in 2D case).
x0 :
    First point on facet referenced by index.
expr :
    Input polynomial
gens :
    Generators which generate the polynomial

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.integrals.intpoly import left_integral2D
&gt;&gt;&gt; from sympy import Point, Polygon
&gt;&gt;&gt; triangle = Polygon(Point(0, 3), Point(5, 3), Point(1, 1))
&gt;&gt;&gt; facets = triangle.sides
&gt;&gt;&gt; left_integral2D(3, 0, facets, facets[0].points[0], 1, (x, y))
5
</pre> 
</div>
</div>
<a id="adc5084505e4715b73d80a2b752b21796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5084505e4715b73d80a2b752b21796">&#9670;&nbsp;</a></span>left_integral3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.left_integral3D </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hp_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the left integral of Eq 10 in Chin et al.

Explanation
===========

For the 3D case, this is the sum of the integral values over constituting
line segments of the face (which is accessed by facets[index]) multiplied
by the distance between the first point of facet and that line segment.

Parameters
==========

facets :
    List of faces of the 3-Polytope.
index :
    Index of face over which integral is to be calculated.
expr :
    Input polynomial.
vertices :
    List of vertices that constitute the 3-Polytope.
hp_param :
    The hyperplane parameters of the face.
degree :
    Degree of the ``expr``.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import left_integral3D
&gt;&gt;&gt; cube = [[(0, 0, 0), (0, 0, 5), (0, 5, 0), (0, 5, 5), (5, 0, 0),\
             (5, 0, 5), (5, 5, 0), (5, 5, 5)],\
             [2, 6, 7, 3], [3, 7, 5, 1], [7, 6, 4, 5], [1, 5, 4, 0],\
             [3, 1, 0, 2], [0, 4, 6, 2]]
&gt;&gt;&gt; facets = cube[1:]
&gt;&gt;&gt; vertices = cube[0]
&gt;&gt;&gt; left_integral3D(facets, 3, 1, vertices, ([0, -1, 0], -5), 0)
-50
</pre> 
</div>
</div>
<a id="ac717d15bb1e6defdf27ba3c4453f0bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac717d15bb1e6defdf27ba3c4453f0bdc">&#9670;&nbsp;</a></span>lineseg_integrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.lineseg_integrate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>line_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function to compute the line integral of ``expr`` over ``line_seg``.

Parameters
===========

polygon :
    Face of a 3-Polytope.
index :
    Index of line_seg in polygon.
line_seg :
    Line Segment.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import lineseg_integrate
&gt;&gt;&gt; polygon = [(0, 5, 0), (5, 5, 0), (5, 5, 5), (0, 5, 5)]
&gt;&gt;&gt; line_seg = [(0, 5, 0), (5, 5, 0)]
&gt;&gt;&gt; lineseg_integrate(polygon, 0, line_seg, 1, 0)
5
</pre> 
</div>
</div>
<a id="a2941bb096f6da3e9312afd54aae2fc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2941bb096f6da3e9312afd54aae2fc57">&#9670;&nbsp;</a></span>main_integrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.main_integrate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hp_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_degree</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to translate the problem of integrating univariate/bivariate
polynomials over a 2-Polytope to integrating over its boundary facets.
This is done using Generalized Stokes's Theorem and Euler's Theorem.

Parameters
==========

expr :
    The input polynomial.
facets :
    Facets(Line Segments) of the 2-Polytope.
hp_params :
    Hyperplane Parameters of the facets.
max_degree : optional
    The maximum degree of any monomial of the input polynomial.

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.integrals.intpoly import main_integrate,\
hyperplane_parameters
&gt;&gt;&gt; from sympy import Point, Polygon
&gt;&gt;&gt; triangle = Polygon(Point(0, 3), Point(5, 3), Point(1, 1))
&gt;&gt;&gt; facets = triangle.sides
&gt;&gt;&gt; hp_params = hyperplane_parameters(triangle)
&gt;&gt;&gt; main_integrate(x**2 + y**2, facets, hp_params)
325/6
</pre> 
</div>
</div>
<a id="aee1836eeaa1477ffe83cd20e0a5e8536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1836eeaa1477ffe83cd20e0a5e8536">&#9670;&nbsp;</a></span>main_integrate3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.main_integrate3d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hp_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_degree</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to translate the problem of integrating uni/bi/tri-variate
polynomials over a 3-Polytope to integrating over its faces.
This is done using Generalized Stokes' Theorem and Euler's Theorem.

Parameters
==========

expr :
    The input polynomial.
facets :
    Faces of the 3-Polytope(expressed as indices of `vertices`).
vertices :
    Vertices that constitute the Polytope.
hp_params :
    Hyperplane Parameters of the facets.
max_degree : optional
    Max degree of constituent monomial in given list of polynomial.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import main_integrate3d, \
hyperplane_parameters
&gt;&gt;&gt; cube = [[(0, 0, 0), (0, 0, 5), (0, 5, 0), (0, 5, 5), (5, 0, 0),\
            (5, 0, 5), (5, 5, 0), (5, 5, 5)],\
            [2, 6, 7, 3], [3, 7, 5, 1], [7, 6, 4, 5], [1, 5, 4, 0],\
            [3, 1, 0, 2], [0, 4, 6, 2]]
&gt;&gt;&gt; vertices = cube[0]
&gt;&gt;&gt; faces = cube[1:]
&gt;&gt;&gt; hp_params = hyperplane_parameters(faces, vertices)
&gt;&gt;&gt; main_integrate3d(1, faces, vertices, hp_params)
-125
</pre> 
</div>
</div>
<a id="a96c5e389beda7b526254f9faeef16de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c5e389beda7b526254f9faeef16de7">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.norm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Euclidean norm of a point from origin.

Parameters
==========

point:
    This denotes a point in the dimension_al spac_e.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import norm
&gt;&gt;&gt; from sympy import Point
&gt;&gt;&gt; norm(Point(2, 7))
sqrt(53)
</pre> 
</div>
</div>
<a id="a14932df97765acbc40eeb3baa2099e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14932df97765acbc40eeb3baa2099e50">&#9670;&nbsp;</a></span>plot_polynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.plot_polynomial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Plots the polynomial using the functions written in
plotting module which in turn uses matplotlib backend.

Parameter
=========

expr:
    Denotes a polynomial(SymPy expression).
</pre> 
</div>
</div>
<a id="aedaa01d8ce19ecae9ae375e90a4061b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaa01d8ce19ecae9ae375e90a4061b3">&#9670;&nbsp;</a></span>plot_polytope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.plot_polytope </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Plots the 2D polytope using the functions written in plotting
module which in turn uses matplotlib backend.

Parameter
=========

poly:
    Denotes a 2-Polytope.
</pre> 
</div>
</div>
<a id="a5e49b8c6578fa0fb1ca3737738bd722c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e49b8c6578fa0fb1ca3737738bd722c">&#9670;&nbsp;</a></span>point_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.point_sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normal</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clockwise</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the same polygon with points sorted in clockwise or
anti-clockwise order.

Note that it's necessary for input points to be sorted in some order
(clockwise or anti-clockwise) for the integration algorithm to work.
As a convention algorithm has been implemented keeping clockwise
orientation in mind.

Parameters
==========

poly:
    2D or 3D Polygon.
normal : optional
    The normal of the plane which the 3-Polytope is a part of.
clockwise : bool, optional
    Returns points sorted in clockwise order if True and
    anti-clockwise if False.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import point_sort
&gt;&gt;&gt; from sympy import Point
&gt;&gt;&gt; point_sort([Point(0, 0), Point(1, 0), Point(1, 1)])
[Point2D(1, 1), Point2D(1, 0), Point2D(0, 0)]
</pre> 
</div>
</div>
<a id="af8cdf683eaf6a10671855fd89f82763d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cdf683eaf6a10671855fd89f82763d">&#9670;&nbsp;</a></span>polygon_integrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.polygon_integrate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hp_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function to integrate the input uni/bi/trivariate polynomial
over a certain face of the 3-Polytope.

Parameters
==========

facet :
    Particular face of the 3-Polytope over which ``expr`` is integrated.
index :
    The index of ``facet`` in ``facets``.
facets :
    Faces of the 3-Polytope(expressed as indices of `vertices`).
vertices :
    Vertices that constitute the facet.
expr :
    The input polynomial.
degree :
    Degree of ``expr``.

Examples
========

&gt;&gt;&gt; from sympy.integrals.intpoly import polygon_integrate
&gt;&gt;&gt; cube = [[(0, 0, 0), (0, 0, 5), (0, 5, 0), (0, 5, 5), (5, 0, 0),\
             (5, 0, 5), (5, 5, 0), (5, 5, 5)],\
             [2, 6, 7, 3], [3, 7, 5, 1], [7, 6, 4, 5], [1, 5, 4, 0],\
             [3, 1, 0, 2], [0, 4, 6, 2]]
&gt;&gt;&gt; facet = cube[1]
&gt;&gt;&gt; facets = cube[1:]
&gt;&gt;&gt; vertices = cube[0]
&gt;&gt;&gt; polygon_integrate(facet, [(0, 1, 0), 5], 0, facets, vertices, 1, 0)
-25
</pre> 
</div>
</div>
<a id="a947051a4456d5bc1c59b8651ce91dd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947051a4456d5bc1c59b8651ce91dd15">&#9670;&nbsp;</a></span>polytope_integrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.polytope_integrate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>clockwise</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_degree</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integrates polynomials over 2/3-Polytopes.

Explanation
===========

This function accepts the polytope in ``poly`` and the function in ``expr``
(uni/bi/trivariate polynomials are implemented) and returns
the exact integral of ``expr`` over ``poly``.

Parameters
==========

poly : The input Polygon.

expr : The input polynomial.

clockwise : Binary value to sort input points of 2-Polytope clockwise.(Optional)

max_degree : The maximum degree of any monomial of the input polynomial.(Optional)

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy import Point, Polygon
&gt;&gt;&gt; from sympy.integrals.intpoly import polytope_integrate
&gt;&gt;&gt; polygon = Polygon(Point(0, 0), Point(0, 1), Point(1, 1), Point(1, 0))
&gt;&gt;&gt; polys = [1, x, y, x*y, x**2*y, x*y**2]
&gt;&gt;&gt; expr = x*y
&gt;&gt;&gt; polytope_integrate(polygon, expr)
1/4
&gt;&gt;&gt; polytope_integrate(polygon, polys, max_degree=3)
{1: 1, x: 1/2, y: 1/2, x*y: 1/4, x*y**2: 1/6, x**2*y: 1/6}
</pre> 
</div>
</div>
<a id="a15c03dfe44ac5e04304a890585a253e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c03dfe44ac5e04304a890585a253e8">&#9670;&nbsp;</a></span>strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.integrals.intpoly.strip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>monom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
