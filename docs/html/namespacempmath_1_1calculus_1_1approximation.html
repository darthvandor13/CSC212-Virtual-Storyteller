<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.calculus.approximation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus_1_1approximation.html">approximation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.calculus.approximation Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae4544eb291c69c9e697bd944a0fefbfa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1approximation.html#ae4544eb291c69c9e697bd944a0fefbfa">chebcoeff</a> (ctx, f, a, b, <a class="el" href="namespacempmath.html#adf23b5a220142224911174feaff6726c">j</a>, N)</td></tr>
<tr class="separator:ae4544eb291c69c9e697bd944a0fefbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c99d9231029e0e3833117c70b86803c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1approximation.html#a6c99d9231029e0e3833117c70b86803c">chebT</a> (ctx, a=1, b=0)</td></tr>
<tr class="separator:a6c99d9231029e0e3833117c70b86803c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba8e5313dfe34e3096a871b65df32e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1approximation.html#a6ba8e5313dfe34e3096a871b65df32e8">chebyfit</a> (ctx, f, interval, N, error=False)</td></tr>
<tr class="separator:a6ba8e5313dfe34e3096a871b65df32e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15818effb1d351d0950bacf3dc15f113"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1approximation.html#a15818effb1d351d0950bacf3dc15f113">fourier</a> (ctx, f, interval, N)</td></tr>
<tr class="separator:a15818effb1d351d0950bacf3dc15f113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3078545d930fb9ff80eaea5f15c9e32b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1approximation.html#a3078545d930fb9ff80eaea5f15c9e32b">fourierval</a> (ctx, series, interval, x)</td></tr>
<tr class="separator:a3078545d930fb9ff80eaea5f15c9e32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae4544eb291c69c9e697bd944a0fefbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4544eb291c69c9e697bd944a0fefbfa">&#9670;&nbsp;</a></span>chebcoeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.approximation.chebcoeff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c99d9231029e0e3833117c70b86803c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c99d9231029e0e3833117c70b86803c">&#9670;&nbsp;</a></span>chebT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.approximation.chebT </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ba8e5313dfe34e3096a871b65df32e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba8e5313dfe34e3096a871b65df32e8">&#9670;&nbsp;</a></span>chebyfit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.approximation.chebyfit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a polynomial of degree `N-1` that approximates the
given function `f` on the interval `[a, b]`. With ``error=True``,
:func:`~mpmath.chebyfit` also returns an accurate estimate of the
maximum absolute error; that is, the maximum value of
`|f(x) - P(x)|` for `x \in [a, b]`.

:func:`~mpmath.chebyfit` uses the Chebyshev approximation formula,
which gives a nearly optimal solution: that is, the maximum
error of the approximating polynomial is very close to
the smallest possible for any polynomial of the same degree.

Chebyshev approximation is very useful if one needs repeated
evaluation of an expensive function, such as function defined
implicitly by an integral or a differential equation. (For
example, it could be used to turn a slow mpmath function
into a fast machine-precision version of the same.)

**Examples**

Here we use :func:`~mpmath.chebyfit` to generate a low-degree approximation
of `f(x) = \cos(x)`, valid on the interval `[1, 2]`::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; poly, err = chebyfit(cos, [1, 2], 5, error=True)
    &gt;&gt;&gt; nprint(poly)
    [0.00291682, 0.146166, -0.732491, 0.174141, 0.949553]
    &gt;&gt;&gt; nprint(err, 12)
    1.61351758081e-5

The polynomial can be evaluated using ``polyval``::

    &gt;&gt;&gt; nprint(polyval(poly, 1.6), 12)
    -0.0291858904138
    &gt;&gt;&gt; nprint(cos(1.6), 12)
    -0.0291995223013

Sampling the true error at 1000 points shows that the error
estimate generated by ``chebyfit`` is remarkably good::

    &gt;&gt;&gt; error = lambda x: abs(cos(x) - polyval(poly, x))
    &gt;&gt;&gt; nprint(max([error(1+n/1000.) for n in range(1000)]), 12)
    1.61349954245e-5

**Choice of degree**

The degree `N` can be set arbitrarily high, to obtain an
arbitrarily good approximation. As a rule of thumb, an
`N`-term Chebyshev approximation is good to `N/(b-a)` decimal
places on a unit interval (although this depends on how
well-behaved `f` is). The cost grows accordingly: ``chebyfit``
evaluates the function `(N^2)/2` times to compute the
coefficients and an additional `N` times to estimate the error.

**Possible issues**

One should be careful to use a sufficiently high working
precision both when calling ``chebyfit`` and when evaluating
the resulting polynomial, as the polynomial is sometimes
ill-conditioned. It is for example difficult to reach
15-digit accuracy when evaluating the polynomial using
machine precision floats, no matter the theoretical
accuracy of the polynomial. (The option to return the
coefficients in Chebyshev form should be made available
in the future.)

It is important to note the Chebyshev approximation works
poorly if `f` is not smooth. A function containing singularities,
rapid oscillation, etc can be approximated more effectively by
multiplying it by a weight function that cancels out the
nonsmooth features, or by dividing the interval into several
segments.
</pre> 
</div>
</div>
<a id="a15818effb1d351d0950bacf3dc15f113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15818effb1d351d0950bacf3dc15f113">&#9670;&nbsp;</a></span>fourier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.approximation.fourier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the Fourier series of degree `N` of the given function
on the interval `[a, b]`. More precisely, :func:`~mpmath.fourier` returns
two lists `(c, s)` of coefficients (the cosine series and sine
series, respectively), such that

.. math ::

    f(x) \sim \sum_{k=0}^N
        c_k \cos(k m x) + s_k \sin(k m x)

where `m = 2 \pi / (b-a)`.

Note that many texts define the first coefficient as `2 c_0` instead
of `c_0`. The easiest way to evaluate the computed series correctly
is to pass it to :func:`~mpmath.fourierval`.

**Examples**

The function `f(x) = x` has a simple Fourier series on the standard
interval `[-\pi, \pi]`. The cosine coefficients are all zero (because
the function has odd symmetry), and the sine coefficients are
rational numbers::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15; mp.pretty = True
    &gt;&gt;&gt; c, s = fourier(lambda x: x, [-pi, pi], 5)
    &gt;&gt;&gt; nprint(c)
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    &gt;&gt;&gt; nprint(s)
    [0.0, 2.0, -1.0, 0.666667, -0.5, 0.4]

This computes a Fourier series of a nonsymmetric function on
a nonstandard interval::

    &gt;&gt;&gt; I = [-1, 1.5]
    &gt;&gt;&gt; f = lambda x: x**2 - 4*x + 1
    &gt;&gt;&gt; cs = fourier(f, I, 4)
    &gt;&gt;&gt; nprint(cs[0])
    [0.583333, 1.12479, -1.27552, 0.904708, -0.441296]
    &gt;&gt;&gt; nprint(cs[1])
    [0.0, -2.6255, 0.580905, 0.219974, -0.540057]

It is instructive to plot a function along with its truncated
Fourier series::

    &gt;&gt;&gt; plot([f, lambda x: fourierval(cs, I, x)], I) #doctest: +SKIP

Fourier series generally converge slowly (and may not converge
pointwise). For example, if `f(x) = \cosh(x)`, a 10-term Fourier
series gives an `L^2` error corresponding to 2-digit accuracy::

    &gt;&gt;&gt; I = [-1, 1]
    &gt;&gt;&gt; cs = fourier(cosh, I, 9)
    &gt;&gt;&gt; g = lambda x: (cosh(x) - fourierval(cs, I, x))**2
    &gt;&gt;&gt; nprint(sqrt(quad(g, I)))
    0.00467963

:func:`~mpmath.fourier` uses numerical quadrature. For nonsmooth functions,
the accuracy (and speed) can be improved by including all singular
points in the interval specification::

    &gt;&gt;&gt; nprint(fourier(abs, [-1, 1], 0), 10)
    ([0.5000441648], [0.0])
    &gt;&gt;&gt; nprint(fourier(abs, [-1, 0, 1], 0), 10)
    ([0.5], [0.0])</pre> 
</div>
</div>
<a id="a3078545d930fb9ff80eaea5f15c9e32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3078545d930fb9ff80eaea5f15c9e32b">&#9670;&nbsp;</a></span>fourierval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.approximation.fourierval </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>series</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluates a Fourier series (in the format computed by
by :func:`~mpmath.fourier` for the given interval) at the point `x`.

The series should be a pair `(c, s)` where `c` is the
cosine series and `s` is the sine series. The two lists
need not have the same length.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
