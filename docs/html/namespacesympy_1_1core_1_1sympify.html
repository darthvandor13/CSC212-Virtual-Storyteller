<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.core.sympify Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1core_1_1sympify.html">sympify</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.core.sympify Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1sympify_1_1SympifyError.html">SympifyError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1core_1_1sympify_1_1CantSympify.html">CantSympify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad50c3e19509793ac85efead23e4bc2a6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1sympify.html#ad50c3e19509793ac85efead23e4bc2a6">sympify</a> (a, locals=None, convert_xor=True, strict=False, rational=False, <a class="el" href="classsympy_1_1core_1_1parameters_1_1evaluate.html">evaluate</a>=None)</td></tr>
<tr class="separator:ad50c3e19509793ac85efead23e4bc2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c83ea63b058fe8f3498e03effefe75"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1core_1_1sympify.html#a04c83ea63b058fe8f3498e03effefe75">kernS</a> (s)</td></tr>
<tr class="separator:a04c83ea63b058fe8f3498e03effefe75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">sympify -- convert objects SymPy internal format</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a04c83ea63b058fe8f3498e03effefe75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c83ea63b058fe8f3498e03effefe75">&#9670;&nbsp;</a></span>kernS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.sympify.kernS </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Use a hack to try keep autosimplification from distributing a
a number into an Add; this modification does not
prevent the 2-arg Mul from becoming an Add, however.

Examples
========

&gt;&gt;&gt; from sympy.core.sympify import kernS
&gt;&gt;&gt; from sympy.abc import x, y

The 2-arg Mul distributes a number (or minus sign) across the terms
of an expression, but kernS will prevent that:

&gt;&gt;&gt; 2*(x + y), -(x + 1)
(2*x + 2*y, -x - 1)
&gt;&gt;&gt; kernS('2*(x + y)')
2*(x + y)
&gt;&gt;&gt; kernS('-(x + 1)')
-(x + 1)

If use of the hack fails, the un-hacked string will be passed to sympify...
and you get what you get.

XXX This hack should not be necessary once issue 4596 has been resolved.
</pre> 
</div>
</div>
<a id="ad50c3e19509793ac85efead23e4bc2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50c3e19509793ac85efead23e4bc2a6">&#9670;&nbsp;</a></span>sympify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.core.sympify.sympify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>locals</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convert_xor</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rational</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>evaluate</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts an arbitrary expression to a type that can be used inside SymPy.

Explanation
===========

It will convert Python ints into instances of :class:`~.Integer`, floats
into instances of :class:`~.Float`, etc. It is also able to coerce
symbolic expressions which inherit from :class:`~.Basic`. This can be
useful in cooperation with SAGE.

.. warning::
    Note that this function uses ``eval``, and thus shouldn't be used on
    unsanitized input.

If the argument is already a type that SymPy understands, it will do
nothing but return that value. This can be used at the beginning of a
function to ensure you are working with the correct type.

Examples
========

&gt;&gt;&gt; from sympy import sympify

&gt;&gt;&gt; sympify(2).is_integer
True
&gt;&gt;&gt; sympify(2).is_real
True

&gt;&gt;&gt; sympify(2.0).is_real
True
&gt;&gt;&gt; sympify("2.0").is_real
True
&gt;&gt;&gt; sympify("2e-45").is_real
True

If the expression could not be converted, a SympifyError is raised.

&gt;&gt;&gt; sympify("x***2")
Traceback (most recent call last):
...
SympifyError: SympifyError: "could not parse 'x***2'"

When attempting to parse non-Python syntax using ``sympify``, it raises a
``SympifyError``:

&gt;&gt;&gt; sympify("2x+1")
Traceback (most recent call last):
...
SympifyError: Sympify of expression 'could not parse '2x+1'' failed

To parse non-Python syntax, use ``parse_expr`` from ``sympy.parsing.sympy_parser``.

&gt;&gt;&gt; from sympy.parsing.sympy_parser import parse_expr
&gt;&gt;&gt; parse_expr("2x+1", transformations="all")
2*x + 1

For more details about ``transformations``: see :func:`~sympy.parsing.sympy_parser.parse_expr`

Locals
------

The sympification happens with access to everything that is loaded
by ``from sympy import *``; anything used in a string that is not
defined by that import will be converted to a symbol. In the following,
the ``bitcount`` function is treated as a symbol and the ``O`` is
interpreted as the :class:`~.Order` object (used with series) and it raises
an error when used improperly:

&gt;&gt;&gt; s = 'bitcount(42)'
&gt;&gt;&gt; sympify(s)
bitcount(42)
&gt;&gt;&gt; sympify("O(x)")
O(x)
&gt;&gt;&gt; sympify("O + 1")
Traceback (most recent call last):
...
TypeError: unbound method...

In order to have ``bitcount`` be recognized it can be imported into a
namespace dictionary and passed as locals:

&gt;&gt;&gt; ns = {}
&gt;&gt;&gt; exec('from sympy.core.evalf import bitcount', ns)
&gt;&gt;&gt; sympify(s, locals=ns)
6

In order to have the ``O`` interpreted as a Symbol, identify it as such
in the namespace dictionary. This can be done in a variety of ways; all
three of the following are possibilities:

&gt;&gt;&gt; from sympy import Symbol
&gt;&gt;&gt; ns["O"] = Symbol("O")  # method 1
&gt;&gt;&gt; exec('from sympy.abc import O', ns)  # method 2
&gt;&gt;&gt; ns.update(dict(O=Symbol("O")))  # method 3
&gt;&gt;&gt; sympify("O + 1", locals=ns)
O + 1

If you want *all* single-letter and Greek-letter variables to be symbols
then you can use the clashing-symbols dictionaries that have been defined
there as private variables: ``_clash1`` (single-letter variables),
``_clash2`` (the multi-letter Greek names) or ``_clash`` (both single and
multi-letter names that are defined in ``abc``).

&gt;&gt;&gt; from sympy.abc import _clash1
&gt;&gt;&gt; set(_clash1)  # if this fails, see issue #23903
{'E', 'I', 'N', 'O', 'Q', 'S'}
&gt;&gt;&gt; sympify('I &amp; Q', _clash1)
I &amp; Q

Strict
------

If the option ``strict`` is set to ``True``, only the types for which an
explicit conversion has been defined are converted. In the other
cases, a SympifyError is raised.

&gt;&gt;&gt; print(sympify(None))
None
&gt;&gt;&gt; sympify(None, strict=True)
Traceback (most recent call last):
...
SympifyError: SympifyError: None

.. deprecated:: 1.6

   ``sympify(obj)`` automatically falls back to ``str(obj)`` when all
   other conversion methods fail, but this is deprecated. ``strict=True``
   will disable this deprecated behavior. See
   :ref:`deprecated-sympify-string-fallback`.

Evaluation
----------

If the option ``evaluate`` is set to ``False``, then arithmetic and
operators will be converted into their SymPy equivalents and the
``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will
be denested first. This is done via an AST transformation that replaces
operators with their SymPy equivalents, so if an operand redefines any
of those operations, the redefined operators will not be used. If
argument a is not a string, the mathematical expression is evaluated
before being passed to sympify, so adding ``evaluate=False`` will still
return the evaluated result of expression.

&gt;&gt;&gt; sympify('2**2 / 3 + 5')
19/3
&gt;&gt;&gt; sympify('2**2 / 3 + 5', evaluate=False)
2**2/3 + 5
&gt;&gt;&gt; sympify('4/2+7', evaluate=True)
9
&gt;&gt;&gt; sympify('4/2+7', evaluate=False)
4/2 + 7
&gt;&gt;&gt; sympify(4/2+7, evaluate=False)
9.00000000000000

Extending
---------

To extend ``sympify`` to convert custom objects (not derived from ``Basic``),
just define a ``_sympy_`` method to your class. You can do that even to
classes that you do not own by subclassing or adding the method at runtime.

&gt;&gt;&gt; from sympy import Matrix
&gt;&gt;&gt; class MyList1(object):
...     def __iter__(self):
...         yield 1
...         yield 2
...         return
...     def __getitem__(self, i): return list(self)[i]
...     def _sympy_(self): return Matrix(self)
&gt;&gt;&gt; sympify(MyList1())
Matrix([
[1],
[2]])

If you do not have control over the class definition you could also use the
``converter`` global dictionary. The key is the class and the value is a
function that takes a single argument and returns the desired SymPy
object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.

&gt;&gt;&gt; class MyList2(object):   # XXX Do not do this if you control the class!
...     def __iter__(self):  #     Use _sympy_!
...         yield 1
...         yield 2
...         return
...     def __getitem__(self, i): return list(self)[i]
&gt;&gt;&gt; from sympy.core.sympify import converter
&gt;&gt;&gt; converter[MyList2] = lambda x: Matrix(x)
&gt;&gt;&gt; sympify(MyList2())
Matrix([
[1],
[2]])

Notes
=====

The keywords ``rational`` and ``convert_xor`` are only used
when the input is a string.

convert_xor
-----------

&gt;&gt;&gt; sympify('x^y',convert_xor=True)
x**y
&gt;&gt;&gt; sympify('x^y',convert_xor=False)
x ^ y

rational
--------

&gt;&gt;&gt; sympify('0.1',rational=False)
0.1
&gt;&gt;&gt; sympify('0.1',rational=True)
1/10

Sometimes autosimplification during sympification results in expressions
that are very different in structure than what was entered. Until such
autosimplification is no longer done, the ``kernS`` function might be of
some use. In the example below you can see how an expression reduces to
$-1$ by autosimplification, but does not do so when ``kernS`` is used.

&gt;&gt;&gt; from sympy.core.sympify import kernS
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
-1
&gt;&gt;&gt; s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'
&gt;&gt;&gt; sympify(s)
-1
&gt;&gt;&gt; kernS(s)
-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1

Parameters
==========

a :
    - any object defined in SymPy
    - standard numeric Python types: ``int``, ``long``, ``float``, ``Decimal``
    - strings (like ``"0.09"``, ``"2e-19"`` or ``'sin(x)'``)
    - booleans, including ``None`` (will leave ``None`` unchanged)
    - dicts, lists, sets or tuples containing any of the above

convert_xor : bool, optional
    If true, treats ``^`` as exponentiation.
    If False, treats ``^`` as XOR itself.
    Used only when input is a string.

locals : any object defined in SymPy, optional
    In order to have strings be recognized it can be imported
    into a namespace dictionary and passed as locals.

strict : bool, optional
    If the option strict is set to ``True``, only the types for which
    an explicit conversion has been defined are converted. In the
    other cases, a SympifyError is raised.

rational : bool, optional
    If ``True``, converts floats into :class:`~.Rational`.
    If ``False``, it lets floats remain as it is.
    Used only when input is a string.

evaluate : bool, optional
    If False, then arithmetic and operators will be converted into
    their SymPy equivalents. If True the expression will be evaluated
    and the result will be returned.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
