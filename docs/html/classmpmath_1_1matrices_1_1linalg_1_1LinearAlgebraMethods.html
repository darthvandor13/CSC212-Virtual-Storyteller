<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.matrices.linalg.LinearAlgebraMethods Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1matrices.html">matrices</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1matrices_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html">LinearAlgebraMethods</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.matrices.linalg.LinearAlgebraMethods Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for mpmath.matrices.linalg.LinearAlgebraMethods:</div>
<div class="dyncontent">
<div class="center"><img src="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods__inherit__graph.png" border="0" usemap="#ampmath_8matrices_8linalg_8LinearAlgebraMethods_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mpmath.matrices.linalg.LinearAlgebraMethods:</div>
<div class="dyncontent">
<div class="center"><img src="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods__coll__graph.png" border="0" usemap="#ampmath_8matrices_8linalg_8LinearAlgebraMethods_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22f00f82683f3dcd420e74523e2fd40c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a22f00f82683f3dcd420e74523e2fd40c">LU_decomp</a> (ctx, A, overwrite=False, use_cache=True)</td></tr>
<tr class="separator:a22f00f82683f3dcd420e74523e2fd40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efa7ae8de9dd16652026de97f88ea0d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a3efa7ae8de9dd16652026de97f88ea0d">L_solve</a> (ctx, L, b, p=None)</td></tr>
<tr class="separator:a3efa7ae8de9dd16652026de97f88ea0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8b6ffec10a21649a158e7384e96f31"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#aef8b6ffec10a21649a158e7384e96f31">U_solve</a> (ctx, U, y)</td></tr>
<tr class="separator:aef8b6ffec10a21649a158e7384e96f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2b3ed2e231680bca6161436e96f829"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a9a2b3ed2e231680bca6161436e96f829">lu_solve</a> (ctx, A, b, **kwargs)</td></tr>
<tr class="separator:a9a2b3ed2e231680bca6161436e96f829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657265366d6a12d4b42ca0bd70ed873b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a657265366d6a12d4b42ca0bd70ed873b">improve_solution</a> (ctx, A, x, b, maxsteps=1)</td></tr>
<tr class="separator:a657265366d6a12d4b42ca0bd70ed873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add41645c522193b61fa7d2873d67405f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#add41645c522193b61fa7d2873d67405f">lu</a> (ctx, A)</td></tr>
<tr class="separator:add41645c522193b61fa7d2873d67405f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbecde3bc6a81b556555d75e5828fee0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#adbecde3bc6a81b556555d75e5828fee0">unitvector</a> (ctx, n, i)</td></tr>
<tr class="separator:adbecde3bc6a81b556555d75e5828fee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e81ecd3c7056aac911e38c05296bd4d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a6e81ecd3c7056aac911e38c05296bd4d">inverse</a> (ctx, A, **kwargs)</td></tr>
<tr class="separator:a6e81ecd3c7056aac911e38c05296bd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d9bfc34676134669ae2dde366345a1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#ae9d9bfc34676134669ae2dde366345a1">householder</a> (ctx, A)</td></tr>
<tr class="separator:ae9d9bfc34676134669ae2dde366345a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4999f93109c9091c12864115477eaaf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#af4999f93109c9091c12864115477eaaf">residual</a> (ctx, A, x, b, **kwargs)</td></tr>
<tr class="separator:af4999f93109c9091c12864115477eaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d23f6eeb6a8eb4a9083c6170348643"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a98d23f6eeb6a8eb4a9083c6170348643">qr_solve</a> (ctx, A, b, <a class="el" href="namespacempmath.html#ad629fef49b7946f34f9be435f72988d6">norm</a>=None, **kwargs)</td></tr>
<tr class="separator:a98d23f6eeb6a8eb4a9083c6170348643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645feffdbfcacb3dac7fda279bd3a408"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a645feffdbfcacb3dac7fda279bd3a408">cholesky</a> (ctx, A, tol=None)</td></tr>
<tr class="separator:a645feffdbfcacb3dac7fda279bd3a408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d9b5ebcd3c3e0c9a27af1a845cb88"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a859d9b5ebcd3c3e0c9a27af1a845cb88">cholesky_solve</a> (ctx, A, b, **kwargs)</td></tr>
<tr class="separator:a859d9b5ebcd3c3e0c9a27af1a845cb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8376dd68819f460ca8e2858ce8c7bfee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a8376dd68819f460ca8e2858ce8c7bfee">det</a> (ctx, A)</td></tr>
<tr class="separator:a8376dd68819f460ca8e2858ce8c7bfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9208c39ed5638271e3ea7e13aa1ce2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a9d9208c39ed5638271e3ea7e13aa1ce2">cond</a> (ctx, A, <a class="el" href="namespacempmath.html#ad629fef49b7946f34f9be435f72988d6">norm</a>=None)</td></tr>
<tr class="separator:a9d9208c39ed5638271e3ea7e13aa1ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1525c85de59511aebbd1e6c7ff8397e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a1525c85de59511aebbd1e6c7ff8397e9">lu_solve_mat</a> (ctx, a, b)</td></tr>
<tr class="separator:a1525c85de59511aebbd1e6c7ff8397e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52acbbf74a1d37489bdb9de92d04cbca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a52acbbf74a1d37489bdb9de92d04cbca">qr</a> (ctx, A, mode='full', edps=10)</td></tr>
<tr class="separator:a52acbbf74a1d37489bdb9de92d04cbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f00f82683f3dcd420e74523e2fd40c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a22f00f82683f3dcd420e74523e2fd40c">LU_decomp</a> (ctx, A, overwrite=False, use_cache=True)</td></tr>
<tr class="separator:a22f00f82683f3dcd420e74523e2fd40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efa7ae8de9dd16652026de97f88ea0d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a3efa7ae8de9dd16652026de97f88ea0d">L_solve</a> (ctx, L, b, p=None)</td></tr>
<tr class="separator:a3efa7ae8de9dd16652026de97f88ea0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8b6ffec10a21649a158e7384e96f31"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#aef8b6ffec10a21649a158e7384e96f31">U_solve</a> (ctx, U, y)</td></tr>
<tr class="separator:aef8b6ffec10a21649a158e7384e96f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2b3ed2e231680bca6161436e96f829"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a9a2b3ed2e231680bca6161436e96f829">lu_solve</a> (ctx, A, b, **kwargs)</td></tr>
<tr class="separator:a9a2b3ed2e231680bca6161436e96f829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657265366d6a12d4b42ca0bd70ed873b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a657265366d6a12d4b42ca0bd70ed873b">improve_solution</a> (ctx, A, x, b, maxsteps=1)</td></tr>
<tr class="separator:a657265366d6a12d4b42ca0bd70ed873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add41645c522193b61fa7d2873d67405f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#add41645c522193b61fa7d2873d67405f">lu</a> (ctx, A)</td></tr>
<tr class="separator:add41645c522193b61fa7d2873d67405f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbecde3bc6a81b556555d75e5828fee0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#adbecde3bc6a81b556555d75e5828fee0">unitvector</a> (ctx, n, i)</td></tr>
<tr class="separator:adbecde3bc6a81b556555d75e5828fee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e81ecd3c7056aac911e38c05296bd4d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a6e81ecd3c7056aac911e38c05296bd4d">inverse</a> (ctx, A, **kwargs)</td></tr>
<tr class="separator:a6e81ecd3c7056aac911e38c05296bd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d9bfc34676134669ae2dde366345a1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#ae9d9bfc34676134669ae2dde366345a1">householder</a> (ctx, A)</td></tr>
<tr class="separator:ae9d9bfc34676134669ae2dde366345a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4999f93109c9091c12864115477eaaf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#af4999f93109c9091c12864115477eaaf">residual</a> (ctx, A, x, b, **kwargs)</td></tr>
<tr class="separator:af4999f93109c9091c12864115477eaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d23f6eeb6a8eb4a9083c6170348643"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a98d23f6eeb6a8eb4a9083c6170348643">qr_solve</a> (ctx, A, b, <a class="el" href="namespacempmath.html#ad629fef49b7946f34f9be435f72988d6">norm</a>=None, **kwargs)</td></tr>
<tr class="separator:a98d23f6eeb6a8eb4a9083c6170348643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645feffdbfcacb3dac7fda279bd3a408"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a645feffdbfcacb3dac7fda279bd3a408">cholesky</a> (ctx, A, tol=None)</td></tr>
<tr class="separator:a645feffdbfcacb3dac7fda279bd3a408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d9b5ebcd3c3e0c9a27af1a845cb88"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a859d9b5ebcd3c3e0c9a27af1a845cb88">cholesky_solve</a> (ctx, A, b, **kwargs)</td></tr>
<tr class="separator:a859d9b5ebcd3c3e0c9a27af1a845cb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8376dd68819f460ca8e2858ce8c7bfee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a8376dd68819f460ca8e2858ce8c7bfee">det</a> (ctx, A)</td></tr>
<tr class="separator:a8376dd68819f460ca8e2858ce8c7bfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9208c39ed5638271e3ea7e13aa1ce2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a9d9208c39ed5638271e3ea7e13aa1ce2">cond</a> (ctx, A, <a class="el" href="namespacempmath.html#ad629fef49b7946f34f9be435f72988d6">norm</a>=None)</td></tr>
<tr class="separator:a9d9208c39ed5638271e3ea7e13aa1ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1525c85de59511aebbd1e6c7ff8397e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a1525c85de59511aebbd1e6c7ff8397e9">lu_solve_mat</a> (ctx, a, b)</td></tr>
<tr class="separator:a1525c85de59511aebbd1e6c7ff8397e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52acbbf74a1d37489bdb9de92d04cbca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1matrices_1_1linalg_1_1LinearAlgebraMethods.html#a52acbbf74a1d37489bdb9de92d04cbca">qr</a> (ctx, A, mode='full', edps=10)</td></tr>
<tr class="separator:a52acbbf74a1d37489bdb9de92d04cbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a645feffdbfcacb3dac7fda279bd3a408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645feffdbfcacb3dac7fda279bd3a408">&#9670;&nbsp;</a></span>cholesky() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.cholesky </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cholesky decomposition of a symmetric positive-definite matrix `A`.
Returns a lower triangular matrix `L` such that `A = L \times L^T`.
More generally, for a complex Hermitian positive-definite matrix,
a Cholesky decomposition satisfying `A = L \times L^H` is returned.

The Cholesky decomposition can be used to solve linear equation
systems twice as efficiently as LU decomposition, or to
test whether `A` is positive-definite.

The optional parameter ``tol`` determines the tolerance for
verifying positive-definiteness.

**Examples**

Cholesky decomposition of a positive-definite symmetric matrix::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 25; mp.pretty = True
    &gt;&gt;&gt; A = eye(3) + hilbert(3)
    &gt;&gt;&gt; nprint(A)
    [     2.0      0.5  0.333333]
    [     0.5  1.33333      0.25]
    [0.333333     0.25       1.2]
    &gt;&gt;&gt; L = cholesky(A)
    &gt;&gt;&gt; nprint(L)
    [ 1.41421      0.0      0.0]
    [0.353553  1.09924      0.0]
    [0.235702  0.15162  1.05899]
    &gt;&gt;&gt; chop(A - L*L.T)
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]

Cholesky decomposition of a Hermitian matrix::

    &gt;&gt;&gt; A = eye(3) + matrix([[0,0.25j,-0.5j],[-0.25j,0,0],[0.5j,0,0]])
    &gt;&gt;&gt; L = cholesky(A)
    &gt;&gt;&gt; nprint(L)
    [          1.0                0.0                0.0]
    [(0.0 - 0.25j)  (0.968246 + 0.0j)                0.0]
    [ (0.0 + 0.5j)  (0.129099 + 0.0j)  (0.856349 + 0.0j)]
    &gt;&gt;&gt; chop(A - L*L.H)
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]

Attempted Cholesky decomposition of a matrix that is not positive
definite::

    &gt;&gt;&gt; A = -eye(3) + hilbert(3)
    &gt;&gt;&gt; L = cholesky(A)
    Traceback (most recent call last):
      ...
    ValueError: matrix is not positive-definite

**References**

1. [Wikipedia]_ http://en.wikipedia.org/wiki/Cholesky_decomposition</pre> 
</div>
</div>
<a id="a645feffdbfcacb3dac7fda279bd3a408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645feffdbfcacb3dac7fda279bd3a408">&#9670;&nbsp;</a></span>cholesky() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.cholesky </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cholesky decomposition of a symmetric positive-definite matrix `A`.
Returns a lower triangular matrix `L` such that `A = L \times L^T`.
More generally, for a complex Hermitian positive-definite matrix,
a Cholesky decomposition satisfying `A = L \times L^H` is returned.

The Cholesky decomposition can be used to solve linear equation
systems twice as efficiently as LU decomposition, or to
test whether `A` is positive-definite.

The optional parameter ``tol`` determines the tolerance for
verifying positive-definiteness.

**Examples**

Cholesky decomposition of a positive-definite symmetric matrix::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 25; mp.pretty = True
    &gt;&gt;&gt; A = eye(3) + hilbert(3)
    &gt;&gt;&gt; nprint(A)
    [     2.0      0.5  0.333333]
    [     0.5  1.33333      0.25]
    [0.333333     0.25       1.2]
    &gt;&gt;&gt; L = cholesky(A)
    &gt;&gt;&gt; nprint(L)
    [ 1.41421      0.0      0.0]
    [0.353553  1.09924      0.0]
    [0.235702  0.15162  1.05899]
    &gt;&gt;&gt; chop(A - L*L.T)
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]

Cholesky decomposition of a Hermitian matrix::

    &gt;&gt;&gt; A = eye(3) + matrix([[0,0.25j,-0.5j],[-0.25j,0,0],[0.5j,0,0]])
    &gt;&gt;&gt; L = cholesky(A)
    &gt;&gt;&gt; nprint(L)
    [          1.0                0.0                0.0]
    [(0.0 - 0.25j)  (0.968246 + 0.0j)                0.0]
    [ (0.0 + 0.5j)  (0.129099 + 0.0j)  (0.856349 + 0.0j)]
    &gt;&gt;&gt; chop(A - L*L.H)
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]
    [0.0  0.0  0.0]

Attempted Cholesky decomposition of a matrix that is not positive
definite::

    &gt;&gt;&gt; A = -eye(3) + hilbert(3)
    &gt;&gt;&gt; L = cholesky(A)
    Traceback (most recent call last):
      ...
    ValueError: matrix is not positive-definite

**References**

1. [Wikipedia]_ http://en.wikipedia.org/wiki/Cholesky_decomposition</pre> 
</div>
</div>
<a id="a859d9b5ebcd3c3e0c9a27af1a845cb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d9b5ebcd3c3e0c9a27af1a845cb88">&#9670;&nbsp;</a></span>cholesky_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.cholesky_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ax = b =&gt; x

Solve a symmetric positive-definite linear equation system.
This is twice as efficient as lu_solve.

Typical use cases:
* A.T*A
* Hessian matrix
* differential equations
</pre> 
</div>
</div>
<a id="a859d9b5ebcd3c3e0c9a27af1a845cb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d9b5ebcd3c3e0c9a27af1a845cb88">&#9670;&nbsp;</a></span>cholesky_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.cholesky_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ax = b =&gt; x

Solve a symmetric positive-definite linear equation system.
This is twice as efficient as lu_solve.

Typical use cases:
* A.T*A
* Hessian matrix
* differential equations
</pre> 
</div>
</div>
<a id="a9d9208c39ed5638271e3ea7e13aa1ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9208c39ed5638271e3ea7e13aa1ce2">&#9670;&nbsp;</a></span>cond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.cond </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the condition number of a matrix using a specified matrix norm.

The condition number estimates the sensitivity of a matrix to errors.
Example: small input errors for ill-conditioned coefficient matrices
alter the solution of the system dramatically.

For ill-conditioned matrices it's recommended to use qr_solve() instead
of lu_solve(). This does not help with input errors however, it just avoids
to add additional errors.

Definition:    cond(A) = ||A|| * ||A**-1||
</pre> 
</div>
</div>
<a id="a9d9208c39ed5638271e3ea7e13aa1ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9208c39ed5638271e3ea7e13aa1ce2">&#9670;&nbsp;</a></span>cond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.cond </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the condition number of a matrix using a specified matrix norm.

The condition number estimates the sensitivity of a matrix to errors.
Example: small input errors for ill-conditioned coefficient matrices
alter the solution of the system dramatically.

For ill-conditioned matrices it's recommended to use qr_solve() instead
of lu_solve(). This does not help with input errors however, it just avoids
to add additional errors.

Definition:    cond(A) = ||A|| * ||A**-1||
</pre> 
</div>
</div>
<a id="a8376dd68819f460ca8e2858ce8c7bfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8376dd68819f460ca8e2858ce8c7bfee">&#9670;&nbsp;</a></span>det() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the determinant of a matrix.
</pre> 
</div>
</div>
<a id="a8376dd68819f460ca8e2858ce8c7bfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8376dd68819f460ca8e2858ce8c7bfee">&#9670;&nbsp;</a></span>det() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the determinant of a matrix.
</pre> 
</div>
</div>
<a id="ae9d9bfc34676134669ae2dde366345a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d9bfc34676134669ae2dde366345a1">&#9670;&nbsp;</a></span>householder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.householder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">(A|b) -&gt; H, p, x, res

(A|b) is the coefficient matrix with left hand side of an optionally
overdetermined linear equation system.
H and p contain all information about the transformation matrices.
x is the solution, res the residual.
</pre> 
</div>
</div>
<a id="ae9d9bfc34676134669ae2dde366345a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d9bfc34676134669ae2dde366345a1">&#9670;&nbsp;</a></span>householder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.householder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">(A|b) -&gt; H, p, x, res

(A|b) is the coefficient matrix with left hand side of an optionally
overdetermined linear equation system.
H and p contain all information about the transformation matrices.
x is the solution, res the residual.
</pre> 
</div>
</div>
<a id="a657265366d6a12d4b42ca0bd70ed873b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657265366d6a12d4b42ca0bd70ed873b">&#9670;&nbsp;</a></span>improve_solution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.improve_solution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsteps</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Improve a solution to a linear equation system iteratively.

This re-uses the LU decomposition and is thus cheap.
Usually 3 up to 4 iterations are giving the maximal improvement.
</pre> 
</div>
</div>
<a id="a657265366d6a12d4b42ca0bd70ed873b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657265366d6a12d4b42ca0bd70ed873b">&#9670;&nbsp;</a></span>improve_solution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.improve_solution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsteps</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Improve a solution to a linear equation system iteratively.

This re-uses the LU decomposition and is thus cheap.
Usually 3 up to 4 iterations are giving the maximal improvement.
</pre> 
</div>
</div>
<a id="a6e81ecd3c7056aac911e38c05296bd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e81ecd3c7056aac911e38c05296bd4d">&#9670;&nbsp;</a></span>inverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.inverse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the inverse of a matrix.

If you want to solve an equation system Ax = b, it's recommended to use
solve(A, b) instead, it's about 3 times more efficient.
</pre> 
</div>
</div>
<a id="a6e81ecd3c7056aac911e38c05296bd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e81ecd3c7056aac911e38c05296bd4d">&#9670;&nbsp;</a></span>inverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.inverse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the inverse of a matrix.

If you want to solve an equation system Ax = b, it's recommended to use
solve(A, b) instead, it's about 3 times more efficient.
</pre> 
</div>
</div>
<a id="a3efa7ae8de9dd16652026de97f88ea0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efa7ae8de9dd16652026de97f88ea0d">&#9670;&nbsp;</a></span>L_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.L_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the lower part of a LU factorized matrix for y.
</pre> 
</div>
</div>
<a id="a3efa7ae8de9dd16652026de97f88ea0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efa7ae8de9dd16652026de97f88ea0d">&#9670;&nbsp;</a></span>L_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.L_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the lower part of a LU factorized matrix for y.
</pre> 
</div>
</div>
<a id="add41645c522193b61fa7d2873d67405f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add41645c522193b61fa7d2873d67405f">&#9670;&nbsp;</a></span>lu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.lu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A -&gt; P, L, U

LU factorisation of a square matrix A. L is the lower, U the upper part.
P is the permutation matrix indicating the row swaps.

P*A = L*U

If you need efficiency, use the low-level method LU_decomp instead, it's
much more memory efficient.
</pre> 
</div>
</div>
<a id="add41645c522193b61fa7d2873d67405f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add41645c522193b61fa7d2873d67405f">&#9670;&nbsp;</a></span>lu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.lu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A -&gt; P, L, U

LU factorisation of a square matrix A. L is the lower, U the upper part.
P is the permutation matrix indicating the row swaps.

P*A = L*U

If you need efficiency, use the low-level method LU_decomp instead, it's
much more memory efficient.
</pre> 
</div>
</div>
<a id="a22f00f82683f3dcd420e74523e2fd40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f00f82683f3dcd420e74523e2fd40c">&#9670;&nbsp;</a></span>LU_decomp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.LU_decomp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_cache</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">LU-factorization of a n*n matrix using the Gauss algorithm.
Returns L and U in one matrix and the pivot indices.

Use overwrite to specify whether A will be overwritten with L and U.
</pre> 
</div>
</div>
<a id="a22f00f82683f3dcd420e74523e2fd40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f00f82683f3dcd420e74523e2fd40c">&#9670;&nbsp;</a></span>LU_decomp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.LU_decomp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_cache</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">LU-factorization of a n*n matrix using the Gauss algorithm.
Returns L and U in one matrix and the pivot indices.

Use overwrite to specify whether A will be overwritten with L and U.
</pre> 
</div>
</div>
<a id="a9a2b3ed2e231680bca6161436e96f829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2b3ed2e231680bca6161436e96f829">&#9670;&nbsp;</a></span>lu_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.lu_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ax = b =&gt; x

Solve a determined or overdetermined linear equations system.
Fast LU decomposition is used, which is less accurate than QR decomposition
(especially for overdetermined systems), but it's twice as efficient.
Use qr_solve if you want more precision or have to solve a very ill-
conditioned system.

If you specify real=True, it does not check for overdeterminded complex
systems.
</pre> 
</div>
</div>
<a id="a9a2b3ed2e231680bca6161436e96f829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2b3ed2e231680bca6161436e96f829">&#9670;&nbsp;</a></span>lu_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.lu_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ax = b =&gt; x

Solve a determined or overdetermined linear equations system.
Fast LU decomposition is used, which is less accurate than QR decomposition
(especially for overdetermined systems), but it's twice as efficient.
Use qr_solve if you want more precision or have to solve a very ill-
conditioned system.

If you specify real=True, it does not check for overdeterminded complex
systems.
</pre> 
</div>
</div>
<a id="a1525c85de59511aebbd1e6c7ff8397e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1525c85de59511aebbd1e6c7ff8397e9">&#9670;&nbsp;</a></span>lu_solve_mat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.lu_solve_mat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a * x = b  where a and b are matrices.</pre> 
</div>
</div>
<a id="a1525c85de59511aebbd1e6c7ff8397e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1525c85de59511aebbd1e6c7ff8397e9">&#9670;&nbsp;</a></span>lu_solve_mat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.lu_solve_mat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a * x = b  where a and b are matrices.</pre> 
</div>
</div>
<a id="a52acbbf74a1d37489bdb9de92d04cbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52acbbf74a1d37489bdb9de92d04cbca">&#9670;&nbsp;</a></span>qr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.qr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'full'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edps</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a QR factorization $A = QR$ where
A is an m x n matrix of real or complex numbers where m &gt;= n

mode has following meanings:
(1) mode = 'raw' returns two matrixes (A, tau) in the
    internal format used by LAPACK
(2) mode = 'skinny' returns the leading n columns of Q
    and n rows of R
(3) Any other value returns the leading m columns of Q
    and m rows of R

edps is the increase in mp precision used for calculations

**Examples**

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; mp.pretty = True
    &gt;&gt;&gt; A = matrix([[1, 2], [3, 4], [1, 1]])
    &gt;&gt;&gt; Q, R = qr(A)
    &gt;&gt;&gt; Q
    [-0.301511344577764   0.861640436855329   0.408248290463863]
    [-0.904534033733291  -0.123091490979333  -0.408248290463863]
    [-0.301511344577764  -0.492365963917331   0.816496580927726]
    &gt;&gt;&gt; R
    [-3.3166247903554  -4.52267016866645]
    [             0.0  0.738548945875996]
    [             0.0                0.0]
    &gt;&gt;&gt; Q * R
    [1.0  2.0]
    [3.0  4.0]
    [1.0  1.0]
    &gt;&gt;&gt; chop(Q.T * Q)
    [1.0  0.0  0.0]
    [0.0  1.0  0.0]
    [0.0  0.0  1.0]
    &gt;&gt;&gt; B = matrix([[1+0j, 2-3j], [3+j, 4+5j]])
    &gt;&gt;&gt; Q, R = qr(B)
    &gt;&gt;&gt; nprint(Q)
    [     (-0.301511 + 0.0j)   (0.0695795 - 0.95092j)]
    [(-0.904534 - 0.301511j)  (-0.115966 + 0.278318j)]
    &gt;&gt;&gt; nprint(R)
    [(-3.31662 + 0.0j)  (-5.72872 - 2.41209j)]
    [              0.0       (3.91965 + 0.0j)]
    &gt;&gt;&gt; Q * R
    [(1.0 + 0.0j)  (2.0 - 3.0j)]
    [(3.0 + 1.0j)  (4.0 + 5.0j)]
    &gt;&gt;&gt; chop(Q.T * Q.conjugate())
    [1.0  0.0]
    [0.0  1.0]</pre> 
</div>
</div>
<a id="a52acbbf74a1d37489bdb9de92d04cbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52acbbf74a1d37489bdb9de92d04cbca">&#9670;&nbsp;</a></span>qr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.qr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'full'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edps</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a QR factorization $A = QR$ where
A is an m x n matrix of real or complex numbers where m &gt;= n

mode has following meanings:
(1) mode = 'raw' returns two matrixes (A, tau) in the
    internal format used by LAPACK
(2) mode = 'skinny' returns the leading n columns of Q
    and n rows of R
(3) Any other value returns the leading m columns of Q
    and m rows of R

edps is the increase in mp precision used for calculations

**Examples**

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; mp.pretty = True
    &gt;&gt;&gt; A = matrix([[1, 2], [3, 4], [1, 1]])
    &gt;&gt;&gt; Q, R = qr(A)
    &gt;&gt;&gt; Q
    [-0.301511344577764   0.861640436855329   0.408248290463863]
    [-0.904534033733291  -0.123091490979333  -0.408248290463863]
    [-0.301511344577764  -0.492365963917331   0.816496580927726]
    &gt;&gt;&gt; R
    [-3.3166247903554  -4.52267016866645]
    [             0.0  0.738548945875996]
    [             0.0                0.0]
    &gt;&gt;&gt; Q * R
    [1.0  2.0]
    [3.0  4.0]
    [1.0  1.0]
    &gt;&gt;&gt; chop(Q.T * Q)
    [1.0  0.0  0.0]
    [0.0  1.0  0.0]
    [0.0  0.0  1.0]
    &gt;&gt;&gt; B = matrix([[1+0j, 2-3j], [3+j, 4+5j]])
    &gt;&gt;&gt; Q, R = qr(B)
    &gt;&gt;&gt; nprint(Q)
    [     (-0.301511 + 0.0j)   (0.0695795 - 0.95092j)]
    [(-0.904534 - 0.301511j)  (-0.115966 + 0.278318j)]
    &gt;&gt;&gt; nprint(R)
    [(-3.31662 + 0.0j)  (-5.72872 - 2.41209j)]
    [              0.0       (3.91965 + 0.0j)]
    &gt;&gt;&gt; Q * R
    [(1.0 + 0.0j)  (2.0 - 3.0j)]
    [(3.0 + 1.0j)  (4.0 + 5.0j)]
    &gt;&gt;&gt; chop(Q.T * Q.conjugate())
    [1.0  0.0]
    [0.0  1.0]</pre> 
</div>
</div>
<a id="a98d23f6eeb6a8eb4a9083c6170348643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d23f6eeb6a8eb4a9083c6170348643">&#9670;&nbsp;</a></span>qr_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.qr_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ax = b =&gt; x, ||Ax - b||

Solve a determined or overdetermined linear equations system and
calculate the norm of the residual (error).
QR decomposition using Householder factorization is applied, which gives very
accurate results even for ill-conditioned matrices. qr_solve is twice as
efficient.
</pre> 
</div>
</div>
<a id="a98d23f6eeb6a8eb4a9083c6170348643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d23f6eeb6a8eb4a9083c6170348643">&#9670;&nbsp;</a></span>qr_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.qr_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ax = b =&gt; x, ||Ax - b||

Solve a determined or overdetermined linear equations system and
calculate the norm of the residual (error).
QR decomposition using Householder factorization is applied, which gives very
accurate results even for ill-conditioned matrices. qr_solve is twice as
efficient.
</pre> 
</div>
</div>
<a id="af4999f93109c9091c12864115477eaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4999f93109c9091c12864115477eaaf">&#9670;&nbsp;</a></span>residual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.residual </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the residual of a solution to a linear equation system.

r = A*x - b for A*x = b
</pre> 
</div>
</div>
<a id="af4999f93109c9091c12864115477eaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4999f93109c9091c12864115477eaaf">&#9670;&nbsp;</a></span>residual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.residual </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the residual of a solution to a linear equation system.

r = A*x - b for A*x = b
</pre> 
</div>
</div>
<a id="aef8b6ffec10a21649a158e7384e96f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8b6ffec10a21649a158e7384e96f31">&#9670;&nbsp;</a></span>U_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.U_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the upper part of a LU factorized matrix for x.
</pre> 
</div>
</div>
<a id="aef8b6ffec10a21649a158e7384e96f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8b6ffec10a21649a158e7384e96f31">&#9670;&nbsp;</a></span>U_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.U_solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the upper part of a LU factorized matrix for x.
</pre> 
</div>
</div>
<a id="adbecde3bc6a81b556555d75e5828fee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbecde3bc6a81b556555d75e5828fee0">&#9670;&nbsp;</a></span>unitvector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.unitvector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the i-th n-dimensional unit vector.
</pre> 
</div>
</div>
<a id="adbecde3bc6a81b556555d75e5828fee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbecde3bc6a81b556555d75e5828fee0">&#9670;&nbsp;</a></span>unitvector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.matrices.linalg.LinearAlgebraMethods.unitvector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the i-th n-dimensional unit vector.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/mpmath/matrices/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2mpmath_2matrices_2linalg_8py.html">linalg.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
