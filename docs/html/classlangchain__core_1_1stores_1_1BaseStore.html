<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: langchain_core.stores.BaseStore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelangchain__core.html">langchain_core</a></li><li class="navelem"><a class="el" href="namespacelangchain__core_1_1stores.html">stores</a></li><li class="navelem"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html">BaseStore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlangchain__core_1_1stores_1_1BaseStore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">langchain_core.stores.BaseStore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for langchain_core.stores.BaseStore:</div>
<div class="dyncontent">
<div class="center"><img src="classlangchain__core_1_1stores_1_1BaseStore__inherit__graph.png" border="0" usemap="#alangchain__core_8stores_8BaseStore_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for langchain_core.stores.BaseStore:</div>
<div class="dyncontent">
<div class="center"><img src="classlangchain__core_1_1stores_1_1BaseStore__coll__graph.png" border="0" usemap="#alangchain__core_8stores_8BaseStore_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c6b80dbd55b85de4eb2f85eb3dc277d"><td class="memItemLeft" align="right" valign="top">list[Optional[<a class="el" href="namespacelangchain__core_1_1stores.html#aed8cce5ec036c5243453c8a45c0dfaf9">V</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html#a0c6b80dbd55b85de4eb2f85eb3dc277d">mget</a> (self, Sequence[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>] keys)</td></tr>
<tr class="separator:a0c6b80dbd55b85de4eb2f85eb3dc277d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd50b307c0033bd6b803859e0dfbc40"><td class="memItemLeft" align="right" valign="top">list[Optional[<a class="el" href="namespacelangchain__core_1_1stores.html#aed8cce5ec036c5243453c8a45c0dfaf9">V</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html#a9dd50b307c0033bd6b803859e0dfbc40">amget</a> (self, Sequence[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>] keys)</td></tr>
<tr class="separator:a9dd50b307c0033bd6b803859e0dfbc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6abe3c8cab741c3b517c45686399c0"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html#a2b6abe3c8cab741c3b517c45686399c0">mset</a> (self, Sequence[tuple[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>, <a class="el" href="namespacelangchain__core_1_1stores.html#aed8cce5ec036c5243453c8a45c0dfaf9">V</a>]] key_value_pairs)</td></tr>
<tr class="separator:a2b6abe3c8cab741c3b517c45686399c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2961b1b0494c9b3bef6d0119165a1870"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html#a2961b1b0494c9b3bef6d0119165a1870">amset</a> (self, Sequence[tuple[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>, <a class="el" href="namespacelangchain__core_1_1stores.html#aed8cce5ec036c5243453c8a45c0dfaf9">V</a>]] key_value_pairs)</td></tr>
<tr class="separator:a2961b1b0494c9b3bef6d0119165a1870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955b7191dafc63e8f7632e9e4d44e813"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html#a955b7191dafc63e8f7632e9e4d44e813">mdelete</a> (self, Sequence[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>] keys)</td></tr>
<tr class="separator:a955b7191dafc63e8f7632e9e4d44e813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f8d3ecf2e2d726ce7dcbc97b3cc6fa"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html#a87f8d3ecf2e2d726ce7dcbc97b3cc6fa">amdelete</a> (self, Sequence[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>] keys)</td></tr>
<tr class="separator:a87f8d3ecf2e2d726ce7dcbc97b3cc6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77955f06948902a0153f6fd6dd3e080b"><td class="memItemLeft" align="right" valign="top">Union[Iterator[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>], Iterator[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html#a77955f06948902a0153f6fd6dd3e080b">yield_keys</a> (self, *Optional[str] prefix=None)</td></tr>
<tr class="separator:a77955f06948902a0153f6fd6dd3e080b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2c3f0806fa07bc484308639f3d0062"><td class="memItemLeft" align="right" valign="top">Union[AsyncIterator[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>], AsyncIterator[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlangchain__core_1_1stores_1_1BaseStore.html#a8d2c3f0806fa07bc484308639f3d0062">ayield_keys</a> (self, *Optional[str] prefix=None)</td></tr>
<tr class="separator:a8d2c3f0806fa07bc484308639f3d0062"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Abstract interface for a key-value store.

This is an interface that's meant to abstract away the details of
different key-value stores. It provides a simple interface for
getting, setting, and deleting key-value pairs.

The basic methods are `mget`, `mset`, and `mdelete` for getting,
setting, and deleting multiple key-value pairs at once. The `yield_keys`
method is used to iterate over keys that match a given prefix.

The async versions of these methods are also provided, which are
meant to be used in async contexts. The async methods are named with
an `a` prefix, e.g., `amget`, `amset`, `amdelete`, and `ayield_keys`.

By default, the `amget`, `amset`, `amdelete`, and `ayield_keys` methods
are implemented using the synchronous methods. If the store can natively
support async  operations, it should override these methods.

By design the methods only accept batches of keys and values, and not
single keys or values. This is done to force user code to work with batches
which will usually be more efficient by saving on round trips to the store.

Examples:

    .. code-block:: python

        from langchain.storage import BaseStore

        class MyInMemoryStore(BaseStore[str, int]):

            def __init__(self):
                self.store = {}

            def mget(self, keys):
                return [self.store.get(key) for key in keys]

            def mset(self, key_value_pairs):
                for key, value in key_value_pairs:
                    self.store[key] = value

            def mdelete(self, keys):
                for key in keys:
                    if key in self.store:
                        del self.store[key]

            def yield_keys(self, prefix=None):
                if prefix is None:
                    yield from self.store.keys()
                else:
                    for key in self.store.keys():
                        if key.startswith(prefix):
                            yield key
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a87f8d3ecf2e2d726ce7dcbc97b3cc6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f8d3ecf2e2d726ce7dcbc97b3cc6fa">&#9670;&nbsp;</a></span>amdelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None langchain_core.stores.BaseStore.amdelete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>]&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async delete the given keys and their associated values.

Args:
    keys (Sequence[K]): A sequence of keys to delete.
</pre> 
<p>Reimplemented in <a class="el" href="classlangchain_1_1storage_1_1encoder__backed_1_1EncoderBackedStore.html#a00f9afe178e9080183782282b2b1faab">langchain.storage.encoder_backed.EncoderBackedStore</a>.</p>

</div>
</div>
<a id="a9dd50b307c0033bd6b803859e0dfbc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd50b307c0033bd6b803859e0dfbc40">&#9670;&nbsp;</a></span>amget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[Optional[<a class="el" href="namespacelangchain__core_1_1stores.html#aed8cce5ec036c5243453c8a45c0dfaf9">V</a>]] langchain_core.stores.BaseStore.amget </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>]&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async get the values associated with the given keys.

Args:
    keys (Sequence[K]): A sequence of keys.

Returns:
    A sequence of optional values associated with the keys.
    If a key is not found, the corresponding value will be None.
</pre> 
<p>Reimplemented in <a class="el" href="classlangchain_1_1storage_1_1encoder__backed_1_1EncoderBackedStore.html#ae6b28c0f99e5c4f0d9035b91e0965a96">langchain.storage.encoder_backed.EncoderBackedStore</a>.</p>

</div>
</div>
<a id="a2961b1b0494c9b3bef6d0119165a1870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2961b1b0494c9b3bef6d0119165a1870">&#9670;&nbsp;</a></span>amset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None langchain_core.stores.BaseStore.amset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[tuple[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>, <a class="el" href="namespacelangchain__core_1_1stores.html#aed8cce5ec036c5243453c8a45c0dfaf9">V</a>]]&#160;</td>
          <td class="paramname"><em>key_value_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async set the values for the given keys.

Args:
    key_value_pairs (Sequence[Tuple[K, V]]): A sequence of key-value pairs.
</pre> 
</div>
</div>
<a id="a8d2c3f0806fa07bc484308639f3d0062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2c3f0806fa07bc484308639f3d0062">&#9670;&nbsp;</a></span>ayield_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[AsyncIterator[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>], AsyncIterator[str]] langchain_core.stores.BaseStore.ayield_keys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[str] &#160;</td>
          <td class="paramname"><em>prefix</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Async get an iterator over keys that match the given prefix.

Args:
    prefix (str): The prefix to match.

Yields:
    Iterator[K | str]: An iterator over keys that match the given prefix.
    This method is allowed to return an iterator over either K or str
    depending on what makes more sense for the given store.
</pre> 
<p>Reimplemented in <a class="el" href="classlangchain_1_1storage_1_1encoder__backed_1_1EncoderBackedStore.html#ad6145a047e84be9ec3ee31bfd617817f">langchain.storage.encoder_backed.EncoderBackedStore</a>.</p>

</div>
</div>
<a id="a955b7191dafc63e8f7632e9e4d44e813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955b7191dafc63e8f7632e9e4d44e813">&#9670;&nbsp;</a></span>mdelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None langchain_core.stores.BaseStore.mdelete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>]&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Delete the given keys and their associated values.

Args:
    keys (Sequence[K]): A sequence of keys to delete.
</pre> 
<p>Reimplemented in <a class="el" href="classlangchain_1_1storage_1_1encoder__backed_1_1EncoderBackedStore.html#ac57a6098a76acbd1e09d38e2e5391c40">langchain.storage.encoder_backed.EncoderBackedStore</a>.</p>

</div>
</div>
<a id="a0c6b80dbd55b85de4eb2f85eb3dc277d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6b80dbd55b85de4eb2f85eb3dc277d">&#9670;&nbsp;</a></span>mget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[Optional[<a class="el" href="namespacelangchain__core_1_1stores.html#aed8cce5ec036c5243453c8a45c0dfaf9">V</a>]] langchain_core.stores.BaseStore.mget </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>]&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Abstract interface for a key-value store.

This is an interface that's meant to abstract away the details of
different key-value stores. It provides a simple interface for
getting, setting, and deleting key-value pairs.

The basic methods are `mget`, `mset`, and `mdelete` for getting,
setting, and deleting multiple key-value pairs at once. The `yield_keys`
method is used to iterate over keys that match a given prefix.

The async versions of these methods are also provided, which are
meant to be used in async contexts. The async methods are named with
an `a` prefix, e.g., `amget`, `amset`, `amdelete`, and `ayield_keys`.

By default, the `amget`, `amset`, `amdelete`, and `ayield_keys` methods
are implemented using the synchronous methods. If the store can natively
support async  operations, it should override these methods.

By design the methods only accept batches of keys and values, and not
single keys or values. This is done to force user code to work with batches
which will usually be more efficient by saving on round trips to the store.

Examples:

    .. code-block:: python

        from langchain.storage import BaseStore

        class MyInMemoryStore(BaseStore[str, int]):

            def __init__(self):
                self.store = {}

            def mget(self, keys):
                return [self.store.get(key) for key in keys]

            def mset(self, key_value_pairs):
                for key, value in key_value_pairs:
                    self.store[key] = value

            def mdelete(self, keys):
                for key in keys:
                    if key in self.store:
                        del self.store[key]

            def yield_keys(self, prefix=None):
                if prefix is None:
                    yield from self.store.keys()
                else:
                    for key in self.store.keys():
                        if key.startswith(prefix):
                            yield key
</pre><pre class="fragment">Get the values associated with the given keys.

Args:
    keys (Sequence[K]): A sequence of keys.

Returns:
    A sequence of optional values associated with the keys.
    If a key is not found, the corresponding value will be None.
</pre> 
<p>Reimplemented in <a class="el" href="classlangchain_1_1storage_1_1encoder__backed_1_1EncoderBackedStore.html#a98fabf11e5a7e2e6c787e28df6aad67e">langchain.storage.encoder_backed.EncoderBackedStore</a>.</p>

</div>
</div>
<a id="a2b6abe3c8cab741c3b517c45686399c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6abe3c8cab741c3b517c45686399c0">&#9670;&nbsp;</a></span>mset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None langchain_core.stores.BaseStore.mset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[tuple[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>, <a class="el" href="namespacelangchain__core_1_1stores.html#aed8cce5ec036c5243453c8a45c0dfaf9">V</a>]]&#160;</td>
          <td class="paramname"><em>key_value_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the values for the given keys.

Args:
    key_value_pairs (Sequence[Tuple[K, V]]): A sequence of key-value pairs.
</pre> 
</div>
</div>
<a id="a77955f06948902a0153f6fd6dd3e080b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77955f06948902a0153f6fd6dd3e080b">&#9670;&nbsp;</a></span>yield_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[Iterator[<a class="el" href="namespacelangchain__core_1_1stores.html#a696121203aaf1788202cbfd068db538d">K</a>], Iterator[str]] langchain_core.stores.BaseStore.yield_keys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[str] &#160;</td>
          <td class="paramname"><em>prefix</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get an iterator over keys that match the given prefix.

Args:
    prefix (str): The prefix to match.

Yields:
    Iterator[K | str]: An iterator over keys that match the given prefix.
    This method is allowed to return an iterator over either K or str
    depending on what makes more sense for the given store.
</pre> 
<p>Reimplemented in <a class="el" href="classlangchain_1_1storage_1_1encoder__backed_1_1EncoderBackedStore.html#afc5a3d925f4803718e2164a9aff654b8">langchain.storage.encoder_backed.EncoderBackedStore</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>py3_env/lib/python3.10/site-packages/langchain_core/<a class="el" href="stores_8py.html">stores.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
