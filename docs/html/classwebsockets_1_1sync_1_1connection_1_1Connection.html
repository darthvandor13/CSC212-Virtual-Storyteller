<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: websockets.sync.connection.Connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewebsockets.html">websockets</a></li><li class="navelem"><a class="el" href="namespacewebsockets_1_1sync.html">sync</a></li><li class="navelem"><a class="el" href="namespacewebsockets_1_1sync_1_1connection.html">connection</a></li><li class="navelem"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html">Connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classwebsockets_1_1sync_1_1connection_1_1Connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">websockets.sync.connection.Connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for websockets.sync.connection.Connection:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsockets_1_1sync_1_1connection_1_1Connection__inherit__graph.png" border="0" usemap="#awebsockets_8sync_8connection_8Connection_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for websockets.sync.connection.Connection:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsockets_1_1sync_1_1connection_1_1Connection__coll__graph.png" border="0" usemap="#awebsockets_8sync_8connection_8Connection_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4b1344ff43d7260084e97021dc44e76"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ae4b1344ff43d7260084e97021dc44e76">__init__</a> (self, socket.socket <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a72160e7c873b205c9d6a1af65d5f1b21">socket</a>, <a class="el" href="classwebsockets_1_1protocol_1_1Protocol.html">Protocol</a> <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a6ef614d010a7321eb0955df984611c25">protocol</a>, *float|None <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a4a87feece00b082f049255dc7acc4817">ping_interval</a>=20, float|None <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a2b86af435eb4eb0db563fc8b3782333a">ping_timeout</a>=20, float|None <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ad5e03724949e1dcb950b2c90d4c04122">close_timeout</a>=10, int|None|tuple[int|None, int|None] <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a9dfa441793993f0458166c83333f7613">max_queue</a>=16)</td></tr>
<tr class="separator:ae4b1344ff43d7260084e97021dc44e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e663d0197e3b169737cf3b683c4159"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a55e663d0197e3b169737cf3b683c4159">local_address</a> (self)</td></tr>
<tr class="separator:a55e663d0197e3b169737cf3b683c4159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca7075f15a3b7102bd69996744a9901"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a2ca7075f15a3b7102bd69996744a9901">remote_address</a> (self)</td></tr>
<tr class="separator:a2ca7075f15a3b7102bd69996744a9901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09995a14d1323c66255f3b1f6a71a422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1protocol_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a09995a14d1323c66255f3b1f6a71a422">state</a> (self)</td></tr>
<tr class="separator:a09995a14d1323c66255f3b1f6a71a422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1cb462cd26489527287e5db5447204"><td class="memItemLeft" align="right" valign="top">Subprotocol|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a1b1cb462cd26489527287e5db5447204">subprotocol</a> (self)</td></tr>
<tr class="separator:a1b1cb462cd26489527287e5db5447204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df1ef554d878b5f8192513c407e467b"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a1df1ef554d878b5f8192513c407e467b">close_code</a> (self)</td></tr>
<tr class="separator:a1df1ef554d878b5f8192513c407e467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45221d5e869454d7b8e1f2480882b191"><td class="memItemLeft" align="right" valign="top">str|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a45221d5e869454d7b8e1f2480882b191">close_reason</a> (self)</td></tr>
<tr class="separator:a45221d5e869454d7b8e1f2480882b191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a98625b59d71fbfc90b1801f3d018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html">Connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ab63a98625b59d71fbfc90b1801f3d018">__enter__</a> (self)</td></tr>
<tr class="separator:ab63a98625b59d71fbfc90b1801f3d018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5777ffbb322221ec9b7a22c3817f2bc7"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a5777ffbb322221ec9b7a22c3817f2bc7">__exit__</a> (self, type[BaseException]|None exc_type, BaseException|None exc_value, TracebackType|None traceback)</td></tr>
<tr class="separator:a5777ffbb322221ec9b7a22c3817f2bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f39e4010d1d39d772d5fd07531cb72"><td class="memItemLeft" align="right" valign="top">Iterator[Data]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a34f39e4010d1d39d772d5fd07531cb72">__iter__</a> (self)</td></tr>
<tr class="separator:a34f39e4010d1d39d772d5fd07531cb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582485bd8411901af88e56b6c5ca5136"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a582485bd8411901af88e56b6c5ca5136">recv</a> (self, float|None timeout, Literal[True] decode)</td></tr>
<tr class="separator:a582485bd8411901af88e56b6c5ca5136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7ade02d59e02b43ff5dd91205fcbab"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#afd7ade02d59e02b43ff5dd91205fcbab">recv</a> (self, float|None timeout, Literal[False] decode)</td></tr>
<tr class="separator:afd7ade02d59e02b43ff5dd91205fcbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c4fa47183b607378be5a21a1cf24e0"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a96c4fa47183b607378be5a21a1cf24e0">recv</a> (self, float|None timeout=None, *Literal[True] decode)</td></tr>
<tr class="separator:a96c4fa47183b607378be5a21a1cf24e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b621409ed11e6f146f0752f4afa127"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#aa3b621409ed11e6f146f0752f4afa127">recv</a> (self, float|None timeout=None, *Literal[False] decode)</td></tr>
<tr class="separator:aa3b621409ed11e6f146f0752f4afa127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9490dd2a29a262ede84ee7e84cd68767"><td class="memItemLeft" align="right" valign="top">Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a9490dd2a29a262ede84ee7e84cd68767">recv</a> (self, float|None timeout=None, bool|None decode=None)</td></tr>
<tr class="separator:a9490dd2a29a262ede84ee7e84cd68767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9490dd2a29a262ede84ee7e84cd68767"><td class="memItemLeft" align="right" valign="top">Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a9490dd2a29a262ede84ee7e84cd68767">recv</a> (self, float|None timeout=None, bool|None decode=None)</td></tr>
<tr class="separator:a9490dd2a29a262ede84ee7e84cd68767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4e825fb0edbe25a4f61fff9e010846"><td class="memItemLeft" align="right" valign="top">Iterator[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a3b4e825fb0edbe25a4f61fff9e010846">recv_streaming</a> (self, Literal[True] decode)</td></tr>
<tr class="separator:a3b4e825fb0edbe25a4f61fff9e010846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa68026b93af97b8491dd19ccc45ac4"><td class="memItemLeft" align="right" valign="top">Iterator[bytes]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a7aa68026b93af97b8491dd19ccc45ac4">recv_streaming</a> (self, Literal[False] decode)</td></tr>
<tr class="separator:a7aa68026b93af97b8491dd19ccc45ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda7ca38729856f446d3e480cd00504e"><td class="memItemLeft" align="right" valign="top">Iterator[Data]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#abda7ca38729856f446d3e480cd00504e">recv_streaming</a> (self, bool|None decode=None)</td></tr>
<tr class="separator:abda7ca38729856f446d3e480cd00504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda7ca38729856f446d3e480cd00504e"><td class="memItemLeft" align="right" valign="top">Iterator[Data]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#abda7ca38729856f446d3e480cd00504e">recv_streaming</a> (self, bool|None decode=None)</td></tr>
<tr class="separator:abda7ca38729856f446d3e480cd00504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91738460a8aa9ed448ad81512b551363"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a91738460a8aa9ed448ad81512b551363">send</a> (self, Data|Iterable[Data] message, bool|None text=None)</td></tr>
<tr class="separator:a91738460a8aa9ed448ad81512b551363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fecae016abc3a7889cb18304560e3a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#aa5fecae016abc3a7889cb18304560e3a">close</a> (self, int code=<a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#af4e8be37b7ef43e1d1b3a8d105f0ed48">CloseCode.NORMAL_CLOSURE</a>, str reason=&quot;&quot;)</td></tr>
<tr class="separator:aa5fecae016abc3a7889cb18304560e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3af730d9097b6d24ba233c4331f9208"><td class="memItemLeft" align="right" valign="top">threading.Event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ae3af730d9097b6d24ba233c4331f9208">ping</a> (self, Data|None data=None, bool ack_on_close=False)</td></tr>
<tr class="separator:ae3af730d9097b6d24ba233c4331f9208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a476d3f0a7aeab0526b9e70f5934ba6"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a5a476d3f0a7aeab0526b9e70f5934ba6">pong</a> (self, Data data=b&quot;&quot;)</td></tr>
<tr class="separator:a5a476d3f0a7aeab0526b9e70f5934ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49b6d83776d20bebe6a41751f5745de"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#aa49b6d83776d20bebe6a41751f5745de">process_event</a> (self, Event event)</td></tr>
<tr class="separator:aa49b6d83776d20bebe6a41751f5745de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807391748e57b80d545d3efe772ed636"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a807391748e57b80d545d3efe772ed636">acknowledge_pings</a> (self, bytes data)</td></tr>
<tr class="separator:a807391748e57b80d545d3efe772ed636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdedea462c4bfc23f10eb5c5e85cf9e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a5fdedea462c4bfc23f10eb5c5e85cf9e">acknowledge_pending_pings</a> (self)</td></tr>
<tr class="separator:a5fdedea462c4bfc23f10eb5c5e85cf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76f819ff1cf11673fcf7a09a986a67f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#aa76f819ff1cf11673fcf7a09a986a67f">keepalive</a> (self)</td></tr>
<tr class="separator:aa76f819ff1cf11673fcf7a09a986a67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881ab972322231b4b09e13be5245d7ac"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a881ab972322231b4b09e13be5245d7ac">start_keepalive</a> (self)</td></tr>
<tr class="separator:a881ab972322231b4b09e13be5245d7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b388f18de71dc4971d20a9d6932d03f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a8b388f18de71dc4971d20a9d6932d03f">recv_events</a> (self)</td></tr>
<tr class="separator:a8b388f18de71dc4971d20a9d6932d03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90923b70eab8b6eeab6c750057fe59f6"><td class="memItemLeft" align="right" valign="top">Iterator[None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a90923b70eab8b6eeab6c750057fe59f6">send_context</a> (self, *<a class="el" href="classwebsockets_1_1protocol_1_1State.html">State</a> expected_state=OPEN)</td></tr>
<tr class="separator:a90923b70eab8b6eeab6c750057fe59f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7931bbe218a2af728ad040c30d4d41ed"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a7931bbe218a2af728ad040c30d4d41ed">send_data</a> (self)</td></tr>
<tr class="separator:a7931bbe218a2af728ad040c30d4d41ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8a2883e2a5ca74828082e4cd39e4a1"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a2f8a2883e2a5ca74828082e4cd39e4a1">set_recv_exc</a> (self, BaseException|None exc)</td></tr>
<tr class="separator:a2f8a2883e2a5ca74828082e4cd39e4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29299a6035bb6d3f3277f25ac02b9501"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a29299a6035bb6d3f3277f25ac02b9501">close_socket</a> (self)</td></tr>
<tr class="separator:a29299a6035bb6d3f3277f25ac02b9501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1344ff43d7260084e97021dc44e76"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ae4b1344ff43d7260084e97021dc44e76">__init__</a> (self, socket.socket <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a72160e7c873b205c9d6a1af65d5f1b21">socket</a>, <a class="el" href="classwebsockets_1_1protocol_1_1Protocol.html">Protocol</a> <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a6ef614d010a7321eb0955df984611c25">protocol</a>, *float|None <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a4a87feece00b082f049255dc7acc4817">ping_interval</a>=20, float|None <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a2b86af435eb4eb0db563fc8b3782333a">ping_timeout</a>=20, float|None <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ad5e03724949e1dcb950b2c90d4c04122">close_timeout</a>=10, int|None|tuple[int|None, int|None] <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a9dfa441793993f0458166c83333f7613">max_queue</a>=16)</td></tr>
<tr class="separator:ae4b1344ff43d7260084e97021dc44e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e663d0197e3b169737cf3b683c4159"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a55e663d0197e3b169737cf3b683c4159">local_address</a> (self)</td></tr>
<tr class="separator:a55e663d0197e3b169737cf3b683c4159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca7075f15a3b7102bd69996744a9901"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a2ca7075f15a3b7102bd69996744a9901">remote_address</a> (self)</td></tr>
<tr class="separator:a2ca7075f15a3b7102bd69996744a9901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09995a14d1323c66255f3b1f6a71a422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1protocol_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a09995a14d1323c66255f3b1f6a71a422">state</a> (self)</td></tr>
<tr class="separator:a09995a14d1323c66255f3b1f6a71a422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1cb462cd26489527287e5db5447204"><td class="memItemLeft" align="right" valign="top">Subprotocol|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a1b1cb462cd26489527287e5db5447204">subprotocol</a> (self)</td></tr>
<tr class="separator:a1b1cb462cd26489527287e5db5447204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df1ef554d878b5f8192513c407e467b"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a1df1ef554d878b5f8192513c407e467b">close_code</a> (self)</td></tr>
<tr class="separator:a1df1ef554d878b5f8192513c407e467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45221d5e869454d7b8e1f2480882b191"><td class="memItemLeft" align="right" valign="top">str|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a45221d5e869454d7b8e1f2480882b191">close_reason</a> (self)</td></tr>
<tr class="separator:a45221d5e869454d7b8e1f2480882b191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a98625b59d71fbfc90b1801f3d018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html">Connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ab63a98625b59d71fbfc90b1801f3d018">__enter__</a> (self)</td></tr>
<tr class="separator:ab63a98625b59d71fbfc90b1801f3d018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5777ffbb322221ec9b7a22c3817f2bc7"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a5777ffbb322221ec9b7a22c3817f2bc7">__exit__</a> (self, type[BaseException]|None exc_type, BaseException|None exc_value, TracebackType|None traceback)</td></tr>
<tr class="separator:a5777ffbb322221ec9b7a22c3817f2bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f39e4010d1d39d772d5fd07531cb72"><td class="memItemLeft" align="right" valign="top">Iterator[Data]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a34f39e4010d1d39d772d5fd07531cb72">__iter__</a> (self)</td></tr>
<tr class="separator:a34f39e4010d1d39d772d5fd07531cb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582485bd8411901af88e56b6c5ca5136"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a582485bd8411901af88e56b6c5ca5136">recv</a> (self, float|None timeout, Literal[True] decode)</td></tr>
<tr class="separator:a582485bd8411901af88e56b6c5ca5136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7ade02d59e02b43ff5dd91205fcbab"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#afd7ade02d59e02b43ff5dd91205fcbab">recv</a> (self, float|None timeout, Literal[False] decode)</td></tr>
<tr class="separator:afd7ade02d59e02b43ff5dd91205fcbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c4fa47183b607378be5a21a1cf24e0"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a96c4fa47183b607378be5a21a1cf24e0">recv</a> (self, float|None timeout=None, *Literal[True] decode)</td></tr>
<tr class="separator:a96c4fa47183b607378be5a21a1cf24e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b621409ed11e6f146f0752f4afa127"><td class="memItemLeft" align="right" valign="top">bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#aa3b621409ed11e6f146f0752f4afa127">recv</a> (self, float|None timeout=None, *Literal[False] decode)</td></tr>
<tr class="separator:aa3b621409ed11e6f146f0752f4afa127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9490dd2a29a262ede84ee7e84cd68767"><td class="memItemLeft" align="right" valign="top">Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a9490dd2a29a262ede84ee7e84cd68767">recv</a> (self, float|None timeout=None, bool|None decode=None)</td></tr>
<tr class="separator:a9490dd2a29a262ede84ee7e84cd68767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9490dd2a29a262ede84ee7e84cd68767"><td class="memItemLeft" align="right" valign="top">Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a9490dd2a29a262ede84ee7e84cd68767">recv</a> (self, float|None timeout=None, bool|None decode=None)</td></tr>
<tr class="separator:a9490dd2a29a262ede84ee7e84cd68767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4e825fb0edbe25a4f61fff9e010846"><td class="memItemLeft" align="right" valign="top">Iterator[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a3b4e825fb0edbe25a4f61fff9e010846">recv_streaming</a> (self, Literal[True] decode)</td></tr>
<tr class="separator:a3b4e825fb0edbe25a4f61fff9e010846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa68026b93af97b8491dd19ccc45ac4"><td class="memItemLeft" align="right" valign="top">Iterator[bytes]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a7aa68026b93af97b8491dd19ccc45ac4">recv_streaming</a> (self, Literal[False] decode)</td></tr>
<tr class="separator:a7aa68026b93af97b8491dd19ccc45ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda7ca38729856f446d3e480cd00504e"><td class="memItemLeft" align="right" valign="top">Iterator[Data]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#abda7ca38729856f446d3e480cd00504e">recv_streaming</a> (self, bool|None decode=None)</td></tr>
<tr class="separator:abda7ca38729856f446d3e480cd00504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda7ca38729856f446d3e480cd00504e"><td class="memItemLeft" align="right" valign="top">Iterator[Data]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#abda7ca38729856f446d3e480cd00504e">recv_streaming</a> (self, bool|None decode=None)</td></tr>
<tr class="separator:abda7ca38729856f446d3e480cd00504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91738460a8aa9ed448ad81512b551363"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a91738460a8aa9ed448ad81512b551363">send</a> (self, Data|Iterable[Data] message, bool|None text=None)</td></tr>
<tr class="separator:a91738460a8aa9ed448ad81512b551363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fecae016abc3a7889cb18304560e3a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#aa5fecae016abc3a7889cb18304560e3a">close</a> (self, int code=<a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#af4e8be37b7ef43e1d1b3a8d105f0ed48">CloseCode.NORMAL_CLOSURE</a>, str reason=&quot;&quot;)</td></tr>
<tr class="separator:aa5fecae016abc3a7889cb18304560e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3af730d9097b6d24ba233c4331f9208"><td class="memItemLeft" align="right" valign="top">threading.Event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ae3af730d9097b6d24ba233c4331f9208">ping</a> (self, Data|None data=None, bool ack_on_close=False)</td></tr>
<tr class="separator:ae3af730d9097b6d24ba233c4331f9208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a476d3f0a7aeab0526b9e70f5934ba6"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a5a476d3f0a7aeab0526b9e70f5934ba6">pong</a> (self, Data data=b&quot;&quot;)</td></tr>
<tr class="separator:a5a476d3f0a7aeab0526b9e70f5934ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49b6d83776d20bebe6a41751f5745de"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#aa49b6d83776d20bebe6a41751f5745de">process_event</a> (self, Event event)</td></tr>
<tr class="separator:aa49b6d83776d20bebe6a41751f5745de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807391748e57b80d545d3efe772ed636"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a807391748e57b80d545d3efe772ed636">acknowledge_pings</a> (self, bytes data)</td></tr>
<tr class="separator:a807391748e57b80d545d3efe772ed636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdedea462c4bfc23f10eb5c5e85cf9e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a5fdedea462c4bfc23f10eb5c5e85cf9e">acknowledge_pending_pings</a> (self)</td></tr>
<tr class="separator:a5fdedea462c4bfc23f10eb5c5e85cf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76f819ff1cf11673fcf7a09a986a67f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#aa76f819ff1cf11673fcf7a09a986a67f">keepalive</a> (self)</td></tr>
<tr class="separator:aa76f819ff1cf11673fcf7a09a986a67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881ab972322231b4b09e13be5245d7ac"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a881ab972322231b4b09e13be5245d7ac">start_keepalive</a> (self)</td></tr>
<tr class="separator:a881ab972322231b4b09e13be5245d7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b388f18de71dc4971d20a9d6932d03f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a8b388f18de71dc4971d20a9d6932d03f">recv_events</a> (self)</td></tr>
<tr class="separator:a8b388f18de71dc4971d20a9d6932d03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90923b70eab8b6eeab6c750057fe59f6"><td class="memItemLeft" align="right" valign="top">Iterator[None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a90923b70eab8b6eeab6c750057fe59f6">send_context</a> (self, *<a class="el" href="classwebsockets_1_1protocol_1_1State.html">State</a> expected_state=OPEN)</td></tr>
<tr class="separator:a90923b70eab8b6eeab6c750057fe59f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7931bbe218a2af728ad040c30d4d41ed"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a7931bbe218a2af728ad040c30d4d41ed">send_data</a> (self)</td></tr>
<tr class="separator:a7931bbe218a2af728ad040c30d4d41ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8a2883e2a5ca74828082e4cd39e4a1"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a2f8a2883e2a5ca74828082e4cd39e4a1">set_recv_exc</a> (self, BaseException|None exc)</td></tr>
<tr class="separator:a2f8a2883e2a5ca74828082e4cd39e4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29299a6035bb6d3f3277f25ac02b9501"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a29299a6035bb6d3f3277f25ac02b9501">close_socket</a> (self)</td></tr>
<tr class="separator:a29299a6035bb6d3f3277f25ac02b9501"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a72160e7c873b205c9d6a1af65d5f1b21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a72160e7c873b205c9d6a1af65d5f1b21">socket</a></td></tr>
<tr class="separator:a72160e7c873b205c9d6a1af65d5f1b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef614d010a7321eb0955df984611c25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a6ef614d010a7321eb0955df984611c25">protocol</a></td></tr>
<tr class="separator:a6ef614d010a7321eb0955df984611c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a87feece00b082f049255dc7acc4817"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a4a87feece00b082f049255dc7acc4817">ping_interval</a></td></tr>
<tr class="separator:a4a87feece00b082f049255dc7acc4817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b86af435eb4eb0db563fc8b3782333a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a2b86af435eb4eb0db563fc8b3782333a">ping_timeout</a></td></tr>
<tr class="separator:a2b86af435eb4eb0db563fc8b3782333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e03724949e1dcb950b2c90d4c04122"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ad5e03724949e1dcb950b2c90d4c04122">close_timeout</a></td></tr>
<tr class="separator:ad5e03724949e1dcb950b2c90d4c04122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfa441793993f0458166c83333f7613"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a9dfa441793993f0458166c83333f7613">max_queue</a></td></tr>
<tr class="separator:a9dfa441793993f0458166c83333f7613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8ba4dbebc20d54d6fd6880ce3d7ae5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a6f8ba4dbebc20d54d6fd6880ce3d7ae5">debug</a></td></tr>
<tr class="separator:a6f8ba4dbebc20d54d6fd6880ce3d7ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7984b8331391b08a7d4e4643d16c0b4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a7984b8331391b08a7d4e4643d16c0b4e">protocol_mutex</a></td></tr>
<tr class="separator:a7984b8331391b08a7d4e4643d16c0b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b95794c81beb845bbfc8ddb16d6053e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a1b95794c81beb845bbfc8ddb16d6053e">recv_flow_control</a></td></tr>
<tr class="separator:a1b95794c81beb845bbfc8ddb16d6053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52b2fb4c3c1ea2f64b76db4f94bf529"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ad52b2fb4c3c1ea2f64b76db4f94bf529">recv_messages</a></td></tr>
<tr class="separator:ad52b2fb4c3c1ea2f64b76db4f94bf529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed4eb683a44088a43f5839abd3fb457"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a5ed4eb683a44088a43f5839abd3fb457">send_in_progress</a></td></tr>
<tr class="separator:a5ed4eb683a44088a43f5839abd3fb457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3578a9126dbd410e22e5add5e2a8d0b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a3578a9126dbd410e22e5add5e2a8d0b9">recv_events_thread</a></td></tr>
<tr class="separator:a3578a9126dbd410e22e5add5e2a8d0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad995f76e894b44f572900d7514c6519e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#ad995f76e894b44f572900d7514c6519e">latency</a></td></tr>
<tr class="separator:ad995f76e894b44f572900d7514c6519e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7203c993189aec262249beceb187419b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a7203c993189aec262249beceb187419b">keepalive_thread</a></td></tr>
<tr class="separator:a7203c993189aec262249beceb187419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea899c79cff3d02eaa490a60af01169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a6ea899c79cff3d02eaa490a60af01169">close_deadline</a></td></tr>
<tr class="separator:a6ea899c79cff3d02eaa490a60af01169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a3f2c03f149ce2b6dc81b535257fb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#a34a3f2c03f149ce2b6dc81b535257fb9">recv_exc</a></td></tr>
<tr class="separator:a34a3f2c03f149ce2b6dc81b535257fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afac084f871ae9cb14b063dade6bcfa41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html#afac084f871ae9cb14b063dade6bcfa41">recv_bufsize</a> = 65536</td></tr>
<tr class="separator:afac084f871ae9cb14b063dade6bcfa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">:mod:`threading` implementation of a WebSocket connection.

:class:`Connection` provides APIs shared between WebSocket servers and
clients.

You shouldn't use it directly. Instead, use
:class:`~websockets.sync.client.ClientConnection` or
:class:`~websockets.sync.server.ServerConnection`.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4b1344ff43d7260084e97021dc44e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1344ff43d7260084e97021dc44e76">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socket.socket&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1protocol_1_1Protocol.html">Protocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*float | None &#160;</td>
          <td class="paramname"><em>ping_interval</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>ping_timeout</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>close_timeout</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None | tuple[int | None, int | None] &#160;</td>
          <td class="paramname"><em>max_queue</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4b1344ff43d7260084e97021dc44e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1344ff43d7260084e97021dc44e76">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socket.socket&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1protocol_1_1Protocol.html">Protocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*float | None &#160;</td>
          <td class="paramname"><em>ping_interval</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>ping_timeout</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>close_timeout</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None | tuple[int | None, int | None] &#160;</td>
          <td class="paramname"><em>max_queue</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab63a98625b59d71fbfc90b1801f3d018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63a98625b59d71fbfc90b1801f3d018">&#9670;&nbsp;</a></span>__enter__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html">Connection</a> websockets.sync.connection.Connection.__enter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab63a98625b59d71fbfc90b1801f3d018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63a98625b59d71fbfc90b1801f3d018">&#9670;&nbsp;</a></span>__enter__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1sync_1_1connection_1_1Connection.html">Connection</a> websockets.sync.connection.Connection.__enter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5777ffbb322221ec9b7a22c3817f2bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5777ffbb322221ec9b7a22c3817f2bc7">&#9670;&nbsp;</a></span>__exit__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.__exit__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[BaseException] | None&#160;</td>
          <td class="paramname"><em>exc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseException | None&#160;</td>
          <td class="paramname"><em>exc_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TracebackType | None&#160;</td>
          <td class="paramname"><em>traceback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5777ffbb322221ec9b7a22c3817f2bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5777ffbb322221ec9b7a22c3817f2bc7">&#9670;&nbsp;</a></span>__exit__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.__exit__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type[BaseException] | None&#160;</td>
          <td class="paramname"><em>exc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseException | None&#160;</td>
          <td class="paramname"><em>exc_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TracebackType | None&#160;</td>
          <td class="paramname"><em>traceback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34f39e4010d1d39d772d5fd07531cb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f39e4010d1d39d772d5fd07531cb72">&#9670;&nbsp;</a></span>__iter__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Data] websockets.sync.connection.Connection.__iter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate on incoming messages.

The iterator calls :meth:`recv` and yields messages in an infinite loop.

It exits when the connection is closed normally. It raises a
:exc:`~websockets.exceptions.ConnectionClosedError` exception after a
protocol error or a network failure.</pre> 
</div>
</div>
<a id="a34f39e4010d1d39d772d5fd07531cb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f39e4010d1d39d772d5fd07531cb72">&#9670;&nbsp;</a></span>__iter__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Data] websockets.sync.connection.Connection.__iter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate on incoming messages.

The iterator calls :meth:`recv` and yields messages in an infinite loop.

It exits when the connection is closed normally. It raises a
:exc:`~websockets.exceptions.ConnectionClosedError` exception after a
protocol error or a network failure.</pre> 
</div>
</div>
<a id="a5fdedea462c4bfc23f10eb5c5e85cf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdedea462c4bfc23f10eb5c5e85cf9e">&#9670;&nbsp;</a></span>acknowledge_pending_pings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.acknowledge_pending_pings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Acknowledge pending pings when the connection is closed.</pre> 
</div>
</div>
<a id="a5fdedea462c4bfc23f10eb5c5e85cf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdedea462c4bfc23f10eb5c5e85cf9e">&#9670;&nbsp;</a></span>acknowledge_pending_pings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.acknowledge_pending_pings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Acknowledge pending pings when the connection is closed.</pre> 
</div>
</div>
<a id="a807391748e57b80d545d3efe772ed636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807391748e57b80d545d3efe772ed636">&#9670;&nbsp;</a></span>acknowledge_pings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.acknowledge_pings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Acknowledge pings when receiving a pong.</pre> 
</div>
</div>
<a id="a807391748e57b80d545d3efe772ed636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807391748e57b80d545d3efe772ed636">&#9670;&nbsp;</a></span>acknowledge_pings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.acknowledge_pings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Acknowledge pings when receiving a pong.</pre> 
</div>
</div>
<a id="aa5fecae016abc3a7889cb18304560e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fecae016abc3a7889cb18304560e3a">&#9670;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>code</em> = <code><a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#af4e8be37b7ef43e1d1b3a8d105f0ed48">CloseCode.NORMAL_CLOSURE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>reason</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the closing handshake.

:meth:`close` waits for the other end to complete the handshake, for the
TCP connection to terminate, and for all incoming messages to be read
with :meth:`recv`.

:meth:`close` is idempotent: it doesn't do anything once the
connection is closed.

Args:
    code: WebSocket close code.
    reason: WebSocket close reason.</pre> 
</div>
</div>
<a id="aa5fecae016abc3a7889cb18304560e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fecae016abc3a7889cb18304560e3a">&#9670;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>code</em> = <code><a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#af4e8be37b7ef43e1d1b3a8d105f0ed48">CloseCode.NORMAL_CLOSURE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>reason</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the closing handshake.

:meth:`close` waits for the other end to complete the handshake, for the
TCP connection to terminate, and for all incoming messages to be read
with :meth:`recv`.

:meth:`close` is idempotent: it doesn't do anything once the
connection is closed.

Args:
    code: WebSocket close code.
    reason: WebSocket close reason.</pre> 
</div>
</div>
<a id="a1df1ef554d878b5f8192513c407e467b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df1ef554d878b5f8192513c407e467b">&#9670;&nbsp;</a></span>close_code() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None websockets.sync.connection.Connection.close_code </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">State of the WebSocket connection, defined in :rfc:`6455`.

This attribute is provided for completeness. Typical applications
shouldn't check its value. Instead, they should inspect attributes
of :exc:`~websockets.exceptions.ConnectionClosed` exceptions.</pre> 
</div>
</div>
<a id="a1df1ef554d878b5f8192513c407e467b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df1ef554d878b5f8192513c407e467b">&#9670;&nbsp;</a></span>close_code() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None websockets.sync.connection.Connection.close_code </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">State of the WebSocket connection, defined in :rfc:`6455`.

This attribute is provided for completeness. Typical applications
shouldn't check its value. Instead, they should inspect attributes
of :exc:`~websockets.exceptions.ConnectionClosed` exceptions.</pre> 
</div>
</div>
<a id="a45221d5e869454d7b8e1f2480882b191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45221d5e869454d7b8e1f2480882b191">&#9670;&nbsp;</a></span>close_reason() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str | None websockets.sync.connection.Connection.close_reason </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">State of the WebSocket connection, defined in :rfc:`6455`.

This attribute is provided for completeness. Typical applications
shouldn't check its value. Instead, they should inspect attributes
of :exc:`~websockets.exceptions.ConnectionClosed` exceptions.</pre> 
</div>
</div>
<a id="a45221d5e869454d7b8e1f2480882b191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45221d5e869454d7b8e1f2480882b191">&#9670;&nbsp;</a></span>close_reason() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str | None websockets.sync.connection.Connection.close_reason </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">State of the WebSocket connection, defined in :rfc:`6455`.

This attribute is provided for completeness. Typical applications
shouldn't check its value. Instead, they should inspect attributes
of :exc:`~websockets.exceptions.ConnectionClosed` exceptions.</pre> 
</div>
</div>
<a id="a29299a6035bb6d3f3277f25ac02b9501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29299a6035bb6d3f3277f25ac02b9501">&#9670;&nbsp;</a></span>close_socket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.close_socket </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Shutdown and close socket. Close message assembler.

Calling close_socket() guarantees that recv_events() terminates. Indeed,
recv_events() may block only on socket.recv() or on recv_messages.put().</pre> 
</div>
</div>
<a id="a29299a6035bb6d3f3277f25ac02b9501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29299a6035bb6d3f3277f25ac02b9501">&#9670;&nbsp;</a></span>close_socket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.close_socket </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Shutdown and close socket. Close message assembler.

Calling close_socket() guarantees that recv_events() terminates. Indeed,
recv_events() may block only on socket.recv() or on recv_messages.put().</pre> 
</div>
</div>
<a id="aa76f819ff1cf11673fcf7a09a986a67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76f819ff1cf11673fcf7a09a986a67f">&#9670;&nbsp;</a></span>keepalive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.keepalive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Ping frame and wait for a Pong frame at regular intervals.</pre> 
</div>
</div>
<a id="aa76f819ff1cf11673fcf7a09a986a67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76f819ff1cf11673fcf7a09a986a67f">&#9670;&nbsp;</a></span>keepalive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.keepalive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Ping frame and wait for a Pong frame at regular intervals.</pre> 
</div>
</div>
<a id="a55e663d0197e3b169737cf3b683c4159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e663d0197e3b169737cf3b683c4159">&#9670;&nbsp;</a></span>local_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any websockets.sync.connection.Connection.local_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Local address of the connection.

For IPv4 connections, this is a ``(host, port)`` tuple.

The format of the address depends on the address family.
See :meth:`~socket.socket.getsockname`.</pre> 
</div>
</div>
<a id="a55e663d0197e3b169737cf3b683c4159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e663d0197e3b169737cf3b683c4159">&#9670;&nbsp;</a></span>local_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any websockets.sync.connection.Connection.local_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Local address of the connection.

For IPv4 connections, this is a ``(host, port)`` tuple.

The format of the address depends on the address family.
See :meth:`~socket.socket.getsockname`.</pre> 
</div>
</div>
<a id="ae3af730d9097b6d24ba233c4331f9208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3af730d9097b6d24ba233c4331f9208">&#9670;&nbsp;</a></span>ping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> threading.Event websockets.sync.connection.Connection.ping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data | None &#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ack_on_close</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Ping_.

.. _Ping: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.2

A ping may serve as a keepalive or as a check that the remote endpoint
received all messages up to this point

Args:
    data: Payload of the ping. A :class:`str` will be encoded to UTF-8.
        If ``data`` is :obj:`None`, the payload is four random bytes.
    ack_on_close: when this option is :obj:`True`, the event will also
        be set when the connection is closed. While this avoids getting
        stuck waiting for a pong that will never arrive, it requires
        checking that the state of the connection is still ``OPEN`` to
        confirm that a pong was received, rather than the connection
        being closed.

Returns:
    An event that will be set when the corresponding pong is received.
    You can ignore it if you don't intend to wait.

    ::

        pong_event = ws.ping()
        pong_event.wait()  # only if you want to wait for the pong

Raises:
    ConnectionClosed: When the connection is closed.
    ConcurrencyError: If another ping was sent with the same data and
        the corresponding pong wasn't received yet.</pre> 
</div>
</div>
<a id="ae3af730d9097b6d24ba233c4331f9208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3af730d9097b6d24ba233c4331f9208">&#9670;&nbsp;</a></span>ping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> threading.Event websockets.sync.connection.Connection.ping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data | None &#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ack_on_close</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Ping_.

.. _Ping: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.2

A ping may serve as a keepalive or as a check that the remote endpoint
received all messages up to this point

Args:
    data: Payload of the ping. A :class:`str` will be encoded to UTF-8.
        If ``data`` is :obj:`None`, the payload is four random bytes.
    ack_on_close: when this option is :obj:`True`, the event will also
        be set when the connection is closed. While this avoids getting
        stuck waiting for a pong that will never arrive, it requires
        checking that the state of the connection is still ``OPEN`` to
        confirm that a pong was received, rather than the connection
        being closed.

Returns:
    An event that will be set when the corresponding pong is received.
    You can ignore it if you don't intend to wait.

    ::

        pong_event = ws.ping()
        pong_event.wait()  # only if you want to wait for the pong

Raises:
    ConnectionClosed: When the connection is closed.
    ConcurrencyError: If another ping was sent with the same data and
        the corresponding pong wasn't received yet.</pre> 
</div>
</div>
<a id="a5a476d3f0a7aeab0526b9e70f5934ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a476d3f0a7aeab0526b9e70f5934ba6">&#9670;&nbsp;</a></span>pong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.pong </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data &#160;</td>
          <td class="paramname"><em>data</em> = <code>b&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Pong_.

.. _Pong: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.3

An unsolicited pong may serve as a unidirectional heartbeat.

Args:
    data: Payload of the pong. A :class:`str` will be encoded to UTF-8.

Raises:
    ConnectionClosed: When the connection is closed.</pre> 
</div>
</div>
<a id="a5a476d3f0a7aeab0526b9e70f5934ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a476d3f0a7aeab0526b9e70f5934ba6">&#9670;&nbsp;</a></span>pong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.pong </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data &#160;</td>
          <td class="paramname"><em>data</em> = <code>b&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Pong_.

.. _Pong: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.3

An unsolicited pong may serve as a unidirectional heartbeat.

Args:
    data: Payload of the pong. A :class:`str` will be encoded to UTF-8.

Raises:
    ConnectionClosed: When the connection is closed.</pre> 
</div>
</div>
<a id="aa49b6d83776d20bebe6a41751f5745de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49b6d83776d20bebe6a41751f5745de">&#9670;&nbsp;</a></span>process_event() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.process_event </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Event&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Process one incoming event.

This method is overridden in subclasses to handle the handshake.</pre> 
<p>Reimplemented in <a class="el" href="classwebsockets_1_1sync_1_1server_1_1ServerConnection.html#a8f845c67d27e7db614bded45135ced4c">websockets.sync.server.ServerConnection</a>, <a class="el" href="classwebsockets_1_1sync_1_1client_1_1ClientConnection.html#aeaaf661e958e17ca0239ebef8e8e467f">websockets.sync.client.ClientConnection</a>, <a class="el" href="classwebsockets_1_1sync_1_1server_1_1ServerConnection.html#a8f845c67d27e7db614bded45135ced4c">websockets.sync.server.ServerConnection</a>, and <a class="el" href="classwebsockets_1_1sync_1_1client_1_1ClientConnection.html#aeaaf661e958e17ca0239ebef8e8e467f">websockets.sync.client.ClientConnection</a>.</p>

</div>
</div>
<a id="aa49b6d83776d20bebe6a41751f5745de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49b6d83776d20bebe6a41751f5745de">&#9670;&nbsp;</a></span>process_event() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.process_event </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Event&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Process one incoming event.

This method is overridden in subclasses to handle the handshake.</pre> 
<p>Reimplemented in <a class="el" href="classwebsockets_1_1sync_1_1server_1_1ServerConnection.html#a8f845c67d27e7db614bded45135ced4c">websockets.sync.server.ServerConnection</a>, <a class="el" href="classwebsockets_1_1sync_1_1client_1_1ClientConnection.html#aeaaf661e958e17ca0239ebef8e8e467f">websockets.sync.client.ClientConnection</a>, <a class="el" href="classwebsockets_1_1sync_1_1server_1_1ServerConnection.html#a8f845c67d27e7db614bded45135ced4c">websockets.sync.server.ServerConnection</a>, and <a class="el" href="classwebsockets_1_1sync_1_1client_1_1ClientConnection.html#aeaaf661e958e17ca0239ebef8e8e467f">websockets.sync.client.ClientConnection</a>.</p>

</div>
</div>
<a id="afd7ade02d59e02b43ff5dd91205fcbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7ade02d59e02b43ff5dd91205fcbab">&#9670;&nbsp;</a></span>recv() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bytes websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[False]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd7ade02d59e02b43ff5dd91205fcbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7ade02d59e02b43ff5dd91205fcbab">&#9670;&nbsp;</a></span>recv() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bytes websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[False]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a582485bd8411901af88e56b6c5ca5136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582485bd8411901af88e56b6c5ca5136">&#9670;&nbsp;</a></span>recv() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[True]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a582485bd8411901af88e56b6c5ca5136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582485bd8411901af88e56b6c5ca5136">&#9670;&nbsp;</a></span>recv() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[True]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b621409ed11e6f146f0752f4afa127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b621409ed11e6f146f0752f4afa127">&#9670;&nbsp;</a></span>recv() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bytes websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal[False]
    &#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b621409ed11e6f146f0752f4afa127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b621409ed11e6f146f0752f4afa127">&#9670;&nbsp;</a></span>recv() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bytes websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal[False]
    &#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c4fa47183b607378be5a21a1cf24e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c4fa47183b607378be5a21a1cf24e0">&#9670;&nbsp;</a></span>recv() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal[True]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c4fa47183b607378be5a21a1cf24e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c4fa47183b607378be5a21a1cf24e0">&#9670;&nbsp;</a></span>recv() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Literal[True]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9490dd2a29a262ede84ee7e84cd68767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9490dd2a29a262ede84ee7e84cd68767">&#9670;&nbsp;</a></span>recv() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Data websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>decode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9490dd2a29a262ede84ee7e84cd68767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9490dd2a29a262ede84ee7e84cd68767">&#9670;&nbsp;</a></span>recv() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Data websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>decode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive the next message.

When the connection is closed, :meth:`recv` raises
:exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it raises
:exc:`~websockets.exceptions.ConnectionClosedOK` after a normal closure
and :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol
error or a network failure. This is how you detect the end of the
message stream.

If ``timeout`` is :obj:`None`, block until a message is received. If
``timeout`` is set, wait up to ``timeout`` seconds for a message to be
received and return it, else raise :exc:`TimeoutError`. If ``timeout``
is ``0`` or negative, check if a message has been received already and
return it, else raise :exc:`TimeoutError`.

If the message is fragmented, wait until all fragments are received,
reassemble them, and return the whole message.

Args:
    timeout: Timeout for receiving a message in seconds.
    decode: Set this flag to override the default behavior of returning
        :class:`str` or :class:`bytes`. See below for details.

Returns:
    A string (:class:`str`) for a Text_ frame or a bytestring
    (:class:`bytes`) for a Binary_ frame.

    .. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
    .. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

    You may override this behavior with the ``decode`` argument:

    * Set ``decode=False`` to disable UTF-8 decoding of Text_ frames and
      return a bytestring (:class:`bytes`). This improves performance
      when decoding isn't needed, for example if the message contains
      JSON and you're using a JSON library that expects a bytestring.
    * Set ``decode=True`` to force UTF-8 decoding of Binary_ frames
      and return a string (:class:`str`). This may be useful for
      servers that send binary frames instead of text frames.

Raises:
    ConnectionClosed: When the connection is closed.
    ConcurrencyError: If two threads call :meth:`recv` or
        :meth:`recv_streaming` concurrently.</pre> 
</div>
</div>
<a id="a9490dd2a29a262ede84ee7e84cd68767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9490dd2a29a262ede84ee7e84cd68767">&#9670;&nbsp;</a></span>recv() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Data websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>decode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9490dd2a29a262ede84ee7e84cd68767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9490dd2a29a262ede84ee7e84cd68767">&#9670;&nbsp;</a></span>recv() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Data websockets.sync.connection.Connection.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>decode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive the next message.

When the connection is closed, :meth:`recv` raises
:exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it raises
:exc:`~websockets.exceptions.ConnectionClosedOK` after a normal closure
and :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol
error or a network failure. This is how you detect the end of the
message stream.

If ``timeout`` is :obj:`None`, block until a message is received. If
``timeout`` is set, wait up to ``timeout`` seconds for a message to be
received and return it, else raise :exc:`TimeoutError`. If ``timeout``
is ``0`` or negative, check if a message has been received already and
return it, else raise :exc:`TimeoutError`.

If the message is fragmented, wait until all fragments are received,
reassemble them, and return the whole message.

Args:
    timeout: Timeout for receiving a message in seconds.
    decode: Set this flag to override the default behavior of returning
        :class:`str` or :class:`bytes`. See below for details.

Returns:
    A string (:class:`str`) for a Text_ frame or a bytestring
    (:class:`bytes`) for a Binary_ frame.

    .. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
    .. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

    You may override this behavior with the ``decode`` argument:

    * Set ``decode=False`` to disable UTF-8 decoding of Text_ frames and
      return a bytestring (:class:`bytes`). This improves performance
      when decoding isn't needed, for example if the message contains
      JSON and you're using a JSON library that expects a bytestring.
    * Set ``decode=True`` to force UTF-8 decoding of Binary_ frames
      and return a string (:class:`str`). This may be useful for
      servers that send binary frames instead of text frames.

Raises:
    ConnectionClosed: When the connection is closed.
    ConcurrencyError: If two threads call :meth:`recv` or
        :meth:`recv_streaming` concurrently.</pre> 
</div>
</div>
<a id="a8b388f18de71dc4971d20a9d6932d03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b388f18de71dc4971d20a9d6932d03f">&#9670;&nbsp;</a></span>recv_events() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.recv_events </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read incoming data from the socket and process events.

Run this method in a thread as long as the connection is alive.

``recv_events()`` exits immediately when the ``self.socket`` is closed.</pre> 
<p>Reimplemented in <a class="el" href="classwebsockets_1_1sync_1_1server_1_1ServerConnection.html#a8d5ee820620f2ef1cbc8682c3f2e339d">websockets.sync.server.ServerConnection</a>, <a class="el" href="classwebsockets_1_1sync_1_1client_1_1ClientConnection.html#a88ea7782a083b22baded4fb12bdaba02">websockets.sync.client.ClientConnection</a>, <a class="el" href="classwebsockets_1_1sync_1_1server_1_1ServerConnection.html#a8d5ee820620f2ef1cbc8682c3f2e339d">websockets.sync.server.ServerConnection</a>, and <a class="el" href="classwebsockets_1_1sync_1_1client_1_1ClientConnection.html#a88ea7782a083b22baded4fb12bdaba02">websockets.sync.client.ClientConnection</a>.</p>

</div>
</div>
<a id="a8b388f18de71dc4971d20a9d6932d03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b388f18de71dc4971d20a9d6932d03f">&#9670;&nbsp;</a></span>recv_events() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.recv_events </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read incoming data from the socket and process events.

Run this method in a thread as long as the connection is alive.

``recv_events()`` exits immediately when the ``self.socket`` is closed.</pre> 
<p>Reimplemented in <a class="el" href="classwebsockets_1_1sync_1_1server_1_1ServerConnection.html#a8d5ee820620f2ef1cbc8682c3f2e339d">websockets.sync.server.ServerConnection</a>, <a class="el" href="classwebsockets_1_1sync_1_1client_1_1ClientConnection.html#a88ea7782a083b22baded4fb12bdaba02">websockets.sync.client.ClientConnection</a>, <a class="el" href="classwebsockets_1_1sync_1_1server_1_1ServerConnection.html#a8d5ee820620f2ef1cbc8682c3f2e339d">websockets.sync.server.ServerConnection</a>, and <a class="el" href="classwebsockets_1_1sync_1_1client_1_1ClientConnection.html#a88ea7782a083b22baded4fb12bdaba02">websockets.sync.client.ClientConnection</a>.</p>

</div>
</div>
<a id="abda7ca38729856f446d3e480cd00504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda7ca38729856f446d3e480cd00504e">&#9670;&nbsp;</a></span>recv_streaming() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Data] websockets.sync.connection.Connection.recv_streaming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>decode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abda7ca38729856f446d3e480cd00504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda7ca38729856f446d3e480cd00504e">&#9670;&nbsp;</a></span>recv_streaming() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Data] websockets.sync.connection.Connection.recv_streaming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>decode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive the next message frame by frame.

This method is designed for receiving fragmented messages. It returns an
iterator that yields each fragment as it is received. This iterator must
be fully consumed. Else, future calls to :meth:`recv` or
:meth:`recv_streaming` will raise
:exc:`~websockets.exceptions.ConcurrencyError`, making the connection
unusable.

:meth:`recv_streaming` raises the same exceptions as :meth:`recv`.

Args:
    decode: Set this flag to override the default behavior of returning
        :class:`str` or :class:`bytes`. See below for details.

Returns:
    An iterator of strings (:class:`str`) for a Text_ frame or
    bytestrings (:class:`bytes`) for a Binary_ frame.

    .. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
    .. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

    You may override this behavior with the ``decode`` argument:

    * Set ``decode=False`` to disable UTF-8 decoding of Text_ frames
      and return bytestrings (:class:`bytes`). This may be useful to
      optimize performance when decoding isn't needed.
    * Set ``decode=True`` to force UTF-8 decoding of Binary_ frames
      and return strings (:class:`str`). This is useful for servers
      that send binary frames instead of text frames.

Raises:
    ConnectionClosed: When the connection is closed.
    ConcurrencyError: If two threads call :meth:`recv` or
        :meth:`recv_streaming` concurrently.</pre> 
</div>
</div>
<a id="abda7ca38729856f446d3e480cd00504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda7ca38729856f446d3e480cd00504e">&#9670;&nbsp;</a></span>recv_streaming() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Data] websockets.sync.connection.Connection.recv_streaming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>decode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abda7ca38729856f446d3e480cd00504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda7ca38729856f446d3e480cd00504e">&#9670;&nbsp;</a></span>recv_streaming() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Data] websockets.sync.connection.Connection.recv_streaming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>decode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive the next message frame by frame.

This method is designed for receiving fragmented messages. It returns an
iterator that yields each fragment as it is received. This iterator must
be fully consumed. Else, future calls to :meth:`recv` or
:meth:`recv_streaming` will raise
:exc:`~websockets.exceptions.ConcurrencyError`, making the connection
unusable.

:meth:`recv_streaming` raises the same exceptions as :meth:`recv`.

Args:
    decode: Set this flag to override the default behavior of returning
        :class:`str` or :class:`bytes`. See below for details.

Returns:
    An iterator of strings (:class:`str`) for a Text_ frame or
    bytestrings (:class:`bytes`) for a Binary_ frame.

    .. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
    .. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

    You may override this behavior with the ``decode`` argument:

    * Set ``decode=False`` to disable UTF-8 decoding of Text_ frames
      and return bytestrings (:class:`bytes`). This may be useful to
      optimize performance when decoding isn't needed.
    * Set ``decode=True`` to force UTF-8 decoding of Binary_ frames
      and return strings (:class:`str`). This is useful for servers
      that send binary frames instead of text frames.

Raises:
    ConnectionClosed: When the connection is closed.
    ConcurrencyError: If two threads call :meth:`recv` or
        :meth:`recv_streaming` concurrently.</pre> 
</div>
</div>
<a id="a7aa68026b93af97b8491dd19ccc45ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa68026b93af97b8491dd19ccc45ac4">&#9670;&nbsp;</a></span>recv_streaming() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[bytes] websockets.sync.connection.Connection.recv_streaming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[False]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7aa68026b93af97b8491dd19ccc45ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa68026b93af97b8491dd19ccc45ac4">&#9670;&nbsp;</a></span>recv_streaming() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[bytes] websockets.sync.connection.Connection.recv_streaming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[False]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b4e825fb0edbe25a4f61fff9e010846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4e825fb0edbe25a4f61fff9e010846">&#9670;&nbsp;</a></span>recv_streaming() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[str] websockets.sync.connection.Connection.recv_streaming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[True]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b4e825fb0edbe25a4f61fff9e010846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4e825fb0edbe25a4f61fff9e010846">&#9670;&nbsp;</a></span>recv_streaming() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[str] websockets.sync.connection.Connection.recv_streaming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[True]&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ca7075f15a3b7102bd69996744a9901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca7075f15a3b7102bd69996744a9901">&#9670;&nbsp;</a></span>remote_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any websockets.sync.connection.Connection.remote_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remote address of the connection.

For IPv4 connections, this is a ``(host, port)`` tuple.

The format of the address depends on the address family.
See :meth:`~socket.socket.getpeername`.</pre> 
</div>
</div>
<a id="a2ca7075f15a3b7102bd69996744a9901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca7075f15a3b7102bd69996744a9901">&#9670;&nbsp;</a></span>remote_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any websockets.sync.connection.Connection.remote_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remote address of the connection.

For IPv4 connections, this is a ``(host, port)`` tuple.

The format of the address depends on the address family.
See :meth:`~socket.socket.getpeername`.</pre> 
</div>
</div>
<a id="a91738460a8aa9ed448ad81512b551363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91738460a8aa9ed448ad81512b551363">&#9670;&nbsp;</a></span>send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.send </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data | Iterable[Data]&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>text</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a message.

A string (:class:`str`) is sent as a Text_ frame. A bytestring or
bytes-like object (:class:`bytes`, :class:`bytearray`, or
:class:`memoryview`) is sent as a Binary_ frame.

.. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
.. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

You may override this behavior with the ``text`` argument:

* Set ``text=True`` to send a bytestring or bytes-like object
  (:class:`bytes`, :class:`bytearray`, or :class:`memoryview`) as a
  Text_ frame. This improves performance when the message is already
  UTF-8 encoded, for example if the message contains JSON and you're
  using a JSON library that produces a bytestring.
* Set ``text=False`` to send a string (:class:`str`) in a Binary_
  frame. This may be useful for servers that expect binary frames
  instead of text frames.

:meth:`send` also accepts an iterable of strings, bytestrings, or
bytes-like objects to enable fragmentation_. Each item is treated as a
message fragment and sent in its own frame. All items must be of the
same type, or else :meth:`send` will raise a :exc:`TypeError` and the
connection will be closed.

.. _fragmentation: https://datatracker.ietf.org/doc/html/rfc6455#section-5.4

:meth:`send` rejects dict-like objects because this is often an error.
(If you really want to send the keys of a dict-like object as fragments,
call its :meth:`~dict.keys` method and pass the result to :meth:`send`.)

When the connection is closed, :meth:`send` raises
:exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it
raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal
connection closure and
:exc:`~websockets.exceptions.ConnectionClosedError` after a protocol
error or a network failure.

Args:
    message: Message to send.

Raises:
    ConnectionClosed: When the connection is closed.
    ConcurrencyError: If the connection is sending a fragmented message.
    TypeError: If ``message`` doesn't have a supported type.</pre> 
</div>
</div>
<a id="a91738460a8aa9ed448ad81512b551363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91738460a8aa9ed448ad81512b551363">&#9670;&nbsp;</a></span>send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.send </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data | Iterable[Data]&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>text</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a message.

A string (:class:`str`) is sent as a Text_ frame. A bytestring or
bytes-like object (:class:`bytes`, :class:`bytearray`, or
:class:`memoryview`) is sent as a Binary_ frame.

.. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
.. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

You may override this behavior with the ``text`` argument:

* Set ``text=True`` to send a bytestring or bytes-like object
  (:class:`bytes`, :class:`bytearray`, or :class:`memoryview`) as a
  Text_ frame. This improves performance when the message is already
  UTF-8 encoded, for example if the message contains JSON and you're
  using a JSON library that produces a bytestring.
* Set ``text=False`` to send a string (:class:`str`) in a Binary_
  frame. This may be useful for servers that expect binary frames
  instead of text frames.

:meth:`send` also accepts an iterable of strings, bytestrings, or
bytes-like objects to enable fragmentation_. Each item is treated as a
message fragment and sent in its own frame. All items must be of the
same type, or else :meth:`send` will raise a :exc:`TypeError` and the
connection will be closed.

.. _fragmentation: https://datatracker.ietf.org/doc/html/rfc6455#section-5.4

:meth:`send` rejects dict-like objects because this is often an error.
(If you really want to send the keys of a dict-like object as fragments,
call its :meth:`~dict.keys` method and pass the result to :meth:`send`.)

When the connection is closed, :meth:`send` raises
:exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it
raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal
connection closure and
:exc:`~websockets.exceptions.ConnectionClosedError` after a protocol
error or a network failure.

Args:
    message: Message to send.

Raises:
    ConnectionClosed: When the connection is closed.
    ConcurrencyError: If the connection is sending a fragmented message.
    TypeError: If ``message`` doesn't have a supported type.</pre> 
</div>
</div>
<a id="a90923b70eab8b6eeab6c750057fe59f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90923b70eab8b6eeab6c750057fe59f6">&#9670;&nbsp;</a></span>send_context() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[None] websockets.sync.connection.Connection.send_context </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classwebsockets_1_1protocol_1_1State.html">State</a> &#160;</td>
          <td class="paramname"><em>expected_state</em> = <code>OPEN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a context for writing to the connection from user code.

On entry, :meth:`send_context` acquires the connection lock and checks
that the connection is open; on exit, it writes outgoing data to the
socket::

    with self.send_context():
        self.protocol.send_text(message.encode())

When the connection isn't open on entry, when the connection is expected
to close on exit, or when an unexpected error happens, terminating the
connection, :meth:`send_context` waits until the connection is closed
then raises :exc:`~websockets.exceptions.ConnectionClosed`.</pre> 
</div>
</div>
<a id="a90923b70eab8b6eeab6c750057fe59f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90923b70eab8b6eeab6c750057fe59f6">&#9670;&nbsp;</a></span>send_context() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[None] websockets.sync.connection.Connection.send_context </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classwebsockets_1_1protocol_1_1State.html">State</a> &#160;</td>
          <td class="paramname"><em>expected_state</em> = <code>OPEN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a context for writing to the connection from user code.

On entry, :meth:`send_context` acquires the connection lock and checks
that the connection is open; on exit, it writes outgoing data to the
socket::

    with self.send_context():
        self.protocol.send_text(message.encode())

When the connection isn't open on entry, when the connection is expected
to close on exit, or when an unexpected error happens, terminating the
connection, :meth:`send_context` waits until the connection is closed
then raises :exc:`~websockets.exceptions.ConnectionClosed`.</pre> 
</div>
</div>
<a id="a7931bbe218a2af728ad040c30d4d41ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7931bbe218a2af728ad040c30d4d41ed">&#9670;&nbsp;</a></span>send_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.send_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send outgoing data.

This method requires holding protocol_mutex.

Raises:
    OSError: When a socket operations fails.</pre> 
</div>
</div>
<a id="a7931bbe218a2af728ad040c30d4d41ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7931bbe218a2af728ad040c30d4d41ed">&#9670;&nbsp;</a></span>send_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.send_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send outgoing data.

This method requires holding protocol_mutex.

Raises:
    OSError: When a socket operations fails.</pre> 
</div>
</div>
<a id="a2f8a2883e2a5ca74828082e4cd39e4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8a2883e2a5ca74828082e4cd39e4a1">&#9670;&nbsp;</a></span>set_recv_exc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.set_recv_exc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseException | None&#160;</td>
          <td class="paramname"><em>exc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set recv_exc, if not set yet.

This method requires holding protocol_mutex.</pre> 
</div>
</div>
<a id="a2f8a2883e2a5ca74828082e4cd39e4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8a2883e2a5ca74828082e4cd39e4a1">&#9670;&nbsp;</a></span>set_recv_exc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.set_recv_exc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseException | None&#160;</td>
          <td class="paramname"><em>exc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set recv_exc, if not set yet.

This method requires holding protocol_mutex.</pre> 
</div>
</div>
<a id="a881ab972322231b4b09e13be5245d7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881ab972322231b4b09e13be5245d7ac">&#9670;&nbsp;</a></span>start_keepalive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.start_keepalive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Run :meth:`keepalive` in a thread, unless keepalive is disabled.</pre> 
</div>
</div>
<a id="a881ab972322231b4b09e13be5245d7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881ab972322231b4b09e13be5245d7ac">&#9670;&nbsp;</a></span>start_keepalive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.sync.connection.Connection.start_keepalive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Run :meth:`keepalive` in a thread, unless keepalive is disabled.</pre> 
</div>
</div>
<a id="a09995a14d1323c66255f3b1f6a71a422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09995a14d1323c66255f3b1f6a71a422">&#9670;&nbsp;</a></span>state() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1protocol_1_1State.html">State</a> websockets.sync.connection.Connection.state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">State of the WebSocket connection, defined in :rfc:`6455`.

This attribute is provided for completeness. Typical applications
shouldn't check its value. Instead, they should call :meth:`~recv` or
:meth:`send` and handle :exc:`~websockets.exceptions.ConnectionClosed`
exceptions.</pre> 
</div>
</div>
<a id="a09995a14d1323c66255f3b1f6a71a422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09995a14d1323c66255f3b1f6a71a422">&#9670;&nbsp;</a></span>state() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1protocol_1_1State.html">State</a> websockets.sync.connection.Connection.state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">State of the WebSocket connection, defined in :rfc:`6455`.

This attribute is provided for completeness. Typical applications
shouldn't check its value. Instead, they should call :meth:`~recv` or
:meth:`send` and handle :exc:`~websockets.exceptions.ConnectionClosed`
exceptions.</pre> 
</div>
</div>
<a id="a1b1cb462cd26489527287e5db5447204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1cb462cd26489527287e5db5447204">&#9670;&nbsp;</a></span>subprotocol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Subprotocol | None websockets.sync.connection.Connection.subprotocol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Subprotocol negotiated during the opening handshake.

:obj:`None` if no subprotocol was negotiated.</pre> 
</div>
</div>
<a id="a1b1cb462cd26489527287e5db5447204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1cb462cd26489527287e5db5447204">&#9670;&nbsp;</a></span>subprotocol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Subprotocol | None websockets.sync.connection.Connection.subprotocol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Subprotocol negotiated during the opening handshake.

:obj:`None` if no subprotocol was negotiated.</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6ea899c79cff3d02eaa490a60af01169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea899c79cff3d02eaa490a60af01169">&#9670;&nbsp;</a></span>close_deadline</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.close_deadline</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5e03724949e1dcb950b2c90d4c04122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e03724949e1dcb950b2c90d4c04122">&#9670;&nbsp;</a></span>close_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.close_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f8ba4dbebc20d54d6fd6880ce3d7ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8ba4dbebc20d54d6fd6880ce3d7ae5">&#9670;&nbsp;</a></span>debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.debug</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7203c993189aec262249beceb187419b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7203c993189aec262249beceb187419b">&#9670;&nbsp;</a></span>keepalive_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.keepalive_thread</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad995f76e894b44f572900d7514c6519e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad995f76e894b44f572900d7514c6519e">&#9670;&nbsp;</a></span>latency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.latency</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dfa441793993f0458166c83333f7613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfa441793993f0458166c83333f7613">&#9670;&nbsp;</a></span>max_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.max_queue</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a87feece00b082f049255dc7acc4817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a87feece00b082f049255dc7acc4817">&#9670;&nbsp;</a></span>ping_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.ping_interval</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b86af435eb4eb0db563fc8b3782333a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b86af435eb4eb0db563fc8b3782333a">&#9670;&nbsp;</a></span>ping_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.ping_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ef614d010a7321eb0955df984611c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef614d010a7321eb0955df984611c25">&#9670;&nbsp;</a></span>protocol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.protocol</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7984b8331391b08a7d4e4643d16c0b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7984b8331391b08a7d4e4643d16c0b4e">&#9670;&nbsp;</a></span>protocol_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.protocol_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afac084f871ae9cb14b063dade6bcfa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac084f871ae9cb14b063dade6bcfa41">&#9670;&nbsp;</a></span>recv_bufsize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int websockets.sync.connection.Connection.recv_bufsize = 65536</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3578a9126dbd410e22e5add5e2a8d0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3578a9126dbd410e22e5add5e2a8d0b9">&#9670;&nbsp;</a></span>recv_events_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.recv_events_thread</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34a3f2c03f149ce2b6dc81b535257fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a3f2c03f149ce2b6dc81b535257fb9">&#9670;&nbsp;</a></span>recv_exc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.recv_exc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b95794c81beb845bbfc8ddb16d6053e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b95794c81beb845bbfc8ddb16d6053e">&#9670;&nbsp;</a></span>recv_flow_control</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.recv_flow_control</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad52b2fb4c3c1ea2f64b76db4f94bf529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52b2fb4c3c1ea2f64b76db4f94bf529">&#9670;&nbsp;</a></span>recv_messages</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.recv_messages</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ed4eb683a44088a43f5839abd3fb457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed4eb683a44088a43f5839abd3fb457">&#9670;&nbsp;</a></span>send_in_progress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.send_in_progress</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72160e7c873b205c9d6a1af65d5f1b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72160e7c873b205c9d6a1af65d5f1b21">&#9670;&nbsp;</a></span>socket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.sync.connection.Connection.socket</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/websockets/sync/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2websockets_2sync_2connection_8py.html">connection.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
