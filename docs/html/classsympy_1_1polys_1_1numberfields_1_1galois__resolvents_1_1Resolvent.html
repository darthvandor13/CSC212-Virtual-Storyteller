<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.polys.numberfields.galois_resolvents.Resolvent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys.html">polys</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys_1_1numberfields.html">numberfields</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys_1_1numberfields_1_1galois__resolvents.html">galois_resolvents</a></li><li class="navelem"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html">Resolvent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sympy.polys.numberfields.galois_resolvents.Resolvent Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a8b4d3dcd2b160bad789933da0f6ca3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a4a8b4d3dcd2b160bad789933da0f6ca3">__init__</a> (self, <a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ad031b1d7c612d33e705d4e3bd90068cc">F</a>, <a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ad08d57d2efa90f61209d11b9738e4640">X</a>, <a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ae8ae1e48101d4b2b3bb01280861a2db3">s</a>)</td></tr>
<tr class="separator:a4a8b4d3dcd2b160bad789933da0f6ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51abab01bef5eb94a50221da43d88089"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a51abab01bef5eb94a50221da43d88089">get_prec</a> (self, M, target='coeffs')</td></tr>
<tr class="separator:a51abab01bef5eb94a50221da43d88089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00330222d943aa16e8b76d1e39673f7a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a00330222d943aa16e8b76d1e39673f7a">approximate_roots_of_poly</a> (self, T, target='coeffs')</td></tr>
<tr class="separator:a00330222d943aa16e8b76d1e39673f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a235e6ff343dc72e5a4caf36e43c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a2a3a235e6ff343dc72e5a4caf36e43c0">round_roots_to_integers_for_poly</a> (self, T)</td></tr>
<tr class="separator:a2a3a235e6ff343dc72e5a4caf36e43c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43aa6fdec4b81605099ef174984ea31b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a43aa6fdec4b81605099ef174984ea31b">eval_for_poly</a> (self, T, find_integer_root=False)</td></tr>
<tr class="separator:a43aa6fdec4b81605099ef174984ea31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b4d3dcd2b160bad789933da0f6ca3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a4a8b4d3dcd2b160bad789933da0f6ca3">__init__</a> (self, <a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ad031b1d7c612d33e705d4e3bd90068cc">F</a>, <a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ad08d57d2efa90f61209d11b9738e4640">X</a>, <a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ae8ae1e48101d4b2b3bb01280861a2db3">s</a>)</td></tr>
<tr class="separator:a4a8b4d3dcd2b160bad789933da0f6ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51abab01bef5eb94a50221da43d88089"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a51abab01bef5eb94a50221da43d88089">get_prec</a> (self, M, target='coeffs')</td></tr>
<tr class="separator:a51abab01bef5eb94a50221da43d88089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00330222d943aa16e8b76d1e39673f7a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a00330222d943aa16e8b76d1e39673f7a">approximate_roots_of_poly</a> (self, T, target='coeffs')</td></tr>
<tr class="separator:a00330222d943aa16e8b76d1e39673f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a235e6ff343dc72e5a4caf36e43c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a2a3a235e6ff343dc72e5a4caf36e43c0">round_roots_to_integers_for_poly</a> (self, T)</td></tr>
<tr class="separator:a2a3a235e6ff343dc72e5a4caf36e43c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43aa6fdec4b81605099ef174984ea31b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a43aa6fdec4b81605099ef174984ea31b">eval_for_poly</a> (self, T, find_integer_root=False)</td></tr>
<tr class="separator:a43aa6fdec4b81605099ef174984ea31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab276dbf95c053bc1e3c9678ce08bebee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ab276dbf95c053bc1e3c9678ce08bebee">round_mpf</a> (a)</td></tr>
<tr class="separator:ab276dbf95c053bc1e3c9678ce08bebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab276dbf95c053bc1e3c9678ce08bebee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ab276dbf95c053bc1e3c9678ce08bebee">round_mpf</a> (a)</td></tr>
<tr class="separator:ab276dbf95c053bc1e3c9678ce08bebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad031b1d7c612d33e705d4e3bd90068cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ad031b1d7c612d33e705d4e3bd90068cc">F</a></td></tr>
<tr class="separator:ad031b1d7c612d33e705d4e3bd90068cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08d57d2efa90f61209d11b9738e4640"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ad08d57d2efa90f61209d11b9738e4640">X</a></td></tr>
<tr class="separator:ad08d57d2efa90f61209d11b9738e4640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ae1e48101d4b2b3bb01280861a2db3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ae8ae1e48101d4b2b3bb01280861a2db3">s</a></td></tr>
<tr class="separator:ae8ae1e48101d4b2b3bb01280861a2db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe4fb4e24f7f4886d675b5c08537ae1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a4fe4fb4e24f7f4886d675b5c08537ae1">m</a></td></tr>
<tr class="separator:a4fe4fb4e24f7f4886d675b5c08537ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5625f9048e491b4feee95dc9292910f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#aa5625f9048e491b4feee95dc9292910f">t</a></td></tr>
<tr class="separator:aa5625f9048e491b4feee95dc9292910f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bea7eb3872fb84201e06e37f5ac268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a35bea7eb3872fb84201e06e37f5ac268">r</a></td></tr>
<tr class="separator:a35bea7eb3872fb84201e06e37f5ac268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4b5168d7f52f4467323838413f6507"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a9f4b5168d7f52f4467323838413f6507">coeff_prec_func</a></td></tr>
<tr class="separator:a9f4b5168d7f52f4467323838413f6507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33ccfd0228b5e0e5b23458b1e38aa9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#aa33ccfd0228b5e0e5b23458b1e38aa9b">root_prec_func</a></td></tr>
<tr class="separator:aa33ccfd0228b5e0e5b23458b1e38aa9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e0c55be1df5e6c91c57c64d783f356"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#a43e0c55be1df5e6c91c57c64d783f356">root_lambdas</a></td></tr>
<tr class="separator:a43e0c55be1df5e6c91c57c64d783f356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87fc71b502505854b3626378a5abc4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1polys_1_1numberfields_1_1galois__resolvents_1_1Resolvent.html#ae87fc71b502505854b3626378a5abc4f">esf_lambdas</a></td></tr>
<tr class="separator:ae87fc71b502505854b3626378a5abc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">If $G$ is a subgroup of the symmetric group $S_n$,
$F$ a multivariate polynomial in $\mathbb{Z}[X_1, \ldots, X_n]$,
$H$ the stabilizer of $F$ in $G$ (i.e. the permutations $\sigma$ such that
$F(X_{\sigma(1)}, \ldots, X_{\sigma(n)}) = F(X_1, \ldots, X_n)$), and $s$
a set of left coset representatives of $H$ in $G$, then the resolvent
polynomial $R(Y)$ is the product over $\sigma \in s$ of
$Y - F(X_{\sigma(1)}, \ldots, X_{\sigma(n)})$.

For example, consider the resolvent for the form
$$F = X_0 X_2 + X_1 X_3$$
and the group $G = S_4$. In this case, the stabilizer $H$ is the dihedral
group $D4 = &lt; (0123), (02) &gt;$, and a set of representatives of $G/H$ is
$\{I, (01), (03)\}$. The resolvent can be constructed as follows:

&gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation
&gt;&gt;&gt; from sympy.core.symbol import symbols
&gt;&gt;&gt; from sympy.polys.numberfields.galoisgroups import Resolvent
&gt;&gt;&gt; X = symbols('X0 X1 X2 X3')
&gt;&gt;&gt; F = X[0]*X[2] + X[1]*X[3]
&gt;&gt;&gt; s = [Permutation([0, 1, 2, 3]), Permutation([1, 0, 2, 3]),
... Permutation([3, 1, 2, 0])]
&gt;&gt;&gt; R = Resolvent(F, X, s)

This resolvent has three roots, which are the conjugates of ``F`` under the
three permutations in ``s``:

&gt;&gt;&gt; R.root_lambdas[0](*X)
X0*X2 + X1*X3
&gt;&gt;&gt; R.root_lambdas[1](*X)
X0*X3 + X1*X2
&gt;&gt;&gt; R.root_lambdas[2](*X)
X0*X1 + X2*X3

Resolvents are useful for computing Galois groups. Given a polynomial $T$
of degree $n$, we will use a resolvent $R$ where $Gal(T) \leq G \leq S_n$.
We will then want to substitute the roots of $T$ for the variables $X_i$
in $R$, and study things like the discriminant of $R$, and the way $R$
factors over $\mathbb{Q}$.

From the symmetry in $R$'s construction, and since $Gal(T) \leq G$, we know
from Galois theory that the coefficients of $R$ must lie in $\mathbb{Z}$.
This allows us to compute the coefficients of $R$ by approximating the
roots of $T$ to sufficient precision, plugging these values in for the
variables $X_i$ in the coefficient expressions of $R$, and then simply
rounding to the nearest integer.

In order to determine a sufficient precision for the roots of $T$, this
``Resolvent`` class imposes certain requirements on the form ``F``. It
could be possible to design a different ``Resolvent`` class, that made
different precision estimates, and different assumptions about ``F``.

``F`` must be homogeneous, and all terms must have unit coefficient.
Furthermore, if $r$ is the number of terms in ``F``, and $t$ the total
degree, and if $m$ is the number of conjugates of ``F``, i.e. the number
of permutations in ``s``, then we require that $m &lt; r 2^t$. Again, it is
not impossible to work with forms ``F`` that violate these assumptions, but
this ``Resolvent`` class requires them.

Since determining the integer coefficients of the resolvent for a given
polynomial $T$ is one of the main problems this class solves, we take some
time to explain the precision bounds it uses.

The general problem is:
Given a multivariate polynomial $P \in \mathbb{Z}[X_1, \ldots, X_n]$, and a
bound $M \in \mathbb{R}_+$, compute an $\varepsilon &gt; 0$ such that for any
complex numbers $a_1, \ldots, a_n$ with $|a_i| &lt; M$, if the $a_i$ are
approximated to within an accuracy of $\varepsilon$ by $b_i$, that is,
$|a_i - b_i| &lt; \varepsilon$ for $i = 1, \ldots, n$, then
$|P(a_1, \ldots, a_n) - P(b_1, \ldots, b_n)| &lt; 1/2$. In other words, if it
is known that $P(a_1, \ldots, a_n) = c$ for some $c \in \mathbb{Z}$, then
$P(b_1, \ldots, b_n)$ can be rounded to the nearest integer in order to
determine $c$.

To derive our error bound, consider the monomial $xyz$. Defining
$d_i = b_i - a_i$, our error is
$|(a_1 + d_1)(a_2 + d_2)(a_3 + d_3) - a_1 a_2 a_3|$, which is bounded
above by $|(M + \varepsilon)^3 - M^3|$. Passing to a general monomial of
total degree $t$, this expression is bounded by
$M^{t-1}\varepsilon(t + 2^t\varepsilon/M)$ provided $\varepsilon &lt; M$,
and by $(t+1)M^{t-1}\varepsilon$ provided $\varepsilon &lt; M/2^t$.
But since our goal is to make the error less than $1/2$, we will choose
$\varepsilon &lt; 1/(2(t+1)M^{t-1})$, which implies the condition that
$\varepsilon &lt; M/2^t$, as long as $M \geq 2$.

Passing from the general monomial to the general polynomial is easy, by
scaling and summing error bounds.

In our specific case, we are given a homogeneous polynomial $F$ of
$r$ terms and total degree $t$, all of whose coefficients are $\pm 1$. We
are given the $m$ permutations that make the conjugates of $F$, and
we want to bound the error in the coefficients of the monic polynomial
$R(Y)$ having $F$ and its conjugates as roots (i.e. the resolvent).

For $j$ from $1$ to $m$, the coefficient of $Y^{m-j}$ in $R(Y)$ is the
$j$th elementary symmetric polynomial in the conjugates of $F$. This sums
the products of these conjugates, taken $j$ at a time, in all possible
combinations. There are $\binom{m}{j}$ such combinations, and each product
of $j$ conjugates of $F$ expands to a sum of $r^j$ terms, each of unit
coefficient, and total degree $jt$. An error bound for the $j$th coeff of
$R$ is therefore
$$\binom{m}{j} r^j (jt + 1) M^{jt - 1} \varepsilon$$
When our goal is to evaluate all the coefficients of $R$, we will want to
use the maximum of these error bounds. It is clear that this bound is
strictly increasing for $j$ up to the ceiling of $m/2$. After that point,
the first factor $\binom{m}{j}$ begins to decrease, while the others
continue to increase. However, the binomial coefficient never falls by more
than a factor of $1/m$ at a time, so our assumptions that $M \geq 2$ and
$m &lt; r 2^t$ are enough to tell us that the constant coefficient of $R$,
i.e. that where $j = m$, has the largest error bound. Therefore we can use
$$r^m (mt + 1) M^{mt - 1} \varepsilon$$
as our error bound for all the coefficients.

Note that this bound is also (more than) adequate to determine whether any
of the roots of $R$ is an integer. Each of these roots is a single
conjugate of $F$, which contains less error than the trace, i.e. the
coefficient of $Y^{m - 1}$. By rounding the roots of $R$ to the nearest
integers, we therefore get all the candidates for integer roots of $R$. By
plugging these candidates into $R$, we can check whether any of them
actually is a root.

Note: We take the definition of resolvent from Cohen, but the error bound
is ours.

References
==========

.. [1] Cohen, H. *A Course in Computational Algebraic Number Theory*.
   (Def 6.3.2)</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4a8b4d3dcd2b160bad789933da0f6ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8b4d3dcd2b160bad789933da0f6ca3">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

F : :py:class:`~.Expr`
    polynomial in the symbols in *X*
X : list of :py:class:`~.Symbol`
s : list of :py:class:`~.Permutation`
    representing the cosets of the stabilizer of *F* in
    some subgroup $G$ of $S_n$, where $n$ is the length of *X*.
</pre> 
</div>
</div>
<a id="a4a8b4d3dcd2b160bad789933da0f6ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8b4d3dcd2b160bad789933da0f6ca3">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
==========

F : :py:class:`~.Expr`
    polynomial in the symbols in *X*
X : list of :py:class:`~.Symbol`
s : list of :py:class:`~.Permutation`
    representing the cosets of the stabilizer of *F* in
    some subgroup $G$ of $S_n$, where $n$ is the length of *X*.
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a00330222d943aa16e8b76d1e39673f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00330222d943aa16e8b76d1e39673f7a">&#9670;&nbsp;</a></span>approximate_roots_of_poly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.approximate_roots_of_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>'coeffs'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Approximate the roots of a given polynomial *T* to sufficient precision
in order to evaluate this resolvent's coefficients, or determine
whether the resolvent has an integer root.

Parameters
==========

T : :py:class:`~.Poly`

target : str, 'coeffs' or 'roots', default='coeffs'
    Set the approximation precision to be sufficient for the desired
    task, which is either determining the coefficients of the resolvent
    ('coeffs') or determining its possible integer roots ('roots').
    The latter may require significantly lower precision.

Returns
=======

list of elements of :ref:`CC`</pre> 
</div>
</div>
<a id="a00330222d943aa16e8b76d1e39673f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00330222d943aa16e8b76d1e39673f7a">&#9670;&nbsp;</a></span>approximate_roots_of_poly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.approximate_roots_of_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>'coeffs'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Approximate the roots of a given polynomial *T* to sufficient precision
in order to evaluate this resolvent's coefficients, or determine
whether the resolvent has an integer root.

Parameters
==========

T : :py:class:`~.Poly`

target : str, 'coeffs' or 'roots', default='coeffs'
    Set the approximation precision to be sufficient for the desired
    task, which is either determining the coefficients of the resolvent
    ('coeffs') or determining its possible integer roots ('roots').
    The latter may require significantly lower precision.

Returns
=======

list of elements of :ref:`CC`</pre> 
</div>
</div>
<a id="a43aa6fdec4b81605099ef174984ea31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43aa6fdec4b81605099ef174984ea31b">&#9670;&nbsp;</a></span>eval_for_poly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.eval_for_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>find_integer_root</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the integer values of the coefficients of this resolvent, when
plugging in the roots of a given polynomial.

Parameters
==========

T : :py:class:`~.Poly`

find_integer_root : ``bool``, default ``False``
    If ``True``, then also determine whether the resolvent has an
    integer root, and return the first one found, along with its
    index, i.e. the index of the permutation ``self.s[i]`` it
    corresponds to.

Returns
=======

Tuple ``(R, a, i)``

    ``R`` is this resolvent as a dense univariate polynomial over
    :ref:`ZZ`, i.e. a list of :ref:`ZZ`.

    If *find_integer_root* was ``True``, then ``a`` and ``i`` are the
    first integer root found, and its index, if one exists.
    Otherwise ``a`` and ``i`` are both ``None``.</pre> 
</div>
</div>
<a id="a43aa6fdec4b81605099ef174984ea31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43aa6fdec4b81605099ef174984ea31b">&#9670;&nbsp;</a></span>eval_for_poly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.eval_for_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>find_integer_root</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the integer values of the coefficients of this resolvent, when
plugging in the roots of a given polynomial.

Parameters
==========

T : :py:class:`~.Poly`

find_integer_root : ``bool``, default ``False``
    If ``True``, then also determine whether the resolvent has an
    integer root, and return the first one found, along with its
    index, i.e. the index of the permutation ``self.s[i]`` it
    corresponds to.

Returns
=======

Tuple ``(R, a, i)``

    ``R`` is this resolvent as a dense univariate polynomial over
    :ref:`ZZ`, i.e. a list of :ref:`ZZ`.

    If *find_integer_root* was ``True``, then ``a`` and ``i`` are the
    first integer root found, and its index, if one exists.
    Otherwise ``a`` and ``i`` are both ``None``.</pre> 
</div>
</div>
<a id="a51abab01bef5eb94a50221da43d88089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51abab01bef5eb94a50221da43d88089">&#9670;&nbsp;</a></span>get_prec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.get_prec </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>'coeffs'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a given upper bound *M* on the magnitude of the complex numbers to
be plugged in for this resolvent's symbols, compute a sufficient
precision for evaluating those complex numbers, such that the
coefficients, or the integer roots, of the resolvent can be determined.

Parameters
==========

M : real number
    Upper bound on magnitude of the complex numbers to be plugged in.

target : str, 'coeffs' or 'roots', default='coeffs'
    Name the task for which a sufficient precision is desired.
    This is either determining the coefficients of the resolvent
    ('coeffs') or determining its possible integer roots ('roots').
    The latter may require significantly lower precision.

Returns
=======

int $m$
    such that $2^{-m}$ is a sufficient upper bound on the
    error in approximating the complex numbers to be plugged in.</pre> 
</div>
</div>
<a id="a51abab01bef5eb94a50221da43d88089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51abab01bef5eb94a50221da43d88089">&#9670;&nbsp;</a></span>get_prec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.get_prec </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>'coeffs'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a given upper bound *M* on the magnitude of the complex numbers to
be plugged in for this resolvent's symbols, compute a sufficient
precision for evaluating those complex numbers, such that the
coefficients, or the integer roots, of the resolvent can be determined.

Parameters
==========

M : real number
    Upper bound on magnitude of the complex numbers to be plugged in.

target : str, 'coeffs' or 'roots', default='coeffs'
    Name the task for which a sufficient precision is desired.
    This is either determining the coefficients of the resolvent
    ('coeffs') or determining its possible integer roots ('roots').
    The latter may require significantly lower precision.

Returns
=======

int $m$
    such that $2^{-m}$ is a sufficient upper bound on the
    error in approximating the complex numbers to be plugged in.</pre> 
</div>
</div>
<a id="ab276dbf95c053bc1e3c9678ce08bebee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab276dbf95c053bc1e3c9678ce08bebee">&#9670;&nbsp;</a></span>round_mpf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.round_mpf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab276dbf95c053bc1e3c9678ce08bebee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab276dbf95c053bc1e3c9678ce08bebee">&#9670;&nbsp;</a></span>round_mpf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.round_mpf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a3a235e6ff343dc72e5a4caf36e43c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3a235e6ff343dc72e5a4caf36e43c0">&#9670;&nbsp;</a></span>round_roots_to_integers_for_poly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.round_roots_to_integers_for_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a given polynomial *T*, round the roots of this resolvent to the
nearest integers.

Explanation
===========

None of the integers returned by this method is guaranteed to be a
root of the resolvent; however, if the resolvent has any integer roots
(for the given polynomial *T*), then they must be among these.

If the coefficients of the resolvent are also desired, then this method
should not be used. Instead, use the ``eval_for_poly`` method. This
method may be significantly faster than ``eval_for_poly``.

Parameters
==========

T : :py:class:`~.Poly`

Returns
=======

dict
    Keys are the indices of those permutations in ``self.s`` such that
    the corresponding root did round to a rational integer.

    Values are :ref:`ZZ`.</pre> 
</div>
</div>
<a id="a2a3a235e6ff343dc72e5a4caf36e43c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3a235e6ff343dc72e5a4caf36e43c0">&#9670;&nbsp;</a></span>round_roots_to_integers_for_poly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.numberfields.galois_resolvents.Resolvent.round_roots_to_integers_for_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For a given polynomial *T*, round the roots of this resolvent to the
nearest integers.

Explanation
===========

None of the integers returned by this method is guaranteed to be a
root of the resolvent; however, if the resolvent has any integer roots
(for the given polynomial *T*), then they must be among these.

If the coefficients of the resolvent are also desired, then this method
should not be used. Instead, use the ``eval_for_poly`` method. This
method may be significantly faster than ``eval_for_poly``.

Parameters
==========

T : :py:class:`~.Poly`

Returns
=======

dict
    Keys are the indices of those permutations in ``self.s`` such that
    the corresponding root did round to a rational integer.

    Values are :ref:`ZZ`.</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9f4b5168d7f52f4467323838413f6507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4b5168d7f52f4467323838413f6507">&#9670;&nbsp;</a></span>coeff_prec_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.coeff_prec_func</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae87fc71b502505854b3626378a5abc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87fc71b502505854b3626378a5abc4f">&#9670;&nbsp;</a></span>esf_lambdas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.esf_lambdas</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad031b1d7c612d33e705d4e3bd90068cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad031b1d7c612d33e705d4e3bd90068cc">&#9670;&nbsp;</a></span>F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.F</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fe4fb4e24f7f4886d675b5c08537ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe4fb4e24f7f4886d675b5c08537ae1">&#9670;&nbsp;</a></span>m</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.m</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35bea7eb3872fb84201e06e37f5ac268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bea7eb3872fb84201e06e37f5ac268">&#9670;&nbsp;</a></span>r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.r</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43e0c55be1df5e6c91c57c64d783f356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e0c55be1df5e6c91c57c64d783f356">&#9670;&nbsp;</a></span>root_lambdas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.root_lambdas</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa33ccfd0228b5e0e5b23458b1e38aa9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33ccfd0228b5e0e5b23458b1e38aa9b">&#9670;&nbsp;</a></span>root_prec_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.root_prec_func</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8ae1e48101d4b2b3bb01280861a2db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ae1e48101d4b2b3bb01280861a2db3">&#9670;&nbsp;</a></span>s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.s</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5625f9048e491b4feee95dc9292910f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5625f9048e491b4feee95dc9292910f">&#9670;&nbsp;</a></span>t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad08d57d2efa90f61209d11b9738e4640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08d57d2efa90f61209d11b9738e4640">&#9670;&nbsp;</a></span>X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.polys.numberfields.galois_resolvents.Resolvent.X</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/sympy/polys/numberfields/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2sympy_2polys_2numberfields_2galois__resolvents_8py.html">galois_resolvents.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
