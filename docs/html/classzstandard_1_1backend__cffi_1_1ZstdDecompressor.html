<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: zstandard.backend_cffi.ZstdDecompressor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacezstandard.html">zstandard</a></li><li class="navelem"><a class="el" href="namespacezstandard_1_1backend__cffi.html">backend_cffi</a></li><li class="navelem"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html">ZstdDecompressor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">zstandard.backend_cffi.ZstdDecompressor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for zstandard.backend_cffi.ZstdDecompressor:</div>
<div class="dyncontent">
<div class="center"><img src="classzstandard_1_1backend__cffi_1_1ZstdDecompressor__inherit__graph.png" border="0" usemap="#azstandard_8backend__cffi_8ZstdDecompressor_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for zstandard.backend_cffi.ZstdDecompressor:</div>
<div class="dyncontent">
<div class="center"><img src="classzstandard_1_1backend__cffi_1_1ZstdDecompressor__coll__graph.png" border="0" usemap="#azstandard_8backend__cffi_8ZstdDecompressor_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86c09741680d697fe89775655fdb8fc7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#a86c09741680d697fe89775655fdb8fc7">__init__</a> (self, dict_data=None, max_window_size=0, format=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a4ac607f43cf12fbf4117f6ebd59db085">FORMAT_ZSTD1</a>)</td></tr>
<tr class="separator:a86c09741680d697fe89775655fdb8fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa483251c95d31450d27917e555ac9dc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#aaa483251c95d31450d27917e555ac9dc">memory_size</a> (self)</td></tr>
<tr class="separator:aaa483251c95d31450d27917e555ac9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0142f8e11c12ea5658aa7afd27c792"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#a3a0142f8e11c12ea5658aa7afd27c792">decompress</a> (self, data, max_output_size=0, read_across_frames=False, allow_extra_data=True)</td></tr>
<tr class="separator:a3a0142f8e11c12ea5658aa7afd27c792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d636d9579e9e285bbde39c1d43c286a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#a7d636d9579e9e285bbde39c1d43c286a">stream_reader</a> (self, source, read_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#aaa147f4abe9c8e0c0685935adf6542e2">DECOMPRESSION_RECOMMENDED_INPUT_SIZE</a>, read_across_frames=False, closefd=True)</td></tr>
<tr class="separator:a7d636d9579e9e285bbde39c1d43c286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b06012aba4ff7d05a4f59d0baedfd8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#ae6b06012aba4ff7d05a4f59d0baedfd8">decompressobj</a> (self, write_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a435e8fc1cb49296958c78abbf74bfdc3">DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE</a>, read_across_frames=False)</td></tr>
<tr class="separator:ae6b06012aba4ff7d05a4f59d0baedfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f62bc77072a26441d66cd9e2b32ce4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#a3f62bc77072a26441d66cd9e2b32ce4e">read_to_iter</a> (self, reader, read_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#aaa147f4abe9c8e0c0685935adf6542e2">DECOMPRESSION_RECOMMENDED_INPUT_SIZE</a>, write_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a435e8fc1cb49296958c78abbf74bfdc3">DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE</a>, skip_bytes=0)</td></tr>
<tr class="separator:a3f62bc77072a26441d66cd9e2b32ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ead044a460434de8068b89a72793a41"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#a2ead044a460434de8068b89a72793a41">stream_writer</a> (self, writer, write_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a435e8fc1cb49296958c78abbf74bfdc3">DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE</a>, write_return_read=True, closefd=True)</td></tr>
<tr class="separator:a2ead044a460434de8068b89a72793a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9496276b4d864c69d13e202b753be047"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#a9496276b4d864c69d13e202b753be047">copy_stream</a> (self, ifh, ofh, read_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#aaa147f4abe9c8e0c0685935adf6542e2">DECOMPRESSION_RECOMMENDED_INPUT_SIZE</a>, write_size=<a class="el" href="namespacezstandard_1_1backend__cffi.html#a435e8fc1cb49296958c78abbf74bfdc3">DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE</a>)</td></tr>
<tr class="separator:a9496276b4d864c69d13e202b753be047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a09e2a836b13a70c8ccf1e20eceef9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#ae4a09e2a836b13a70c8ccf1e20eceef9">decompress_content_dict_chain</a> (self, frames)</td></tr>
<tr class="separator:ae4a09e2a836b13a70c8ccf1e20eceef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dd4373d14c1331d207b31915b1e1e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzstandard_1_1backend__cffi_1_1ZstdDecompressor.html#a08dd4373d14c1331d207b31915b1e1e7">multi_decompress_to_buffer</a> (self, frames, decompressed_sizes=None, threads=0)</td></tr>
<tr class="separator:a08dd4373d14c1331d207b31915b1e1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Context for performing zstandard decompression.

Each instance is essentially a wrapper around a ``ZSTD_DCtx`` from zstd's
C API.

An instance can compress data various ways. Instances can be used multiple
times.

The interface of this class is very similar to
:py:class:`zstandard.ZstdCompressor` (by design).

Assume that each ``ZstdDecompressor`` instance can only handle a single
logical compression operation at the same time. i.e. if you call a method
like ``decompressobj()`` to obtain multiple objects derived from the same
``ZstdDecompressor`` instance and attempt to use them simultaneously, errors
will likely occur.

If you need to perform multiple logical decompression operations and you
can't guarantee those operations are temporally non-overlapping, you need
to obtain multiple ``ZstdDecompressor`` instances.

Unless specified otherwise, assume that no two methods of
``ZstdDecompressor`` instances can be called from multiple Python
threads simultaneously. In other words, assume instances are not thread safe
unless stated otherwise.

:param dict_data:
   Compression dictionary to use.
:param max_window_size:
   Sets an upper limit on the window size for decompression operations in
   kibibytes. This setting can be used to prevent large memory allocations
   for inputs using large compression windows.
:param format:
   Set the format of data for the decoder.

   By default this is ``zstandard.FORMAT_ZSTD1``. It can be set to
   ``zstandard.FORMAT_ZSTD1_MAGICLESS`` to allow decoding frames without
   the 4 byte magic header. Not all decompression APIs support this mode.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a86c09741680d697fe89775655fdb8fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c09741680d697fe89775655fdb8fc7">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dict_data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_window_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a4ac607f43cf12fbf4117f6ebd59db085">FORMAT_ZSTD1</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9496276b4d864c69d13e202b753be047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9496276b4d864c69d13e202b753be047">&#9670;&nbsp;</a></span>copy_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.copy_stream </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ifh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ofh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#aaa147f4abe9c8e0c0685935adf6542e2">DECOMPRESSION_RECOMMENDED_INPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a435e8fc1cb49296958c78abbf74bfdc3">DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Copy data between streams, decompressing in the process.

Compressed data will be read from ``ifh``, decompressed, and written
to ``ofh``.

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; dctx.copy_stream(ifh, ofh)

e.g. to decompress a file to another file:

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; with open(input_path, 'rb') as ifh, open(output_path, 'wb') as ofh:
...     dctx.copy_stream(ifh, ofh)

The size of chunks being ``read()`` and ``write()`` from and to the
streams can be specified:

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; dctx.copy_stream(ifh, ofh, read_size=8192, write_size=16384)

:param ifh:
   Source stream to read compressed data from.

   Must have a ``read()`` method.
:param ofh:
   Destination stream to write uncompressed data to.

   Must have a ``write()`` method.
:param read_size:
   The number of bytes to ``read()`` from the source in a single
   operation.
:param write_size:
   The number of bytes to ``write()`` to the destination in a single
   operation.
:return:
   2-tuple of integers representing the number of bytes read and
   written, respectively.
</pre> 
</div>
</div>
<a id="a3a0142f8e11c12ea5658aa7afd27c792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0142f8e11c12ea5658aa7afd27c792">&#9670;&nbsp;</a></span>decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.decompress </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_output_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_across_frames</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_extra_data</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decompress data in a single operation.

This method will decompress the input data in a single operation and
return the decompressed data.

The input bytes are expected to contain at least 1 full Zstandard frame
(something compressed with :py:meth:`ZstdCompressor.compress` or
similar). If the input does not contain a full frame, an exception will
be raised.

``read_across_frames`` controls whether to read multiple zstandard
frames in the input. When False, decompression stops after reading the
first frame. This feature is not yet implemented but the argument is
provided for forward API compatibility when the default is changed to
True in a future release. For now, if you need to decompress multiple
frames, use an API like :py:meth:`ZstdCompressor.stream_reader` with
``read_across_frames=True``.

``allow_extra_data`` controls how to handle extra input data after a
fully decoded frame. If False, any extra data (which could be a valid
zstd frame) will result in ``ZstdError`` being raised. If True, extra
data is silently ignored. The default will likely change to False in a
future release when ``read_across_frames`` defaults to True.

If the input contains extra data after a full frame, that extra input
data is silently ignored. This behavior is undesirable in many scenarios
and will likely be changed or controllable in a future release (see
#181).

If the frame header of the compressed data does not contain the content
size, ``max_output_size`` must be specified or ``ZstdError`` will be
raised. An allocation of size ``max_output_size`` will be performed and an
attempt will be made to perform decompression into that buffer. If the
buffer is too small or cannot be allocated, ``ZstdError`` will be
raised. The buffer will be resized if it is too large.

Uncompressed data could be much larger than compressed data. As a result,
calling this function could result in a very large memory allocation
being performed to hold the uncompressed data. This could potentially
result in ``MemoryError`` or system memory swapping. If you don't need
the full output data in a single contiguous array in memory, consider
using streaming decompression for more resilient memory behavior.

Usage:

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; decompressed = dctx.decompress(data)

If the compressed data doesn't have its content size embedded within it,
decompression can be attempted by specifying the ``max_output_size``
argument:

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; uncompressed = dctx.decompress(data, max_output_size=1048576)

Ideally, ``max_output_size`` will be identical to the decompressed
output size.

.. important::

   If the exact size of decompressed data is unknown (not passed in
   explicitly and not stored in the zstd frame), for performance
   reasons it is encouraged to use a streaming API.

:param data:
   Compressed data to decompress.
:param max_output_size:
   Integer max size of response.

   If ``0``, there is no limit and we can attempt to allocate an output
   buffer of infinite size.
:return:
   ``bytes`` representing decompressed output.
</pre> 
</div>
</div>
<a id="ae4a09e2a836b13a70c8ccf1e20eceef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a09e2a836b13a70c8ccf1e20eceef9">&#9670;&nbsp;</a></span>decompress_content_dict_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.decompress_content_dict_chain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decompress a series of frames using the content dictionary chaining technique.

Such a list of frames is produced by compressing discrete inputs where
each non-initial input is compressed with a *prefix* dictionary consisting
of the content of the previous input.

For example, say you have the following inputs:

&gt;&gt;&gt; inputs = [b"input 1", b"input 2", b"input 3"]

The zstd frame chain consists of:

1. ``b"input 1"`` compressed in standalone/discrete mode
2. ``b"input 2"`` compressed using ``b"input 1"`` as a *prefix* dictionary
3. ``b"input 3"`` compressed using ``b"input 2"`` as a *prefix* dictionary

Each zstd frame **must** have the content size written.

The following Python code can be used to produce a *prefix dictionary chain*:

&gt;&gt;&gt; def make_chain(inputs):
...    frames = []
...
...    # First frame is compressed in standalone/discrete mode.
...    zctx = zstandard.ZstdCompressor()
...    frames.append(zctx.compress(inputs[0]))
...
...    # Subsequent frames use the previous fulltext as a prefix dictionary
...    for i, raw in enumerate(inputs[1:]):
...        dict_data = zstandard.ZstdCompressionDict(
...            inputs[i], dict_type=zstandard.DICT_TYPE_RAWCONTENT)
...        zctx = zstandard.ZstdCompressor(dict_data=dict_data)
...        frames.append(zctx.compress(raw))
...
...    return frames

``decompress_content_dict_chain()`` returns the uncompressed data of the last
element in the input chain.

.. note::

   It is possible to implement *prefix dictionary chain* decompression
   on top of other APIs. However, this function will likely be faster -
   especially for long input chains - as it avoids the overhead of
   instantiating and passing around intermediate objects between
   multiple functions.

:param frames:
   List of ``bytes`` holding compressed zstd frames.
:return:
</pre> 
</div>
</div>
<a id="ae6b06012aba4ff7d05a4f59d0baedfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b06012aba4ff7d05a4f59d0baedfd8">&#9670;&nbsp;</a></span>decompressobj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.decompressobj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a435e8fc1cb49296958c78abbf74bfdc3">DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_across_frames</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Obtain a standard library compatible incremental decompressor.

See :py:class:`ZstdDecompressionObj` for more documentation
and usage examples.

:param write_size: size of internal output buffer to collect decompressed
  chunks in.
:param read_across_frames: whether to read across multiple zstd frames.
  If False, reading stops after 1 frame and subsequent decompress
  attempts will raise an exception.
:return:
   :py:class:`zstandard.ZstdDecompressionObj`
</pre> 
</div>
</div>
<a id="aaa483251c95d31450d27917e555ac9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa483251c95d31450d27917e555ac9dc">&#9670;&nbsp;</a></span>memory_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.memory_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Size of decompression context, in bytes.

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; size = dctx.memory_size()
</pre> 
</div>
</div>
<a id="a08dd4373d14c1331d207b31915b1e1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dd4373d14c1331d207b31915b1e1e7">&#9670;&nbsp;</a></span>multi_decompress_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.multi_decompress_to_buffer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>decompressed_sizes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decompress multiple zstd frames to output buffers as a single operation.

(Experimental. Not available in CFFI backend.)

Compressed frames can be passed to the function as a
``BufferWithSegments``, a ``BufferWithSegmentsCollection``, or as a
list containing objects that conform to the buffer protocol. For best
performance, pass a ``BufferWithSegmentsCollection`` or a
``BufferWithSegments``, as minimal input validation will be done for
that type. If calling from Python (as opposed to C), constructing one
of these instances may add overhead cancelling out the performance
overhead of validation for list inputs.

Returns a ``BufferWithSegmentsCollection`` containing the decompressed
data. All decompressed data is allocated in a single memory buffer. The
``BufferWithSegments`` instance tracks which objects are at which offsets
and their respective lengths.

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; results = dctx.multi_decompress_to_buffer([b'...', b'...'])

The decompressed size of each frame MUST be discoverable. It can either be
embedded within the zstd frame or passed in via the ``decompressed_sizes``
argument.

The ``decompressed_sizes`` argument is an object conforming to the buffer
protocol which holds an array of 64-bit unsigned integers in the machine's
native format defining the decompressed sizes of each frame. If this argument
is passed, it avoids having to scan each frame for its decompressed size.
This frame scanning can add noticeable overhead in some scenarios.

&gt;&gt;&gt; frames = [...]
&gt;&gt;&gt; sizes = struct.pack('=QQQQ', len0, len1, len2, len3)
&gt;&gt;&gt;
&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; results = dctx.multi_decompress_to_buffer(frames, decompressed_sizes=sizes)

.. note::

   It is possible to pass a ``mmap.mmap()`` instance into this function by
   wrapping it with a ``BufferWithSegments`` instance (which will define the
   offsets of frames within the memory mapped region).

This function is logically equivalent to performing
:py:meth:`ZstdCompressor.decompress` on each input frame and returning the
result.

This function exists to perform decompression on multiple frames as fast
as possible by having as little overhead as possible. Since decompression is
performed as a single operation and since the decompressed output is stored in
a single buffer, extra memory allocations, Python objects, and Python function
calls are avoided. This is ideal for scenarios where callers know up front that
they need to access data for multiple frames, such as when  *delta chains* are
being used.

Currently, the implementation always spawns multiple threads when requested,
even if the amount of work to do is small. In the future, it will be smarter
about avoiding threads and their associated overhead when the amount of
work to do is small.

:param frames:
   Source defining zstd frames to decompress.
:param decompressed_sizes:
   Array of integers representing sizes of decompressed zstd frames.
:param threads:
   How many threads to use for decompression operations.

   Negative values will use the same number of threads as logical CPUs
   on the machine. Values ``0`` or ``1`` use a single thread.
:return:
   ``BufferWithSegmentsCollection``
</pre> 
</div>
</div>
<a id="a3f62bc77072a26441d66cd9e2b32ce4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f62bc77072a26441d66cd9e2b32ce4e">&#9670;&nbsp;</a></span>read_to_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.read_to_iter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#aaa147f4abe9c8e0c0685935adf6542e2">DECOMPRESSION_RECOMMENDED_INPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a435e8fc1cb49296958c78abbf74bfdc3">DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skip_bytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read compressed data to an iterator of uncompressed chunks.

This method will read data from ``reader``, feed it to a decompressor,
and emit ``bytes`` chunks representing the decompressed result.

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; for chunk in dctx.read_to_iter(fh):
...     # Do something with original data.

``read_to_iter()`` accepts an object with a ``read(size)`` method that
will return compressed bytes or an object conforming to the buffer
protocol.

``read_to_iter()`` returns an iterator whose elements are chunks of the
decompressed data.

The size of requested ``read()`` from the source can be specified:

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; for chunk in dctx.read_to_iter(fh, read_size=16384):
...    pass

It is also possible to skip leading bytes in the input data:

&gt;&gt;&gt; dctx = zstandard.ZstdDecompressor()
&gt;&gt;&gt; for chunk in dctx.read_to_iter(fh, skip_bytes=1):
...    pass

.. tip::

   Skipping leading bytes is useful if the source data contains extra
   *header* data. Traditionally, you would need to create a slice or
   ``memoryview`` of the data you want to decompress. This would create
   overhead. It is more efficient to pass the offset into this API.

Similarly to :py:meth:`ZstdCompressor.read_to_iter`, the consumer of the
iterator controls when data is decompressed. If the iterator isn't consumed,
decompression is put on hold.

When ``read_to_iter()`` is passed an object conforming to the buffer protocol,
the behavior may seem similar to what occurs when the simple decompression
API is used. However, this API works when the decompressed size is unknown.
Furthermore, if feeding large inputs, the decompressor will work in chunks
instead of performing a single operation.

:param reader:
   Source of compressed data. Can be any object with a
   ``read(size)`` method or any object conforming to the buffer
   protocol.
:param read_size:
   Integer size of data chunks to read from ``reader`` and feed into
   the decompressor.
:param write_size:
   Integer size of data chunks to emit from iterator.
:param skip_bytes:
   Integer number of bytes to skip over before sending data into
   the decompressor.
:return:
   Iterator of ``bytes`` representing uncompressed data.
</pre> 
</div>
</div>
<a id="a7d636d9579e9e285bbde39c1d43c286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d636d9579e9e285bbde39c1d43c286a">&#9670;&nbsp;</a></span>stream_reader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.stream_reader </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#aaa147f4abe9c8e0c0685935adf6542e2">DECOMPRESSION_RECOMMENDED_INPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_across_frames</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>closefd</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read-only stream wrapper that performs decompression.

This method obtains an object that conforms to the ``io.RawIOBase``
interface and performs transparent decompression via ``read()``
operations. Source data is obtained by calling ``read()`` on a
source stream or object implementing the buffer protocol.

See :py:class:`zstandard.ZstdDecompressionReader` for more documentation
and usage examples.

:param source:
   Source of compressed data to decompress. Can be any object
   with a ``read(size)`` method or that conforms to the buffer protocol.
:param read_size:
   Integer number of bytes to read from the source and feed into the
   compressor at a time.
:param read_across_frames:
   Whether to read data across multiple zstd frames. If False,
   decompression is stopped at frame boundaries.
:param closefd:
   Whether to close the source stream when this instance is closed.
:return:
   :py:class:`zstandard.ZstdDecompressionReader`.
</pre> 
</div>
</div>
<a id="a2ead044a460434de8068b89a72793a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ead044a460434de8068b89a72793a41">&#9670;&nbsp;</a></span>stream_writer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def zstandard.backend_cffi.ZstdDecompressor.stream_writer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_size</em> = <code><a class="el" href="namespacezstandard_1_1backend__cffi.html#a435e8fc1cb49296958c78abbf74bfdc3">DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_return_read</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>closefd</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Push-based stream wrapper that performs decompression.

This method constructs a stream wrapper that conforms to the
``io.RawIOBase`` interface and performs transparent decompression
when writing to a wrapper stream.

See :py:class:`zstandard.ZstdDecompressionWriter` for more documentation
and usage examples.

:param writer:
   Destination for decompressed output. Can be any object with a
   ``write(data)``.
:param write_size:
   Integer size of chunks to ``write()`` to ``writer``.
:param write_return_read:
   Whether ``write()`` should return the number of bytes of input
   consumed. If False, ``write()`` returns the number of bytes sent
   to the inner stream.
:param closefd:
   Whether to ``close()`` the inner stream when this stream is closed.
:return:
   :py:class:`zstandard.ZstdDecompressionWriter`
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>py3_env/lib/python3.10/site-packages/zstandard/<a class="el" href="backend__cffi_8py.html">backend_cffi.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
