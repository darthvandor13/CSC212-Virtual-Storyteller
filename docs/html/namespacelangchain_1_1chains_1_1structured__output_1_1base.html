<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: langchain.chains.structured_output.base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelangchain.html">langchain</a></li><li class="navelem"><a class="el" href="namespacelangchain_1_1chains.html">chains</a></li><li class="navelem"><a class="el" href="namespacelangchain_1_1chains_1_1structured__output.html">structured_output</a></li><li class="navelem"><a class="el" href="namespacelangchain_1_1chains_1_1structured__output_1_1base.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">langchain.chains.structured_output.base Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62e643be6048a9eb0a07d8a8e1e29ad6"><td class="memItemLeft" align="right" valign="top">Runnable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain_1_1chains_1_1structured__output_1_1base.html#a62e643be6048a9eb0a07d8a8e1e29ad6">create_openai_fn_runnable</a> (Sequence[Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>], Callable]] functions, Runnable llm, Optional[BasePromptTemplate] prompt=None, *bool enforce_single_function_usage=True, Optional[Union[BaseOutputParser, BaseGenerationOutputParser]] output_parser=None, **Any llm_kwargs)</td></tr>
<tr class="separator:a62e643be6048a9eb0a07d8a8e1e29ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23266a9ecdf1cab334145e457ae818d"><td class="memItemLeft" align="right" valign="top">Runnable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain_1_1chains_1_1structured__output_1_1base.html#ac23266a9ecdf1cab334145e457ae818d">create_structured_output_runnable</a> (Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]] output_schema, Runnable llm, Optional[BasePromptTemplate] prompt=None, *Optional[Union[BaseOutputParser, BaseGenerationOutputParser]] output_parser=None, bool enforce_function_usage=True, bool return_single=True, Literal[&quot;openai-functions&quot;, &quot;openai-tools&quot;, &quot;openai-json&quot;] mode=&quot;openai-functions&quot;, **Any kwargs)</td></tr>
<tr class="separator:ac23266a9ecdf1cab334145e457ae818d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28695163b2355bba8526eedd9042258"><td class="memItemLeft" align="right" valign="top">Union[BaseOutputParser, BaseGenerationOutputParser]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain_1_1chains_1_1structured__output_1_1base.html#aa28695163b2355bba8526eedd9042258">get_openai_output_parser</a> (Sequence[Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>], Callable]] functions)</td></tr>
<tr class="separator:aa28695163b2355bba8526eedd9042258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5ac20fcfee2752c4de1194c23477b954"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain_1_1chains_1_1structured__output_1_1base.html#a5ac20fcfee2752c4de1194c23477b954">removal</a> = &quot;1.0&quot;,</td></tr>
<tr class="separator:a5ac20fcfee2752c4de1194c23477b954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae122b30d5f057848f623b80c0b261260"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelangchain_1_1chains_1_1structured__output_1_1base.html#ae122b30d5f057848f623b80c0b261260">alternative</a></td></tr>
<tr class="separator:ae122b30d5f057848f623b80c0b261260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a62e643be6048a9eb0a07d8a8e1e29ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e643be6048a9eb0a07d8a8e1e29ad6">&#9670;&nbsp;</a></span>create_openai_fn_runnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Runnable langchain.chains.structured_output.base.create_openai_fn_runnable </td>
          <td>(</td>
          <td class="paramtype">Sequence[Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>], Callable]]&#160;</td>
          <td class="paramname"><em>functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Runnable&#160;</td>
          <td class="paramname"><em>llm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[BasePromptTemplate] &#160;</td>
          <td class="paramname"><em>prompt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>enforce_single_function_usage</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Union[BaseOutputParser, BaseGenerationOutputParser]] &#160;</td>
          <td class="paramname"><em>output_parser</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>llm_kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a runnable sequence that uses OpenAI functions.

Args:
    functions: A sequence of either dictionaries, pydantic.BaseModels classes, or
        Python functions. If dictionaries are passed in, they are assumed to
        already be a valid OpenAI functions. If only a single
        function is passed in, then it will be enforced that the model use that
        function. pydantic.BaseModels and Python functions should have docstrings
        describing what the function does. For best results, pydantic.BaseModels
        should have descriptions of the parameters and Python functions should have
        Google Python style args descriptions in the docstring. Additionally,
        Python functions should only use primitive types (str, int, float, bool) or
        pydantic.BaseModels for arguments.
    llm: Language model to use, assumed to support the OpenAI function-calling API.
    prompt: BasePromptTemplate to pass to the model.
    enforce_single_function_usage: only used if a single function is passed in. If
        True, then the model will be forced to use the given function. If False,
        then the model will be given the option to use the given function or not.
    output_parser: BaseLLMOutputParser to use for parsing model outputs. By default
        will be inferred from the function types. If pydantic.BaseModels are passed
        in, then the OutputParser will try to parse outputs using those. Otherwise
        model outputs will simply be parsed as JSON. If multiple functions are
        passed in and they are not pydantic.BaseModels, the chain output will
        include both the name of the function that was returned and the arguments
        to pass to the function.
    **llm_kwargs: Additional named arguments to pass to the language model.

Returns:
    A runnable sequence that will pass in the given functions to the model when run.

Example:
    .. code-block:: python

            from typing import Optional

            from langchain.chains.structured_output import create_openai_fn_runnable
            from langchain_openai import ChatOpenAI
            from pydantic import BaseModel, Field


            class RecordPerson(BaseModel):
                '''Record some identifying information about a person.'''

                name: str = Field(..., description="The person's name")
                age: int = Field(..., description="The person's age")
                fav_food: Optional[str] = Field(None, description="The person's favorite food")


            class RecordDog(BaseModel):
                '''Record some identifying information about a dog.'''

                name: str = Field(..., description="The dog's name")
                color: str = Field(..., description="The dog's color")
                fav_food: Optional[str] = Field(None, description="The dog's favorite food")


            llm = ChatOpenAI(model="gpt-4", temperature=0)
            structured_llm = create_openai_fn_runnable([RecordPerson, RecordDog], llm)
            structured_llm.invoke("Harry was a chubby brown beagle who loved chicken)
            # -&gt; RecordDog(name="Harry", color="brown", fav_food="chicken")
</pre> 
</div>
</div>
<a id="ac23266a9ecdf1cab334145e457ae818d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23266a9ecdf1cab334145e457ae818d">&#9670;&nbsp;</a></span>create_structured_output_runnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Runnable langchain.chains.structured_output.base.create_structured_output_runnable </td>
          <td>(</td>
          <td class="paramtype">Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]]&#160;</td>
          <td class="paramname"><em>output_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Runnable&#160;</td>
          <td class="paramname"><em>llm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[BasePromptTemplate] &#160;</td>
          <td class="paramname"><em>prompt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[Union[BaseOutputParser, BaseGenerationOutputParser]] &#160;</td>
          <td class="paramname"><em>output_parser</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>enforce_function_usage</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>return_single</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[
        &quot;openai-functions&quot;, &quot;openai-tools&quot;, &quot;openai-json&quot;
    ] &#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;openai-functions&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a runnable for extracting structured outputs.

Args:
    output_schema: Either a dictionary or pydantic.BaseModel class. If a dictionary
        is passed in, it's assumed to already be a valid JsonSchema.
        For best results, pydantic.BaseModels should have docstrings describing what
        the schema represents and descriptions for the parameters.
    llm: Language model to use. Assumed to support the OpenAI function-calling API 
        if mode is 'openai-function'. Assumed to support OpenAI response_format 
        parameter if mode is 'openai-json'.
    prompt: BasePromptTemplate to pass to the model. If mode is 'openai-json' and 
        prompt has input variable 'output_schema' then the given output_schema 
        will be converted to a JsonSchema and inserted in the prompt.
    output_parser: Output parser to use for parsing model outputs. By default
        will be inferred from the function types. If pydantic.BaseModel is passed
        in, then the OutputParser will try to parse outputs using the pydantic 
        class. Otherwise model outputs will be parsed as JSON.
    mode: How structured outputs are extracted from the model. If 'openai-functions' 
        then OpenAI function calling is used with the deprecated 'functions', 
        'function_call' schema. If 'openai-tools' then OpenAI function 
        calling with the latest 'tools', 'tool_choice' schema is used. This is 
        recommended over 'openai-functions'. If 'openai-json' then OpenAI model 
        with response_format set to JSON is used.
    enforce_function_usage: Only applies when mode is 'openai-tools' or 
        'openai-functions'. If True, then the model will be forced to use the given 
        output schema. If False, then the model can elect whether to use the output 
        schema.
    return_single: Only applies when mode is 'openai-tools'. Whether to a list of 
        structured outputs or a single one. If True and model does not return any 
        structured outputs then chain output is None. If False and model does not 
        return any structured outputs then chain output is an empty list.
    kwargs: Additional named arguments.

Returns:
    A runnable sequence that will return a structured output(s) matching the given 
        output_schema.

OpenAI tools example with Pydantic schema (mode='openai-tools'):
    .. code-block:: python
    
            from typing import Optional

            from langchain.chains import create_structured_output_runnable
            from langchain_openai import ChatOpenAI
            from pydantic import BaseModel, Field


            class RecordDog(BaseModel):
                '''Record some identifying information about a dog.'''

                name: str = Field(..., description="The dog's name")
                color: str = Field(..., description="The dog's color")
                fav_food: Optional[str] = Field(None, description="The dog's favorite food")

            llm = ChatOpenAI(model="gpt-3.5-turbo-0125", temperature=0)
            prompt = ChatPromptTemplate.from_messages(
                [
                    ("system", "You are an extraction algorithm. Please extract every possible instance"), 
                    ('human', '{input}')
                ]
            )
            structured_llm = create_structured_output_runnable(
                RecordDog, 
                llm, 
                mode="openai-tools", 
                enforce_function_usage=True, 
                return_single=True
            )
            structured_llm.invoke({"input": "Harry was a chubby brown beagle who loved chicken"})
            # -&gt; RecordDog(name="Harry", color="brown", fav_food="chicken")
            
OpenAI tools example with dict schema (mode="openai-tools"):
    .. code-block:: python
    
            from typing import Optional

            from langchain.chains import create_structured_output_runnable
            from langchain_openai import ChatOpenAI


            dog_schema = {
                "type": "function",
                "function": {
                    "name": "record_dog",
                    "description": "Record some identifying information about a dog.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "name": {
                                "description": "The dog's name",
                                "type": "string"
                            },
                            "color": {
                                "description": "The dog's color",
                                "type": "string"
                            },
                            "fav_food": {
                                "description": "The dog's favorite food",
                                "type": "string"
                            }
                        },
                        "required": ["name", "color"]
                    }
                }
            }


            llm = ChatOpenAI(model="gpt-3.5-turbo-0125", temperature=0)
            structured_llm = create_structured_output_runnable(
                dog_schema, 
                llm, 
                mode="openai-tools", 
                enforce_function_usage=True, 
                return_single=True
            )
            structured_llm.invoke("Harry was a chubby brown beagle who loved chicken")
            # -&gt; {'name': 'Harry', 'color': 'brown', 'fav_food': 'chicken'}

OpenAI functions example (mode="openai-functions"):
    .. code-block:: python

            from typing import Optional

            from langchain.chains import create_structured_output_runnable
            from langchain_openai import ChatOpenAI
            from pydantic import BaseModel, Field

            class Dog(BaseModel):
                '''Identifying information about a dog.'''

                name: str = Field(..., description="The dog's name")
                color: str = Field(..., description="The dog's color")
                fav_food: Optional[str] = Field(None, description="The dog's favorite food")

            llm = ChatOpenAI(model="gpt-3.5-turbo-0125", temperature=0)
            structured_llm = create_structured_output_runnable(Dog, llm, mode="openai-functions")
            structured_llm.invoke("Harry was a chubby brown beagle who loved chicken")
            # -&gt; Dog(name="Harry", color="brown", fav_food="chicken")
            
OpenAI functions with prompt example:
    .. code-block:: python

            from typing import Optional

            from langchain.chains import create_structured_output_runnable
            from langchain_openai import ChatOpenAI
            from langchain_core.prompts import ChatPromptTemplate
            from pydantic import BaseModel, Field

            class Dog(BaseModel):
                '''Identifying information about a dog.'''

                name: str = Field(..., description="The dog's name")
                color: str = Field(..., description="The dog's color")
                fav_food: Optional[str] = Field(None, description="The dog's favorite food")

            llm = ChatOpenAI(model="gpt-3.5-turbo-0125", temperature=0)
            structured_llm = create_structured_output_runnable(Dog, llm, mode="openai-functions")
            system = '''Extract information about any dogs mentioned in the user input.'''
            prompt = ChatPromptTemplate.from_messages(
                [("system", system), ("human", "{input}"),]
            )
            chain = prompt | structured_llm
            chain.invoke({"input": "Harry was a chubby brown beagle who loved chicken"})
            # -&gt; Dog(name="Harry", color="brown", fav_food="chicken")
OpenAI json response format example (mode="openai-json"):
    .. code-block:: python
    
            from typing import Optional

            from langchain.chains import create_structured_output_runnable
            from langchain_openai import ChatOpenAI
            from langchain_core.prompts import ChatPromptTemplate
            from pydantic import BaseModel, Field

            class Dog(BaseModel):
                '''Identifying information about a dog.'''

                name: str = Field(..., description="The dog's name")
                color: str = Field(..., description="The dog's color")
                fav_food: Optional[str] = Field(None, description="The dog's favorite food")

            llm = ChatOpenAI(model="gpt-3.5-turbo-0125", temperature=0)
            structured_llm = create_structured_output_runnable(Dog, llm, mode="openai-json")
            system = '''You are a world class assistant for extracting information in structured JSON formats. \
            
            Extract a valid JSON blob from the user input that matches the following JSON Schema:
            
            {output_schema}'''
            prompt = ChatPromptTemplate.from_messages(
                [("system", system), ("human", "{input}"),]
            )
            chain = prompt | structured_llm
            chain.invoke({"input": "Harry was a chubby brown beagle who loved chicken"})
</pre> 
</div>
</div>
<a id="aa28695163b2355bba8526eedd9042258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28695163b2355bba8526eedd9042258">&#9670;&nbsp;</a></span>get_openai_output_parser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[BaseOutputParser, BaseGenerationOutputParser] langchain.chains.structured_output.base.get_openai_output_parser </td>
          <td>(</td>
          <td class="paramtype">Sequence[Union[Dict[str, Any], Type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>], Callable]]&#160;</td>
          <td class="paramname"><em>functions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the appropriate function output parser given the user functions.

Args:
    functions: Sequence where element is a dictionary, a pydantic.BaseModel class,
        or a Python function. If a dictionary is passed in, it is assumed to
        already be a valid OpenAI function.

Returns:
    A PydanticOutputFunctionsParser if functions are Pydantic classes, otherwise
        a JsonOutputFunctionsParser. If there's only one function and it is
        not a Pydantic class, then the output parser will automatically extract
        only the function arguments and not the function name.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae122b30d5f057848f623b80c0b261260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae122b30d5f057848f623b80c0b261260">&#9670;&nbsp;</a></span>alternative</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple langchain.chains.structured_output.base.alternative</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;= (</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;        </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ),</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ac20fcfee2752c4de1194c23477b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac20fcfee2752c4de1194c23477b954">&#9670;&nbsp;</a></span>removal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string langchain.chains.structured_output.base.removal = &quot;1.0&quot;,</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
