<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.crypto.crypto Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1crypto.html">crypto</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html">crypto</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.crypto.crypto Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1crypto_1_1crypto_1_1NonInvertibleCipherWarning.html">NonInvertibleCipherWarning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a09ed2c6245f46ed0afefc94b4b34a62c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a09ed2c6245f46ed0afefc94b4b34a62c">AZ</a> (s=None)</td></tr>
<tr class="separator:a09ed2c6245f46ed0afefc94b4b34a62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086fc01b97a0a91e9f7c6a85a104ff52"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a086fc01b97a0a91e9f7c6a85a104ff52">padded_key</a> (key, symbols)</td></tr>
<tr class="separator:a086fc01b97a0a91e9f7c6a85a104ff52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4203540834a2023e6c1c50e26eff8576"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a4203540834a2023e6c1c50e26eff8576">check_and_join</a> (phrase, symbols=None, filter=None)</td></tr>
<tr class="separator:a4203540834a2023e6c1c50e26eff8576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9435cecfbe51d2f87c133ac6862672e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a9435cecfbe51d2f87c133ac6862672e5">cycle_list</a> (k, n)</td></tr>
<tr class="separator:a9435cecfbe51d2f87c133ac6862672e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3448ad7c59237c878e5a44b51a7fc8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a5d3448ad7c59237c878e5a44b51a7fc8">encipher_shift</a> (msg, key, symbols=None)</td></tr>
<tr class="memdesc:a5d3448ad7c59237c878e5a44b51a7fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">shift cipher examples ############  <a href="namespacesympy_1_1crypto_1_1crypto.html#a5d3448ad7c59237c878e5a44b51a7fc8">More...</a><br /></td></tr>
<tr class="separator:a5d3448ad7c59237c878e5a44b51a7fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe91f83bd1b23a0f7f637f9159d07fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a6fe91f83bd1b23a0f7f637f9159d07fe">decipher_shift</a> (msg, key, symbols=None)</td></tr>
<tr class="separator:a6fe91f83bd1b23a0f7f637f9159d07fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495929c4e036e14a61ae2ae5cf9ab5e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a495929c4e036e14a61ae2ae5cf9ab5e9">encipher_rot13</a> (msg, symbols=None)</td></tr>
<tr class="separator:a495929c4e036e14a61ae2ae5cf9ab5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a57f73bd0a521d515f49483d4de1bec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a9a57f73bd0a521d515f49483d4de1bec">decipher_rot13</a> (msg, symbols=None)</td></tr>
<tr class="separator:a9a57f73bd0a521d515f49483d4de1bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc726b149ef63a31579dc46755ecb2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#ae6dc726b149ef63a31579dc46755ecb2">encipher_affine</a> (msg, key, symbols=None, _inverse=False)</td></tr>
<tr class="memdesc:ae6dc726b149ef63a31579dc46755ecb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">affine cipher examples ############  <a href="namespacesympy_1_1crypto_1_1crypto.html#ae6dc726b149ef63a31579dc46755ecb2">More...</a><br /></td></tr>
<tr class="separator:ae6dc726b149ef63a31579dc46755ecb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30fc7df5bcfb51ebb3eda6ee0835506"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#ad30fc7df5bcfb51ebb3eda6ee0835506">decipher_affine</a> (msg, key, symbols=None)</td></tr>
<tr class="separator:ad30fc7df5bcfb51ebb3eda6ee0835506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388eb3bde68fd64c660da1d243d6d717"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a388eb3bde68fd64c660da1d243d6d717">encipher_atbash</a> (msg, symbols=None)</td></tr>
<tr class="separator:a388eb3bde68fd64c660da1d243d6d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8497efffe35584d1d8b66c81fa767f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#ab8497efffe35584d1d8b66c81fa767f7">decipher_atbash</a> (msg, symbols=None)</td></tr>
<tr class="separator:ab8497efffe35584d1d8b66c81fa767f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe312eb5d4494237e003a91472dfa48b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#afe312eb5d4494237e003a91472dfa48b">encipher_substitution</a> (msg, old, new=None)</td></tr>
<tr class="memdesc:afe312eb5d4494237e003a91472dfa48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">substitution cipher ###########################  <a href="namespacesympy_1_1crypto_1_1crypto.html#afe312eb5d4494237e003a91472dfa48b">More...</a><br /></td></tr>
<tr class="separator:afe312eb5d4494237e003a91472dfa48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e57ea30e43ecdb09a8ac2e48d531673"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a2e57ea30e43ecdb09a8ac2e48d531673">encipher_vigenere</a> (msg, key, symbols=None)</td></tr>
<tr class="memdesc:a2e57ea30e43ecdb09a8ac2e48d531673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vigenere cipher examples ########################.  <a href="namespacesympy_1_1crypto_1_1crypto.html#a2e57ea30e43ecdb09a8ac2e48d531673">More...</a><br /></td></tr>
<tr class="separator:a2e57ea30e43ecdb09a8ac2e48d531673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f3fb33817fe21537e789196f2312ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a72f3fb33817fe21537e789196f2312ff">decipher_vigenere</a> (msg, key, symbols=None)</td></tr>
<tr class="separator:a72f3fb33817fe21537e789196f2312ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5f108847e4acde6e02ad73e2224a8c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#adb5f108847e4acde6e02ad73e2224a8c">encipher_hill</a> (msg, key, symbols=None, pad=&quot;Q&quot;)</td></tr>
<tr class="memdesc:adb5f108847e4acde6e02ad73e2224a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hill cipher ########################.  <a href="namespacesympy_1_1crypto_1_1crypto.html#adb5f108847e4acde6e02ad73e2224a8c">More...</a><br /></td></tr>
<tr class="separator:adb5f108847e4acde6e02ad73e2224a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74444d0c6057b3698aa0eedf03e91092"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a74444d0c6057b3698aa0eedf03e91092">decipher_hill</a> (msg, key, symbols=None)</td></tr>
<tr class="separator:a74444d0c6057b3698aa0eedf03e91092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a22952ed544cf879ba1f1ae9cdbd0c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a13a22952ed544cf879ba1f1ae9cdbd0c">encipher_bifid</a> (msg, key, symbols=None)</td></tr>
<tr class="memdesc:a13a22952ed544cf879ba1f1ae9cdbd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bifid cipher ########################.  <a href="namespacesympy_1_1crypto_1_1crypto.html#a13a22952ed544cf879ba1f1ae9cdbd0c">More...</a><br /></td></tr>
<tr class="separator:a13a22952ed544cf879ba1f1ae9cdbd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecadce1f9f3799cfe09ee8147ba29ce0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#aecadce1f9f3799cfe09ee8147ba29ce0">decipher_bifid</a> (msg, key, symbols=None)</td></tr>
<tr class="separator:aecadce1f9f3799cfe09ee8147ba29ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1276d049afff426e079958d90e490364"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a1276d049afff426e079958d90e490364">bifid_square</a> (key)</td></tr>
<tr class="separator:a1276d049afff426e079958d90e490364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a1a082ea2fc35ac4c3835e0c058bc8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a04a1a082ea2fc35ac4c3835e0c058bc8">encipher_bifid5</a> (msg, key)</td></tr>
<tr class="separator:a04a1a082ea2fc35ac4c3835e0c058bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf863a00cc8abc41f8fbac8cd26539c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#aebf863a00cc8abc41f8fbac8cd26539c">decipher_bifid5</a> (msg, key)</td></tr>
<tr class="separator:aebf863a00cc8abc41f8fbac8cd26539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b68ab5700778bb504b22d4568d8156a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a4b68ab5700778bb504b22d4568d8156a">bifid5_square</a> (key=None)</td></tr>
<tr class="separator:a4b68ab5700778bb504b22d4568d8156a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f8b53633a083aa08ad495a63665437"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a98f8b53633a083aa08ad495a63665437">encipher_bifid6</a> (msg, key)</td></tr>
<tr class="separator:a98f8b53633a083aa08ad495a63665437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2728df400c2dc08fab297943b4e05b6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#aa2728df400c2dc08fab297943b4e05b6">decipher_bifid6</a> (msg, key)</td></tr>
<tr class="separator:aa2728df400c2dc08fab297943b4e05b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363cedcd7954556ef35a1e644fdd6b99"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a363cedcd7954556ef35a1e644fdd6b99">bifid6_square</a> (key=None)</td></tr>
<tr class="separator:a363cedcd7954556ef35a1e644fdd6b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a1269d69d8859f738de4167007bc23"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#ac7a1269d69d8859f738de4167007bc23">rsa_public_key</a> (*args, **kwargs)</td></tr>
<tr class="separator:ac7a1269d69d8859f738de4167007bc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd31187978a4f37304145849633130a3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#afd31187978a4f37304145849633130a3">rsa_private_key</a> (*args, **kwargs)</td></tr>
<tr class="separator:afd31187978a4f37304145849633130a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d98d4092717c91f6da8619aa51d317"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a80d98d4092717c91f6da8619aa51d317">encipher_rsa</a> (i, key, factors=None)</td></tr>
<tr class="separator:a80d98d4092717c91f6da8619aa51d317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe622a9ac0eb7dd5a487c343cdf34c9f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#afe622a9ac0eb7dd5a487c343cdf34c9f">decipher_rsa</a> (i, key, factors=None)</td></tr>
<tr class="separator:afe622a9ac0eb7dd5a487c343cdf34c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7c500a27e2e24f2aac4cd916d63e5c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#add7c500a27e2e24f2aac4cd916d63e5c">kid_rsa_public_key</a> (a, b, A, B)</td></tr>
<tr class="memdesc:add7c500a27e2e24f2aac4cd916d63e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">kid krypto (kid RSA) #############################  <a href="namespacesympy_1_1crypto_1_1crypto.html#add7c500a27e2e24f2aac4cd916d63e5c">More...</a><br /></td></tr>
<tr class="separator:add7c500a27e2e24f2aac4cd916d63e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beabbcf96b9b01f6f524589bd6851eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a9beabbcf96b9b01f6f524589bd6851eb">kid_rsa_private_key</a> (a, b, A, B)</td></tr>
<tr class="separator:a9beabbcf96b9b01f6f524589bd6851eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951bf6b70f1caf19b6471d463141db9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a3951bf6b70f1caf19b6471d463141db9">encipher_kid_rsa</a> (msg, key)</td></tr>
<tr class="separator:a3951bf6b70f1caf19b6471d463141db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccaedd9206dac51b45af276f5fda856"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a3ccaedd9206dac51b45af276f5fda856">decipher_kid_rsa</a> (msg, key)</td></tr>
<tr class="separator:a3ccaedd9206dac51b45af276f5fda856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526dba5a7140ced621d041b0df37cbc6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a526dba5a7140ced621d041b0df37cbc6">encode_morse</a> (msg, sep='|', mapping=None)</td></tr>
<tr class="separator:a526dba5a7140ced621d041b0df37cbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578efa3e60410952893bb104685eaa10"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a578efa3e60410952893bb104685eaa10">decode_morse</a> (msg, sep='|', mapping=None)</td></tr>
<tr class="separator:a578efa3e60410952893bb104685eaa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4747b3e827f9061d6c654bb97dcbff5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#ad4747b3e827f9061d6c654bb97dcbff5">lfsr_sequence</a> (key, fill, n)</td></tr>
<tr class="memdesc:ad4747b3e827f9061d6c654bb97dcbff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LFSRs ##########################################.  <a href="namespacesympy_1_1crypto_1_1crypto.html#ad4747b3e827f9061d6c654bb97dcbff5">More...</a><br /></td></tr>
<tr class="separator:ad4747b3e827f9061d6c654bb97dcbff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9804f41a5b5db476736f888d20481743"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a9804f41a5b5db476736f888d20481743">lfsr_autocorrelation</a> (L, P, k)</td></tr>
<tr class="separator:a9804f41a5b5db476736f888d20481743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4012a9efa1b6d3e59df460b404bb94"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a1c4012a9efa1b6d3e59df460b404bb94">lfsr_connection_polynomial</a> (s)</td></tr>
<tr class="separator:a1c4012a9efa1b6d3e59df460b404bb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6121460967746635d888220af3dac1b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#ad6121460967746635d888220af3dac1b">elgamal_private_key</a> (digit=10, seed=None)</td></tr>
<tr class="memdesc:ad6121460967746635d888220af3dac1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ElGamal #############################.  <a href="namespacesympy_1_1crypto_1_1crypto.html#ad6121460967746635d888220af3dac1b">More...</a><br /></td></tr>
<tr class="separator:ad6121460967746635d888220af3dac1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c6fc61d5d18c0a4d2f6083d6011b96"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a63c6fc61d5d18c0a4d2f6083d6011b96">elgamal_public_key</a> (key)</td></tr>
<tr class="separator:a63c6fc61d5d18c0a4d2f6083d6011b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b078a7502b571e19d3b57bab6f5370"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a65b078a7502b571e19d3b57bab6f5370">encipher_elgamal</a> (i, key, seed=None)</td></tr>
<tr class="separator:a65b078a7502b571e19d3b57bab6f5370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa676bcc55c3d8eb2ce0979d7f4dfab4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#aa676bcc55c3d8eb2ce0979d7f4dfab4e">decipher_elgamal</a> (msg, key)</td></tr>
<tr class="separator:aa676bcc55c3d8eb2ce0979d7f4dfab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3cc80da5c6b28633ecfdb149160192"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#afc3cc80da5c6b28633ecfdb149160192">dh_private_key</a> (digit=10, seed=None)</td></tr>
<tr class="memdesc:afc3cc80da5c6b28633ecfdb149160192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diffie-Hellman Key Exchange #########################.  <a href="namespacesympy_1_1crypto_1_1crypto.html#afc3cc80da5c6b28633ecfdb149160192">More...</a><br /></td></tr>
<tr class="separator:afc3cc80da5c6b28633ecfdb149160192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe29dbf09c9c272ca546658bd0b6217f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#afe29dbf09c9c272ca546658bd0b6217f">dh_public_key</a> (key)</td></tr>
<tr class="separator:afe29dbf09c9c272ca546658bd0b6217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2f397bb0ce97731f9e2892d25c7d09"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a4d2f397bb0ce97731f9e2892d25c7d09">dh_shared_key</a> (key, b)</td></tr>
<tr class="separator:a4d2f397bb0ce97731f9e2892d25c7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4f47813e810d7e5388a52412ecbbd8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#acf4f47813e810d7e5388a52412ecbbd8">gm_private_key</a> (p, q, a=None)</td></tr>
<tr class="separator:acf4f47813e810d7e5388a52412ecbbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760a613b8e736d8faf9d9194b9f1ee71"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a760a613b8e736d8faf9d9194b9f1ee71">gm_public_key</a> (p, q, a=None, seed=None)</td></tr>
<tr class="separator:a760a613b8e736d8faf9d9194b9f1ee71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7394586077900770029351dca89cf9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#aaf7394586077900770029351dca89cf9">encipher_gm</a> (i, key, seed=None)</td></tr>
<tr class="separator:aaf7394586077900770029351dca89cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4d5f0261a5d1aaf4403b0b15146d3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a0c4d5f0261a5d1aaf4403b0b15146d3f">decipher_gm</a> (message, key)</td></tr>
<tr class="separator:a0c4d5f0261a5d1aaf4403b0b15146d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa51b1184b3953c4f3cae0cbbfa5f1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#aeaa51b1184b3953c4f3cae0cbbfa5f1c">encipher_railfence</a> (message, rails)</td></tr>
<tr class="memdesc:aeaa51b1184b3953c4f3cae0cbbfa5f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">RailFence Cipher #############.  <a href="namespacesympy_1_1crypto_1_1crypto.html#aeaa51b1184b3953c4f3cae0cbbfa5f1c">More...</a><br /></td></tr>
<tr class="separator:aeaa51b1184b3953c4f3cae0cbbfa5f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c73204223bc1f5fe6d42d2845ca750d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a2c73204223bc1f5fe6d42d2845ca750d">decipher_railfence</a> (ciphertext, rails)</td></tr>
<tr class="separator:a2c73204223bc1f5fe6d42d2845ca750d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9abb83d8cc1649e3f09e1fe9415dfb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a2e9abb83d8cc1649e3f09e1fe9415dfb">bg_private_key</a> (p, q)</td></tr>
<tr class="memdesc:a2e9abb83d8cc1649e3f09e1fe9415dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blum-Goldwasser cryptosystem #########################.  <a href="namespacesympy_1_1crypto_1_1crypto.html#a2e9abb83d8cc1649e3f09e1fe9415dfb">More...</a><br /></td></tr>
<tr class="separator:a2e9abb83d8cc1649e3f09e1fe9415dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649d491c8a499a3d5ddb9b5a6b947deb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a649d491c8a499a3d5ddb9b5a6b947deb">bg_public_key</a> (p, q)</td></tr>
<tr class="separator:a649d491c8a499a3d5ddb9b5a6b947deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab4a080f59dd0e9183dadef64e86629"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a3ab4a080f59dd0e9183dadef64e86629">encipher_bg</a> (i, key, seed=None)</td></tr>
<tr class="separator:a3ab4a080f59dd0e9183dadef64e86629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dad3c90debd7fe45d9d3a7feec9ae3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a02dad3c90debd7fe45d9d3a7feec9ae3">decipher_bg</a> (message, key)</td></tr>
<tr class="separator:a02dad3c90debd7fe45d9d3a7feec9ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaee1dc5c1c393f141c19348ea7115a48"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#aaee1dc5c1c393f141c19348ea7115a48">bifid5</a> = <a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a09ed2c6245f46ed0afefc94b4b34a62c">AZ</a>().replace('J', '')</td></tr>
<tr class="separator:aaee1dc5c1c393f141c19348ea7115a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c47f7098a56e3a0be2bb5d5b8bc8fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a42c47f7098a56e3a0be2bb5d5b8bc8fb">bifid6</a> = <a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a09ed2c6245f46ed0afefc94b4b34a62c">AZ</a>() + '0123456789'</td></tr>
<tr class="separator:a42c47f7098a56e3a0be2bb5d5b8bc8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a36996891d0194a340b1eaf30bf4d41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a3a36996891d0194a340b1eaf30bf4d41">bifid10</a> = printable</td></tr>
<tr class="separator:a3a36996891d0194a340b1eaf30bf4d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c77c9b21a69e3a275b92758148c196"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#ae5c77c9b21a69e3a275b92758148c196">morse_char</a></td></tr>
<tr class="memdesc:ae5c77c9b21a69e3a275b92758148c196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Morse Code ######################################.  <a href="namespacesympy_1_1crypto_1_1crypto.html#ae5c77c9b21a69e3a275b92758148c196">More...</a><br /></td></tr>
<tr class="separator:ae5c77c9b21a69e3a275b92758148c196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91819b29a57f9646d0812df4e4464b47"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a91819b29a57f9646d0812df4e4464b47">char_morse</a> = {v: k for k, v in morse_char.items()}</td></tr>
<tr class="separator:a91819b29a57f9646d0812df4e4464b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This file contains some classical ciphers and routines
implementing a linear-feedback shift register (LFSR)
and the Diffie-Hellman key exchange.

.. warning::

   This module is intended for educational purposes only. Do not use the
   functions in this module for real cryptographic applications. If you wish
   to encrypt real data, we recommend using something like the `cryptography
   &lt;https://cryptography.io/en/latest/&gt;`_ module.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a09ed2c6245f46ed0afefc94b4b34a62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ed2c6245f46ed0afefc94b4b34a62c">&#9670;&nbsp;</a></span>AZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.AZ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the letters of ``s`` in uppercase. In case more than
one string is passed, each of them will be processed and a list
of upper case strings will be returned.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import AZ
&gt;&gt;&gt; AZ('Hello, world!')
'HELLOWORLD'
&gt;&gt;&gt; AZ('Hello, world!'.split())
['HELLO', 'WORLD']

See Also
========

check_and_join</pre> 
</div>
</div>
<a id="a2e9abb83d8cc1649e3f09e1fe9415dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9abb83d8cc1649e3f09e1fe9415dfb">&#9670;&nbsp;</a></span>bg_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.bg_private_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blum-Goldwasser cryptosystem #########################. </p>
<pre class="fragment">Check if p and q can be used as private keys for
the Blum-Goldwasser cryptosystem.

Explanation
===========

The three necessary checks for p and q to pass
so that they can be used as private keys:

    1. p and q must both be prime
    2. p and q must be distinct
    3. p and q must be congruent to 3 mod 4

Parameters
==========

p, q
    The keys to be checked.

Returns
=======

p, q
    Input values.

Raises
======

ValueError
    If p and q do not pass the above conditions.</pre> 
</div>
</div>
<a id="a649d491c8a499a3d5ddb9b5a6b947deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649d491c8a499a3d5ddb9b5a6b947deb">&#9670;&nbsp;</a></span>bg_public_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.bg_public_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates public keys from private keys.

Explanation
===========

The function first checks the validity of
private keys passed as arguments and
then returns their product.

Parameters
==========

p, q
    The private keys.

Returns
=======

N
    The public key.</pre> 
</div>
</div>
<a id="a4b68ab5700778bb504b22d4568d8156a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b68ab5700778bb504b22d4568d8156a">&#9670;&nbsp;</a></span>bifid5_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.bifid5_square </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">5x5 Polybius square.

Produce the Polybius square for the `5 \times 5` Bifid cipher.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import bifid5_square
&gt;&gt;&gt; bifid5_square("gold bug")
Matrix([
[G, O, L, D, B],
[U, A, C, E, F],
[H, I, K, M, N],
[P, Q, R, S, T],
[V, W, X, Y, Z]])</pre> 
</div>
</div>
<a id="a363cedcd7954556ef35a1e644fdd6b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363cedcd7954556ef35a1e644fdd6b99">&#9670;&nbsp;</a></span>bifid6_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.bifid6_square </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">6x6 Polybius square.

Produces the Polybius square for the `6 \times 6` Bifid cipher.
Assumes alphabet of symbols is "A", ..., "Z", "0", ..., "9".

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import bifid6_square
&gt;&gt;&gt; key = "gold bug"
&gt;&gt;&gt; bifid6_square(key)
Matrix([
[G, O, L, D, B, U],
[A, C, E, F, H, I],
[J, K, M, N, P, Q],
[R, S, T, V, W, X],
[Y, Z, 0, 1, 2, 3],
[4, 5, 6, 7, 8, 9]])</pre> 
</div>
</div>
<a id="a1276d049afff426e079958d90e490364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1276d049afff426e079958d90e490364">&#9670;&nbsp;</a></span>bifid_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.bifid_square </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return characters of ``key`` arranged in a square.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import (
...    bifid_square, AZ, padded_key, bifid5)
&gt;&gt;&gt; bifid_square(AZ().replace('J', ''))
Matrix([
[A, B, C, D, E],
[F, G, H, I, K],
[L, M, N, O, P],
[Q, R, S, T, U],
[V, W, X, Y, Z]])

&gt;&gt;&gt; bifid_square(padded_key(AZ('gold bug!'), bifid5))
Matrix([
[G, O, L, D, B],
[U, A, C, E, F],
[H, I, K, M, N],
[P, Q, R, S, T],
[V, W, X, Y, Z]])

See Also
========

padded_key</pre> 
</div>
</div>
<a id="a4203540834a2023e6c1c50e26eff8576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4203540834a2023e6c1c50e26eff8576">&#9670;&nbsp;</a></span>check_and_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.check_and_join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>phrase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Joins characters of ``phrase`` and if ``symbols`` is given, raises
an error if any character in ``phrase`` is not in ``symbols``.

Parameters
==========

phrase
    String or list of strings to be returned as a string.

symbols
    Iterable of characters allowed in ``phrase``.

    If ``symbols`` is ``None``, no checking is performed.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import check_and_join
&gt;&gt;&gt; check_and_join('a phrase')
'a phrase'
&gt;&gt;&gt; check_and_join('a phrase'.upper().split())
'APHRASE'
&gt;&gt;&gt; check_and_join('a phrase!'.upper().split(), 'ARE', filter=True)
'ARAE'
&gt;&gt;&gt; check_and_join('a phrase!'.upper().split(), 'ARE')
Traceback (most recent call last):
...
ValueError: characters in phrase but not symbols: "!HPS"</pre> 
</div>
</div>
<a id="a9435cecfbe51d2f87c133ac6862672e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9435cecfbe51d2f87c133ac6862672e5">&#9670;&nbsp;</a></span>cycle_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.cycle_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the elements of the list ``range(n)`` shifted to the
left by ``k`` (so the list starts with ``k`` (mod ``n``)).

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import cycle_list
&gt;&gt;&gt; cycle_list(3, 10)
[3, 4, 5, 6, 7, 8, 9, 0, 1, 2]</pre> 
</div>
</div>
<a id="ad30fc7df5bcfb51ebb3eda6ee0835506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30fc7df5bcfb51ebb3eda6ee0835506">&#9670;&nbsp;</a></span>decipher_affine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_affine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the deciphered text that was made from the mapping,
`x \rightarrow ax+b` (mod `N`), where ``N`` is the
number of characters in the alphabet. Deciphering is done by
reciphering with a new key: `x \rightarrow cx+d` (mod `N`),
where `c = a^{-1}` (mod `N`) and `d = -a^{-1}b` (mod `N`).

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_affine, decipher_affine
&gt;&gt;&gt; msg = "GO NAVY BEAT ARMY"
&gt;&gt;&gt; key = (3, 1)
&gt;&gt;&gt; encipher_affine(msg, key)
'TROBMVENBGBALV'
&gt;&gt;&gt; decipher_affine(_, key)
'GONAVYBEATARMY'

See Also
========

encipher_affine</pre> 
</div>
</div>
<a id="ab8497efffe35584d1d8b66c81fa767f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8497efffe35584d1d8b66c81fa767f7">&#9670;&nbsp;</a></span>decipher_atbash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_atbash </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Deciphers a given ``msg`` using Atbash cipher and returns it.

Explanation
===========

``decipher_atbash`` is functionally equivalent to ``encipher_atbash``.
However, it has still been added as a separate function to maintain
consistency.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_atbash, decipher_atbash
&gt;&gt;&gt; msg = 'GONAVYBEATARMY'
&gt;&gt;&gt; encipher_atbash(msg)
'TLMZEBYVZGZINB'
&gt;&gt;&gt; decipher_atbash(msg)
'TLMZEBYVZGZINB'
&gt;&gt;&gt; encipher_atbash(msg) == decipher_atbash(msg)
True
&gt;&gt;&gt; msg == encipher_atbash(encipher_atbash(msg))
True

References
==========

.. [1] https://en.wikipedia.org/wiki/Atbash

See Also
========

encipher_atbash</pre> 
</div>
</div>
<a id="a02dad3c90debd7fe45d9d3a7feec9ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dad3c90debd7fe45d9d3a7feec9ae3">&#9670;&nbsp;</a></span>decipher_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_bg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrypts the message using private keys.

Explanation
===========

ALGORITHM:
    1. Let, c be the encrypted message, y the second number received,
    and p and q be the private keys.
    2. Compute, r_p = y^((p+1)/4 ^ L) mod p and
    r_q = y^((q+1)/4 ^ L) mod q.
    3. Compute x_0 = (q(q^-1 mod p)r_p + p(p^-1 mod q)r_q) mod N.
    4. From, recompute the bits using the BBS generator, as in the
    encryption algorithm.
    5. Compute original message by XORing c and b.

Parameters
==========

message
    Tuple of encrypted message and a non-negative integer.

key
    Tuple of private keys.

Returns
=======

orig_msg
    The original message</pre> 
</div>
</div>
<a id="aecadce1f9f3799cfe09ee8147ba29ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecadce1f9f3799cfe09ee8147ba29ce0">&#9670;&nbsp;</a></span>decipher_bifid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_bifid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the Bifid cipher decryption on ciphertext ``msg``, and
returns the plaintext.

This is the version of the Bifid cipher that uses the `n \times n`
Polybius square.

Parameters
==========

msg
    Ciphertext string.

key
    Short string for key.

    Duplicate characters are ignored and then it is padded with the
    characters in symbols that were not in the short key.

symbols
    `n \times n` characters defining the alphabet.

    (default=string.printable, a `10 \times 10` matrix)

Returns
=======

deciphered
    Deciphered text.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import (
...     encipher_bifid, decipher_bifid, AZ)

Do an encryption using the bifid5 alphabet:

&gt;&gt;&gt; alp = AZ().replace('J', '')
&gt;&gt;&gt; ct = AZ("meet me on monday!")
&gt;&gt;&gt; key = AZ("gold bug")
&gt;&gt;&gt; encipher_bifid(ct, key, alp)
'IEILHHFSTSFQYE'

When entering the text or ciphertext, spaces are ignored so it
can be formatted as desired. Re-entering the ciphertext from the
preceding, putting 4 characters per line and padding with an extra
J, does not cause problems for the deciphering:

&gt;&gt;&gt; decipher_bifid('''
... IEILH
... HFSTS
... FQYEJ''', key, alp)
'MEETMEONMONDAY'

When no alphabet is given, all 100 printable characters will be
used:

&gt;&gt;&gt; key = ''
&gt;&gt;&gt; encipher_bifid('hello world!', key)
'bmtwmg-bIo*w'
&gt;&gt;&gt; decipher_bifid(_, key)
'hello world!'

If the key is changed, a different encryption is obtained:

&gt;&gt;&gt; key = 'gold bug'
&gt;&gt;&gt; encipher_bifid('hello world!', 'gold_bug')
'hg2sfuei7t}w'

And if the key used to decrypt the message is not exact, the
original text will not be perfectly obtained:

&gt;&gt;&gt; decipher_bifid(_, 'gold pug')
'heldo~wor6d!'</pre> 
</div>
</div>
<a id="aebf863a00cc8abc41f8fbac8cd26539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf863a00cc8abc41f8fbac8cd26539c">&#9670;&nbsp;</a></span>decipher_bifid5()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_bifid5 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Bifid cipher decryption of ``msg``.

Explanation
===========

This is the version of the Bifid cipher that uses the `5 \times 5`
Polybius square; the letter "J" is ignored unless a ``key`` of
length 25 is used.

Parameters
==========

msg
    Ciphertext string.

key
    Short string for key; duplicated characters are ignored and if
    the length is less then 25 characters, it will be padded with
    other letters from the alphabet omitting "J".
    Non-alphabetic characters are ignored.

Returns
=======

plaintext
    Plaintext from Bifid5 cipher (all caps, no spaces).

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_bifid5, decipher_bifid5
&gt;&gt;&gt; key = "gold bug"
&gt;&gt;&gt; encipher_bifid5('meet me on friday', key)
'IEILEHFSTSFXEE'
&gt;&gt;&gt; encipher_bifid5('meet me on monday', key)
'IEILHHFSTSFQYE'
&gt;&gt;&gt; decipher_bifid5(_, key)
'MEETMEONMONDAY'</pre> 
</div>
</div>
<a id="aa2728df400c2dc08fab297943b4e05b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2728df400c2dc08fab297943b4e05b6">&#9670;&nbsp;</a></span>decipher_bifid6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_bifid6 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the Bifid cipher decryption on ciphertext ``msg``, and
returns the plaintext.

This is the version of the Bifid cipher that uses the `6 \times 6`
Polybius square.

Parameters
==========

msg
    Ciphertext string (digits okay); converted to upper case

key
    Short string for key (digits okay).

    If ``key`` is less than 36 characters long, the square will be
    filled with letters A through Z and digits 0 through 9.
    All letters are converted to uppercase.

Returns
=======

plaintext
    Plaintext from Bifid cipher (all caps, no spaces).

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_bifid6, decipher_bifid6
&gt;&gt;&gt; key = "gold bug"
&gt;&gt;&gt; encipher_bifid6('meet me on monday at 8am', key)
'KFKLJJHF5MMMKTFRGPL'
&gt;&gt;&gt; decipher_bifid6(_, key)
'MEETMEONMONDAYAT8AM'</pre> 
</div>
</div>
<a id="aa676bcc55c3d8eb2ce0979d7f4dfab4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa676bcc55c3d8eb2ce0979d7f4dfab4e">&#9670;&nbsp;</a></span>decipher_elgamal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_elgamal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrypt message with private key.

`msg = (c_{1}, c_{2})`

`key = (p, r, d)`

According to extended Eucliden theorem,
`u c_{1}^{d} + p n = 1`

`u \equiv 1/{{c_{1}}^d} \pmod p`

`u c_{2} \equiv \frac{1}{c_{1}^d} c_{2} \equiv \frac{1}{r^{ad}} c_{2} \pmod p`

`\frac{1}{r^{ad}} m e^a \equiv \frac{1}{r^{ad}} m {r^{d a}} \equiv m \pmod p`

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import decipher_elgamal
&gt;&gt;&gt; from sympy.crypto.crypto import encipher_elgamal
&gt;&gt;&gt; from sympy.crypto.crypto import elgamal_private_key
&gt;&gt;&gt; from sympy.crypto.crypto import elgamal_public_key

&gt;&gt;&gt; pri = elgamal_private_key(5, seed=[3])
&gt;&gt;&gt; pub = elgamal_public_key(pri); pub
(37, 2, 8)
&gt;&gt;&gt; msg = 17
&gt;&gt;&gt; decipher_elgamal(encipher_elgamal(msg, pub), pri) == msg
True</pre> 
</div>
</div>
<a id="a0c4d5f0261a5d1aaf4403b0b15146d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4d5f0261a5d1aaf4403b0b15146d3f">&#9670;&nbsp;</a></span>decipher_gm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_gm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrypt message 'message' using public_key 'key'.

Parameters
==========

message : list of int
    The randomized encrypted message.

key : (p, q)
    The private key.

Returns
=======

int
    The encrypted message.</pre> 
</div>
</div>
<a id="a74444d0c6057b3698aa0eedf03e91092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74444d0c6057b3698aa0eedf03e91092">&#9670;&nbsp;</a></span>decipher_hill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_hill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Deciphering is the same as enciphering but using the inverse of the
key matrix.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_hill, decipher_hill
&gt;&gt;&gt; from sympy import Matrix

&gt;&gt;&gt; key = Matrix([[1, 2], [3, 5]])
&gt;&gt;&gt; encipher_hill("meet me on monday", key)
'UEQDUEODOCTCWQ'
&gt;&gt;&gt; decipher_hill(_, key)
'MEETMEONMONDAY'

When the length of the plaintext (stripped of invalid characters)
is not a multiple of the key dimension, extra characters will
appear at the end of the enciphered and deciphered text. In order to
decipher the text, those characters must be included in the text to
be deciphered. In the following, the key has a dimension of 4 but
the text is 2 short of being a multiple of 4 so two characters will
be added.

&gt;&gt;&gt; key = Matrix([[1, 1, 1, 2], [0, 1, 1, 0],
...               [2, 2, 3, 4], [1, 1, 0, 1]])
&gt;&gt;&gt; msg = "ST"
&gt;&gt;&gt; encipher_hill(msg, key)
'HJEB'
&gt;&gt;&gt; decipher_hill(_, key)
'STQQ'
&gt;&gt;&gt; encipher_hill(msg, key, pad="Z")
'ISPK'
&gt;&gt;&gt; decipher_hill(_, key)
'STZZ'

If the last two characters of the ciphertext were ignored in
either case, the wrong plaintext would be recovered:

&gt;&gt;&gt; decipher_hill("HD", key)
'ORMV'
&gt;&gt;&gt; decipher_hill("IS", key)
'UIKY'

See Also
========

encipher_hill</pre> 
</div>
</div>
<a id="a3ccaedd9206dac51b45af276f5fda856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccaedd9206dac51b45af276f5fda856">&#9670;&nbsp;</a></span>decipher_kid_rsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_kid_rsa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Here ``msg`` is the plaintext and ``key`` is the private key.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import (
...     kid_rsa_public_key, kid_rsa_private_key,
...     decipher_kid_rsa, encipher_kid_rsa)
&gt;&gt;&gt; a, b, A, B = 3, 4, 5, 6
&gt;&gt;&gt; d = kid_rsa_private_key(a, b, A, B)
&gt;&gt;&gt; msg = 200
&gt;&gt;&gt; pub = kid_rsa_public_key(a, b, A, B)
&gt;&gt;&gt; pri = kid_rsa_private_key(a, b, A, B)
&gt;&gt;&gt; ct = encipher_kid_rsa(msg, pub)
&gt;&gt;&gt; decipher_kid_rsa(ct, pri)
200</pre> 
</div>
</div>
<a id="a2c73204223bc1f5fe6d42d2845ca750d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c73204223bc1f5fe6d42d2845ca750d">&#9670;&nbsp;</a></span>decipher_railfence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_railfence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rails</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrypt the message using the given rails

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import decipher_railfence
&gt;&gt;&gt; decipher_railfence("horel ollwd",3)
'hello world'

Parameters
==========

message : string, the message to encrypt.
rails : int, the number of rails.

Returns
=======

The Decrypted string message.</pre> 
</div>
</div>
<a id="a9a57f73bd0a521d515f49483d4de1bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a57f73bd0a521d515f49483d4de1bec">&#9670;&nbsp;</a></span>decipher_rot13()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_rot13 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the ROT13 decryption on a given plaintext ``msg``.

Explanation
============

``decipher_rot13`` is equivalent to ``encipher_rot13`` as both
``decipher_shift`` with a key of 13 and ``encipher_shift`` key with a
key of 13 will return the same results. Nonetheless,
``decipher_rot13`` has nonetheless been explicitly defined here for
consistency.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_rot13, decipher_rot13
&gt;&gt;&gt; msg = 'GONAVYBEATARMY'
&gt;&gt;&gt; ciphertext = encipher_rot13(msg);ciphertext
'TBANILORNGNEZL'
&gt;&gt;&gt; decipher_rot13(ciphertext)
'GONAVYBEATARMY'
&gt;&gt;&gt; encipher_rot13(msg) == decipher_rot13(msg)
True
&gt;&gt;&gt; msg == decipher_rot13(ciphertext)
True</pre> 
</div>
</div>
<a id="afe622a9ac0eb7dd5a487c343cdf34c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe622a9ac0eb7dd5a487c343cdf34c9f">&#9670;&nbsp;</a></span>decipher_rsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_rsa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factors</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decrypt the ciphertext with RSA.

Parameters
==========

i : integer
    The ciphertext to be decrypted for.

key : (n, d) where n, d are integers
    `n` is the modulus of the key and `d` is the exponent of the
    key. The decryption is computed by `i^d \bmod n`.

    The key can either be a public key or a private key, however,
    the message encrypted by a public key can only be decrypted by
    a private key, and vice versa, as RSA is an asymmetric
    cryptography system.

factors : list of coprime integers
    As the modulus `n` created from RSA key generation is composed
    of arbitrary prime factors
    `n = {p_1}^{k_1}{p_2}^{k_2}\dots{p_n}^{k_n}` where
    `p_1, p_2, \dots, p_n` are distinct primes and
    `k_1, k_2, \dots, k_n` are positive integers, chinese remainder
    theorem can be used to compute `i^d \bmod n` from the
    fragmented modulo operations like

    .. math::
        i^d \bmod {p_1}^{k_1}, i^d \bmod {p_2}^{k_2}, \dots,
        i^d \bmod {p_n}^{k_n}

    or like

    .. math::
        i^d \bmod {p_1}^{k_1}{p_2}^{k_2},
        i^d \bmod {p_3}^{k_3}, \dots ,
        i^d \bmod {p_n}^{k_n}

    as long as every moduli does not share any common divisor each
    other.

    The raw primes used in generating the RSA key pair can be a good
    option.

    Note that the speed advantage of using this is only viable for
    very large cases (Like 2048-bit RSA keys) since the
    overhead of using pure Python implementation of
    :meth:`sympy.ntheory.modular.crt` may overcompensate the
    theoretical speed advantage.

Notes
=====

See the ``Notes`` section in the documentation of
:meth:`encipher_rsa`

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import decipher_rsa, encipher_rsa
&gt;&gt;&gt; from sympy.crypto.crypto import rsa_public_key, rsa_private_key

Public Key Encryption and Decryption:

&gt;&gt;&gt; p, q, e = 3, 5, 7
&gt;&gt;&gt; prk = rsa_private_key(p, q, e)
&gt;&gt;&gt; puk = rsa_public_key(p, q, e)
&gt;&gt;&gt; msg = 12
&gt;&gt;&gt; new_msg = encipher_rsa(msg, prk)
&gt;&gt;&gt; new_msg
3
&gt;&gt;&gt; decipher_rsa(new_msg, puk)
12

Private Key Encryption and Decryption:

&gt;&gt;&gt; p, q, e = 3, 5, 7
&gt;&gt;&gt; prk = rsa_private_key(p, q, e)
&gt;&gt;&gt; puk = rsa_public_key(p, q, e)
&gt;&gt;&gt; msg = 12
&gt;&gt;&gt; new_msg = encipher_rsa(msg, puk)
&gt;&gt;&gt; new_msg
3
&gt;&gt;&gt; decipher_rsa(new_msg, prk)
12

Decryption using chinese remainder theorem:

&gt;&gt;&gt; decipher_rsa(new_msg, prk, factors=[p, q])
12

See Also
========

encipher_rsa
</pre> 
</div>
</div>
<a id="a6fe91f83bd1b23a0f7f637f9159d07fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe91f83bd1b23a0f7f637f9159d07fe">&#9670;&nbsp;</a></span>decipher_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the text by shifting the characters of ``msg`` to the
left by the amount given by ``key``.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_shift, decipher_shift
&gt;&gt;&gt; msg = "GONAVYBEATARMY"
&gt;&gt;&gt; ct = encipher_shift(msg, 1); ct
'HPOBWZCFBUBSNZ'

To decipher the shifted text, change the sign of the key:

&gt;&gt;&gt; encipher_shift(ct, -1)
'GONAVYBEATARMY'

Or use this function with the original key:

&gt;&gt;&gt; decipher_shift(ct, 1)
'GONAVYBEATARMY'</pre> 
</div>
</div>
<a id="a72f3fb33817fe21537e789196f2312ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f3fb33817fe21537e789196f2312ff">&#9670;&nbsp;</a></span>decipher_vigenere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decipher_vigenere </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decode using the Vigenere cipher.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import decipher_vigenere
&gt;&gt;&gt; key = "encrypt"
&gt;&gt;&gt; ct = "QRGK kt HRZQE BPR"
&gt;&gt;&gt; decipher_vigenere(ct, key)
'MEETMEONMONDAY'</pre> 
</div>
</div>
<a id="a578efa3e60410952893bb104685eaa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578efa3e60410952893bb104685eaa10">&#9670;&nbsp;</a></span>decode_morse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.decode_morse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em> = <code>'|'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decodes a Morse Code with letters separated by ``sep``
(default is '|') and words by `word_sep` (default is '||)
into plaintext.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import decode_morse
&gt;&gt;&gt; mc = '--|---|...-|.||.|.-|...|-'
&gt;&gt;&gt; decode_morse(mc)
'MOVE EAST'

References
==========

.. [1] https://en.wikipedia.org/wiki/Morse_code</pre> 
</div>
</div>
<a id="afc3cc80da5c6b28633ecfdb149160192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3cc80da5c6b28633ecfdb149160192">&#9670;&nbsp;</a></span>dh_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.dh_private_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>digit</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diffie-Hellman Key Exchange #########################. </p>
<pre class="fragment">Return three integer tuple as private key.

Explanation
===========

Diffie-Hellman key exchange is based on the mathematical problem
called the Discrete Logarithm Problem (see ElGamal).

Diffie-Hellman key exchange is divided into the following steps:

*   Alice and Bob agree on a base that consist of a prime ``p``
    and a primitive root of ``p`` called ``g``
*   Alice choses a number ``a`` and Bob choses a number ``b`` where
    ``a`` and ``b`` are random numbers in range `[2, p)`. These are
    their private keys.
*   Alice then publicly sends Bob `g^{a} \pmod p` while Bob sends
    Alice `g^{b} \pmod p`
*   They both raise the received value to their secretly chosen
    number (``a`` or ``b``) and now have both as their shared key
    `g^{ab} \pmod p`

Parameters
==========

digit
    Minimum number of binary digits required in key.

Returns
=======

tuple : (p, g, a)
    p = prime number.

    g = primitive root of p.

    a = random number from 2 through p - 1.

Notes
=====

For testing purposes, the ``seed`` parameter may be set to control
the output of this routine. See sympy.core.random._randrange.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import dh_private_key
&gt;&gt;&gt; from sympy.ntheory import isprime, is_primitive_root
&gt;&gt;&gt; p, g, _ = dh_private_key()
&gt;&gt;&gt; isprime(p)
True
&gt;&gt;&gt; is_primitive_root(g, p)
True
&gt;&gt;&gt; p, g, _ = dh_private_key(5)
&gt;&gt;&gt; isprime(p)
True
&gt;&gt;&gt; is_primitive_root(g, p)
True</pre> 
</div>
</div>
<a id="afe29dbf09c9c272ca546658bd0b6217f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe29dbf09c9c272ca546658bd0b6217f">&#9670;&nbsp;</a></span>dh_public_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.dh_public_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return three number tuple as public key.

This is the tuple that Alice sends to Bob.

Parameters
==========

key : (p, g, a)
    A tuple generated by ``dh_private_key``.

Returns
=======

tuple : int, int, int
    A tuple of `(p, g, g^a \mod p)` with `p`, `g` and `a` given as
    parameters.s

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import dh_private_key, dh_public_key
&gt;&gt;&gt; p, g, a = dh_private_key();
&gt;&gt;&gt; _p, _g, x = dh_public_key((p, g, a))
&gt;&gt;&gt; p == _p and g == _g
True
&gt;&gt;&gt; x == pow(g, a, p)
True</pre> 
</div>
</div>
<a id="a4d2f397bb0ce97731f9e2892d25c7d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2f397bb0ce97731f9e2892d25c7d09">&#9670;&nbsp;</a></span>dh_shared_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.dh_shared_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an integer that is the shared key.

This is what Bob and Alice can both calculate using the public
keys they received from each other and their private keys.

Parameters
==========

key : (p, g, x)
    Tuple `(p, g, x)` generated by ``dh_public_key``.

b
    Random number in the range of `2` to `p - 1`
    (Chosen by second key exchange member (Bob)).

Returns
=======

int
    A shared key.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import (
...     dh_private_key, dh_public_key, dh_shared_key)
&gt;&gt;&gt; prk = dh_private_key();
&gt;&gt;&gt; p, g, x = dh_public_key(prk);
&gt;&gt;&gt; sk = dh_shared_key((p, g, x), 1000)
&gt;&gt;&gt; sk == pow(x, 1000, p)
True</pre> 
</div>
</div>
<a id="ad6121460967746635d888220af3dac1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6121460967746635d888220af3dac1b">&#9670;&nbsp;</a></span>elgamal_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.elgamal_private_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>digit</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ElGamal #############################. </p>
<pre class="fragment">Return three number tuple as private key.

Explanation
===========

Elgamal encryption is based on the mathematical problem
called the Discrete Logarithm Problem (DLP). For example,

`a^{b} \equiv c \pmod p`

In general, if ``a`` and ``b`` are known, ``ct`` is easily
calculated. If ``b`` is unknown, it is hard to use
``a`` and ``ct`` to get ``b``.

Parameters
==========

digit : int
    Minimum number of binary digits for key.

Returns
=======

tuple : (p, r, d)
    p = prime number.

    r = primitive root.

    d = random number.

Notes
=====

For testing purposes, the ``seed`` parameter may be set to control
the output of this routine. See sympy.core.random._randrange.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import elgamal_private_key
&gt;&gt;&gt; from sympy.ntheory import is_primitive_root, isprime
&gt;&gt;&gt; a, b, _ = elgamal_private_key()
&gt;&gt;&gt; isprime(a)
True
&gt;&gt;&gt; is_primitive_root(b, a)
True</pre> 
</div>
</div>
<a id="a63c6fc61d5d18c0a4d2f6083d6011b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c6fc61d5d18c0a4d2f6083d6011b96">&#9670;&nbsp;</a></span>elgamal_public_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.elgamal_public_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return three number tuple as public key.

Parameters
==========

key : (p, r, e)
    Tuple generated by ``elgamal_private_key``.

Returns
=======

tuple : (p, r, e)
    `e = r**d \bmod p`

    `d` is a random number in private key.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import elgamal_public_key
&gt;&gt;&gt; elgamal_public_key((1031, 14, 636))
(1031, 14, 212)</pre> 
</div>
</div>
<a id="ae6dc726b149ef63a31579dc46755ecb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dc726b149ef63a31579dc46755ecb2">&#9670;&nbsp;</a></span>encipher_affine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_affine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_inverse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>affine cipher examples ############ </p>
<pre class="fragment">Performs the affine cipher encryption on plaintext ``msg``, and
returns the ciphertext.

Explanation
===========

Encryption is based on the map `x \rightarrow ax+b` (mod `N`)
where ``N`` is the number of characters in the alphabet.
Decryption is based on the map `x \rightarrow cx+d` (mod `N`),
where `c = a^{-1}` (mod `N`) and `d = -a^{-1}b` (mod `N`).
In particular, for the map to be invertible, we need
`\mathrm{gcd}(a, N) = 1` and an error will be raised if this is
not true.

Parameters
==========

msg : str
    Characters that appear in ``symbols``.

a, b : int, int
    A pair integers, with ``gcd(a, N) = 1`` (the secret key).

symbols
    String of characters (default = uppercase letters).

    When no symbols are given, ``msg`` is converted to upper case
    letters and all other characters are ignored.

Returns
=======

ct
    String of characters (the ciphertext message)

Notes
=====

ALGORITHM:

    STEPS:
        0. Number the letters of the alphabet from 0, ..., N
        1. Compute from the string ``msg`` a list ``L1`` of
           corresponding integers.
        2. Compute from the list ``L1`` a new list ``L2``, given by
           replacing ``x`` by ``a*x + b (mod N)``, for each element
           ``x`` in ``L1``.
        3. Compute from the list ``L2`` a string ``ct`` of
           corresponding letters.

This is a straightforward generalization of the shift cipher with
the added complexity of requiring 2 characters to be deciphered in
order to recover the key.

References
==========

.. [1] https://en.wikipedia.org/wiki/Affine_cipher

See Also
========

decipher_affine</pre> 
</div>
</div>
<a id="a388eb3bde68fd64c660da1d243d6d717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388eb3bde68fd64c660da1d243d6d717">&#9670;&nbsp;</a></span>encipher_atbash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_atbash </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enciphers a given ``msg`` into its Atbash ciphertext and returns it.

Explanation
===========

Atbash is a substitution cipher originally used to encrypt the Hebrew
alphabet. Atbash works on the principle of mapping each alphabet to its
reverse / counterpart (i.e. a would map to z, b to y etc.)

Atbash is functionally equivalent to the affine cipher with ``a = 25``
and ``b = 25``

See Also
========

decipher_atbash</pre> 
</div>
</div>
<a id="a3ab4a080f59dd0e9183dadef64e86629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab4a080f59dd0e9183dadef64e86629">&#9670;&nbsp;</a></span>encipher_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_bg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Encrypts the message using public key and seed.

Explanation
===========

ALGORITHM:
    1. Encodes i as a string of L bits, m.
    2. Select a random element r, where 1 &lt; r &lt; key, and computes
       x = r^2 mod key.
    3. Use BBS pseudo-random number generator to generate L random bits, b,
    using the initial seed as x.
    4. Encrypted message, c_i = m_i XOR b_i, 1 &lt;= i &lt;= L.
    5. x_L = x^(2^L) mod key.
    6. Return (c, x_L)

Parameters
==========

i
    Message, a non-negative integer

key
    The public key

Returns
=======

Tuple
    (encrypted_message, x_L)

Raises
======

ValueError
    If i is negative.</pre> 
</div>
</div>
<a id="a13a22952ed544cf879ba1f1ae9cdbd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a22952ed544cf879ba1f1ae9cdbd0c">&#9670;&nbsp;</a></span>encipher_bifid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_bifid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bifid cipher ########################. </p>
<pre class="fragment">Performs the Bifid cipher encryption on plaintext ``msg``, and
returns the ciphertext.

This is the version of the Bifid cipher that uses an `n \times n`
Polybius square.

Parameters
==========

msg
    Plaintext string.

key
    Short string for key.

    Duplicate characters are ignored and then it is padded with the
    characters in ``symbols`` that were not in the short key.

symbols
    `n \times n` characters defining the alphabet.

    (default is string.printable)

Returns
=======

ciphertext
    Ciphertext using Bifid5 cipher without spaces.

See Also
========

decipher_bifid, encipher_bifid5, encipher_bifid6

References
==========

.. [1] https://en.wikipedia.org/wiki/Bifid_cipher</pre> 
</div>
</div>
<a id="a04a1a082ea2fc35ac4c3835e0c058bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a1a082ea2fc35ac4c3835e0c058bc8">&#9670;&nbsp;</a></span>encipher_bifid5()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_bifid5 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the Bifid cipher encryption on plaintext ``msg``, and
returns the ciphertext.

Explanation
===========

This is the version of the Bifid cipher that uses the `5 \times 5`
Polybius square. The letter "J" is ignored so it must be replaced
with something else (traditionally an "I") before encryption.

ALGORITHM: (5x5 case)

    STEPS:
        0. Create the `5 \times 5` Polybius square ``S`` associated
           to ``key`` as follows:

            a) moving from left-to-right, top-to-bottom,
               place the letters of the key into a `5 \times 5`
               matrix,
            b) if the key has less than 25 letters, add the
               letters of the alphabet not in the key until the
               `5 \times 5` square is filled.

        1. Create a list ``P`` of pairs of numbers which are the
           coordinates in the Polybius square of the letters in
           ``msg``.
        2. Let ``L1`` be the list of all first coordinates of ``P``
           (length of ``L1 = n``), let ``L2`` be the list of all
           second coordinates of ``P`` (so the length of ``L2``
           is also ``n``).
        3. Let ``L`` be the concatenation of ``L1`` and ``L2``
           (length ``L = 2*n``), except that consecutive numbers
           are paired ``(L[2*i], L[2*i + 1])``. You can regard
           ``L`` as a list of pairs of length ``n``.
        4. Let ``C`` be the list of all letters which are of the
           form ``S[i, j]``, for all ``(i, j)`` in ``L``. As a
           string, this is the ciphertext of ``msg``.

Parameters
==========

msg : str
    Plaintext string.

    Converted to upper case and filtered of anything but all letters
    except J.

key
    Short string for key; non-alphabetic letters, J and duplicated
    characters are ignored and then, if the length is less than 25
    characters, it is padded with other letters of the alphabet
    (in alphabetical order).

Returns
=======

ct
    Ciphertext (all caps, no spaces).

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import (
...     encipher_bifid5, decipher_bifid5)

"J" will be omitted unless it is replaced with something else:

&gt;&gt;&gt; round_trip = lambda m, k: \
...     decipher_bifid5(encipher_bifid5(m, k), k)
&gt;&gt;&gt; key = 'a'
&gt;&gt;&gt; msg = "JOSIE"
&gt;&gt;&gt; round_trip(msg, key)
'OSIE'
&gt;&gt;&gt; round_trip(msg.replace("J", "I"), key)
'IOSIE'
&gt;&gt;&gt; j = "QIQ"
&gt;&gt;&gt; round_trip(msg.replace("J", j), key).replace(j, "J")
'JOSIE'


Notes
=====

The Bifid cipher was invented around 1901 by Felix Delastelle.
It is a *fractional substitution* cipher, where letters are
replaced by pairs of symbols from a smaller alphabet. The
cipher uses a `5 \times 5` square filled with some ordering of the
alphabet, except that "J" is replaced with "I" (this is a so-called
Polybius square; there is a `6 \times 6` analog if you add back in
"J" and also append onto the usual 26 letter alphabet, the digits
0, 1, ..., 9).
According to Helen Gaines' book *Cryptanalysis*, this type of cipher
was used in the field by the German Army during World War I.

See Also
========

decipher_bifid5, encipher_bifid</pre> 
</div>
</div>
<a id="a98f8b53633a083aa08ad495a63665437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f8b53633a083aa08ad495a63665437">&#9670;&nbsp;</a></span>encipher_bifid6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_bifid6 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the Bifid cipher encryption on plaintext ``msg``, and
returns the ciphertext.

This is the version of the Bifid cipher that uses the `6 \times 6`
Polybius square.

Parameters
==========

msg
    Plaintext string (digits okay).

key
    Short string for key (digits okay).

    If ``key`` is less than 36 characters long, the square will be
    filled with letters A through Z and digits 0 through 9.

Returns
=======

ciphertext
    Ciphertext from Bifid cipher (all caps, no spaces).

See Also
========

decipher_bifid6, encipher_bifid</pre> 
</div>
</div>
<a id="a65b078a7502b571e19d3b57bab6f5370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b078a7502b571e19d3b57bab6f5370">&#9670;&nbsp;</a></span>encipher_elgamal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_elgamal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Encrypt message with public key.

Explanation
===========

``i`` is a plaintext message expressed as an integer.
``key`` is public key (p, r, e). In order to encrypt
a message, a random number ``a`` in ``range(2, p)``
is generated and the encryped message is returned as
`c_{1}` and `c_{2}` where:

`c_{1} \equiv r^{a} \pmod p`

`c_{2} \equiv m e^{a} \pmod p`

Parameters
==========

msg
    int of encoded message.

key
    Public key.

Returns
=======

tuple : (c1, c2)
    Encipher into two number.

Notes
=====

For testing purposes, the ``seed`` parameter may be set to control
the output of this routine. See sympy.core.random._randrange.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_elgamal, elgamal_private_key, elgamal_public_key
&gt;&gt;&gt; pri = elgamal_private_key(5, seed=[3]); pri
(37, 2, 3)
&gt;&gt;&gt; pub = elgamal_public_key(pri); pub
(37, 2, 8)
&gt;&gt;&gt; msg = 36
&gt;&gt;&gt; encipher_elgamal(msg, pub, seed=[3])
(8, 6)</pre> 
</div>
</div>
<a id="aaf7394586077900770029351dca89cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7394586077900770029351dca89cf9">&#9670;&nbsp;</a></span>encipher_gm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_gm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Encrypt integer 'i' using public_key 'key'
Note that gm uses random encryption.

Parameters
==========

i : int
    The message to encrypt.

key : (a, N)
    The public key.

Returns
=======

list : list of int
    The randomized encrypted message.</pre> 
</div>
</div>
<a id="adb5f108847e4acde6e02ad73e2224a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5f108847e4acde6e02ad73e2224a8c">&#9670;&nbsp;</a></span>encipher_hill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_hill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad</em> = <code>&quot;Q&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hill cipher ########################. </p>
<pre class="fragment">Return the Hill cipher encryption of ``msg``.

Explanation
===========

The Hill cipher [1]_, invented by Lester S. Hill in the 1920's [2]_,
was the first polygraphic cipher in which it was practical
(though barely) to operate on more than three symbols at once.
The following discussion assumes an elementary knowledge of
matrices.

First, each letter is first encoded as a number starting with 0.
Suppose your message `msg` consists of `n` capital letters, with no
spaces. This may be regarded an `n`-tuple M of elements of
`Z_{26}` (if the letters are those of the English alphabet). A key
in the Hill cipher is a `k x k` matrix `K`, all of whose entries
are in `Z_{26}`, such that the matrix `K` is invertible (i.e., the
linear transformation `K: Z_{N}^k \rightarrow Z_{N}^k`
is one-to-one).


Parameters
==========

msg
    Plaintext message of `n` upper-case letters.

key
    A `k \times k` invertible matrix `K`, all of whose entries are
    in `Z_{26}` (or whatever number of symbols are being used).

pad
    Character (default "Q") to use to make length of text be a
    multiple of ``k``.

Returns
=======

ct
    Ciphertext of upper-case letters.

Notes
=====

ALGORITHM:

    STEPS:
        0. Number the letters of the alphabet from 0, ..., N
        1. Compute from the string ``msg`` a list ``L`` of
           corresponding integers. Let ``n = len(L)``.
        2. Break the list ``L`` up into ``t = ceiling(n/k)``
           sublists ``L_1``, ..., ``L_t`` of size ``k`` (with
           the last list "padded" to ensure its size is
           ``k``).
        3. Compute new list ``C_1``, ..., ``C_t`` given by
           ``C[i] = K*L_i`` (arithmetic is done mod N), for each
           ``i``.
        4. Concatenate these into a list ``C = C_1 + ... + C_t``.
        5. Compute from ``C`` a string ``ct`` of corresponding
           letters. This has length ``k*t``.

References
==========

.. [1] https://en.wikipedia.org/wiki/Hill_cipher
.. [2] Lester S. Hill, Cryptography in an Algebraic Alphabet,
   The American Mathematical Monthly Vol.36, June-July 1929,
   pp.306-312.

See Also
========

decipher_hill</pre> 
</div>
</div>
<a id="a3951bf6b70f1caf19b6471d463141db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3951bf6b70f1caf19b6471d463141db9">&#9670;&nbsp;</a></span>encipher_kid_rsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_kid_rsa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Here ``msg`` is the plaintext and ``key`` is the public key.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import (
...     encipher_kid_rsa, kid_rsa_public_key)
&gt;&gt;&gt; msg = 200
&gt;&gt;&gt; a, b, A, B = 3, 4, 5, 6
&gt;&gt;&gt; key = kid_rsa_public_key(a, b, A, B)
&gt;&gt;&gt; encipher_kid_rsa(msg, key)
161</pre> 
</div>
</div>
<a id="aeaa51b1184b3953c4f3cae0cbbfa5f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa51b1184b3953c4f3cae0cbbfa5f1c">&#9670;&nbsp;</a></span>encipher_railfence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_railfence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rails</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RailFence Cipher #############. </p>
<pre class="fragment">Performs Railfence Encryption on plaintext and returns ciphertext

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_railfence
&gt;&gt;&gt; message = "hello world"
&gt;&gt;&gt; encipher_railfence(message,3)
'horel ollwd'

Parameters
==========

message : string, the message to encrypt.
rails : int, the number of rails.

Returns
=======

The Encrypted string message.

References
==========
.. [1] https://en.wikipedia.org/wiki/Rail_fence_cipher</pre> 
</div>
</div>
<a id="a495929c4e036e14a61ae2ae5cf9ab5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495929c4e036e14a61ae2ae5cf9ab5e9">&#9670;&nbsp;</a></span>encipher_rot13()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_rot13 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the ROT13 encryption on a given plaintext ``msg``.

Explanation
===========

ROT13 is a substitution cipher which substitutes each letter
in the plaintext message for the letter furthest away from it
in the English alphabet.

Equivalently, it is just a Caeser (shift) cipher with a shift
key of 13 (midway point of the alphabet).

References
==========

.. [1] https://en.wikipedia.org/wiki/ROT13

See Also
========

decipher_rot13
encipher_shift</pre> 
</div>
</div>
<a id="a80d98d4092717c91f6da8619aa51d317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d98d4092717c91f6da8619aa51d317">&#9670;&nbsp;</a></span>encipher_rsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_rsa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factors</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Encrypt the plaintext with RSA.

Parameters
==========

i : integer
    The plaintext to be encrypted for.

key : (n, e) where n, e are integers
    `n` is the modulus of the key and `e` is the exponent of the
    key. The encryption is computed by `i^e \bmod n`.

    The key can either be a public key or a private key, however,
    the message encrypted by a public key can only be decrypted by
    a private key, and vice versa, as RSA is an asymmetric
    cryptography system.

factors : list of coprime integers
    This is identical to the keyword ``factors`` in
    :meth:`decipher_rsa`.

Notes
=====

Some specifications may make the RSA not cryptographically
meaningful.

For example, `0`, `1` will remain always same after taking any
number of exponentiation, thus, should be avoided.

Furthermore, if `i^e &lt; n`, `i` may easily be figured out by taking
`e` th root.

And also, specifying the exponent as `1` or in more generalized form
as `1 + k \lambda(n)` where `k` is an nonnegative integer,
`\lambda` is a carmichael totient, the RSA becomes an identity
mapping.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_rsa
&gt;&gt;&gt; from sympy.crypto.crypto import rsa_public_key, rsa_private_key

Public Key Encryption:

&gt;&gt;&gt; p, q, e = 3, 5, 7
&gt;&gt;&gt; puk = rsa_public_key(p, q, e)
&gt;&gt;&gt; msg = 12
&gt;&gt;&gt; encipher_rsa(msg, puk)
3

Private Key Encryption:

&gt;&gt;&gt; p, q, e = 3, 5, 7
&gt;&gt;&gt; prk = rsa_private_key(p, q, e)
&gt;&gt;&gt; msg = 12
&gt;&gt;&gt; encipher_rsa(msg, prk)
3

Encryption using chinese remainder theorem:

&gt;&gt;&gt; encipher_rsa(msg, prk, factors=[p, q])
3
</pre> 
</div>
</div>
<a id="a5d3448ad7c59237c878e5a44b51a7fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3448ad7c59237c878e5a44b51a7fc8">&#9670;&nbsp;</a></span>encipher_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shift cipher examples ############ </p>
<pre class="fragment">Performs shift cipher encryption on plaintext msg, and returns the
ciphertext.

Parameters
==========

key : int
    The secret key.

msg : str
    Plaintext of upper-case letters.

Returns
=======

str
    Ciphertext of upper-case letters.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_shift, decipher_shift
&gt;&gt;&gt; msg = "GONAVYBEATARMY"
&gt;&gt;&gt; ct = encipher_shift(msg, 1); ct
'HPOBWZCFBUBSNZ'

To decipher the shifted text, change the sign of the key:

&gt;&gt;&gt; encipher_shift(ct, -1)
'GONAVYBEATARMY'

There is also a convenience function that does this with the
original key:

&gt;&gt;&gt; decipher_shift(ct, 1)
'GONAVYBEATARMY'

Notes
=====

ALGORITHM:

    STEPS:
        0. Number the letters of the alphabet from 0, ..., N
        1. Compute from the string ``msg`` a list ``L1`` of
           corresponding integers.
        2. Compute from the list ``L1`` a new list ``L2``, given by
           adding ``(k mod 26)`` to each element in ``L1``.
        3. Compute from the list ``L2`` a string ``ct`` of
           corresponding letters.

The shift cipher is also called the Caesar cipher, after
Julius Caesar, who, according to Suetonius, used it with a
shift of three to protect messages of military significance.
Caesar's nephew Augustus reportedly used a similar cipher, but
with a right shift of 1.

References
==========

.. [1] https://en.wikipedia.org/wiki/Caesar_cipher
.. [2] https://mathworld.wolfram.com/CaesarsMethod.html

See Also
========

decipher_shift</pre> 
</div>
</div>
<a id="afe312eb5d4494237e003a91472dfa48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe312eb5d4494237e003a91472dfa48b">&#9670;&nbsp;</a></span>encipher_substitution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_substitution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>substitution cipher ########################### </p>
<pre class="fragment">Returns the ciphertext obtained by replacing each character that
appears in ``old`` with the corresponding character in ``new``.
If ``old`` is a mapping, then new is ignored and the replacements
defined by ``old`` are used.

Explanation
===========

This is a more general than the affine cipher in that the key can
only be recovered by determining the mapping for each symbol.
Though in practice, once a few symbols are recognized the mappings
for other characters can be quickly guessed.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_substitution, AZ
&gt;&gt;&gt; old = 'OEYAG'
&gt;&gt;&gt; new = '034^6'
&gt;&gt;&gt; msg = AZ("go navy! beat army!")
&gt;&gt;&gt; ct = encipher_substitution(msg, old, new); ct
'60N^V4B3^T^RM4'

To decrypt a substitution, reverse the last two arguments:

&gt;&gt;&gt; encipher_substitution(ct, new, old)
'GONAVYBEATARMY'

In the special case where ``old`` and ``new`` are a permutation of
order 2 (representing a transposition of characters) their order
is immaterial:

&gt;&gt;&gt; old = 'NAVY'
&gt;&gt;&gt; new = 'ANYV'
&gt;&gt;&gt; encipher = lambda x: encipher_substitution(x, old, new)
&gt;&gt;&gt; encipher('NAVY')
'ANYV'
&gt;&gt;&gt; encipher(_)
'NAVY'

The substitution cipher, in general, is a method
whereby "units" (not necessarily single characters) of plaintext
are replaced with ciphertext according to a regular system.

&gt;&gt;&gt; ords = dict(zip('abc', ['\\%i' % ord(i) for i in 'abc']))
&gt;&gt;&gt; print(encipher_substitution('abc', ords))
\97\98\99

References
==========

.. [1] https://en.wikipedia.org/wiki/Substitution_cipher</pre> 
</div>
</div>
<a id="a2e57ea30e43ecdb09a8ac2e48d531673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e57ea30e43ecdb09a8ac2e48d531673">&#9670;&nbsp;</a></span>encipher_vigenere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encipher_vigenere </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vigenere cipher examples ########################. </p>
<pre class="fragment">Performs the Vigenere cipher encryption on plaintext ``msg``, and
returns the ciphertext.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encipher_vigenere, AZ
&gt;&gt;&gt; key = "encrypt"
&gt;&gt;&gt; msg = "meet me on monday"
&gt;&gt;&gt; encipher_vigenere(msg, key)
'QRGKKTHRZQEBPR'

Section 1 of the Kryptos sculpture at the CIA headquarters
uses this cipher and also changes the order of the
alphabet [2]_. Here is the first line of that section of
the sculpture:

&gt;&gt;&gt; from sympy.crypto.crypto import decipher_vigenere, padded_key
&gt;&gt;&gt; alp = padded_key('KRYPTOS', AZ())
&gt;&gt;&gt; key = 'PALIMPSEST'
&gt;&gt;&gt; msg = 'EMUFPHZLRFAXYUSDJKZLDKRNSHGNFIVJ'
&gt;&gt;&gt; decipher_vigenere(msg, key, alp)
'BETWEENSUBTLESHADINGANDTHEABSENC'

Explanation
===========

The Vigenere cipher is named after Blaise de Vigenere, a sixteenth
century diplomat and cryptographer, by a historical accident.
Vigenere actually invented a different and more complicated cipher.
The so-called *Vigenere cipher* was actually invented
by Giovan Batista Belaso in 1553.

This cipher was used in the 1800's, for example, during the American
Civil War. The Confederacy used a brass cipher disk to implement the
Vigenere cipher (now on display in the NSA Museum in Fort
Meade) [1]_.

The Vigenere cipher is a generalization of the shift cipher.
Whereas the shift cipher shifts each letter by the same amount
(that amount being the key of the shift cipher) the Vigenere
cipher shifts a letter by an amount determined by the key (which is
a word or phrase known only to the sender and receiver).

For example, if the key was a single letter, such as "C", then the
so-called Vigenere cipher is actually a shift cipher with a
shift of `2` (since "C" is the 2nd letter of the alphabet, if
you start counting at `0`). If the key was a word with two
letters, such as "CA", then the so-called Vigenere cipher will
shift letters in even positions by `2` and letters in odd positions
are left alone (shifted by `0`, since "A" is the 0th letter, if
you start counting at `0`).


ALGORITHM:

    INPUT:

        ``msg``: string of characters that appear in ``symbols``
        (the plaintext)

        ``key``: a string of characters that appear in ``symbols``
        (the secret key)

        ``symbols``: a string of letters defining the alphabet


    OUTPUT:

        ``ct``: string of characters (the ciphertext message)

    STEPS:
        0. Number the letters of the alphabet from 0, ..., N
        1. Compute from the string ``key`` a list ``L1`` of
           corresponding integers. Let ``n1 = len(L1)``.
        2. Compute from the string ``msg`` a list ``L2`` of
           corresponding integers. Let ``n2 = len(L2)``.
        3. Break ``L2`` up sequentially into sublists of size
           ``n1``; the last sublist may be smaller than ``n1``
        4. For each of these sublists ``L`` of ``L2``, compute a
           new list ``C`` given by ``C[i] = L[i] + L1[i] (mod N)``
           to the ``i``-th element in the sublist, for each ``i``.
        5. Assemble these lists ``C`` by concatenation into a new
           list of length ``n2``.
        6. Compute from the new list a string ``ct`` of
           corresponding letters.

Once it is known that the key is, say, `n` characters long,
frequency analysis can be applied to every `n`-th letter of
the ciphertext to determine the plaintext. This method is
called *Kasiski examination* (although it was first discovered
by Babbage). If they key is as long as the message and is
comprised of randomly selected characters -- a one-time pad -- the
message is theoretically unbreakable.

The cipher Vigenere actually discovered is an "auto-key" cipher
described as follows.

ALGORITHM:

    INPUT:

      ``key``: a string of letters (the secret key)

      ``msg``: string of letters (the plaintext message)

    OUTPUT:

      ``ct``: string of upper-case letters (the ciphertext message)

    STEPS:
        0. Number the letters of the alphabet from 0, ..., N
        1. Compute from the string ``msg`` a list ``L2`` of
           corresponding integers. Let ``n2 = len(L2)``.
        2. Let ``n1`` be the length of the key. Append to the
           string ``key`` the first ``n2 - n1`` characters of
           the plaintext message. Compute from this string (also of
           length ``n2``) a list ``L1`` of integers corresponding
           to the letter numbers in the first step.
        3. Compute a new list ``C`` given by
           ``C[i] = L1[i] + L2[i] (mod N)``.
        4. Compute from the new list a string ``ct`` of letters
           corresponding to the new integers.

To decipher the auto-key ciphertext, the key is used to decipher
the first ``n1`` characters and then those characters become the
key to  decipher the next ``n1`` characters, etc...:

&gt;&gt;&gt; m = AZ('go navy, beat army! yes you can'); m
'GONAVYBEATARMYYESYOUCAN'
&gt;&gt;&gt; key = AZ('gold bug'); n1 = len(key); n2 = len(m)
&gt;&gt;&gt; auto_key = key + m[:n2 - n1]; auto_key
'GOLDBUGGONAVYBEATARMYYE'
&gt;&gt;&gt; ct = encipher_vigenere(m, auto_key); ct
'MCYDWSHKOGAMKZCELYFGAYR'
&gt;&gt;&gt; n1 = len(key)
&gt;&gt;&gt; pt = []
&gt;&gt;&gt; while ct:
...     part, ct = ct[:n1], ct[n1:]
...     pt.append(decipher_vigenere(part, key))
...     key = pt[-1]
...
&gt;&gt;&gt; ''.join(pt) == m
True

References
==========

.. [1] https://en.wikipedia.org/wiki/Vigenere_cipher
.. [2] https://web.archive.org/web/20071116100808/https://filebox.vt.edu/users/batman/kryptos.html
   (short URL: https://goo.gl/ijr22d)</pre> 
</div>
</div>
<a id="a526dba5a7140ced621d041b0df37cbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526dba5a7140ced621d041b0df37cbc6">&#9670;&nbsp;</a></span>encode_morse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.encode_morse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em> = <code>'|'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Encodes a plaintext into popular Morse Code with letters
separated by ``sep`` and words by a double ``sep``.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import encode_morse
&gt;&gt;&gt; msg = 'ATTACK RIGHT FLANK'
&gt;&gt;&gt; encode_morse(msg)
'.-|-|-|.-|-.-.|-.-||.-.|..|--.|....|-||..-.|.-..|.-|-.|-.-'

References
==========

.. [1] https://en.wikipedia.org/wiki/Morse_code</pre> 
</div>
</div>
<a id="acf4f47813e810d7e5388a52412ecbbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4f47813e810d7e5388a52412ecbbd8">&#9670;&nbsp;</a></span>gm_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.gm_private_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if ``p`` and ``q`` can be used as private keys for
the Goldwasser-Micali encryption. The method works
roughly as follows.

Explanation
===========

#. Pick two large primes $p$ and $q$.
#. Call their product $N$.
#. Given a message as an integer $i$, write $i$ in its bit representation $b_0, \dots, b_n$.
#. For each $k$,

 if $b_k = 0$:
    let $a_k$ be a random square
    (quadratic residue) modulo $p q$
    such that ``jacobi_symbol(a, p*q) = 1``
 if $b_k = 1$:
    let $a_k$ be a random non-square
    (non-quadratic residue) modulo $p q$
    such that ``jacobi_symbol(a, p*q) = 1``

returns $\left[a_1, a_2, \dots\right]$

$b_k$ can be recovered by checking whether or not
$a_k$ is a residue. And from the $b_k$'s, the message
can be reconstructed.

The idea is that, while ``jacobi_symbol(a, p*q)``
can be easily computed (and when it is equal to $-1$ will
tell you that $a$ is not a square mod $p q$), quadratic
residuosity modulo a composite number is hard to compute
without knowing its factorization.

Moreover, approximately half the numbers coprime to $p q$ have
:func:`~.jacobi_symbol` equal to $1$ . And among those, approximately half
are residues and approximately half are not. This maximizes the
entropy of the code.

Parameters
==========

p, q, a
    Initialization variables.

Returns
=======

tuple : (p, q)
    The input value ``p`` and ``q``.

Raises
======

ValueError
    If ``p`` and ``q`` are not distinct odd primes.</pre> 
</div>
</div>
<a id="a760a613b8e736d8faf9d9194b9f1ee71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760a613b8e736d8faf9d9194b9f1ee71">&#9670;&nbsp;</a></span>gm_public_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.gm_public_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute public keys for ``p`` and ``q``.
Note that in Goldwasser-Micali Encryption,
public keys are randomly selected.

Parameters
==========

p, q, a : int, int, int
    Initialization variables.

Returns
=======

tuple : (a, N)
    ``a`` is the input ``a`` if it is not ``None`` otherwise
    some random integer coprime to ``p`` and ``q``.

    ``N`` is the product of ``p`` and ``q``.</pre> 
</div>
</div>
<a id="a9beabbcf96b9b01f6f524589bd6851eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9beabbcf96b9b01f6f524589bd6851eb">&#9670;&nbsp;</a></span>kid_rsa_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.kid_rsa_private_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute `M = a b - 1`, `e = A M + a`, `d = B M + b`,
`n = (e d - 1) / M`. The *private key* is `d`, which Bob
keeps secret.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import kid_rsa_private_key
&gt;&gt;&gt; a, b, A, B = 3, 4, 5, 6
&gt;&gt;&gt; kid_rsa_private_key(a, b, A, B)
(369, 70)</pre> 
</div>
</div>
<a id="add7c500a27e2e24f2aac4cd916d63e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7c500a27e2e24f2aac4cd916d63e5c">&#9670;&nbsp;</a></span>kid_rsa_public_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.kid_rsa_public_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kid krypto (kid RSA) ############################# </p>
<pre class="fragment">Kid RSA is a version of RSA useful to teach grade school children
since it does not involve exponentiation.

Explanation
===========

Alice wants to talk to Bob. Bob generates keys as follows.
Key generation:

* Select positive integers `a, b, A, B` at random.
* Compute `M = a b - 1`, `e = A M + a`, `d = B M + b`,
  `n = (e d - 1)//M`.
* The *public key* is `(n, e)`. Bob sends these to Alice.
* The *private key* is `(n, d)`, which Bob keeps secret.

Encryption: If `p` is the plaintext message then the
ciphertext is `c = p e \pmod n`.

Decryption: If `c` is the ciphertext message then the
plaintext is `p = c d \pmod n`.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import kid_rsa_public_key
&gt;&gt;&gt; a, b, A, B = 3, 4, 5, 6
&gt;&gt;&gt; kid_rsa_public_key(a, b, A, B)
(369, 58)</pre> 
</div>
</div>
<a id="a9804f41a5b5db476736f888d20481743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9804f41a5b5db476736f888d20481743">&#9670;&nbsp;</a></span>lfsr_autocorrelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.lfsr_autocorrelation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function computes the LFSR autocorrelation function.

Parameters
==========

L
    A periodic sequence of elements of `GF(2)`.
    L must have length larger than P.

P
    The period of L.

k : int
    An integer `k` (`0 &lt; k &lt; P`).

Returns
=======

autocorrelation
    The k-th value of the autocorrelation of the LFSR L.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import (
...     lfsr_sequence, lfsr_autocorrelation)
&gt;&gt;&gt; from sympy.polys.domains import FF
&gt;&gt;&gt; F = FF(2)
&gt;&gt;&gt; fill = [F(1), F(1), F(0), F(1)]
&gt;&gt;&gt; key = [F(1), F(0), F(0), F(1)]
&gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)
&gt;&gt;&gt; lfsr_autocorrelation(s, 15, 7)
-1/15
&gt;&gt;&gt; lfsr_autocorrelation(s, 15, 0)
1</pre> 
</div>
</div>
<a id="a1c4012a9efa1b6d3e59df460b404bb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4012a9efa1b6d3e59df460b404bb94">&#9670;&nbsp;</a></span>lfsr_connection_polynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.lfsr_connection_polynomial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function computes the LFSR connection polynomial.

Parameters
==========

s
    A sequence of elements of even length, with entries in a finite
    field.

Returns
=======

C(x)
    The connection polynomial of a minimal LFSR yielding s.

    This implements the algorithm in section 3 of J. L. Massey's
    article [M]_.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import (
...     lfsr_sequence, lfsr_connection_polynomial)
&gt;&gt;&gt; from sympy.polys.domains import FF
&gt;&gt;&gt; F = FF(2)
&gt;&gt;&gt; fill = [F(1), F(1), F(0), F(1)]
&gt;&gt;&gt; key = [F(1), F(0), F(0), F(1)]
&gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)
&gt;&gt;&gt; lfsr_connection_polynomial(s)
x**4 + x + 1
&gt;&gt;&gt; fill = [F(1), F(0), F(0), F(1)]
&gt;&gt;&gt; key = [F(1), F(1), F(0), F(1)]
&gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)
&gt;&gt;&gt; lfsr_connection_polynomial(s)
x**3 + 1
&gt;&gt;&gt; fill = [F(1), F(0), F(1)]
&gt;&gt;&gt; key = [F(1), F(1), F(0)]
&gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)
&gt;&gt;&gt; lfsr_connection_polynomial(s)
x**3 + x**2 + 1
&gt;&gt;&gt; fill = [F(1), F(0), F(1)]
&gt;&gt;&gt; key = [F(1), F(0), F(1)]
&gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)
&gt;&gt;&gt; lfsr_connection_polynomial(s)
x**3 + x + 1

References
==========

.. [M] James L. Massey, "Shift-Register Synthesis and BCH Decoding."
    IEEE Trans. on Information Theory, vol. 15(1), pp. 122-127,
    Jan 1969.</pre> 
</div>
</div>
<a id="ad4747b3e827f9061d6c654bb97dcbff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4747b3e827f9061d6c654bb97dcbff5">&#9670;&nbsp;</a></span>lfsr_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.lfsr_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LFSRs ##########################################. </p>
<pre class="fragment">This function creates an LFSR sequence.

Parameters
==========

key : list
    A list of finite field elements, `[c_0, c_1, \ldots, c_k].`

fill : list
    The list of the initial terms of the LFSR sequence,
    `[x_0, x_1, \ldots, x_k].`

n
    Number of terms of the sequence that the function returns.

Returns
=======

L
    The LFSR sequence defined by
    `x_{n+1} = c_k x_n + \ldots + c_0 x_{n-k}`, for
    `n \leq k`.

Notes
=====

S. Golomb [G]_ gives a list of three statistical properties a
sequence of numbers `a = \{a_n\}_{n=1}^\infty`,
`a_n \in \{0,1\}`, should display to be considered
"random". Define the autocorrelation of `a` to be

.. math::

    C(k) = C(k,a) = \lim_{N\rightarrow \infty} {1\over N}\sum_{n=1}^N (-1)^{a_n + a_{n+k}}.

In the case where `a` is periodic with period
`P` then this reduces to

.. math::

    C(k) = {1\over P}\sum_{n=1}^P (-1)^{a_n + a_{n+k}}.

Assume `a` is periodic with period `P`.

- balance:

  .. math::

    \left|\sum_{n=1}^P(-1)^{a_n}\right| \leq 1.

- low autocorrelation:

   .. math::

     C(k) = \left\{ \begin{array}{cc} 1,&amp; k = 0,\\ \epsilon, &amp; k \ne 0. \end{array} \right.

  (For sequences satisfying these first two properties, it is known
  that `\epsilon = -1/P` must hold.)

- proportional runs property: In each period, half the runs have
  length `1`, one-fourth have length `2`, etc.
  Moreover, there are as many runs of `1`'s as there are of
  `0`'s.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import lfsr_sequence
&gt;&gt;&gt; from sympy.polys.domains import FF
&gt;&gt;&gt; F = FF(2)
&gt;&gt;&gt; fill = [F(1), F(1), F(0), F(1)]
&gt;&gt;&gt; key = [F(1), F(0), F(0), F(1)]
&gt;&gt;&gt; lfsr_sequence(key, fill, 10)
[1 mod 2, 1 mod 2, 0 mod 2, 1 mod 2, 0 mod 2,
1 mod 2, 1 mod 2, 0 mod 2, 0 mod 2, 1 mod 2]

References
==========

.. [G] Solomon Golomb, Shift register sequences, Aegean Park Press,
   Laguna Hills, Ca, 1967</pre> 
</div>
</div>
<a id="a086fc01b97a0a91e9f7c6a85a104ff52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086fc01b97a0a91e9f7c6a85a104ff52">&#9670;&nbsp;</a></span>padded_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.padded_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a string of the distinct characters of ``symbols`` with
those of ``key`` appearing first. A ValueError is raised if
a) there are duplicate characters in ``symbols`` or
b) there are characters in ``key`` that are  not in ``symbols``.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import padded_key
&gt;&gt;&gt; padded_key('PUPPY', 'OPQRSTUVWXY')
'PUYOQRSTVWX'
&gt;&gt;&gt; padded_key('RSA', 'ARTIST')
Traceback (most recent call last):
...
ValueError: duplicate characters in symbols: T</pre> 
</div>
</div>
<a id="afd31187978a4f37304145849633130a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd31187978a4f37304145849633130a3">&#9670;&nbsp;</a></span>rsa_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.rsa_private_key </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the RSA *private key* pair, `(n, d)`

Parameters
==========

args : naturals
    The keyword is identical to the ``args`` in
    :meth:`rsa_public_key`.

totient : bool, optional
    If ``'Euler'``, it uses Euler's totient convention `\phi(n)`
    which is :meth:`sympy.functions.combinatorial.numbers.totient` in SymPy.

    If ``'Carmichael'``, it uses Carmichael's totient convention
    `\lambda(n)` which is
    :meth:`sympy.functions.combinatorial.numbers.reduced_totient` in SymPy.

    There can be some output differences for private key generation
    as examples below.

    Example using Euler's totient:

    &gt;&gt;&gt; from sympy.crypto.crypto import rsa_private_key
    &gt;&gt;&gt; rsa_private_key(61, 53, 17, totient='Euler')
    (3233, 2753)

    Example using Carmichael's totient:

    &gt;&gt;&gt; from sympy.crypto.crypto import rsa_private_key
    &gt;&gt;&gt; rsa_private_key(61, 53, 17, totient='Carmichael')
    (3233, 413)

index : nonnegative integer, optional
    Returns an arbitrary solution of a RSA private key at the index
    specified at `0, 1, 2, \dots`. This parameter needs to be
    specified along with ``totient='Carmichael'``.

    RSA private exponent is a non-unique solution of
    `e d \mod \lambda(n) = 1` and it is possible in any form of
    `d + k \lambda(n)`, where `d` is an another
    already-computed private exponent, and `\lambda` is a
    Carmichael's totient function, and `k` is any integer.

    However, considering only the positive cases, there can be
    a principal solution of a RSA private exponent `d_0` in
    `0 &lt; d_0 &lt; \lambda(n)`, and all the other solutions
    can be canonicalzed in a form of `d_0 + k \lambda(n)`.

    ``index`` specifies the `k` notation to yield any possible value
    an RSA private key can have.

    An example of computing any arbitrary RSA private key:

    &gt;&gt;&gt; from sympy.crypto.crypto import rsa_private_key
    &gt;&gt;&gt; rsa_private_key(61, 53, 17, totient='Carmichael', index=0)
    (3233, 413)
    &gt;&gt;&gt; rsa_private_key(61, 53, 17, totient='Carmichael', index=1)
    (3233, 1193)
    &gt;&gt;&gt; rsa_private_key(61, 53, 17, totient='Carmichael', index=2)
    (3233, 1973)

multipower : bool, optional
    The keyword is identical to the ``multipower`` in
    :meth:`rsa_public_key`.

Returns
=======

(n, d) : int, int
    `n` is a product of any arbitrary number of primes given as
    the argument.

    `d` is the inverse of `e` (mod `\phi(n)`) where `e` is the
    exponent given, and `\phi` is a Euler totient.

False
    Returned if less than two arguments are given, or `e` is
    not relatively prime to the totient of the modulus.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import rsa_private_key

A private key of a two-prime RSA:

&gt;&gt;&gt; p, q, e = 3, 5, 7
&gt;&gt;&gt; rsa_private_key(p, q, e)
(15, 7)
&gt;&gt;&gt; rsa_private_key(p, q, 30)
False

A private key of a multiprime RSA:

&gt;&gt;&gt; primes = [2, 3, 5, 7, 11, 13]
&gt;&gt;&gt; e = 7
&gt;&gt;&gt; args = primes + [e]
&gt;&gt;&gt; rsa_private_key(*args)
(30030, 823)

See Also
========

rsa_public_key
encipher_rsa
decipher_rsa

References
==========

.. [1] https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29

.. [2] https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf

.. [3] https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf

.. [4] https://www.itiis.org/digital-library/manuscript/1381
</pre> 
</div>
</div>
<a id="ac7a1269d69d8859f738de4167007bc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a1269d69d8859f738de4167007bc23">&#9670;&nbsp;</a></span>rsa_public_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.rsa_public_key </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the RSA *public key* pair, `(n, e)`

Parameters
==========

args : naturals
    If specified as `p, q, e` where `p` and `q` are distinct primes
    and `e` is a desired public exponent of the RSA, `n = p q` and
    `e` will be verified against the totient
    `\phi(n)` (Euler totient) or `\lambda(n)` (Carmichael totient)
    to be `\gcd(e, \phi(n)) = 1` or `\gcd(e, \lambda(n)) = 1`.

    If specified as `p_1, p_2, \dots, p_n, e` where
    `p_1, p_2, \dots, p_n` are specified as primes,
    and `e` is specified as a desired public exponent of the RSA,
    it will be able to form a multi-prime RSA, which is a more
    generalized form of the popular 2-prime RSA.

    It can also be possible to form a single-prime RSA by specifying
    the argument as `p, e`, which can be considered a trivial case
    of a multiprime RSA.

    Furthermore, it can be possible to form a multi-power RSA by
    specifying two or more pairs of the primes to be same.
    However, unlike the two-distinct prime RSA or multi-prime
    RSA, not every numbers in the complete residue system
    (`\mathbb{Z}_n`) will be decryptable since the mapping
    `\mathbb{Z}_{n} \rightarrow \mathbb{Z}_{n}`
    will not be bijective.
    (Only except for the trivial case when
    `e = 1`
    or more generally,

    .. math::
        e \in \left \{ 1 + k \lambda(n)
        \mid k \in \mathbb{Z} \land k \geq 0 \right \}

    when RSA reduces to the identity.)
    However, the RSA can still be decryptable for the numbers in the
    reduced residue system (`\mathbb{Z}_n^{\times}`), since the
    mapping
    `\mathbb{Z}_{n}^{\times} \rightarrow \mathbb{Z}_{n}^{\times}`
    can still be bijective.

    If you pass a non-prime integer to the arguments
    `p_1, p_2, \dots, p_n`, the particular number will be
    prime-factored and it will become either a multi-prime RSA or a
    multi-power RSA in its canonical form, depending on whether the
    product equals its radical or not.
    `p_1 p_2 \dots p_n = \text{rad}(p_1 p_2 \dots p_n)`

totient : bool, optional
    If ``'Euler'``, it uses Euler's totient `\phi(n)` which is
    :meth:`sympy.functions.combinatorial.numbers.totient` in SymPy.

    If ``'Carmichael'``, it uses Carmichael's totient `\lambda(n)`
    which is :meth:`sympy.functions.combinatorial.numbers.reduced_totient` in SymPy.

    Unlike private key generation, this is a trivial keyword for
    public key generation because
    `\gcd(e, \phi(n)) = 1 \iff \gcd(e, \lambda(n)) = 1`.

index : nonnegative integer, optional
    Returns an arbitrary solution of a RSA public key at the index
    specified at `0, 1, 2, \dots`. This parameter needs to be
    specified along with ``totient='Carmichael'``.

    Similarly to the non-uniquenss of a RSA private key as described
    in the ``index`` parameter documentation in
    :meth:`rsa_private_key`, RSA public key is also not unique and
    there is an infinite number of RSA public exponents which
    can behave in the same manner.

    From any given RSA public exponent `e`, there are can be an
    another RSA public exponent `e + k \lambda(n)` where `k` is an
    integer, `\lambda` is a Carmichael's totient function.

    However, considering only the positive cases, there can be
    a principal solution of a RSA public exponent `e_0` in
    `0 &lt; e_0 &lt; \lambda(n)`, and all the other solutions
    can be canonicalzed in a form of `e_0 + k \lambda(n)`.

    ``index`` specifies the `k` notation to yield any possible value
    an RSA public key can have.

    An example of computing any arbitrary RSA public key:

    &gt;&gt;&gt; from sympy.crypto.crypto import rsa_public_key
    &gt;&gt;&gt; rsa_public_key(61, 53, 17, totient='Carmichael', index=0)
    (3233, 17)
    &gt;&gt;&gt; rsa_public_key(61, 53, 17, totient='Carmichael', index=1)
    (3233, 797)
    &gt;&gt;&gt; rsa_public_key(61, 53, 17, totient='Carmichael', index=2)
    (3233, 1577)

multipower : bool, optional
    Any pair of non-distinct primes found in the RSA specification
    will restrict the domain of the cryptosystem, as noted in the
    explanation of the parameter ``args``.

    SymPy RSA key generator may give a warning before dispatching it
    as a multi-power RSA, however, you can disable the warning if
    you pass ``True`` to this keyword.

Returns
=======

(n, e) : int, int
    `n` is a product of any arbitrary number of primes given as
    the argument.

    `e` is relatively prime (coprime) to the Euler totient
    `\phi(n)`.

False
    Returned if less than two arguments are given, or `e` is
    not relatively prime to the modulus.

Examples
========

&gt;&gt;&gt; from sympy.crypto.crypto import rsa_public_key

A public key of a two-prime RSA:

&gt;&gt;&gt; p, q, e = 3, 5, 7
&gt;&gt;&gt; rsa_public_key(p, q, e)
(15, 7)
&gt;&gt;&gt; rsa_public_key(p, q, 30)
False

A public key of a multiprime RSA:

&gt;&gt;&gt; primes = [2, 3, 5, 7, 11, 13]
&gt;&gt;&gt; e = 7
&gt;&gt;&gt; args = primes + [e]
&gt;&gt;&gt; rsa_public_key(*args)
(30030, 7)

Notes
=====

Although the RSA can be generalized over any modulus `n`, using
two large primes had became the most popular specification because a
product of two large primes is usually the hardest to factor
relatively to the digits of `n` can have.

However, it may need further understanding of the time complexities
of each prime-factoring algorithms to verify the claim.

See Also
========

rsa_private_key
encipher_rsa
decipher_rsa

References
==========

.. [1] https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29

.. [2] https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf

.. [3] https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf

.. [4] https://www.itiis.org/digital-library/manuscript/1381
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3a36996891d0194a340b1eaf30bf4d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a36996891d0194a340b1eaf30bf4d41">&#9670;&nbsp;</a></span>bifid10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sympy.crypto.crypto.bifid10 = printable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaee1dc5c1c393f141c19348ea7115a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee1dc5c1c393f141c19348ea7115a48">&#9670;&nbsp;</a></span>bifid5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.bifid5 = <a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a09ed2c6245f46ed0afefc94b4b34a62c">AZ</a>().replace('J', '')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42c47f7098a56e3a0be2bb5d5b8bc8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c47f7098a56e3a0be2bb5d5b8bc8fb">&#9670;&nbsp;</a></span>bifid6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.crypto.crypto.bifid6 = <a class="el" href="namespacesympy_1_1crypto_1_1crypto.html#a09ed2c6245f46ed0afefc94b4b34a62c">AZ</a>() + '0123456789'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91819b29a57f9646d0812df4e4464b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91819b29a57f9646d0812df4e4464b47">&#9670;&nbsp;</a></span>char_morse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary sympy.crypto.crypto.char_morse = {v: k for k, v in morse_char.items()}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5c77c9b21a69e3a275b92758148c196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c77c9b21a69e3a275b92758148c196">&#9670;&nbsp;</a></span>morse_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary sympy.crypto.crypto.morse_char</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    <span class="stringliteral">&quot;.-&quot;</span>: <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;-...&quot;</span>: <span class="stringliteral">&quot;B&quot;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    <span class="stringliteral">&quot;-.-.&quot;</span>: <span class="stringliteral">&quot;C&quot;</span>, <span class="stringliteral">&quot;-..&quot;</span>: <span class="stringliteral">&quot;D&quot;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    <span class="stringliteral">&quot;.&quot;</span>: <span class="stringliteral">&quot;E&quot;</span>, <span class="stringliteral">&quot;..-.&quot;</span>: <span class="stringliteral">&quot;F&quot;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    <span class="stringliteral">&quot;--.&quot;</span>: <span class="stringliteral">&quot;G&quot;</span>, <span class="stringliteral">&quot;....&quot;</span>: <span class="stringliteral">&quot;H&quot;</span>,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    <span class="stringliteral">&quot;..&quot;</span>: <span class="stringliteral">&quot;I&quot;</span>, <span class="stringliteral">&quot;.---&quot;</span>: <span class="stringliteral">&quot;J&quot;</span>,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    <span class="stringliteral">&quot;-.-&quot;</span>: <span class="stringliteral">&quot;K&quot;</span>, <span class="stringliteral">&quot;.-..&quot;</span>: <span class="stringliteral">&quot;L&quot;</span>,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    <span class="stringliteral">&quot;--&quot;</span>: <span class="stringliteral">&quot;M&quot;</span>, <span class="stringliteral">&quot;-.&quot;</span>: <span class="stringliteral">&quot;N&quot;</span>,</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    <span class="stringliteral">&quot;---&quot;</span>: <span class="stringliteral">&quot;O&quot;</span>, <span class="stringliteral">&quot;.--.&quot;</span>: <span class="stringliteral">&quot;P&quot;</span>,</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    <span class="stringliteral">&quot;--.-&quot;</span>: <span class="stringliteral">&quot;Q&quot;</span>, <span class="stringliteral">&quot;.-.&quot;</span>: <span class="stringliteral">&quot;R&quot;</span>,</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <span class="stringliteral">&quot;...&quot;</span>: <span class="stringliteral">&quot;S&quot;</span>, <span class="stringliteral">&quot;-&quot;</span>: <span class="stringliteral">&quot;T&quot;</span>,</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <span class="stringliteral">&quot;..-&quot;</span>: <span class="stringliteral">&quot;U&quot;</span>, <span class="stringliteral">&quot;...-&quot;</span>: <span class="stringliteral">&quot;V&quot;</span>,</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <span class="stringliteral">&quot;.--&quot;</span>: <span class="stringliteral">&quot;W&quot;</span>, <span class="stringliteral">&quot;-..-&quot;</span>: <span class="stringliteral">&quot;X&quot;</span>,</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <span class="stringliteral">&quot;-.--&quot;</span>: <span class="stringliteral">&quot;Y&quot;</span>, <span class="stringliteral">&quot;--..&quot;</span>: <span class="stringliteral">&quot;Z&quot;</span>,</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <span class="stringliteral">&quot;-----&quot;</span>: <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;.----&quot;</span>: <span class="stringliteral">&quot;1&quot;</span>,</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="stringliteral">&quot;..---&quot;</span>: <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;...--&quot;</span>: <span class="stringliteral">&quot;3&quot;</span>,</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <span class="stringliteral">&quot;....-&quot;</span>: <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;.....&quot;</span>: <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <span class="stringliteral">&quot;-....&quot;</span>: <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;--...&quot;</span>: <span class="stringliteral">&quot;7&quot;</span>,</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="stringliteral">&quot;---..&quot;</span>: <span class="stringliteral">&quot;8&quot;</span>, <span class="stringliteral">&quot;----.&quot;</span>: <span class="stringliteral">&quot;9&quot;</span>,</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="stringliteral">&quot;.-.-.-&quot;</span>: <span class="stringliteral">&quot;.&quot;</span>, <span class="stringliteral">&quot;--..--&quot;</span>: <span class="stringliteral">&quot;,&quot;</span>,</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="stringliteral">&quot;---...&quot;</span>: <span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot;-.-.-.&quot;</span>: <span class="stringliteral">&quot;;&quot;</span>,</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="stringliteral">&quot;..--..&quot;</span>: <span class="stringliteral">&quot;?&quot;</span>, <span class="stringliteral">&quot;-....-&quot;</span>: <span class="stringliteral">&quot;-&quot;</span>,</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="stringliteral">&quot;..--.-&quot;</span>: <span class="stringliteral">&quot;_&quot;</span>, <span class="stringliteral">&quot;-.--.&quot;</span>: <span class="stringliteral">&quot;(&quot;</span>,</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="stringliteral">&quot;-.--.-&quot;</span>: <span class="stringliteral">&quot;)&quot;</span>, <span class="stringliteral">&quot;.----.&quot;</span>: <span class="stringliteral">&quot;&#39;&quot;</span>,</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="stringliteral">&quot;-...-&quot;</span>: <span class="stringliteral">&quot;=&quot;</span>, <span class="stringliteral">&quot;.-.-.&quot;</span>: <span class="stringliteral">&quot;+&quot;</span>,</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="stringliteral">&quot;-..-.&quot;</span>: <span class="stringliteral">&quot;/&quot;</span>, <span class="stringliteral">&quot;.--.-.&quot;</span>: <span class="stringliteral">&quot;@&quot;</span>,</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="stringliteral">&quot;...-..-&quot;</span>: <span class="stringliteral">&quot;$&quot;</span>, <span class="stringliteral">&quot;-.-.--&quot;</span>: <span class="stringliteral">&quot;!&quot;</span>}</div>
</div><!-- fragment -->
<p>Morse Code ######################################. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
