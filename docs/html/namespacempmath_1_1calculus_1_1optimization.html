<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: mpmath.calculus.optimization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacempmath.html">mpmath</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus.html">calculus</a></li><li class="navelem"><a class="el" href="namespacempmath_1_1calculus_1_1optimization.html">optimization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mpmath.calculus.optimization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1OptimizationMethods.html">OptimizationMethods</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1Newton.html">Newton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1Secant.html">Secant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1MNewton.html">MNewton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1Halley.html">Halley</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1Muller.html">Muller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1Bisection.html">Bisection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1Illinois.html">Illinois</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1Ridder.html">Ridder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1ANewton.html">ANewton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpmath_1_1calculus_1_1optimization_1_1MDNewton.html">MDNewton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5bf729072c230b48a13246c8873e6f29"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1optimization.html#a5bf729072c230b48a13246c8873e6f29">Pegasus</a> (*args, **kwargs)</td></tr>
<tr class="separator:a5bf729072c230b48a13246c8873e6f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f4f4309f7dc78f4eed9f24619a07e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1optimization.html#ae1f4f4309f7dc78f4eed9f24619a07e9">Anderson</a> (*args, **kwargs)</td></tr>
<tr class="separator:ae1f4f4309f7dc78f4eed9f24619a07e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59096f4174788210a7e116add5733d17"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1optimization.html#a59096f4174788210a7e116add5733d17">jacobian</a> (ctx, f, x)</td></tr>
<tr class="separator:a59096f4174788210a7e116add5733d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25981180264f7abd47cfd001f8eafad1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1optimization.html#a25981180264f7abd47cfd001f8eafad1">findroot</a> (ctx, f, x0, solver='secant', tol=None, verbose=False, verify=True, **kwargs)</td></tr>
<tr class="separator:a25981180264f7abd47cfd001f8eafad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a6529cc70a661c894abd6bdd345ff2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1optimization.html#af5a6529cc70a661c894abd6bdd345ff2">multiplicity</a> (ctx, f, <a class="el" href="namespacempmath.html#ae2671e402d11cc5ff6703dcfae8a4ec3">root</a>, tol=None, maxsteps=10, **kwargs)</td></tr>
<tr class="separator:af5a6529cc70a661c894abd6bdd345ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78ffd32ba94a70145cc934ac196fbeb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1optimization.html#ad78ffd32ba94a70145cc934ac196fbeb">steffensen</a> (f)</td></tr>
<tr class="separator:ad78ffd32ba94a70145cc934ac196fbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3ed9ef4dfa1f79a05cde8538b9e08bda"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacempmath_1_1calculus_1_1optimization.html#a3ed9ef4dfa1f79a05cde8538b9e08bda">str2solver</a></td></tr>
<tr class="separator:a3ed9ef4dfa1f79a05cde8538b9e08bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae1f4f4309f7dc78f4eed9f24619a07e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f4f4309f7dc78f4eed9f24619a07e9">&#9670;&nbsp;</a></span>Anderson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.optimization.Anderson </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">1d-solver generating pairs of approximative root and error.

Uses Anderson-Bjoerk method to find a root of f in [a, b].
Wrapper for illinois to use method='pegasus'.
</pre> 
</div>
</div>
<a id="a25981180264f7abd47cfd001f8eafad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25981180264f7abd47cfd001f8eafad1">&#9670;&nbsp;</a></span>findroot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.optimization.findroot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>solver</em> = <code>'secant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verify</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find an approximate solution to `f(x) = 0`, using *x0* as starting point or
interval for *x*.

Multidimensional overdetermined systems are supported.
You can specify them using a function or a list of functions.

Mathematically speaking, this function returns `x` such that
`|f(x)|^2 \leq \mathrm{tol}` is true within the current working precision.
If the computed value does not meet this criterion, an exception is raised.
This exception can be disabled with *verify=False*.

For interval arithmetic (``iv.findroot()``), please note that
the returned interval ``x`` is not guaranteed to contain `f(x)=0`!
It is only some `x` for which `|f(x)|^2 \leq \mathrm{tol}` certainly holds
regardless of numerical error. This may be improved in the future.

**Arguments**

*f*
    one dimensional function
*x0*
    starting point, several starting points or interval (depends on solver)
*tol*
    the returned solution has an error smaller than this
*verbose*
    print additional information for each iteration if true
*verify*
    verify the solution and raise a ValueError if `|f(x)|^2 &gt; \mathrm{tol}`
*solver*
    a generator for *f* and *x0* returning approximative solution and error
*maxsteps*
    after how many steps the solver will cancel
*df*
    first derivative of *f* (used by some solvers)
*d2f*
    second derivative of *f* (used by some solvers)
*multidimensional*
    force multidimensional solving
*J*
    Jacobian matrix of *f* (used by multidimensional solvers)
*norm*
    used vector norm (used by multidimensional solvers)

solver has to be callable with ``(f, x0, **kwargs)`` and return an generator
yielding pairs of approximative solution and estimated error (which is
expected to be positive).
You can use the following string aliases:
'secant', 'mnewton', 'halley', 'muller', 'illinois', 'pegasus', 'anderson',
'ridder', 'anewton', 'bisect'

See mpmath.calculus.optimization for their documentation.

**Examples**

The function :func:`~mpmath.findroot` locates a root of a given function using the
secant method by default. A simple example use of the secant method is to
compute `\pi` as the root of `\sin x` closest to `x_0 = 3`::

    &gt;&gt;&gt; from mpmath import *
    &gt;&gt;&gt; mp.dps = 30; mp.pretty = True
    &gt;&gt;&gt; findroot(sin, 3)
    3.14159265358979323846264338328

The secant method can be used to find complex roots of analytic functions,
although it must in that case generally be given a nonreal starting value
(or else it will never leave the real line)::

    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; findroot(lambda x: x**3 + 2*x + 1, j)
    (0.226698825758202 + 1.46771150871022j)

A nice application is to compute nontrivial roots of the Riemann zeta
function with many digits (good initial values are needed for convergence)::

    &gt;&gt;&gt; mp.dps = 30
    &gt;&gt;&gt; findroot(zeta, 0.5+14j)
    (0.5 + 14.1347251417346937904572519836j)

The secant method can also be used as an optimization algorithm, by passing
it a derivative of a function. The following example locates the positive
minimum of the gamma function::

    &gt;&gt;&gt; mp.dps = 20
    &gt;&gt;&gt; findroot(lambda x: diff(gamma, x), 1)
    1.4616321449683623413

Finally, a useful application is to compute inverse functions, such as the
Lambert W function which is the inverse of `w e^w`, given the first
term of the solution's asymptotic expansion as the initial value. In basic
cases, this gives identical results to mpmath's built-in ``lambertw``
function::

    &gt;&gt;&gt; def lambert(x):
    ...     return findroot(lambda w: w*exp(w) - x, log(1+x))
    ...
    &gt;&gt;&gt; mp.dps = 15
    &gt;&gt;&gt; lambert(1); lambertw(1)
    0.567143290409784
    0.567143290409784
    &gt;&gt;&gt; lambert(1000); lambert(1000)
    5.2496028524016
    5.2496028524016

Multidimensional functions are also supported::

    &gt;&gt;&gt; f = [lambda x1, x2: x1**2 + x2,
    ...      lambda x1, x2: 5*x1**2 - 3*x1 + 2*x2 - 3]
    &gt;&gt;&gt; findroot(f, (0, 0))
    [-0.618033988749895]
    [-0.381966011250105]
    &gt;&gt;&gt; findroot(f, (10, 10))
    [ 1.61803398874989]
    [-2.61803398874989]

You can verify this by solving the system manually.

Please note that the following (more general) syntax also works::

    &gt;&gt;&gt; def f(x1, x2):
    ...     return x1**2 + x2, 5*x1**2 - 3*x1 + 2*x2 - 3
    ...
    &gt;&gt;&gt; findroot(f, (0, 0))
    [-0.618033988749895]
    [-0.381966011250105]


**Multiple roots**

For multiple roots all methods of the Newtonian family (including secant)
converge slowly. Consider this example::

    &gt;&gt;&gt; f = lambda x: (x - 1)**99
    &gt;&gt;&gt; findroot(f, 0.9, verify=False)
    0.918073542444929

Even for a very close starting point the secant method converges very
slowly. Use ``verbose=True`` to illustrate this.

It is possible to modify Newton's method to make it converge regardless of
the root's multiplicity::

    &gt;&gt;&gt; findroot(f, -10, solver='mnewton')
    1.0

This variant uses the first and second derivative of the function, which is
not very efficient.

Alternatively you can use an experimental Newtonian solver that keeps track
of the speed of convergence and accelerates it using Steffensen's method if
necessary::

    &gt;&gt;&gt; findroot(f, -10, solver='anewton', verbose=True)
    x:     -9.88888888888888888889
    error: 0.111111111111111111111
    converging slowly
    x:     -9.77890011223344556678
    error: 0.10998877665544332211
    converging slowly
    x:     -9.67002233332199662166
    error: 0.108877778911448945119
    converging slowly
    accelerating convergence
    x:     -9.5622443299551077669
    error: 0.107778003366888854764
    converging slowly
    x:     0.99999999999999999214
    error: 10.562244329955107759
    x:     1.0
    error: 7.8598304758094664213e-18
    ZeroDivisionError: canceled with x = 1.0
    1.0

**Complex roots**

For complex roots it's recommended to use Muller's method as it converges
even for real starting points very fast::

    &gt;&gt;&gt; findroot(lambda x: x**4 + x + 1, (0, 1, 2), solver='muller')
    (0.727136084491197 + 0.934099289460529j)


**Intersection methods**

When you need to find a root in a known interval, it's highly recommended to
use an intersection-based solver like ``'anderson'`` or ``'ridder'``.
Usually they converge faster and more reliable. They have however problems
with multiple roots and usually need a sign change to find a root::

    &gt;&gt;&gt; findroot(lambda x: x**3, (-1, 1), solver='anderson')
    0.0

Be careful with symmetric functions::

    &gt;&gt;&gt; findroot(lambda x: x**2, (-1, 1), solver='anderson') #doctest:+ELLIPSIS
    Traceback (most recent call last):
      ...
    ZeroDivisionError

It fails even for better starting points, because there is no sign change::

    &gt;&gt;&gt; findroot(lambda x: x**2, (-1, .5), solver='anderson')
    Traceback (most recent call last):
      ...
    ValueError: Could not find root within given tolerance. (1.0 &gt; 2.16840434497100886801e-19)
    Try another starting point or tweak arguments.</pre> 
</div>
</div>
<a id="a59096f4174788210a7e116add5733d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59096f4174788210a7e116add5733d17">&#9670;&nbsp;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.optimization.jacobian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the Jacobian matrix of a function at the point x0.

This is the first derivative of a vectorial function:

    f : R^m -&gt; R^n with m &gt;= n
</pre> 
</div>
</div>
<a id="af5a6529cc70a661c894abd6bdd345ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a6529cc70a661c894abd6bdd345ff2">&#9670;&nbsp;</a></span>multiplicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.optimization.multiplicity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsteps</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the multiplicity of a given root of f.

Internally, numerical derivatives are used. This might be inefficient for
higher order derviatives. Due to this, ``multiplicity`` cancels after
evaluating 10 derivatives by default. You can be specify the n-th derivative
using the dnf keyword.

&gt;&gt;&gt; from mpmath import *
&gt;&gt;&gt; multiplicity(lambda x: sin(x) - 1, pi/2)
2</pre> 
</div>
</div>
<a id="a5bf729072c230b48a13246c8873e6f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf729072c230b48a13246c8873e6f29">&#9670;&nbsp;</a></span>Pegasus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.optimization.Pegasus </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">1d-solver generating pairs of approximative root and error.

Uses Pegasus method to find a root of f in [a, b].
Wrapper for illinois to use method='pegasus'.
</pre> 
</div>
</div>
<a id="ad78ffd32ba94a70145cc934ac196fbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78ffd32ba94a70145cc934ac196fbeb">&#9670;&nbsp;</a></span>steffensen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def mpmath.calculus.optimization.steffensen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">linear convergent function -&gt; quadratic convergent function

Steffensen's method for quadratic convergence of a linear converging
sequence.
Don not use it for higher rates of convergence.
It may even work for divergent sequences.

Definition:
F(x) = (x*f(f(x)) - f(x)**2) / (f(f(x)) - 2*f(x) + x)

Example
.......

You can use Steffensen's method to accelerate a fixpoint iteration of linear
(or less) convergence.

x* is a fixpoint of the iteration x_{k+1} = phi(x_k) if x* = phi(x*). For
phi(x) = x**2 there are two fixpoints: 0 and 1.

Let's try Steffensen's method:

&gt;&gt;&gt; f = lambda x: x**2
&gt;&gt;&gt; from mpmath.calculus.optimization import steffensen
&gt;&gt;&gt; F = steffensen(f)
&gt;&gt;&gt; for x in [0.5, 0.9, 2.0]:
...     fx = Fx = x
...     for i in xrange(9):
...         try:
...             fx = f(fx)
...         except OverflowError:
...             pass
...         try:
...             Fx = F(Fx)
...         except ZeroDivisionError:
...             pass
...         print('%20g  %20g' % (fx, Fx))
                0.25                  -0.5
              0.0625                   0.1
          0.00390625            -0.0011236
         1.52588e-05           1.41691e-09
         2.32831e-10          -2.84465e-27
         5.42101e-20           2.30189e-80
         2.93874e-39          -1.2197e-239
         8.63617e-78                     0
        7.45834e-155                     0
                0.81               1.02676
              0.6561               1.00134
            0.430467                     1
            0.185302                     1
           0.0343368                     1
          0.00117902                     1
         1.39008e-06                     1
         1.93233e-12                     1
         3.73392e-24                     1
                   4                   1.6
                  16                1.2962
                 256               1.10194
               65536               1.01659
         4.29497e+09               1.00053
         1.84467e+19                     1
         3.40282e+38                     1
         1.15792e+77                     1
        1.34078e+154                     1

Unmodified, the iteration converges only towards 0. Modified it converges
not only much faster, it converges even to the repelling fixpoint 1.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3ed9ef4dfa1f79a05cde8538b9e08bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed9ef4dfa1f79a05cde8538b9e08bda">&#9670;&nbsp;</a></span>str2solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary mpmath.calculus.optimization.str2solver</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  {<span class="stringliteral">&#39;newton&#39;</span>:Newton, <span class="stringliteral">&#39;secant&#39;</span>:Secant, <span class="stringliteral">&#39;mnewton&#39;</span>:MNewton,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;              <span class="stringliteral">&#39;halley&#39;</span>:Halley, <span class="stringliteral">&#39;muller&#39;</span>:Muller, <span class="stringliteral">&#39;bisect&#39;</span>:Bisection,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;              <span class="stringliteral">&#39;illinois&#39;</span>:Illinois, <span class="stringliteral">&#39;pegasus&#39;</span>:Pegasus, <span class="stringliteral">&#39;anderson&#39;</span>:Anderson,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;              <span class="stringliteral">&#39;ridder&#39;</span>:Ridder, <span class="stringliteral">&#39;anewton&#39;</span>:ANewton, <span class="stringliteral">&#39;mdnewton&#39;</span>:MDNewton}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
