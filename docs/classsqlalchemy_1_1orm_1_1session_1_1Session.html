<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sqlalchemy.orm.session.Session Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesqlalchemy.html">sqlalchemy</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1orm.html">orm</a></li><li class="navelem"><a class="el" href="namespacesqlalchemy_1_1orm_1_1session.html">session</a></li><li class="navelem"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html">Session</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsqlalchemy_1_1orm_1_1session_1_1Session-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sqlalchemy.orm.session.Session Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for sqlalchemy.orm.session.Session:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1orm_1_1session_1_1Session__inherit__graph.png" border="0" usemap="#asqlalchemy_8orm_8session_8Session_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sqlalchemy.orm.session.Session:</div>
<div class="dyncontent">
<div class="center"><img src="classsqlalchemy_1_1orm_1_1session_1_1Session__coll__graph.png" border="0" usemap="#asqlalchemy_8orm_8session_8Session_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac45fab33629f0e434d4f394827b90cfd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ac45fab33629f0e434d4f394827b90cfd">__init__</a> (self, Optional[_SessionBind] <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ae1ec6c6975ce12366b35f9f022e04f4b">bind</a>=None, *bool <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a6f3113baa32e565038e999bef8b0f592">autoflush</a>=True, Literal[True] future=True, bool <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a03a942722dbb9b89d96ae43c649afb88">expire_on_commit</a>=True, bool <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a69f74f654f539562eded345db6fa0838">autobegin</a>=True, bool <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a754268fa1caa7d8d5c7e931dbe1a8195">twophase</a>=False, Optional[Dict[_SessionBindKey, _SessionBind]] binds=None, bool <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a6388605c6b4c2e093c2f79c16196f458">enable_baked_queries</a>=True, Optional[_InfoType] <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a58bafd20973ecb39c0387755b43d836b">info</a>=None, Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[Any]]] query_cls=None, Literal[False] autocommit=False, <a class="el" href="namespacesqlalchemy_1_1orm_1_1session.html#aed7664da1df19c2e180d229d6602ac2b">JoinTransactionMode</a> <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a786f6c9b52b962ba97d9c5ed985df3a8">join_transaction_mode</a>=&quot;conditional_savepoint&quot;, Union[bool, <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>] close_resets_only=<a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a>)</td></tr>
<tr class="separator:ac45fab33629f0e434d4f394827b90cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafd66684373d2b522d6110575115e66"><td class="memItemLeft" align="right" valign="top">_S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#adafd66684373d2b522d6110575115e66">__enter__</a> (_S self)</td></tr>
<tr class="separator:adafd66684373d2b522d6110575115e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3e16bf133db3c8047b381078289466"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a5b3e16bf133db3c8047b381078289466">__exit__</a> (self, Any type_, Any value, Any traceback)</td></tr>
<tr class="separator:a5b3e16bf133db3c8047b381078289466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ca4c6583695571825ece266bd5d8b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ae4ca4c6583695571825ece266bd5d8b8">in_transaction</a> (self)</td></tr>
<tr class="separator:ae4ca4c6583695571825ece266bd5d8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d81c0995523b7082b27eb994a8da3c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a2d81c0995523b7082b27eb994a8da3c7">in_nested_transaction</a> (self)</td></tr>
<tr class="separator:a2d81c0995523b7082b27eb994a8da3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1863167b3d44ea8bd6cc5cefaf222f42"><td class="memItemLeft" align="right" valign="top">Optional[<a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1SessionTransaction.html">SessionTransaction</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a1863167b3d44ea8bd6cc5cefaf222f42">get_transaction</a> (self)</td></tr>
<tr class="separator:a1863167b3d44ea8bd6cc5cefaf222f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade117cc64dba1e07b2f26181dea46b4"><td class="memItemLeft" align="right" valign="top">Optional[<a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1SessionTransaction.html">SessionTransaction</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#aade117cc64dba1e07b2f26181dea46b4">get_nested_transaction</a> (self)</td></tr>
<tr class="separator:aade117cc64dba1e07b2f26181dea46b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bafd20973ecb39c0387755b43d836b"><td class="memItemLeft" align="right" valign="top">_InfoType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a58bafd20973ecb39c0387755b43d836b">info</a> (self)</td></tr>
<tr class="separator:a58bafd20973ecb39c0387755b43d836b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf0406432902a5818cfd3f41ad4c7d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1SessionTransaction.html">SessionTransaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#aecf0406432902a5818cfd3f41ad4c7d1">begin</a> (self, bool nested=False)</td></tr>
<tr class="separator:aecf0406432902a5818cfd3f41ad4c7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aede905e68ebb33f731567afa6a4f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1SessionTransaction.html">SessionTransaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a9aede905e68ebb33f731567afa6a4f96">begin_nested</a> (self)</td></tr>
<tr class="separator:a9aede905e68ebb33f731567afa6a4f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a11a82590708e182c6ed4d84a083d61"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a0a11a82590708e182c6ed4d84a083d61">rollback</a> (self)</td></tr>
<tr class="separator:a0a11a82590708e182c6ed4d84a083d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0177fb39072ffef1831aa6c48e1d8e93"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a0177fb39072ffef1831aa6c48e1d8e93">commit</a> (self)</td></tr>
<tr class="separator:a0177fb39072ffef1831aa6c48e1d8e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2826758b47756a15eea1fd7756115488"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a2826758b47756a15eea1fd7756115488">prepare</a> (self)</td></tr>
<tr class="separator:a2826758b47756a15eea1fd7756115488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391100aa0c4b009a6a3b645bd0202f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a391100aa0c4b009a6a3b645bd0202f47">connection</a> (self, Optional[_BindArguments] bind_arguments=None, Optional[CoreExecuteOptionsParameter] execution_options=None)</td></tr>
<tr class="separator:a391100aa0c4b009a6a3b645bd0202f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8821aabe227a7632354970a542902aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1Result.html">Result</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#aa8821aabe227a7632354970a542902aa">execute</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1TypedReturnsRows.html">TypedReturnsRows</a>[_T] statement, Optional[_CoreAnyExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, Optional[Any] _parent_execute_state=None, Optional[Any] _add_event=None)</td></tr>
<tr class="separator:aa8821aabe227a7632354970a542902aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b21de054e1d343e5df774d25b90b6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1cursor_1_1CursorResult.html">CursorResult</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ab5b21de054e1d343e5df774d25b90b6f">execute</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1dml_1_1UpdateBase.html">UpdateBase</a> statement, Optional[_CoreAnyExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, Optional[Any] _parent_execute_state=None, Optional[Any] _add_event=None)</td></tr>
<tr class="separator:ab5b21de054e1d343e5df774d25b90b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa004c99ca8bde4aca37dcb8b994c79f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1Result.html">Result</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#aaa004c99ca8bde4aca37dcb8b994c79f">execute</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a> statement, Optional[_CoreAnyExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, Optional[Any] _parent_execute_state=None, Optional[Any] _add_event=None)</td></tr>
<tr class="separator:aaa004c99ca8bde4aca37dcb8b994c79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa004c99ca8bde4aca37dcb8b994c79f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1Result.html">Result</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#aaa004c99ca8bde4aca37dcb8b994c79f">execute</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a> statement, Optional[_CoreAnyExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, Optional[Any] _parent_execute_state=None, Optional[Any] _add_event=None)</td></tr>
<tr class="separator:aaa004c99ca8bde4aca37dcb8b994c79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f34a357d7b308d43c36efab9a1bc2f"><td class="memItemLeft" align="right" valign="top">Optional[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a54f34a357d7b308d43c36efab9a1bc2f">scalar</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1TypedReturnsRows.html">TypedReturnsRows</a>[Tuple[_T]] statement, Optional[_CoreSingleExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, **Any kw)</td></tr>
<tr class="separator:a54f34a357d7b308d43c36efab9a1bc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54f9167271f49c522e94988d4597dbd"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ab54f9167271f49c522e94988d4597dbd">scalar</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a> statement, Optional[_CoreSingleExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, **Any kw)</td></tr>
<tr class="separator:ab54f9167271f49c522e94988d4597dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54f9167271f49c522e94988d4597dbd"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ab54f9167271f49c522e94988d4597dbd">scalar</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a> statement, Optional[_CoreSingleExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, **Any kw)</td></tr>
<tr class="separator:ab54f9167271f49c522e94988d4597dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a8646ef7a1ed315298489c4c463bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1ScalarResult.html">ScalarResult</a>[_T]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ac3a8646ef7a1ed315298489c4c463bdb">scalars</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1TypedReturnsRows.html">TypedReturnsRows</a>[Tuple[_T]] statement, Optional[_CoreAnyExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, **Any kw)</td></tr>
<tr class="separator:ac3a8646ef7a1ed315298489c4c463bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7688af0cade7681d67ce5fc70d53231f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1ScalarResult.html">ScalarResult</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a7688af0cade7681d67ce5fc70d53231f">scalars</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a> statement, Optional[_CoreAnyExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, **Any kw)</td></tr>
<tr class="separator:a7688af0cade7681d67ce5fc70d53231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7688af0cade7681d67ce5fc70d53231f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1ScalarResult.html">ScalarResult</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a7688af0cade7681d67ce5fc70d53231f">scalars</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a> statement, Optional[_CoreAnyExecuteParams] params=None, *OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None, **Any kw)</td></tr>
<tr class="separator:a7688af0cade7681d67ce5fc70d53231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48580e0e9e48dc3d0f2bf7fc53cc683"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#af48580e0e9e48dc3d0f2bf7fc53cc683">close</a> (self)</td></tr>
<tr class="separator:af48580e0e9e48dc3d0f2bf7fc53cc683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211f3d3b203b0d004a39ce24a44bb5db"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a211f3d3b203b0d004a39ce24a44bb5db">reset</a> (self)</td></tr>
<tr class="separator:a211f3d3b203b0d004a39ce24a44bb5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214e57cdb1d9841a3ddd0c02cbd16662"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a214e57cdb1d9841a3ddd0c02cbd16662">invalidate</a> (self)</td></tr>
<tr class="separator:a214e57cdb1d9841a3ddd0c02cbd16662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e796b93ccbf4538db2e0d8226d583c"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ac3e796b93ccbf4538db2e0d8226d583c">expunge_all</a> (self)</td></tr>
<tr class="separator:ac3e796b93ccbf4538db2e0d8226d583c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d2e9cbbec20307036a68abb570d47d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a65d2e9cbbec20307036a68abb570d47d">bind_mapper</a> (self, _EntityBindKey[_O] mapper, _SessionBind <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ae1ec6c6975ce12366b35f9f022e04f4b">bind</a>)</td></tr>
<tr class="separator:a65d2e9cbbec20307036a68abb570d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af849ab909a08b95a5739dd079e138008"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#af849ab909a08b95a5739dd079e138008">bind_table</a> (self, TableClause table, _SessionBind <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ae1ec6c6975ce12366b35f9f022e04f4b">bind</a>)</td></tr>
<tr class="separator:af849ab909a08b95a5739dd079e138008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05049c1ad5b2579d494c651802886ac"><td class="memItemLeft" align="right" valign="top">Union[<a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a>, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ab05049c1ad5b2579d494c651802886ac">get_bind</a> (self, Optional[_EntityBindKey[_O]] mapper=None, *Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ClauseElement.html">ClauseElement</a>] clause=None, Optional[_SessionBind] <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ae1ec6c6975ce12366b35f9f022e04f4b">bind</a>=None, Optional[bool] _sa_skip_events=None, bool _sa_skip_for_implicit_returning=False, **Any kw)</td></tr>
<tr class="separator:ab05049c1ad5b2579d494c651802886ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01ec1ccec906605605f1dca87fff5ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[_O]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ac01ec1ccec906605605f1dca87fff5ae">query</a> (self, _EntityType[_O] _entity)</td></tr>
<tr class="separator:ac01ec1ccec906605605f1dca87fff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f6fcf2dbe048fd9fedd2d88ad19b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ac4f6fcf2dbe048fd9fedd2d88ad19b43">query</a> (self, <a class="el" href="classsqlalchemy_1_1sql_1_1roles_1_1TypedColumnsClauseRole.html">TypedColumnsClauseRole</a>[_T] _colexpr)</td></tr>
<tr class="separator:ac4f6fcf2dbe048fd9fedd2d88ad19b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c8c2385ab51110f770f24ef574c46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a06c8c2385ab51110f770f24ef574c46a">query</a> (self, _TCCA[_T0] __ent0, _TCCA[_T1] __ent1)</td></tr>
<tr class="separator:a06c8c2385ab51110f770f24ef574c46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d3cc0311ad55b5fb093c1016f7bb81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a73d3cc0311ad55b5fb093c1016f7bb81">query</a> (self, _TCCA[_T0] __ent0, _TCCA[_T1] __ent1, _TCCA[_T2] __ent2)</td></tr>
<tr class="separator:a73d3cc0311ad55b5fb093c1016f7bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488cb344d79888c234195cfcabf1d144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a488cb344d79888c234195cfcabf1d144">query</a> (self, _TCCA[_T0] __ent0, _TCCA[_T1] __ent1, _TCCA[_T2] __ent2, _TCCA[_T3] __ent3)</td></tr>
<tr class="separator:a488cb344d79888c234195cfcabf1d144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eba1c832e8b4a636a460ed776ca6591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3, _T4]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a6eba1c832e8b4a636a460ed776ca6591">query</a> (self, _TCCA[_T0] __ent0, _TCCA[_T1] __ent1, _TCCA[_T2] __ent2, _TCCA[_T3] __ent3, _TCCA[_T4] __ent4)</td></tr>
<tr class="separator:a6eba1c832e8b4a636a460ed776ca6591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c552a6a92d4c60481d87f615713858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a70c552a6a92d4c60481d87f615713858">query</a> (self, _TCCA[_T0] __ent0, _TCCA[_T1] __ent1, _TCCA[_T2] __ent2, _TCCA[_T3] __ent3, _TCCA[_T4] __ent4, _TCCA[_T5] __ent5)</td></tr>
<tr class="separator:a70c552a6a92d4c60481d87f615713858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac225bf4df734adbe0b78271b7c58162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#aac225bf4df734adbe0b78271b7c58162">query</a> (self, _TCCA[_T0] __ent0, _TCCA[_T1] __ent1, _TCCA[_T2] __ent2, _TCCA[_T3] __ent3, _TCCA[_T4] __ent4, _TCCA[_T5] __ent5, _TCCA[_T6] __ent6)</td></tr>
<tr class="separator:aac225bf4df734adbe0b78271b7c58162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc97c2ffce85916b4efdf2c8ba66cbd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#acc97c2ffce85916b4efdf2c8ba66cbd1">query</a> (self, _TCCA[_T0] __ent0, _TCCA[_T1] __ent1, _TCCA[_T2] __ent2, _TCCA[_T3] __ent3, _TCCA[_T4] __ent4, _TCCA[_T5] __ent5, _TCCA[_T6] __ent6, _TCCA[_T7] __ent7)</td></tr>
<tr class="separator:acc97c2ffce85916b4efdf2c8ba66cbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dac4c9a800e88f5cce27fee0c92283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a09dac4c9a800e88f5cce27fee0c92283">query</a> (self, *_ColumnsClauseArgument[Any] entities, **Any kwargs)</td></tr>
<tr class="separator:a09dac4c9a800e88f5cce27fee0c92283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dac4c9a800e88f5cce27fee0c92283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a09dac4c9a800e88f5cce27fee0c92283">query</a> (self, *_ColumnsClauseArgument[Any] entities, **Any kwargs)</td></tr>
<tr class="separator:a09dac4c9a800e88f5cce27fee0c92283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269d3fbfd7a8df067be09b3d39df6307"><td class="memItemLeft" align="right" valign="top">Iterator[<a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html">Session</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a269d3fbfd7a8df067be09b3d39df6307">no_autoflush</a> (self)</td></tr>
<tr class="separator:a269d3fbfd7a8df067be09b3d39df6307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11c051aa34bc14b6bb433a883ab8d13"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ac11c051aa34bc14b6bb433a883ab8d13">refresh</a> (self, object instance, Optional[Iterable[str]] attribute_names=None, ForUpdateParameter with_for_update=None)</td></tr>
<tr class="separator:ac11c051aa34bc14b6bb433a883ab8d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b84298f6416fdb77fbd8f21653cf86"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a61b84298f6416fdb77fbd8f21653cf86">expire_all</a> (self)</td></tr>
<tr class="separator:a61b84298f6416fdb77fbd8f21653cf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384d8c897934d371a32fe9f6376c69a9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a384d8c897934d371a32fe9f6376c69a9">expire</a> (self, object instance, Optional[Iterable[str]] attribute_names=None)</td></tr>
<tr class="separator:a384d8c897934d371a32fe9f6376c69a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53513889880612ab7f96e728cc787c6a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a53513889880612ab7f96e728cc787c6a">expunge</a> (self, object instance)</td></tr>
<tr class="separator:a53513889880612ab7f96e728cc787c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28403bb56652e1fce78cf9cb6983a795"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a28403bb56652e1fce78cf9cb6983a795">add</a> (self, object instance, bool _warn=True)</td></tr>
<tr class="separator:a28403bb56652e1fce78cf9cb6983a795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aa42e8a0ebe3c4be32b7d1620aed4b"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a73aa42e8a0ebe3c4be32b7d1620aed4b">add_all</a> (self, Iterable[object] instances)</td></tr>
<tr class="separator:a73aa42e8a0ebe3c4be32b7d1620aed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290d20249056beabee6fb2ab16771eb5"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a290d20249056beabee6fb2ab16771eb5">delete</a> (self, object instance)</td></tr>
<tr class="separator:a290d20249056beabee6fb2ab16771eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae7fcf7cd65f352637745c0d3299921"><td class="memItemLeft" align="right" valign="top">Optional[_O]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#afae7fcf7cd65f352637745c0d3299921">get</a> (self, _EntityBindKey[_O] entity, _PKIdentityArgument ident, *Optional[Sequence[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption.html">ORMOption</a>]] options=None, bool populate_existing=False, ForUpdateParameter with_for_update=None, Optional[Any] identity_token=None, OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None)</td></tr>
<tr class="separator:afae7fcf7cd65f352637745c0d3299921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7c85dcf82714d345be3d3e26fbfdb6"><td class="memItemLeft" align="right" valign="top">_O&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a5e7c85dcf82714d345be3d3e26fbfdb6">get_one</a> (self, _EntityBindKey[_O] entity, _PKIdentityArgument ident, *Optional[Sequence[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption.html">ORMOption</a>]] options=None, bool populate_existing=False, ForUpdateParameter with_for_update=None, Optional[Any] identity_token=None, OrmExecuteOptionsParameter execution_options=util.EMPTY_DICT, Optional[_BindArguments] bind_arguments=None)</td></tr>
<tr class="separator:a5e7c85dcf82714d345be3d3e26fbfdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8b78bdaffa6dbc62fb44731cec3393"><td class="memItemLeft" align="right" valign="top">_O&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a8c8b78bdaffa6dbc62fb44731cec3393">merge</a> (self, _O instance, *bool load=True, Optional[Sequence[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption.html">ORMOption</a>]] options=None)</td></tr>
<tr class="separator:a8c8b78bdaffa6dbc62fb44731cec3393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd1ac1c29004537dbd22700e19ff54e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#adbd1ac1c29004537dbd22700e19ff54e">enable_relationship_loading</a> (self, object obj)</td></tr>
<tr class="separator:adbd1ac1c29004537dbd22700e19ff54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9899f3dd09659bd0f294891d76f994d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#aa9899f3dd09659bd0f294891d76f994d">__contains__</a> (self, object instance)</td></tr>
<tr class="separator:aa9899f3dd09659bd0f294891d76f994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6d10c55587f7084654cef584643a4a"><td class="memItemLeft" align="right" valign="top">Iterator[object]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#afa6d10c55587f7084654cef584643a4a">__iter__</a> (self)</td></tr>
<tr class="separator:afa6d10c55587f7084654cef584643a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaa7450189961e64d0d834e7a6f103e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#afbaa7450189961e64d0d834e7a6f103e">flush</a> (self, Optional[Sequence[Any]] objects=None)</td></tr>
<tr class="separator:afbaa7450189961e64d0d834e7a6f103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d964e65672de9b4655c56341c9dfb1d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a8d964e65672de9b4655c56341c9dfb1d">bulk_save_objects</a> (self, Iterable[object] objects, bool return_defaults=False, bool update_changed_only=True, bool preserve_order=True)</td></tr>
<tr class="separator:a8d964e65672de9b4655c56341c9dfb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0ab5152777ebe5efb2a978e1a01955"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a7a0ab5152777ebe5efb2a978e1a01955">bulk_insert_mappings</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[Any] mapper, Iterable[Dict[str, Any]] mappings, bool return_defaults=False, bool render_nulls=False)</td></tr>
<tr class="separator:a7a0ab5152777ebe5efb2a978e1a01955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d40815232553a5fe62ef40928dfeeb"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ae0d40815232553a5fe62ef40928dfeeb">bulk_update_mappings</a> (self, <a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[Any] mapper, Iterable[Dict[str, Any]] mappings)</td></tr>
<tr class="separator:ae0d40815232553a5fe62ef40928dfeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870049af0198ed2587b83d6cb7dc44ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a870049af0198ed2587b83d6cb7dc44ba">is_modified</a> (self, object instance, bool include_collections=True)</td></tr>
<tr class="separator:a870049af0198ed2587b83d6cb7dc44ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8327a39eaf678dae330ec25fef86fd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ad8327a39eaf678dae330ec25fef86fd5">is_active</a> (self)</td></tr>
<tr class="separator:ad8327a39eaf678dae330ec25fef86fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885f93494f7391cc1f39d93e3fb060e3"><td class="memItemLeft" align="right" valign="top">IdentitySet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a885f93494f7391cc1f39d93e3fb060e3">dirty</a> (self)</td></tr>
<tr class="separator:a885f93494f7391cc1f39d93e3fb060e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ce49b7a8253eab599940ca91f0a3fc"><td class="memItemLeft" align="right" valign="top">IdentitySet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a50ce49b7a8253eab599940ca91f0a3fc">deleted</a> (self)</td></tr>
<tr class="separator:a50ce49b7a8253eab599940ca91f0a3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e5252aa099ce533987bd7331ab15cb"><td class="memItemLeft" align="right" valign="top">IdentitySet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ae1e5252aa099ce533987bd7331ab15cb">new</a> (self)</td></tr>
<tr class="separator:ae1e5252aa099ce533987bd7331ab15cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods.html">sqlalchemy.orm.session._SessionClassMethods</a></td></tr>
<tr class="memitem:af92ff8fe5205100386865680da3e0cfc inherit pub_methods_classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods.html#af92ff8fe5205100386865680da3e0cfc">close_all</a> (cls)</td></tr>
<tr class="separator:af92ff8fe5205100386865680da3e0cfc inherit pub_methods_classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96adfe0fe19045149a0fd28d8214c86f inherit pub_methods_classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods"><td class="memItemLeft" align="right" valign="top">_IdentityKeyType[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods.html#a96adfe0fe19045149a0fd28d8214c86f">identity_key</a> (cls, Optional[Type[Any]] class_=None, Union[Any, Tuple[Any,...]] ident=None, *Optional[Any] instance=None, Optional[Union[<a class="el" href="classsqlalchemy_1_1engine_1_1row_1_1Row.html">Row</a>[Any], <a class="el" href="classsqlalchemy_1_1engine_1_1row_1_1RowMapping.html">RowMapping</a>]] row=None, Optional[Any] identity_token=None)</td></tr>
<tr class="separator:a96adfe0fe19045149a0fd28d8214c86f inherit pub_methods_classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cba4efb0844e0f044c34bd665b98c42 inherit pub_methods_classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods"><td class="memItemLeft" align="right" valign="top">Optional[<a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html">Session</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods.html#a8cba4efb0844e0f044c34bd665b98c42">object_session</a> (cls, object instance)</td></tr>
<tr class="separator:a8cba4efb0844e0f044c34bd665b98c42 inherit pub_methods_classsqlalchemy_1_1orm_1_1session_1_1__SessionClassMethods"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a16529a3fab937858438d1b6ea18fc099"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a16529a3fab937858438d1b6ea18fc099">identity_map</a></td></tr>
<tr class="separator:a16529a3fab937858438d1b6ea18fc099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ec6c6975ce12366b35f9f022e04f4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#ae1ec6c6975ce12366b35f9f022e04f4b">bind</a></td></tr>
<tr class="separator:ae1ec6c6975ce12366b35f9f022e04f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9fd8a27109dfccfb6d9c6b5376e9b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a9a9fd8a27109dfccfb6d9c6b5376e9b9">hash_key</a></td></tr>
<tr class="separator:a9a9fd8a27109dfccfb6d9c6b5376e9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f74f654f539562eded345db6fa0838"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a69f74f654f539562eded345db6fa0838">autobegin</a></td></tr>
<tr class="separator:a69f74f654f539562eded345db6fa0838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3113baa32e565038e999bef8b0f592"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a6f3113baa32e565038e999bef8b0f592">autoflush</a></td></tr>
<tr class="separator:a6f3113baa32e565038e999bef8b0f592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a942722dbb9b89d96ae43c649afb88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a03a942722dbb9b89d96ae43c649afb88">expire_on_commit</a></td></tr>
<tr class="separator:a03a942722dbb9b89d96ae43c649afb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6388605c6b4c2e093c2f79c16196f458"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a6388605c6b4c2e093c2f79c16196f458">enable_baked_queries</a></td></tr>
<tr class="separator:a6388605c6b4c2e093c2f79c16196f458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786f6c9b52b962ba97d9c5ed985df3a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a786f6c9b52b962ba97d9c5ed985df3a8">join_transaction_mode</a></td></tr>
<tr class="separator:a786f6c9b52b962ba97d9c5ed985df3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754268fa1caa7d8d5c7e931dbe1a8195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html#a754268fa1caa7d8d5c7e931dbe1a8195">twophase</a></td></tr>
<tr class="separator:a754268fa1caa7d8d5c7e931dbe1a8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Manages persistence operations for ORM-mapped objects.

The :class:`_orm.Session` is **not safe for use in concurrent threads.**.
See :ref:`session_faq_threadsafe` for background.

The Session's usage paradigm is described at :doc:`/orm/session`.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac45fab33629f0e434d4f394827b90cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45fab33629f0e434d4f394827b90cfd">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sqlalchemy.orm.session.Session.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_SessionBind] &#160;</td>
          <td class="paramname"><em>bind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>autoflush</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[True] &#160;</td>
          <td class="paramname"><em>future</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>expire_on_commit</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>autobegin</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>twophase</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Dict[_SessionBindKey, _SessionBind]] &#160;</td>
          <td class="paramname"><em>binds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>enable_baked_queries</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_InfoType] &#160;</td>
          <td class="paramname"><em>info</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Type[<a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[Any]]] &#160;</td>
          <td class="paramname"><em>query_cls</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[False] &#160;</td>
          <td class="paramname"><em>autocommit</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesqlalchemy_1_1orm_1_1session.html#aed7664da1df19c2e180d229d6602ac2b">JoinTransactionMode</a> &#160;</td>
          <td class="paramname"><em>join_transaction_mode</em> = <code>&quot;conditional_savepoint&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[bool, <a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html">_NoArg</a>] &#160;</td>
          <td class="paramname"><em>close_resets_only</em> = <code><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1__NoArg.html#afab96fa3f8b07127b0c13ceca946f7ca">_NoArg.NO_ARG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a new :class:`_orm.Session`.

See also the :class:`.sessionmaker` function which is used to
generate a :class:`.Session`-producing callable with a given
set of arguments.

:param autoflush: When ``True``, all query operations will issue a
   :meth:`~.Session.flush` call to this ``Session`` before proceeding.
   This is a convenience feature so that :meth:`~.Session.flush` need
   not be called repeatedly in order for database queries to retrieve
   results.

   .. seealso::

       :ref:`session_flushing` - additional background on autoflush

:param autobegin: Automatically start transactions (i.e. equivalent to
   invoking :meth:`_orm.Session.begin`) when database access is
   requested by an operation.   Defaults to ``True``.    Set to
   ``False`` to prevent a :class:`_orm.Session` from implicitly
   beginning transactions after construction, as well as after any of
   the :meth:`_orm.Session.rollback`, :meth:`_orm.Session.commit`,
   or :meth:`_orm.Session.close` methods are called.

   .. versionadded:: 2.0

   .. seealso::

        :ref:`session_autobegin_disable`

:param bind: An optional :class:`_engine.Engine` or
   :class:`_engine.Connection` to
   which this ``Session`` should be bound. When specified, all SQL
   operations performed by this session will execute via this
   connectable.

:param binds: A dictionary which may specify any number of
   :class:`_engine.Engine` or :class:`_engine.Connection`
   objects as the source of
   connectivity for SQL operations on a per-entity basis.   The keys
   of the dictionary consist of any series of mapped classes,
   arbitrary Python classes that are bases for mapped classes,
   :class:`_schema.Table` objects and :class:`_orm.Mapper` objects.
   The
   values of the dictionary are then instances of
   :class:`_engine.Engine`
   or less commonly :class:`_engine.Connection` objects.
   Operations which
   proceed relative to a particular mapped class will consult this
   dictionary for the closest matching entity in order to determine
   which :class:`_engine.Engine` should be used for a particular SQL
   operation.    The complete heuristics for resolution are
   described at :meth:`.Session.get_bind`.  Usage looks like::

    Session = sessionmaker(
        binds={
            SomeMappedClass: create_engine("postgresql+psycopg2://engine1"),
            SomeDeclarativeBase: create_engine(
                "postgresql+psycopg2://engine2"
            ),
            some_mapper: create_engine("postgresql+psycopg2://engine3"),
            some_table: create_engine("postgresql+psycopg2://engine4"),
        }
    )

   .. seealso::

        :ref:`session_partitioning`

        :meth:`.Session.bind_mapper`

        :meth:`.Session.bind_table`

        :meth:`.Session.get_bind`


:param \class_: Specify an alternate class other than
   ``sqlalchemy.orm.session.Session`` which should be used by the
   returned class. This is the only argument that is local to the
   :class:`.sessionmaker` function, and is not sent directly to the
   constructor for ``Session``.

:param enable_baked_queries: legacy; defaults to ``True``.
   A parameter consumed
   by the :mod:`sqlalchemy.ext.baked` extension to determine if
   "baked queries" should be cached, as is the normal operation
   of this extension.  When set to ``False``, caching as used by
   this particular extension is disabled.

   .. versionchanged:: 1.4 The ``sqlalchemy.ext.baked`` extension is
      legacy and is not used by any of SQLAlchemy's internals. This
      flag therefore only affects applications that are making explicit
      use of this extension within their own code.

:param expire_on_commit:  Defaults to ``True``. When ``True``, all
   instances will be fully expired after each :meth:`~.commit`,
   so that all attribute/object access subsequent to a completed
   transaction will load from the most recent database state.

    .. seealso::

        :ref:`session_committing`

:param future: Deprecated; this flag is always True.

  .. seealso::

    :ref:`migration_20_toplevel`

:param info: optional dictionary of arbitrary data to be associated
   with this :class:`.Session`.  Is available via the
   :attr:`.Session.info` attribute.  Note the dictionary is copied at
   construction time so that modifications to the per-
   :class:`.Session` dictionary will be local to that
   :class:`.Session`.

:param query_cls:  Class which should be used to create new Query
  objects, as returned by the :meth:`~.Session.query` method.
  Defaults to :class:`_query.Query`.

:param twophase:  When ``True``, all transactions will be started as
    a "two phase" transaction, i.e. using the "two phase" semantics
    of the database in use along with an XID.  During a
    :meth:`~.commit`, after :meth:`~.flush` has been issued for all
    attached databases, the :meth:`~.TwoPhaseTransaction.prepare`
    method on each database's :class:`.TwoPhaseTransaction` will be
    called. This allows each database to roll back the entire
    transaction, before each transaction is committed.

:param autocommit: the "autocommit" keyword is present for backwards
    compatibility but must remain at its default value of ``False``.

:param join_transaction_mode: Describes the transactional behavior to
  take when a given bind is a :class:`_engine.Connection` that
  has already begun a transaction outside the scope of this
  :class:`_orm.Session`; in other words the
  :meth:`_engine.Connection.in_transaction()` method returns True.

  The following behaviors only take effect when the :class:`_orm.Session`
  **actually makes use of the connection given**; that is, a method
  such as :meth:`_orm.Session.execute`, :meth:`_orm.Session.connection`,
  etc. are actually invoked:

  * ``"conditional_savepoint"`` - this is the default.  if the given
    :class:`_engine.Connection` is begun within a transaction but
    does not have a SAVEPOINT, then ``"rollback_only"`` is used.
    If the :class:`_engine.Connection` is additionally within
    a SAVEPOINT, in other words
    :meth:`_engine.Connection.in_nested_transaction()` method returns
    True, then ``"create_savepoint"`` is used.

    ``"conditional_savepoint"`` behavior attempts to make use of
    savepoints in order to keep the state of the existing transaction
    unchanged, but only if there is already a savepoint in progress;
    otherwise, it is not assumed that the backend in use has adequate
    support for SAVEPOINT, as availability of this feature varies.
    ``"conditional_savepoint"`` also seeks to establish approximate
    backwards compatibility with previous :class:`_orm.Session`
    behavior, for applications that are not setting a specific mode. It
    is recommended that one of the explicit settings be used.

  * ``"create_savepoint"`` - the :class:`_orm.Session` will use
    :meth:`_engine.Connection.begin_nested()` in all cases to create
    its own transaction.  This transaction by its nature rides
    "on top" of any existing transaction that's opened on the given
    :class:`_engine.Connection`; if the underlying database and
    the driver in use has full, non-broken support for SAVEPOINT, the
    external transaction will remain unaffected throughout the
    lifespan of the :class:`_orm.Session`.

    The ``"create_savepoint"`` mode is the most useful for integrating
    a :class:`_orm.Session` into a test suite where an externally
    initiated transaction should remain unaffected; however, it relies
    on proper SAVEPOINT support from the underlying driver and
    database.

    .. tip:: When using SQLite, the SQLite driver included through
       Python 3.11 does not handle SAVEPOINTs correctly in all cases
       without workarounds. See the sections
       :ref:`pysqlite_serializable` and :ref:`aiosqlite_serializable`
       for details on current workarounds.

  * ``"control_fully"`` - the :class:`_orm.Session` will take
    control of the given transaction as its own;
    :meth:`_orm.Session.commit` will call ``.commit()`` on the
    transaction, :meth:`_orm.Session.rollback` will call
    ``.rollback()`` on the transaction, :meth:`_orm.Session.close` will
    call ``.rollback`` on the transaction.

    .. tip:: This mode of use is equivalent to how SQLAlchemy 1.4 would
       handle a :class:`_engine.Connection` given with an existing
       SAVEPOINT (i.e. :meth:`_engine.Connection.begin_nested`); the
       :class:`_orm.Session` would take full control of the existing
       SAVEPOINT.

  * ``"rollback_only"`` - the :class:`_orm.Session` will take control
    of the given transaction for ``.rollback()`` calls only;
    ``.commit()`` calls will not be propagated to the given
    transaction.  ``.close()`` calls will have no effect on the
    given transaction.

    .. tip:: This mode of use is equivalent to how SQLAlchemy 1.4 would
       handle a :class:`_engine.Connection` given with an existing
       regular database transaction (i.e.
       :meth:`_engine.Connection.begin`); the :class:`_orm.Session`
       would propagate :meth:`_orm.Session.rollback` calls to the
       underlying transaction, but not :meth:`_orm.Session.commit` or
       :meth:`_orm.Session.close` calls.

  .. versionadded:: 2.0.0rc1

:param close_resets_only: Defaults to ``True``. Determines if
  the session should reset itself after calling ``.close()``
  or should pass in a no longer usable state, disabling re-use.

  .. versionadded:: 2.0.22 added flag ``close_resets_only``.
    A future SQLAlchemy version may change the default value of
    this flag to ``False``.

  .. seealso::

    :ref:`session_closing` - Detail on the semantics of
    :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`.</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa9899f3dd09659bd0f294891d76f994d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9899f3dd09659bd0f294891d76f994d">&#9670;&nbsp;</a></span>__contains__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool sqlalchemy.orm.session.Session.__contains__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if the instance is associated with this session.

The instance may be pending or persistent within the Session for a
result of True.</pre> 
</div>
</div>
<a id="adafd66684373d2b522d6110575115e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafd66684373d2b522d6110575115e66">&#9670;&nbsp;</a></span>__enter__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> _S sqlalchemy.orm.session.Session.__enter__ </td>
          <td>(</td>
          <td class="paramtype">_S&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3e16bf133db3c8047b381078289466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3e16bf133db3c8047b381078289466">&#9670;&nbsp;</a></span>__exit__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.__exit__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>type_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>traceback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa6d10c55587f7084654cef584643a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6d10c55587f7084654cef584643a4a">&#9670;&nbsp;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[object] sqlalchemy.orm.session.Session.__iter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate over all pending or persistent instances within this
Session.</pre> 
</div>
</div>
<a id="a28403bb56652e1fce78cf9cb6983a795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28403bb56652e1fce78cf9cb6983a795">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.add </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>_warn</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Place an object into this :class:`_orm.Session`.

Objects that are in the :term:`transient` state when passed to the
:meth:`_orm.Session.add` method will move to the
:term:`pending` state, until the next flush, at which point they
will move to the :term:`persistent` state.

Objects that are in the :term:`detached` state when passed to the
:meth:`_orm.Session.add` method will move to the :term:`persistent`
state directly.

If the transaction used by the :class:`_orm.Session` is rolled back,
objects which were transient when they were passed to
:meth:`_orm.Session.add` will be moved back to the
:term:`transient` state, and will no longer be present within this
:class:`_orm.Session`.

.. seealso::

    :meth:`_orm.Session.add_all`

    :ref:`session_adding` - at :ref:`session_basics`</pre> 
</div>
</div>
<a id="a73aa42e8a0ebe3c4be32b7d1620aed4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73aa42e8a0ebe3c4be32b7d1620aed4b">&#9670;&nbsp;</a></span>add_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.add_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[object]&#160;</td>
          <td class="paramname"><em>instances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add the given collection of instances to this :class:`_orm.Session`.

See the documentation for :meth:`_orm.Session.add` for a general
behavioral description.

.. seealso::

    :meth:`_orm.Session.add`

    :ref:`session_adding` - at :ref:`session_basics`</pre> 
</div>
</div>
<a id="aecf0406432902a5818cfd3f41ad4c7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf0406432902a5818cfd3f41ad4c7d1">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1SessionTransaction.html">SessionTransaction</a> sqlalchemy.orm.session.Session.begin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>nested</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Begin a transaction, or nested transaction,
on this :class:`.Session`, if one is not already begun.

The :class:`_orm.Session` object features **autobegin** behavior,
so that normally it is not necessary to call the
:meth:`_orm.Session.begin`
method explicitly. However, it may be used in order to control
the scope of when the transactional state is begun.

When used to begin the outermost transaction, an error is raised
if this :class:`.Session` is already inside of a transaction.

:param nested: if True, begins a SAVEPOINT transaction and is
 equivalent to calling :meth:`~.Session.begin_nested`. For
 documentation on SAVEPOINT transactions, please see
 :ref:`session_begin_nested`.

:return: the :class:`.SessionTransaction` object.  Note that
 :class:`.SessionTransaction`
 acts as a Python context manager, allowing :meth:`.Session.begin`
 to be used in a "with" block.  See :ref:`session_explicit_begin` for
 an example.

.. seealso::

    :ref:`session_autobegin`

    :ref:`unitofwork_transaction`

    :meth:`.Session.begin_nested`</pre> 
</div>
</div>
<a id="a9aede905e68ebb33f731567afa6a4f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aede905e68ebb33f731567afa6a4f96">&#9670;&nbsp;</a></span>begin_nested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1SessionTransaction.html">SessionTransaction</a> sqlalchemy.orm.session.Session.begin_nested </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Begin a "nested" transaction on this Session, e.g. SAVEPOINT.

The target database(s) and associated drivers must support SQL
SAVEPOINT for this method to function correctly.

For documentation on SAVEPOINT
transactions, please see :ref:`session_begin_nested`.

:return: the :class:`.SessionTransaction` object.  Note that
 :class:`.SessionTransaction` acts as a context manager, allowing
 :meth:`.Session.begin_nested` to be used in a "with" block.
 See :ref:`session_begin_nested` for a usage example.

.. seealso::

    :ref:`session_begin_nested`

    :ref:`pysqlite_serializable` - special workarounds required
    with the SQLite driver in order for SAVEPOINT to work
    correctly. For asyncio use cases, see the section
    :ref:`aiosqlite_serializable`.</pre> 
</div>
</div>
<a id="a65d2e9cbbec20307036a68abb570d47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d2e9cbbec20307036a68abb570d47d">&#9670;&nbsp;</a></span>bind_mapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.bind_mapper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_EntityBindKey[_O]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_SessionBind
    &#160;</td>
          <td class="paramname"><em>bind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Associate a :class:`_orm.Mapper` or arbitrary Python class with a
"bind", e.g. an :class:`_engine.Engine` or
:class:`_engine.Connection`.

The given entity is added to a lookup used by the
:meth:`.Session.get_bind` method.

:param mapper: a :class:`_orm.Mapper` object,
 or an instance of a mapped
 class, or any Python class that is the base of a set of mapped
 classes.

:param bind: an :class:`_engine.Engine` or :class:`_engine.Connection`
            object.

.. seealso::

    :ref:`session_partitioning`

    :paramref:`.Session.binds`

    :meth:`.Session.bind_table`</pre> 
</div>
</div>
<a id="af849ab909a08b95a5739dd079e138008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af849ab909a08b95a5739dd079e138008">&#9670;&nbsp;</a></span>bind_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.bind_table </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TableClause&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_SessionBind&#160;</td>
          <td class="paramname"><em>bind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Associate a :class:`_schema.Table` with a "bind", e.g. an
:class:`_engine.Engine`
or :class:`_engine.Connection`.

The given :class:`_schema.Table` is added to a lookup used by the
:meth:`.Session.get_bind` method.

:param table: a :class:`_schema.Table` object,
 which is typically the target
 of an ORM mapping, or is present within a selectable that is
 mapped.

:param bind: an :class:`_engine.Engine` or :class:`_engine.Connection`
 object.

.. seealso::

    :ref:`session_partitioning`

    :paramref:`.Session.binds`

    :meth:`.Session.bind_mapper`</pre> 
</div>
</div>
<a id="a7a0ab5152777ebe5efb2a978e1a01955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0ab5152777ebe5efb2a978e1a01955">&#9670;&nbsp;</a></span>bulk_insert_mappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.bulk_insert_mappings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[Any]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[Dict[str, Any]]&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>return_defaults</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>render_nulls</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a bulk insert of the given list of mapping dictionaries.

.. legacy::

    This method is a legacy feature as of the 2.0 series of
    SQLAlchemy.   For modern bulk INSERT and UPDATE, see
    the sections :ref:`orm_queryguide_bulk_insert` and
    :ref:`orm_queryguide_bulk_update`.  The 2.0 API shares
    implementation details with this method and adds new features
    as well.

:param mapper: a mapped class, or the actual :class:`_orm.Mapper`
 object,
 representing the single kind of object represented within the mapping
 list.

:param mappings: a sequence of dictionaries, each one containing the
 state of the mapped row to be inserted, in terms of the attribute
 names on the mapped class.   If the mapping refers to multiple tables,
 such as a joined-inheritance mapping, each dictionary must contain all
 keys to be populated into all tables.

:param return_defaults: when True, the INSERT process will be altered
 to ensure that newly generated primary key values will be fetched.
 The rationale for this parameter is typically to enable
 :ref:`Joined Table Inheritance &lt;joined_inheritance&gt;` mappings to
 be bulk inserted.

 .. note:: for backends that don't support RETURNING, the
    :paramref:`_orm.Session.bulk_insert_mappings.return_defaults`
    parameter can significantly decrease performance as INSERT
    statements can no longer be batched.   See
    :ref:`engine_insertmanyvalues`
    for background on which backends are affected.

:param render_nulls: When True, a value of ``None`` will result
 in a NULL value being included in the INSERT statement, rather
 than the column being omitted from the INSERT.   This allows all
 the rows being INSERTed to have the identical set of columns which
 allows the full set of rows to be batched to the DBAPI.  Normally,
 each column-set that contains a different combination of NULL values
 than the previous row must omit a different series of columns from
 the rendered INSERT statement, which means it must be emitted as a
 separate statement.   By passing this flag, the full set of rows
 are guaranteed to be batchable into one batch; the cost however is
 that server-side defaults which are invoked by an omitted column will
 be skipped, so care must be taken to ensure that these are not
 necessary.

 .. warning::

    When this flag is set, **server side default SQL values will
    not be invoked** for those columns that are inserted as NULL;
    the NULL value will be sent explicitly.   Care must be taken
    to ensure that no server-side default functions need to be
    invoked for the operation as a whole.

.. seealso::

    :doc:`queryguide/dml`

    :meth:`.Session.bulk_save_objects`

    :meth:`.Session.bulk_update_mappings`</pre> 
</div>
</div>
<a id="a8d964e65672de9b4655c56341c9dfb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d964e65672de9b4655c56341c9dfb1d">&#9670;&nbsp;</a></span>bulk_save_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.bulk_save_objects </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[object]&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>return_defaults</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>update_changed_only</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>preserve_order</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a bulk save of the given list of objects.

.. legacy::

    This method is a legacy feature as of the 2.0 series of
    SQLAlchemy.   For modern bulk INSERT and UPDATE, see
    the sections :ref:`orm_queryguide_bulk_insert` and
    :ref:`orm_queryguide_bulk_update`.

    For general INSERT and UPDATE of existing ORM mapped objects,
    prefer standard :term:`unit of work` data management patterns,
    introduced in the :ref:`unified_tutorial` at
    :ref:`tutorial_orm_data_manipulation`.  SQLAlchemy 2.0
    now uses :ref:`engine_insertmanyvalues` with modern dialects
    which solves previous issues of bulk INSERT slowness.

:param objects: a sequence of mapped object instances.  The mapped
 objects are persisted as is, and are **not** associated with the
 :class:`.Session` afterwards.

 For each object, whether the object is sent as an INSERT or an
 UPDATE is dependent on the same rules used by the :class:`.Session`
 in traditional operation; if the object has the
 :attr:`.InstanceState.key`
 attribute set, then the object is assumed to be "detached" and
 will result in an UPDATE.  Otherwise, an INSERT is used.

 In the case of an UPDATE, statements are grouped based on which
 attributes have changed, and are thus to be the subject of each
 SET clause.  If ``update_changed_only`` is False, then all
 attributes present within each object are applied to the UPDATE
 statement, which may help in allowing the statements to be grouped
 together into a larger executemany(), and will also reduce the
 overhead of checking history on attributes.

:param return_defaults: when True, rows that are missing values which
 generate defaults, namely integer primary key defaults and sequences,
 will be inserted **one at a time**, so that the primary key value
 is available.  In particular this will allow joined-inheritance
 and other multi-table mappings to insert correctly without the need
 to provide primary key values ahead of time; however,
 :paramref:`.Session.bulk_save_objects.return_defaults` **greatly
 reduces the performance gains** of the method overall.  It is strongly
 advised to please use the standard :meth:`_orm.Session.add_all`
 approach.

:param update_changed_only: when True, UPDATE statements are rendered
 based on those attributes in each state that have logged changes.
 When False, all attributes present are rendered into the SET clause
 with the exception of primary key attributes.

:param preserve_order: when True, the order of inserts and updates
 matches exactly the order in which the objects are given.   When
 False, common types of objects are grouped into inserts
 and updates, to allow for more batching opportunities.

.. seealso::

    :doc:`queryguide/dml`

    :meth:`.Session.bulk_insert_mappings`

    :meth:`.Session.bulk_update_mappings`</pre> 
</div>
</div>
<a id="ae0d40815232553a5fe62ef40928dfeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d40815232553a5fe62ef40928dfeeb">&#9670;&nbsp;</a></span>bulk_update_mappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.bulk_update_mappings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1orm_1_1mapper_1_1Mapper.html">Mapper</a>[Any]&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[Dict[str, Any]]
    &#160;</td>
          <td class="paramname"><em>mappings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a bulk update of the given list of mapping dictionaries.

.. legacy::

    This method is a legacy feature as of the 2.0 series of
    SQLAlchemy.   For modern bulk INSERT and UPDATE, see
    the sections :ref:`orm_queryguide_bulk_insert` and
    :ref:`orm_queryguide_bulk_update`.  The 2.0 API shares
    implementation details with this method and adds new features
    as well.

:param mapper: a mapped class, or the actual :class:`_orm.Mapper`
 object,
 representing the single kind of object represented within the mapping
 list.

:param mappings: a sequence of dictionaries, each one containing the
 state of the mapped row to be updated, in terms of the attribute names
 on the mapped class.   If the mapping refers to multiple tables, such
 as a joined-inheritance mapping, each dictionary may contain keys
 corresponding to all tables.   All those keys which are present and
 are not part of the primary key are applied to the SET clause of the
 UPDATE statement; the primary key values, which are required, are
 applied to the WHERE clause.


.. seealso::

    :doc:`queryguide/dml`

    :meth:`.Session.bulk_insert_mappings`

    :meth:`.Session.bulk_save_objects`</pre> 
</div>
</div>
<a id="af48580e0e9e48dc3d0f2bf7fc53cc683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48580e0e9e48dc3d0f2bf7fc53cc683">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close out the transactional resources and ORM objects used by this
:class:`_orm.Session`.

This expunges all ORM objects associated with this
:class:`_orm.Session`, ends any transaction in progress and
:term:`releases` any :class:`_engine.Connection` objects which this
:class:`_orm.Session` itself has checked out from associated
:class:`_engine.Engine` objects. The operation then leaves the
:class:`_orm.Session` in a state which it may be used again.

.. tip::

    In the default running mode the :meth:`_orm.Session.close`
    method **does not prevent the Session from being used again**.
    The :class:`_orm.Session` itself does not actually have a
    distinct "closed" state; it merely means
    the :class:`_orm.Session` will release all database connections
    and ORM objects.

    Setting the parameter :paramref:`_orm.Session.close_resets_only`
    to ``False`` will instead make the ``close`` final, meaning that
    any further action on the session will be forbidden.

.. versionchanged:: 1.4  The :meth:`.Session.close` method does not
   immediately create a new :class:`.SessionTransaction` object;
   instead, the new :class:`.SessionTransaction` is created only if
   the :class:`.Session` is used again for a database operation.

.. seealso::

    :ref:`session_closing` - detail on the semantics of
    :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`.

    :meth:`_orm.Session.reset` - a similar method that behaves like
    ``close()`` with  the parameter
    :paramref:`_orm.Session.close_resets_only` set to ``True``.</pre> 
</div>
</div>
<a id="a0177fb39072ffef1831aa6c48e1d8e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0177fb39072ffef1831aa6c48e1d8e93">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.commit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flush pending changes and commit the current transaction.

When the COMMIT operation is complete, all objects are fully
:term:`expired`, erasing their internal contents, which will be
automatically re-loaded when the objects are next accessed. In the
interim, these objects are in an expired state and will not function if
they are :term:`detached` from the :class:`.Session`. Additionally,
this re-load operation is not supported when using asyncio-oriented
APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
to disable this behavior.

When there is no transaction in place for the :class:`.Session`,
indicating that no operations were invoked on this :class:`.Session`
since the previous call to :meth:`.Session.commit`, the method will
begin and commit an internal-only "logical" transaction, that does not
normally affect the database unless pending flush changes were
detected, but will still invoke event handlers and object expiration
rules.

The outermost database transaction is committed unconditionally,
automatically releasing any SAVEPOINTs in effect.

.. seealso::

    :ref:`session_committing`

    :ref:`unitofwork_transaction`

    :ref:`asyncio_orm_avoid_lazyloads`</pre> 
</div>
</div>
<a id="a391100aa0c4b009a6a3b645bd0202f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391100aa0c4b009a6a3b645bd0202f47">&#9670;&nbsp;</a></span>connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a> sqlalchemy.orm.session.Session.connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[CoreExecuteOptionsParameter] &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a :class:`_engine.Connection` object corresponding to this
:class:`.Session` object's transactional state.

Either the :class:`_engine.Connection` corresponding to the current
transaction is returned, or if no transaction is in progress, a new
one is begun and the :class:`_engine.Connection`
returned (note that no
transactional state is established with the DBAPI until the first
SQL statement is emitted).

Ambiguity in multi-bind or unbound :class:`.Session` objects can be
resolved through any of the optional keyword arguments.   This
ultimately makes usage of the :meth:`.get_bind` method for resolution.

:param bind_arguments: dictionary of bind arguments.  May include
 "mapper", "bind", "clause", other custom arguments that are passed
 to :meth:`.Session.get_bind`.

:param execution_options: a dictionary of execution options that will
 be passed to :meth:`_engine.Connection.execution_options`, **when the
 connection is first procured only**.   If the connection is already
 present within the :class:`.Session`, a warning is emitted and
 the arguments are ignored.

 .. seealso::

    :ref:`session_transaction_isolation`</pre> 
</div>
</div>
<a id="a290d20249056beabee6fb2ab16771eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290d20249056beabee6fb2ab16771eb5">&#9670;&nbsp;</a></span>delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.delete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Mark an instance as deleted.

The object is assumed to be either :term:`persistent` or
:term:`detached` when passed; after the method is called, the
object will remain in the :term:`persistent` state until the next
flush proceeds.  During this time, the object will also be a member
of the :attr:`_orm.Session.deleted` collection.

When the next flush proceeds, the object will move to the
:term:`deleted` state, indicating a ``DELETE`` statement was emitted
for its row within the current transaction.   When the transaction
is successfully committed,
the deleted object is moved to the :term:`detached` state and is
no longer present within this :class:`_orm.Session`.

.. seealso::

    :ref:`session_deleting` - at :ref:`session_basics`</pre> 
</div>
</div>
<a id="a50ce49b7a8253eab599940ca91f0a3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ce49b7a8253eab599940ca91f0a3fc">&#9670;&nbsp;</a></span>deleted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> IdentitySet sqlalchemy.orm.session.Session.deleted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a885f93494f7391cc1f39d93e3fb060e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885f93494f7391cc1f39d93e3fb060e3">&#9670;&nbsp;</a></span>dirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> IdentitySet sqlalchemy.orm.session.Session.dirty </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The set of all persistent instances considered dirty.

E.g.::

    some_mapped_object in session.dirty

Instances are considered dirty when they were modified but not
deleted.

Note that this 'dirty' calculation is 'optimistic'; most
attribute-setting or collection modification operations will
mark an instance as 'dirty' and place it in this set, even if
there is no net change to the attribute's value.  At flush
time, the value of each attribute is compared to its
previously saved value, and if there's no net change, no SQL
operation will occur (this is a more expensive operation so
it's only done at flush time).

To check if an instance has actionable net changes to its
attributes, use the :meth:`.Session.is_modified` method.</pre> 
</div>
</div>
<a id="adbd1ac1c29004537dbd22700e19ff54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd1ac1c29004537dbd22700e19ff54e">&#9670;&nbsp;</a></span>enable_relationship_loading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.enable_relationship_loading </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Associate an object with this :class:`.Session` for related
object loading.

.. warning::

    :meth:`.enable_relationship_loading` exists to serve special
    use cases and is not recommended for general use.

Accesses of attributes mapped with :func:`_orm.relationship`
will attempt to load a value from the database using this
:class:`.Session` as the source of connectivity.  The values
will be loaded based on foreign key and primary key values
present on this object - if not present, then those relationships
will be unavailable.

The object will be attached to this session, but will
**not** participate in any persistence operations; its state
for almost all purposes will remain either "transient" or
"detached", except for the case of relationship loading.

Also note that backrefs will often not work as expected.
Altering a relationship-bound attribute on the target object
may not fire off a backref event, if the effective value
is what was already loaded from a foreign-key-holding value.

The :meth:`.Session.enable_relationship_loading` method is
similar to the ``load_on_pending`` flag on :func:`_orm.relationship`.
Unlike that flag, :meth:`.Session.enable_relationship_loading` allows
an object to remain transient while still being able to load
related items.

To make a transient object associated with a :class:`.Session`
via :meth:`.Session.enable_relationship_loading` pending, add
it to the :class:`.Session` using :meth:`.Session.add` normally.
If the object instead represents an existing identity in the database,
it should be merged using :meth:`.Session.merge`.

:meth:`.Session.enable_relationship_loading` does not improve
behavior when the ORM is used normally - object references should be
constructed at the object level, not at the foreign key level, so
that they are present in an ordinary way before flush()
proceeds.  This method is not intended for general use.

.. seealso::

    :paramref:`_orm.relationship.load_on_pending` - this flag
    allows per-relationship loading of many-to-ones on items that
    are pending.

    :func:`.make_transient_to_detached` - allows for an object to
    be added to a :class:`.Session` without SQL emitted, which then
    will unexpire attributes on access.</pre> 
</div>
</div>
<a id="aaa004c99ca8bde4aca37dcb8b994c79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa004c99ca8bde4aca37dcb8b994c79f">&#9670;&nbsp;</a></span>execute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1Result.html">Result</a>[Any] sqlalchemy.orm.session.Session.execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreAnyExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>_parent_execute_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>_add_event</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa004c99ca8bde4aca37dcb8b994c79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa004c99ca8bde4aca37dcb8b994c79f">&#9670;&nbsp;</a></span>execute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1Result.html">Result</a>[Any] sqlalchemy.orm.session.Session.execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreAnyExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>_parent_execute_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>_add_event</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Execute a SQL expression construct.

Returns a :class:`_engine.Result` object representing
results of the statement execution.

E.g.::

    from sqlalchemy import select

    result = session.execute(select(User).where(User.id == 5))

The API contract of :meth:`_orm.Session.execute` is similar to that
of :meth:`_engine.Connection.execute`, the :term:`2.0 style` version
of :class:`_engine.Connection`.

.. versionchanged:: 1.4 the :meth:`_orm.Session.execute` method is
   now the primary point of ORM statement execution when using
   :term:`2.0 style` ORM usage.

:param statement:
    An executable statement (i.e. an :class:`.Executable` expression
    such as :func:`_expression.select`).

:param params:
    Optional dictionary, or list of dictionaries, containing
    bound parameter values.   If a single dictionary, single-row
    execution occurs; if a list of dictionaries, an
    "executemany" will be invoked.  The keys in each dictionary
    must correspond to parameter names present in the statement.

:param execution_options: optional dictionary of execution options,
 which will be associated with the statement execution.  This
 dictionary can provide a subset of the options that are accepted
 by :meth:`_engine.Connection.execution_options`, and may also
 provide additional options understood only in an ORM context.

 .. seealso::

    :ref:`orm_queryguide_execution_options` - ORM-specific execution
    options

:param bind_arguments: dictionary of additional arguments to determine
 the bind.  May include "mapper", "bind", or other custom arguments.
 Contents of this dictionary are passed to the
 :meth:`.Session.get_bind` method.

:return: a :class:`_engine.Result` object.</pre> 
</div>
</div>
<a id="aa8821aabe227a7632354970a542902aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8821aabe227a7632354970a542902aa">&#9670;&nbsp;</a></span>execute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1Result.html">Result</a>[_T] sqlalchemy.orm.session.Session.execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1TypedReturnsRows.html">TypedReturnsRows</a>[_T]&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreAnyExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>_parent_execute_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>_add_event</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5b21de054e1d343e5df774d25b90b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b21de054e1d343e5df774d25b90b6f">&#9670;&nbsp;</a></span>execute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1cursor_1_1CursorResult.html">CursorResult</a>[Any] sqlalchemy.orm.session.Session.execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1dml_1_1UpdateBase.html">UpdateBase</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreAnyExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>_parent_execute_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>_add_event</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a384d8c897934d371a32fe9f6376c69a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384d8c897934d371a32fe9f6376c69a9">&#9670;&nbsp;</a></span>expire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.expire </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Iterable[str]] &#160;</td>
          <td class="paramname"><em>attribute_names</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Expire the attributes on an instance.

Marks the attributes of an instance as out of date. When an expired
attribute is next accessed, a query will be issued to the
:class:`.Session` object's current transactional context in order to
load all expired attributes for the given instance.   Note that
a highly isolated transaction will return the same values as were
previously read in that same transaction, regardless of changes
in database state outside of that transaction.

To expire all objects in the :class:`.Session` simultaneously,
use :meth:`Session.expire_all`.

The :class:`.Session` object's default behavior is to
expire all state whenever the :meth:`Session.rollback`
or :meth:`Session.commit` methods are called, so that new
state can be loaded for the new transaction.   For this reason,
calling :meth:`Session.expire` only makes sense for the specific
case that a non-ORM SQL statement was emitted in the current
transaction.

:param instance: The instance to be refreshed.
:param attribute_names: optional list of string attribute names
  indicating a subset of attributes to be expired.

.. seealso::

    :ref:`session_expire` - introductory material

    :meth:`.Session.expire`

    :meth:`.Session.refresh`

    :meth:`_orm.Query.populate_existing`</pre> 
</div>
</div>
<a id="a61b84298f6416fdb77fbd8f21653cf86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b84298f6416fdb77fbd8f21653cf86">&#9670;&nbsp;</a></span>expire_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.expire_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Expires all persistent instances within this Session.

When any attributes on a persistent instance is next accessed,
a query will be issued using the
:class:`.Session` object's current transactional context in order to
load all expired attributes for the given instance.   Note that
a highly isolated transaction will return the same values as were
previously read in that same transaction, regardless of changes
in database state outside of that transaction.

To expire individual objects and individual attributes
on those objects, use :meth:`Session.expire`.

The :class:`.Session` object's default behavior is to
expire all state whenever the :meth:`Session.rollback`
or :meth:`Session.commit` methods are called, so that new
state can be loaded for the new transaction.   For this reason,
calling :meth:`Session.expire_all` is not usually needed,
assuming the transaction is isolated.

.. seealso::

    :ref:`session_expire` - introductory material

    :meth:`.Session.expire`

    :meth:`.Session.refresh`

    :meth:`_orm.Query.populate_existing`</pre> 
</div>
</div>
<a id="a53513889880612ab7f96e728cc787c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53513889880612ab7f96e728cc787c6a">&#9670;&nbsp;</a></span>expunge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.expunge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove the `instance` from this ``Session``.

This will free all internal references to the instance.  Cascading
will be applied according to the *expunge* cascade rule.</pre> 
</div>
</div>
<a id="ac3e796b93ccbf4538db2e0d8226d583c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e796b93ccbf4538db2e0d8226d583c">&#9670;&nbsp;</a></span>expunge_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.expunge_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove all object instances from this ``Session``.

This is equivalent to calling ``expunge(obj)`` on all objects in this
``Session``.</pre> 
</div>
</div>
<a id="afbaa7450189961e64d0d834e7a6f103e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaa7450189961e64d0d834e7a6f103e">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.flush </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Sequence[Any]] &#160;</td>
          <td class="paramname"><em>objects</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flush all the object changes to the database.

Writes out all pending object creations, deletions and modifications
to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
automatically ordered by the Session's unit of work dependency
solver.

Database operations will be issued in the current transactional
context and do not affect the state of the transaction, unless an
error occurs, in which case the entire transaction is rolled back.
You may flush() as often as you like within a transaction to move
changes from Python to the database's transaction buffer.

:param objects: Optional; restricts the flush operation to operate
  only on elements that are in the given collection.

  This feature is for an extremely narrow set of use cases where
  particular objects may need to be operated upon before the
  full flush() occurs.  It is not intended for general use.</pre> 
</div>
</div>
<a id="afae7fcf7cd65f352637745c0d3299921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae7fcf7cd65f352637745c0d3299921">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[_O] sqlalchemy.orm.session.Session.get </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_EntityBindKey[_O]&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_PKIdentityArgument&#160;</td>
          <td class="paramname"><em>ident</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[Sequence[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption.html">ORMOption</a>]] &#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>populate_existing</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForUpdateParameter &#160;</td>
          <td class="paramname"><em>with_for_update</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>identity_token</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an instance based on the given primary key identifier,
or ``None`` if not found.

E.g.::

    my_user = session.get(User, 5)

    some_object = session.get(VersionedFoo, (5, 10))

    some_object = session.get(VersionedFoo, {"id": 5, "version_id": 10})

.. versionadded:: 1.4 Added :meth:`_orm.Session.get`, which is moved
   from the now legacy :meth:`_orm.Query.get` method.

:meth:`_orm.Session.get` is special in that it provides direct
access to the identity map of the :class:`.Session`.
If the given primary key identifier is present
in the local identity map, the object is returned
directly from this collection and no SQL is emitted,
unless the object has been marked fully expired.
If not present,
a SELECT is performed in order to locate the object.

:meth:`_orm.Session.get` also will perform a check if
the object is present in the identity map and
marked as expired - a SELECT
is emitted to refresh the object as well as to
ensure that the row is still present.
If not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised.

:param entity: a mapped class or :class:`.Mapper` indicating the
 type of entity to be loaded.

:param ident: A scalar, tuple, or dictionary representing the
 primary key.  For a composite (e.g. multiple column) primary key,
 a tuple or dictionary should be passed.

 For a single-column primary key, the scalar calling form is typically
 the most expedient.  If the primary key of a row is the value "5",
 the call looks like::

    my_object = session.get(SomeClass, 5)

 The tuple form contains primary key values typically in
 the order in which they correspond to the mapped
 :class:`_schema.Table`
 object's primary key columns, or if the
 :paramref:`_orm.Mapper.primary_key` configuration parameter were
 used, in
 the order used for that parameter. For example, if the primary key
 of a row is represented by the integer
 digits "5, 10" the call would look like::

     my_object = session.get(SomeClass, (5, 10))

 The dictionary form should include as keys the mapped attribute names
 corresponding to each element of the primary key.  If the mapped class
 has the attributes ``id``, ``version_id`` as the attributes which
 store the object's primary key value, the call would look like::

    my_object = session.get(SomeClass, {"id": 5, "version_id": 10})

:param options: optional sequence of loader options which will be
 applied to the query, if one is emitted.

:param populate_existing: causes the method to unconditionally emit
 a SQL query and refresh the object with the newly loaded data,
 regardless of whether or not the object is already present.

:param with_for_update: optional boolean ``True`` indicating FOR UPDATE
  should be used, or may be a dictionary containing flags to
  indicate a more specific set of FOR UPDATE flags for the SELECT;
  flags should match the parameters of
  :meth:`_query.Query.with_for_update`.
  Supersedes the :paramref:`.Session.refresh.lockmode` parameter.

:param execution_options: optional dictionary of execution options,
 which will be associated with the query execution if one is emitted.
 This dictionary can provide a subset of the options that are
 accepted by :meth:`_engine.Connection.execution_options`, and may
 also provide additional options understood only in an ORM context.

 .. versionadded:: 1.4.29

 .. seealso::

    :ref:`orm_queryguide_execution_options` - ORM-specific execution
    options

:param bind_arguments: dictionary of additional arguments to determine
 the bind.  May include "mapper", "bind", or other custom arguments.
 Contents of this dictionary are passed to the
 :meth:`.Session.get_bind` method.

 .. versionadded: 2.0.0rc1

:return: The object instance, or ``None``.</pre> 
</div>
</div>
<a id="ab05049c1ad5b2579d494c651802886ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05049c1ad5b2579d494c651802886ac">&#9670;&nbsp;</a></span>get_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Union[<a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Engine.html">Engine</a>, <a class="el" href="classsqlalchemy_1_1engine_1_1base_1_1Connection.html">Connection</a>] sqlalchemy.orm.session.Session.get_bind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_EntityBindKey[_O]] &#160;</td>
          <td class="paramname"><em>mapper</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[<a class="el" href="classsqlalchemy_1_1sql_1_1elements_1_1ClauseElement.html">ClauseElement</a>] &#160;</td>
          <td class="paramname"><em>clause</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_SessionBind] &#160;</td>
          <td class="paramname"><em>bind</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_sa_skip_events</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>_sa_skip_for_implicit_returning</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a "bind" to which this :class:`.Session` is bound.

The "bind" is usually an instance of :class:`_engine.Engine`,
except in the case where the :class:`.Session` has been
explicitly bound directly to a :class:`_engine.Connection`.

For a multiply-bound or unbound :class:`.Session`, the
``mapper`` or ``clause`` arguments are used to determine the
appropriate bind to return.

Note that the "mapper" argument is usually present
when :meth:`.Session.get_bind` is called via an ORM
operation such as a :meth:`.Session.query`, each
individual INSERT/UPDATE/DELETE operation within a
:meth:`.Session.flush`, call, etc.

The order of resolution is:

1. if mapper given and :paramref:`.Session.binds` is present,
   locate a bind based first on the mapper in use, then
   on the mapped class in use, then on any base classes that are
   present in the ``__mro__`` of the mapped class, from more specific
   superclasses to more general.
2. if clause given and ``Session.binds`` is present,
   locate a bind based on :class:`_schema.Table` objects
   found in the given clause present in ``Session.binds``.
3. if ``Session.binds`` is present, return that.
4. if clause given, attempt to return a bind
   linked to the :class:`_schema.MetaData` ultimately
   associated with the clause.
5. if mapper given, attempt to return a bind
   linked to the :class:`_schema.MetaData` ultimately
   associated with the :class:`_schema.Table` or other
   selectable to which the mapper is mapped.
6. No bind can be found, :exc:`~sqlalchemy.exc.UnboundExecutionError`
   is raised.

Note that the :meth:`.Session.get_bind` method can be overridden on
a user-defined subclass of :class:`.Session` to provide any kind
of bind resolution scheme.  See the example at
:ref:`session_custom_partitioning`.

:param mapper:
  Optional mapped class or corresponding :class:`_orm.Mapper` instance.
  The bind can be derived from a :class:`_orm.Mapper` first by
  consulting the "binds" map associated with this :class:`.Session`,
  and secondly by consulting the :class:`_schema.MetaData` associated
  with the :class:`_schema.Table` to which the :class:`_orm.Mapper` is
  mapped for a bind.

:param clause:
    A :class:`_expression.ClauseElement` (i.e.
    :func:`_expression.select`,
    :func:`_expression.text`,
    etc.).  If the ``mapper`` argument is not present or could not
    produce a bind, the given expression construct will be searched
    for a bound element, typically a :class:`_schema.Table`
    associated with
    bound :class:`_schema.MetaData`.

.. seealso::

     :ref:`session_partitioning`

     :paramref:`.Session.binds`

     :meth:`.Session.bind_mapper`

     :meth:`.Session.bind_table`</pre> 
</div>
</div>
<a id="aade117cc64dba1e07b2f26181dea46b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade117cc64dba1e07b2f26181dea46b4">&#9670;&nbsp;</a></span>get_nested_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[<a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1SessionTransaction.html">SessionTransaction</a>] sqlalchemy.orm.session.Session.get_nested_transaction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the current nested transaction in progress, if any.

.. versionadded:: 1.4</pre> 
</div>
</div>
<a id="a5e7c85dcf82714d345be3d3e26fbfdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7c85dcf82714d345be3d3e26fbfdb6">&#9670;&nbsp;</a></span>get_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> _O sqlalchemy.orm.session.Session.get_one </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_EntityBindKey[_O]&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_PKIdentityArgument&#160;</td>
          <td class="paramname"><em>ident</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Optional[Sequence[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption.html">ORMOption</a>]] &#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>populate_existing</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForUpdateParameter &#160;</td>
          <td class="paramname"><em>with_for_update</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Any] &#160;</td>
          <td class="paramname"><em>identity_token</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return exactly one instance based on the given primary key
identifier, or raise an exception if not found.

Raises ``sqlalchemy.orm.exc.NoResultFound`` if the query
selects no rows.

For a detailed documentation of the arguments see the
method :meth:`.Session.get`.

.. versionadded:: 2.0.22

:return: The object instance.

.. seealso::

    :meth:`.Session.get` - equivalent method that instead
      returns ``None`` if no row was found with the provided primary
      key</pre> 
</div>
</div>
<a id="a1863167b3d44ea8bd6cc5cefaf222f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1863167b3d44ea8bd6cc5cefaf222f42">&#9670;&nbsp;</a></span>get_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[<a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1SessionTransaction.html">SessionTransaction</a>] sqlalchemy.orm.session.Session.get_transaction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the current root transaction in progress, if any.

.. versionadded:: 1.4</pre> 
</div>
</div>
<a id="a2d81c0995523b7082b27eb994a8da3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d81c0995523b7082b27eb994a8da3c7">&#9670;&nbsp;</a></span>in_nested_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool sqlalchemy.orm.session.Session.in_nested_transaction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if this :class:`_orm.Session` has begun a nested
transaction, e.g. SAVEPOINT.

.. versionadded:: 1.4</pre> 
</div>
</div>
<a id="ae4ca4c6583695571825ece266bd5d8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ca4c6583695571825ece266bd5d8b8">&#9670;&nbsp;</a></span>in_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool sqlalchemy.orm.session.Session.in_transaction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if this :class:`_orm.Session` has begun a transaction.

.. versionadded:: 1.4

.. seealso::

    :attr:`_orm.Session.is_active`</pre> 
</div>
</div>
<a id="a58bafd20973ecb39c0387755b43d836b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bafd20973ecb39c0387755b43d836b">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> _InfoType sqlalchemy.orm.session.Session.info </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A user-modifiable dictionary.

The initial value of this dictionary can be populated using the
``info`` argument to the :class:`.Session` constructor or
:class:`.sessionmaker` constructor or factory methods.  The dictionary
here is always local to this :class:`.Session` and can be modified
independently of all other :class:`.Session` objects.</pre> 
</div>
</div>
<a id="a214e57cdb1d9841a3ddd0c02cbd16662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214e57cdb1d9841a3ddd0c02cbd16662">&#9670;&nbsp;</a></span>invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.invalidate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close this Session, using connection invalidation.

This is a variant of :meth:`.Session.close` that will additionally
ensure that the :meth:`_engine.Connection.invalidate`
method will be called on each :class:`_engine.Connection` object
that is currently in use for a transaction (typically there is only
one connection unless the :class:`_orm.Session` is used with
multiple engines).

This can be called when the database is known to be in a state where
the connections are no longer safe to be used.

Below illustrates a scenario when using `gevent
&lt;https://www.gevent.org/&gt;`_, which can produce ``Timeout`` exceptions
that may mean the underlying connection should be discarded::

    import gevent

    try:
        sess = Session()
        sess.add(User())
        sess.commit()
    except gevent.Timeout:
        sess.invalidate()
        raise
    except:
        sess.rollback()
        raise

The method additionally does everything that :meth:`_orm.Session.close`
does, including that all ORM objects are expunged.</pre> 
</div>
</div>
<a id="ad8327a39eaf678dae330ec25fef86fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8327a39eaf678dae330ec25fef86fd5">&#9670;&nbsp;</a></span>is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool sqlalchemy.orm.session.Session.is_active </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">True if this :class:`.Session` not in "partial rollback" state.

.. versionchanged:: 1.4 The :class:`_orm.Session` no longer begins
   a new transaction immediately, so this attribute will be False
   when the :class:`_orm.Session` is first instantiated.

"partial rollback" state typically indicates that the flush process
of the :class:`_orm.Session` has failed, and that the
:meth:`_orm.Session.rollback` method must be emitted in order to
fully roll back the transaction.

If this :class:`_orm.Session` is not in a transaction at all, the
:class:`_orm.Session` will autobegin when it is first used, so in this
case :attr:`_orm.Session.is_active` will return True.

Otherwise, if this :class:`_orm.Session` is within a transaction,
and that transaction has not been rolled back internally, the
:attr:`_orm.Session.is_active` will also return True.

.. seealso::

    :ref:`faq_session_rollback`

    :meth:`_orm.Session.in_transaction`</pre> 
</div>
</div>
<a id="a870049af0198ed2587b83d6cb7dc44ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870049af0198ed2587b83d6cb7dc44ba">&#9670;&nbsp;</a></span>is_modified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool sqlalchemy.orm.session.Session.is_modified </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>include_collections</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if the given instance has locally
modified attributes.

This method retrieves the history for each instrumented
attribute on the instance and performs a comparison of the current
value to its previously flushed or committed value, if any.

It is in effect a more expensive and accurate
version of checking for the given instance in the
:attr:`.Session.dirty` collection; a full test for
each attribute's net "dirty" status is performed.

E.g.::

    return session.is_modified(someobject)

A few caveats to this method apply:

* Instances present in the :attr:`.Session.dirty` collection may
  report ``False`` when tested with this method.  This is because
  the object may have received change events via attribute mutation,
  thus placing it in :attr:`.Session.dirty`, but ultimately the state
  is the same as that loaded from the database, resulting in no net
  change here.
* Scalar attributes may not have recorded the previously set
  value when a new value was applied, if the attribute was not loaded,
  or was expired, at the time the new value was received - in these
  cases, the attribute is assumed to have a change, even if there is
  ultimately no net change against its database value. SQLAlchemy in
  most cases does not need the "old" value when a set event occurs, so
  it skips the expense of a SQL call if the old value isn't present,
  based on the assumption that an UPDATE of the scalar value is
  usually needed, and in those few cases where it isn't, is less
  expensive on average than issuing a defensive SELECT.

  The "old" value is fetched unconditionally upon set only if the
  attribute container has the ``active_history`` flag set to ``True``.
  This flag is set typically for primary key attributes and scalar
  object references that are not a simple many-to-one.  To set this
  flag for any arbitrary mapped column, use the ``active_history``
  argument with :func:`.column_property`.

:param instance: mapped instance to be tested for pending changes.
:param include_collections: Indicates if multivalued collections
 should be included in the operation.  Setting this to ``False`` is a
 way to detect only local-column based properties (i.e. scalar columns
 or many-to-one foreign keys) that would result in an UPDATE for this
 instance upon flush.</pre> 
</div>
</div>
<a id="a8c8b78bdaffa6dbc62fb44731cec3393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8b78bdaffa6dbc62fb44731cec3393">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> _O sqlalchemy.orm.session.Session.merge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_O&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>load</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Sequence[<a class="el" href="classsqlalchemy_1_1orm_1_1interfaces_1_1ORMOption.html">ORMOption</a>]] &#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Copy the state of a given instance into a corresponding instance
within this :class:`.Session`.

:meth:`.Session.merge` examines the primary key attributes of the
source instance, and attempts to reconcile it with an instance of the
same primary key in the session.   If not found locally, it attempts
to load the object from the database based on primary key, and if
none can be located, creates a new instance.  The state of each
attribute on the source instance is then copied to the target
instance.  The resulting target instance is then returned by the
method; the original source instance is left unmodified, and
un-associated with the :class:`.Session` if not already.

This operation cascades to associated instances if the association is
mapped with ``cascade="merge"``.

See :ref:`unitofwork_merging` for a detailed discussion of merging.

:param instance: Instance to be merged.
:param load: Boolean, when False, :meth:`.merge` switches into
 a "high performance" mode which causes it to forego emitting history
 events as well as all database access.  This flag is used for
 cases such as transferring graphs of objects into a :class:`.Session`
 from a second level cache, or to transfer just-loaded objects
 into the :class:`.Session` owned by a worker thread or process
 without re-querying the database.

 The ``load=False`` use case adds the caveat that the given
 object has to be in a "clean" state, that is, has no pending changes
 to be flushed - even if the incoming object is detached from any
 :class:`.Session`.   This is so that when
 the merge operation populates local attributes and
 cascades to related objects and
 collections, the values can be "stamped" onto the
 target object as is, without generating any history or attribute
 events, and without the need to reconcile the incoming data with
 any existing related objects or collections that might not
 be loaded.  The resulting objects from ``load=False`` are always
 produced as "clean", so it is only appropriate that the given objects
 should be "clean" as well, else this suggests a mis-use of the
 method.
:param options: optional sequence of loader options which will be
 applied to the :meth:`_orm.Session.get` method when the merge
 operation loads the existing version of the object from the database.

 .. versionadded:: 1.4.24


.. seealso::

    :func:`.make_transient_to_detached` - provides for an alternative
    means of "merging" a single object into the :class:`.Session`</pre> 
</div>
</div>
<a id="ae1e5252aa099ce533987bd7331ab15cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e5252aa099ce533987bd7331ab15cb">&#9670;&nbsp;</a></span>new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> IdentitySet sqlalchemy.orm.session.Session.new </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a269d3fbfd7a8df067be09b3d39df6307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269d3fbfd7a8df067be09b3d39df6307">&#9670;&nbsp;</a></span>no_autoflush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[<a class="el" href="classsqlalchemy_1_1orm_1_1session_1_1Session.html">Session</a>] sqlalchemy.orm.session.Session.no_autoflush </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a context manager that disables autoflush.

e.g.::

    with session.no_autoflush:

        some_object = SomeClass()
        session.add(some_object)
        # won't autoflush
        some_object.related_thing = session.query(SomeRelated).first()

Operations that proceed within the ``with:`` block
will not be subject to flushes occurring upon query
access.  This is useful when initializing a series
of objects which involve existing database queries,
where the uncompleted object should not yet be flushed.</pre> 
</div>
</div>
<a id="a2826758b47756a15eea1fd7756115488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2826758b47756a15eea1fd7756115488">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.prepare </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Prepare the current transaction in progress for two phase commit.

If no transaction is in progress, this method raises an
:exc:`~sqlalchemy.exc.InvalidRequestError`.

Only root transactions of two phase sessions can be prepared. If the
current transaction is not such, an
:exc:`~sqlalchemy.exc.InvalidRequestError` is raised.</pre> 
</div>
</div>
<a id="a09dac4c9a800e88f5cce27fee0c92283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dac4c9a800e88f5cce27fee0c92283">&#9670;&nbsp;</a></span>query() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[Any] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_ColumnsClauseArgument[Any]&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09dac4c9a800e88f5cce27fee0c92283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dac4c9a800e88f5cce27fee0c92283">&#9670;&nbsp;</a></span>query() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[Any] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*_ColumnsClauseArgument[Any]&#160;</td>
          <td class="paramname"><em>entities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any
    &#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new :class:`_query.Query` object corresponding to this
:class:`_orm.Session`.

Note that the :class:`_query.Query` object is legacy as of
SQLAlchemy 2.0; the :func:`_sql.select` construct is now used
to construct ORM queries.

.. seealso::

    :ref:`unified_tutorial`

    :ref:`queryguide_toplevel`

    :ref:`query_api_toplevel` - legacy API doc</pre> 
</div>
</div>
<a id="ac01ec1ccec906605605f1dca87fff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01ec1ccec906605605f1dca87fff5ae">&#9670;&nbsp;</a></span>query() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1Query.html">Query</a>[_O] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_EntityType[_O]&#160;</td>
          <td class="paramname"><em>_entity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06c8c2385ab51110f770f24ef574c46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c8c2385ab51110f770f24ef574c46a">&#9670;&nbsp;</a></span>query() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1]] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T0]&#160;</td>
          <td class="paramname"><em>__ent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T1]
    &#160;</td>
          <td class="paramname"><em>__ent1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73d3cc0311ad55b5fb093c1016f7bb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d3cc0311ad55b5fb093c1016f7bb81">&#9670;&nbsp;</a></span>query() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2]] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T0]&#160;</td>
          <td class="paramname"><em>__ent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T1]&#160;</td>
          <td class="paramname"><em>__ent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T2]
    &#160;</td>
          <td class="paramname"><em>__ent2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a488cb344d79888c234195cfcabf1d144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488cb344d79888c234195cfcabf1d144">&#9670;&nbsp;</a></span>query() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3]] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T0]&#160;</td>
          <td class="paramname"><em>__ent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T1]&#160;</td>
          <td class="paramname"><em>__ent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T2]&#160;</td>
          <td class="paramname"><em>__ent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T3]&#160;</td>
          <td class="paramname"><em>__ent3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eba1c832e8b4a636a460ed776ca6591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eba1c832e8b4a636a460ed776ca6591">&#9670;&nbsp;</a></span>query() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3, _T4]] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T0]&#160;</td>
          <td class="paramname"><em>__ent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T1]&#160;</td>
          <td class="paramname"><em>__ent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T2]&#160;</td>
          <td class="paramname"><em>__ent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T3]&#160;</td>
          <td class="paramname"><em>__ent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T4]&#160;</td>
          <td class="paramname"><em>__ent4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70c552a6a92d4c60481d87f615713858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c552a6a92d4c60481d87f615713858">&#9670;&nbsp;</a></span>query() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T0]&#160;</td>
          <td class="paramname"><em>__ent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T1]&#160;</td>
          <td class="paramname"><em>__ent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T2]&#160;</td>
          <td class="paramname"><em>__ent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T3]&#160;</td>
          <td class="paramname"><em>__ent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T4]&#160;</td>
          <td class="paramname"><em>__ent4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T5]&#160;</td>
          <td class="paramname"><em>__ent5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac225bf4df734adbe0b78271b7c58162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac225bf4df734adbe0b78271b7c58162">&#9670;&nbsp;</a></span>query() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T0]&#160;</td>
          <td class="paramname"><em>__ent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T1]&#160;</td>
          <td class="paramname"><em>__ent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T2]&#160;</td>
          <td class="paramname"><em>__ent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T3]&#160;</td>
          <td class="paramname"><em>__ent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T4]&#160;</td>
          <td class="paramname"><em>__ent4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T5]&#160;</td>
          <td class="paramname"><em>__ent5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T6]&#160;</td>
          <td class="paramname"><em>__ent6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc97c2ffce85916b4efdf2c8ba66cbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc97c2ffce85916b4efdf2c8ba66cbd1">&#9670;&nbsp;</a></span>query() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T0]&#160;</td>
          <td class="paramname"><em>__ent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T1]&#160;</td>
          <td class="paramname"><em>__ent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T2]&#160;</td>
          <td class="paramname"><em>__ent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T3]&#160;</td>
          <td class="paramname"><em>__ent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T4]&#160;</td>
          <td class="paramname"><em>__ent4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T5]&#160;</td>
          <td class="paramname"><em>__ent5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T6]&#160;</td>
          <td class="paramname"><em>__ent6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_TCCA[_T7]&#160;</td>
          <td class="paramname"><em>__ent7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4f6fcf2dbe048fd9fedd2d88ad19b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f6fcf2dbe048fd9fedd2d88ad19b43">&#9670;&nbsp;</a></span>query() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1orm_1_1query_1_1RowReturningQuery.html">RowReturningQuery</a>[Tuple[_T]] sqlalchemy.orm.session.Session.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1roles_1_1TypedColumnsClauseRole.html">TypedColumnsClauseRole</a>[_T]
    &#160;</td>
          <td class="paramname"><em>_colexpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac11c051aa34bc14b6bb433a883ab8d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11c051aa34bc14b6bb433a883ab8d13">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.refresh </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Iterable[str]] &#160;</td>
          <td class="paramname"><em>attribute_names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForUpdateParameter &#160;</td>
          <td class="paramname"><em>with_for_update</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Expire and refresh attributes on the given instance.

The selected attributes will first be expired as they would when using
:meth:`_orm.Session.expire`; then a SELECT statement will be issued to
the database to refresh column-oriented attributes with the current
value available in the current transaction.

:func:`_orm.relationship` oriented attributes will also be immediately
loaded if they were already eagerly loaded on the object, using the
same eager loading strategy that they were loaded with originally.

.. versionadded:: 1.4 - the :meth:`_orm.Session.refresh` method
   can also refresh eagerly loaded attributes.

:func:`_orm.relationship` oriented attributes that would normally
load using the ``select`` (or "lazy") loader strategy will also
load **if they are named explicitly in the attribute_names
collection**, emitting a SELECT statement for the attribute using the
``immediate`` loader strategy.  If lazy-loaded relationships are not
named in :paramref:`_orm.Session.refresh.attribute_names`, then
they remain as "lazy loaded" attributes and are not implicitly
refreshed.

.. versionchanged:: 2.0.4  The :meth:`_orm.Session.refresh` method
   will now refresh lazy-loaded :func:`_orm.relationship` oriented
   attributes for those which are named explicitly in the
   :paramref:`_orm.Session.refresh.attribute_names` collection.

.. tip::

    While the :meth:`_orm.Session.refresh` method is capable of
    refreshing both column and relationship oriented attributes, its
    primary focus is on refreshing of local column-oriented attributes
    on a single instance. For more open ended "refresh" functionality,
    including the ability to refresh the attributes on many objects at
    once while having explicit control over relationship loader
    strategies, use the
    :ref:`populate existing &lt;orm_queryguide_populate_existing&gt;` feature
    instead.

Note that a highly isolated transaction will return the same values as
were previously read in that same transaction, regardless of changes
in database state outside of that transaction.   Refreshing
attributes usually only makes sense at the start of a transaction
where database rows have not yet been accessed.

:param attribute_names: optional.  An iterable collection of
  string attribute names indicating a subset of attributes to
  be refreshed.

:param with_for_update: optional boolean ``True`` indicating FOR UPDATE
  should be used, or may be a dictionary containing flags to
  indicate a more specific set of FOR UPDATE flags for the SELECT;
  flags should match the parameters of
  :meth:`_query.Query.with_for_update`.
  Supersedes the :paramref:`.Session.refresh.lockmode` parameter.

.. seealso::

    :ref:`session_expire` - introductory material

    :meth:`.Session.expire`

    :meth:`.Session.expire_all`

    :ref:`orm_queryguide_populate_existing` - allows any ORM query
    to refresh objects as they would be loaded normally.</pre> 
</div>
</div>
<a id="a211f3d3b203b0d004a39ce24a44bb5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211f3d3b203b0d004a39ce24a44bb5db">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.reset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close out the transactional resources and ORM objects used by this
:class:`_orm.Session`, resetting the session to its initial state.

This method provides for same "reset-only" behavior that the
:meth:`_orm.Session.close` method has provided historically, where the
state of the :class:`_orm.Session` is reset as though the object were
brand new, and ready to be used again.
This method may then be useful for :class:`_orm.Session` objects
which set :paramref:`_orm.Session.close_resets_only` to ``False``,
so that "reset only" behavior is still available.

.. versionadded:: 2.0.22

.. seealso::

    :ref:`session_closing` - detail on the semantics of
    :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`.

    :meth:`_orm.Session.close` - a similar method will additionally
    prevent re-use of the Session when the parameter
    :paramref:`_orm.Session.close_resets_only` is set to ``False``.
</pre> 
</div>
</div>
<a id="a0a11a82590708e182c6ed4d84a083d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a11a82590708e182c6ed4d84a083d61">&#9670;&nbsp;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None sqlalchemy.orm.session.Session.rollback </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rollback the current transaction in progress.

If no transaction is in progress, this method is a pass-through.

The method always rolls back
the topmost database transaction, discarding any nested
transactions that may be in progress.

.. seealso::

    :ref:`session_rollback`

    :ref:`unitofwork_transaction`</pre> 
</div>
</div>
<a id="ab54f9167271f49c522e94988d4597dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54f9167271f49c522e94988d4597dbd">&#9670;&nbsp;</a></span>scalar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any sqlalchemy.orm.session.Session.scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreSingleExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab54f9167271f49c522e94988d4597dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54f9167271f49c522e94988d4597dbd">&#9670;&nbsp;</a></span>scalar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any sqlalchemy.orm.session.Session.scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreSingleExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Execute a statement and return a scalar result.

Usage and parameters are the same as that of
:meth:`_orm.Session.execute`; the return result is a scalar Python
value.</pre> 
</div>
</div>
<a id="a54f34a357d7b308d43c36efab9a1bc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f34a357d7b308d43c36efab9a1bc2f">&#9670;&nbsp;</a></span>scalar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[_T] sqlalchemy.orm.session.Session.scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1TypedReturnsRows.html">TypedReturnsRows</a>[Tuple[_T]]&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreSingleExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7688af0cade7681d67ce5fc70d53231f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7688af0cade7681d67ce5fc70d53231f">&#9670;&nbsp;</a></span>scalars() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1ScalarResult.html">ScalarResult</a>[Any] sqlalchemy.orm.session.Session.scalars </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreAnyExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7688af0cade7681d67ce5fc70d53231f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7688af0cade7681d67ce5fc70d53231f">&#9670;&nbsp;</a></span>scalars() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1ScalarResult.html">ScalarResult</a>[Any] sqlalchemy.orm.session.Session.scalars </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1base_1_1Executable.html">Executable</a>&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreAnyExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Execute a statement and return the results as scalars.

Usage and parameters are the same as that of
:meth:`_orm.Session.execute`; the return result is a
:class:`_result.ScalarResult` filtering object which
will return single elements rather than :class:`_row.Row` objects.

:return:  a :class:`_result.ScalarResult` object

.. versionadded:: 1.4.24 Added :meth:`_orm.Session.scalars`

.. versionadded:: 1.4.26 Added :meth:`_orm.scoped_session.scalars`

.. seealso::

    :ref:`orm_queryguide_select_orm_entities` - contrasts the behavior
    of :meth:`_orm.Session.execute` to :meth:`_orm.Session.scalars`</pre> 
</div>
</div>
<a id="ac3a8646ef7a1ed315298489c4c463bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a8646ef7a1ed315298489c4c463bdb">&#9670;&nbsp;</a></span>scalars() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classsqlalchemy_1_1engine_1_1result_1_1ScalarResult.html">ScalarResult</a>[_T] sqlalchemy.orm.session.Session.scalars </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsqlalchemy_1_1sql_1_1selectable_1_1TypedReturnsRows.html">TypedReturnsRows</a>[Tuple[_T]]&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_CoreAnyExecuteParams] &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*OrmExecuteOptionsParameter &#160;</td>
          <td class="paramname"><em>execution_options</em> = <code>util.EMPTY_DICT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[_BindArguments] &#160;</td>
          <td class="paramname"><em>bind_arguments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a69f74f654f539562eded345db6fa0838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f74f654f539562eded345db6fa0838">&#9670;&nbsp;</a></span>autobegin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.autobegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f3113baa32e565038e999bef8b0f592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3113baa32e565038e999bef8b0f592">&#9670;&nbsp;</a></span>autoflush</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.autoflush</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1ec6c6975ce12366b35f9f022e04f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ec6c6975ce12366b35f9f022e04f4b">&#9670;&nbsp;</a></span>bind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.bind</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6388605c6b4c2e093c2f79c16196f458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6388605c6b4c2e093c2f79c16196f458">&#9670;&nbsp;</a></span>enable_baked_queries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.enable_baked_queries</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03a942722dbb9b89d96ae43c649afb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a942722dbb9b89d96ae43c649afb88">&#9670;&nbsp;</a></span>expire_on_commit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.expire_on_commit</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a9fd8a27109dfccfb6d9c6b5376e9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9fd8a27109dfccfb6d9c6b5376e9b9">&#9670;&nbsp;</a></span>hash_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.hash_key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16529a3fab937858438d1b6ea18fc099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16529a3fab937858438d1b6ea18fc099">&#9670;&nbsp;</a></span>identity_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.identity_map</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a786f6c9b52b962ba97d9c5ed985df3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786f6c9b52b962ba97d9c5ed985df3a8">&#9670;&nbsp;</a></span>join_transaction_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.join_transaction_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a754268fa1caa7d8d5c7e931dbe1a8195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754268fa1caa7d8d5c7e931dbe1a8195">&#9670;&nbsp;</a></span>twophase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlalchemy.orm.session.Session.twophase</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>py3_env/lib/python3.10/site-packages/sqlalchemy/orm/<a class="el" href="py3__env_2lib_2python3_810_2site-packages_2sqlalchemy_2orm_2session_8py.html">session.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
