<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.ntheory.factor_ Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1ntheory.html">ntheory</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html">factor_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sympy.ntheory.factor_ Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e610ad5f7802ea011d2fc4cb0b59942"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a8e610ad5f7802ea011d2fc4cb0b59942">smoothness</a> (n)</td></tr>
<tr class="separator:a8e610ad5f7802ea011d2fc4cb0b59942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018867189444f6dac899e369a41f2def"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a018867189444f6dac899e369a41f2def">smoothness_p</a> (n, m=-1, power=0, visual=None)</td></tr>
<tr class="separator:a018867189444f6dac899e369a41f2def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbddb8d645dc306183926a5e5a20268"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#afdbddb8d645dc306183926a5e5a20268">multiplicity</a> (p, n)</td></tr>
<tr class="separator:afdbddb8d645dc306183926a5e5a20268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa042833dfd1c848c633fbffa353d889"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#aaa042833dfd1c848c633fbffa353d889">multiplicity_in_factorial</a> (p, n)</td></tr>
<tr class="separator:aaa042833dfd1c848c633fbffa353d889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c0883e3f0aaff8839a12e217bd279f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a21c0883e3f0aaff8839a12e217bd279f">perfect_power</a> (n, candidates=None, big=True, factor=True)</td></tr>
<tr class="separator:a21c0883e3f0aaff8839a12e217bd279f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1b84e473c181a861821a4812c23bf5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a9b1b84e473c181a861821a4812c23bf5">pollard_rho</a> (n, s=2, a=1, retries=5, seed=1234, max_steps=None, F=None)</td></tr>
<tr class="separator:a9b1b84e473c181a861821a4812c23bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84006e530fd1ff88ee0eb15d5cd63fef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a84006e530fd1ff88ee0eb15d5cd63fef">pollard_pm1</a> (n, B=10, a=2, retries=0, seed=1234)</td></tr>
<tr class="separator:a84006e530fd1ff88ee0eb15d5cd63fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6549e4d5e91407a2ecea200e4e7feb27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a6549e4d5e91407a2ecea200e4e7feb27">factorint</a> (n, limit=None, use_trial=True, use_rho=True, use_pm1=True, use_ecm=True, verbose=False, visual=None, multiple=False)</td></tr>
<tr class="separator:a6549e4d5e91407a2ecea200e4e7feb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcac7384be01f1cf9c5dbfc2f8c9633"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a3dcac7384be01f1cf9c5dbfc2f8c9633">factorrat</a> (rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False)</td></tr>
<tr class="separator:a3dcac7384be01f1cf9c5dbfc2f8c9633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03caadb45d631e60f8a19ea5aca64b04"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a03caadb45d631e60f8a19ea5aca64b04">primefactors</a> (n, limit=None, verbose=False, **kwargs)</td></tr>
<tr class="separator:a03caadb45d631e60f8a19ea5aca64b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466a569021315a9f37b5f6948e1ef04f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a466a569021315a9f37b5f6948e1ef04f">divisors</a> (n, generator=False, proper=False)</td></tr>
<tr class="separator:a466a569021315a9f37b5f6948e1ef04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23b7f5f53c278fb6f43f536ea492425"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#aa23b7f5f53c278fb6f43f536ea492425">divisor_count</a> (n, modulus=1, proper=False)</td></tr>
<tr class="separator:aa23b7f5f53c278fb6f43f536ea492425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fdd96724122af24d343c1f573eb268"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#aa6fdd96724122af24d343c1f573eb268">proper_divisors</a> (n, generator=False)</td></tr>
<tr class="separator:aa6fdd96724122af24d343c1f573eb268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05701c46806227834bf07695a10a0f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#ab05701c46806227834bf07695a10a0f6">proper_divisor_count</a> (n, modulus=1)</td></tr>
<tr class="separator:ab05701c46806227834bf07695a10a0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2327b076d65cf273145355157ac9ea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a2d2327b076d65cf273145355157ac9ea">udivisors</a> (n, generator=False)</td></tr>
<tr class="separator:a2d2327b076d65cf273145355157ac9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fb8b7bb95f4f4a5a3f36e699857831"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a89fb8b7bb95f4f4a5a3f36e699857831">udivisor_count</a> (n)</td></tr>
<tr class="separator:a89fb8b7bb95f4f4a5a3f36e699857831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d089a35301a906fec323dca485ef852"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a3d089a35301a906fec323dca485ef852">antidivisors</a> (n, generator=False)</td></tr>
<tr class="separator:a3d089a35301a906fec323dca485ef852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bdde909754c457689cc53eaa54da92"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a39bdde909754c457689cc53eaa54da92">antidivisor_count</a> (n)</td></tr>
<tr class="separator:a39bdde909754c457689cc53eaa54da92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732ce72ee3e0ed02c8293a36637990e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a732ce72ee3e0ed02c8293a36637990e1">totient</a> (n)</td></tr>
<tr class="separator:a732ce72ee3e0ed02c8293a36637990e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff5822c0b0320f4b14d2aed3f856b9a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a3ff5822c0b0320f4b14d2aed3f856b9a">reduced_totient</a> (n)</td></tr>
<tr class="separator:a3ff5822c0b0320f4b14d2aed3f856b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e056780de60b151cc10a5e547308be4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a8e056780de60b151cc10a5e547308be4">divisor_sigma</a> (n, k=1)</td></tr>
<tr class="separator:a8e056780de60b151cc10a5e547308be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbab67cbd1798a0c97c5344a90e900c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a0bbab67cbd1798a0c97c5344a90e900c">core</a> (n, t=2)</td></tr>
<tr class="separator:a0bbab67cbd1798a0c97c5344a90e900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f17b4724fab08c97f8f60eec2a2685"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#ac8f17b4724fab08c97f8f60eec2a2685">udivisor_sigma</a> (n, k=1)</td></tr>
<tr class="separator:ac8f17b4724fab08c97f8f60eec2a2685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c079b5184deb9596f8a19ecbdb5fdf1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a7c079b5184deb9596f8a19ecbdb5fdf1">primenu</a> (n)</td></tr>
<tr class="separator:a7c079b5184deb9596f8a19ecbdb5fdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9e37de8c9577fe896174ee23474fe5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a5e9e37de8c9577fe896174ee23474fe5">primeomega</a> (n)</td></tr>
<tr class="separator:a5e9e37de8c9577fe896174ee23474fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e075c84509b2074592a611a5ac00c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a97e075c84509b2074592a611a5ac00c0">mersenne_prime_exponent</a> (nth)</td></tr>
<tr class="separator:a97e075c84509b2074592a611a5ac00c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3615859080814379023577758b1f0c5b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a3615859080814379023577758b1f0c5b">is_perfect</a> (n)</td></tr>
<tr class="separator:a3615859080814379023577758b1f0c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313bedd38d2d93d59fc6116aea1916ea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a313bedd38d2d93d59fc6116aea1916ea">abundance</a> (n)</td></tr>
<tr class="separator:a313bedd38d2d93d59fc6116aea1916ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258af1f0b6d9f2de0fc6a185a85ab346"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a258af1f0b6d9f2de0fc6a185a85ab346">is_abundant</a> (n)</td></tr>
<tr class="separator:a258af1f0b6d9f2de0fc6a185a85ab346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b7bfed7d056ed72c0620388c92017b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a14b7bfed7d056ed72c0620388c92017b">is_deficient</a> (n)</td></tr>
<tr class="separator:a14b7bfed7d056ed72c0620388c92017b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805d1569ad5032ce797994b8798d7ba1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a805d1569ad5032ce797994b8798d7ba1">is_amicable</a> (m, n)</td></tr>
<tr class="separator:a805d1569ad5032ce797994b8798d7ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b0daba084d08fc7807b66b36e260a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#af6b0daba084d08fc7807b66b36e260a5">is_carmichael</a> (n)</td></tr>
<tr class="separator:af6b0daba084d08fc7807b66b36e260a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e77c9fd4340e99aa31b0e6f568f30"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a7a9e77c9fd4340e99aa31b0e6f568f30">find_carmichael_numbers_in_range</a> (x, y)</td></tr>
<tr class="separator:a7a9e77c9fd4340e99aa31b0e6f568f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d9f6464ff088f23c9283c8f984e2b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a10d9f6464ff088f23c9283c8f984e2b3">find_first_n_carmichaels</a> (n)</td></tr>
<tr class="separator:a10d9f6464ff088f23c9283c8f984e2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a46f70cca41f988094d9ec10ec45bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#ae3a46f70cca41f988094d9ec10ec45bc">dra</a> (n, b)</td></tr>
<tr class="separator:ae3a46f70cca41f988094d9ec10ec45bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd6ab738a2ba2a3636cb719097bd860"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#accd6ab738a2ba2a3636cb719097bd860">drm</a> (n, b)</td></tr>
<tr class="separator:accd6ab738a2ba2a3636cb719097bd860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af7bedd789a619274847d45ae12dd7a29"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#af7bedd789a619274847d45ae12dd7a29">trial_int_msg</a> = &quot;Trial division with ints [%i ... %i] and fail_max=%i&quot;</td></tr>
<tr class="separator:af7bedd789a619274847d45ae12dd7a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7c75d944d44da94b50962b9fdd7f88"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#aaf7c75d944d44da94b50962b9fdd7f88">trial_msg</a> = &quot;Trial division with primes [%i ... %i]&quot;</td></tr>
<tr class="separator:aaf7c75d944d44da94b50962b9fdd7f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70384238f79926a461c5bc16aaa3b8f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#aa70384238f79926a461c5bc16aaa3b8f">rho_msg</a> = &quot;Pollard's rho with retries %i, max_steps %i and seed %i&quot;</td></tr>
<tr class="separator:aa70384238f79926a461c5bc16aaa3b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe03bfd1fb0606a3ca958d6a168a8f81"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#afe03bfd1fb0606a3ca958d6a168a8f81">pm1_msg</a> = &quot;Pollard's p-1 with <a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a8e610ad5f7802ea011d2fc4cb0b59942">smoothness</a> bound %i and seed %i&quot;</td></tr>
<tr class="separator:afe03bfd1fb0606a3ca958d6a168a8f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0793622e325faa829c3f02814ce504b3"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a0793622e325faa829c3f02814ce504b3">ecm_msg</a> = &quot;Elliptic <a class="el" href="classsympy_1_1geometry_1_1curve_1_1Curve.html">Curve</a> with B1 bound %i, B2 bound %i, num_curves %i&quot;</td></tr>
<tr class="separator:a0793622e325faa829c3f02814ce504b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd79e91b7f2bbf4abcb5c693032d558c"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#abd79e91b7f2bbf4abcb5c693032d558c">factor_msg</a> = '\t%i ** %i'</td></tr>
<tr class="separator:abd79e91b7f2bbf4abcb5c693032d558c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165ed32e673dbac47b23146e199cfb0e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a165ed32e673dbac47b23146e199cfb0e">fermat_msg</a> = 'Close factors satisying Fermat condition found.'</td></tr>
<tr class="separator:a165ed32e673dbac47b23146e199cfb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed8f827f9bdd6cf536124f52e5cd304"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a7ed8f827f9bdd6cf536124f52e5cd304">complete_msg</a> = 'Factorization is complete.'</td></tr>
<tr class="separator:a7ed8f827f9bdd6cf536124f52e5cd304"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Integer factorization
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a313bedd38d2d93d59fc6116aea1916ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313bedd38d2d93d59fc6116aea1916ea">&#9670;&nbsp;</a></span>abundance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.abundance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the difference between the sum of the positive
proper divisors of a number and the number.

Examples
========

&gt;&gt;&gt; from sympy.ntheory import abundance, is_perfect, is_abundant
&gt;&gt;&gt; abundance(6)
0
&gt;&gt;&gt; is_perfect(6)
True
&gt;&gt;&gt; abundance(10)
-2
&gt;&gt;&gt; is_abundant(10)
False
</pre> 
</div>
</div>
<a id="a39bdde909754c457689cc53eaa54da92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bdde909754c457689cc53eaa54da92">&#9670;&nbsp;</a></span>antidivisor_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.antidivisor_count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of antidivisors [1]_ of ``n``.

Parameters
==========

n : integer

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import antidivisor_count
&gt;&gt;&gt; antidivisor_count(13)
4
&gt;&gt;&gt; antidivisor_count(27)
5

See Also
========

factorint, divisors, antidivisors, divisor_count, totient

References
==========

.. [1] formula from https://oeis.org/A066272</pre> 
</div>
</div>
<a id="a3d089a35301a906fec323dca485ef852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d089a35301a906fec323dca485ef852">&#9670;&nbsp;</a></span>antidivisors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.antidivisors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>generator</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return all antidivisors of n sorted from 1..n by default.

Antidivisors [1]_ of n are numbers that do not divide n by the largest
possible margin.  If generator is True an unordered generator is returned.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import antidivisors
&gt;&gt;&gt; antidivisors(24)
[7, 16]

&gt;&gt;&gt; sorted(antidivisors(128, generator=True))
[3, 5, 15, 17, 51, 85]

See Also
========

primefactors, factorint, divisors, divisor_count, antidivisor_count

References
==========

.. [1] definition is described in https://oeis.org/A066272/a066272a.html</pre> 
</div>
</div>
<a id="a0bbab67cbd1798a0c97c5344a90e900c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbab67cbd1798a0c97c5344a90e900c">&#9670;&nbsp;</a></span>core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.core </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate core(n, t) = `core_t(n)` of a positive integer n

``core_2(n)`` is equal to the squarefree part of n

If n's prime factorization is:

.. math ::
    n = \prod_{i=1}^\omega p_i^{m_i},

then

.. math ::
    core_t(n) = \prod_{i=1}^\omega p_i^{m_i \mod t}.

Parameters
==========

n : integer

t : integer
    core(n, t) calculates the t-th power free part of n

    ``core(n, 2)`` is the squarefree part of ``n``
    ``core(n, 3)`` is the cubefree part of ``n``

    Default for t is 2.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import core
&gt;&gt;&gt; core(24, 2)
6
&gt;&gt;&gt; core(9424, 3)
1178
&gt;&gt;&gt; core(379238)
379238
&gt;&gt;&gt; core(15**11, 10)
15

See Also
========

factorint, sympy.solvers.diophantine.diophantine.square_factor

References
==========

.. [1] https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core</pre> 
</div>
</div>
<a id="aa23b7f5f53c278fb6f43f536ea492425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23b7f5f53c278fb6f43f536ea492425">&#9670;&nbsp;</a></span>divisor_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.divisor_count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modulus</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proper</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of divisors of ``n``. If ``modulus`` is not 1 then only
those that are divisible by ``modulus`` are counted. If ``proper`` is True
then the divisor of ``n`` will not be counted.

Examples
========

&gt;&gt;&gt; from sympy import divisor_count
&gt;&gt;&gt; divisor_count(6)
4
&gt;&gt;&gt; divisor_count(6, 2)
2
&gt;&gt;&gt; divisor_count(6, proper=True)
3

See Also
========

factorint, divisors, totient, proper_divisor_count</pre> 
</div>
</div>
<a id="a8e056780de60b151cc10a5e547308be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e056780de60b151cc10a5e547308be4">&#9670;&nbsp;</a></span>divisor_sigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.divisor_sigma </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the divisor function `\sigma_k(n)` for positive integer n

.. deprecated:: 1.13

    The ``divisor_sigma`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.divisor_sigma`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

``divisor_sigma(n, k)`` is equal to ``sum([x**k for x in divisors(n)])``

If n's prime factorization is:

.. math ::
    n = \prod_{i=1}^\omega p_i^{m_i},

then

.. math ::
    \sigma_k(n) = \prod_{i=1}^\omega (1+p_i^k+p_i^{2k}+\cdots
    + p_i^{m_ik}).

Parameters
==========

n : integer

k : integer, optional
    power of divisors in the sum

    for k = 0, 1:
    ``divisor_sigma(n, 0)`` is equal to ``divisor_count(n)``
    ``divisor_sigma(n, 1)`` is equal to ``sum(divisors(n))``

    Default for k is 1.

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import divisor_sigma
&gt;&gt;&gt; divisor_sigma(18, 0)
6
&gt;&gt;&gt; divisor_sigma(39, 1)
56
&gt;&gt;&gt; divisor_sigma(12, 2)
210
&gt;&gt;&gt; divisor_sigma(37)
38

See Also
========

divisor_count, totient, divisors, factorint

References
==========

.. [1] https://en.wikipedia.org/wiki/Divisor_function</pre> 
</div>
</div>
<a id="a466a569021315a9f37b5f6948e1ef04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466a569021315a9f37b5f6948e1ef04f">&#9670;&nbsp;</a></span>divisors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.divisors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>generator</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proper</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return all divisors of n sorted from 1..n by default.
If generator is ``True`` an unordered generator is returned.

The number of divisors of n can be quite large if there are many
prime factors (counting repeated factors). If only the number of
factors is desired use divisor_count(n).

Examples
========

&gt;&gt;&gt; from sympy import divisors, divisor_count
&gt;&gt;&gt; divisors(24)
[1, 2, 3, 4, 6, 8, 12, 24]
&gt;&gt;&gt; divisor_count(24)
8

&gt;&gt;&gt; list(divisors(120, generator=True))
[1, 2, 4, 8, 3, 6, 12, 24, 5, 10, 20, 40, 15, 30, 60, 120]

Notes
=====

This is a slightly modified version of Tim Peters referenced at:
https://stackoverflow.com/questions/1010381/python-factorization

See Also
========

primefactors, factorint, divisor_count
</pre> 
</div>
</div>
<a id="ae3a46f70cca41f988094d9ec10ec45bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a46f70cca41f988094d9ec10ec45bc">&#9670;&nbsp;</a></span>dra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.dra </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the additive digital root of a natural number ``n`` in base ``b``
which is a single digit value obtained by an iterative process of summing
digits, on each iteration using the result from the previous iteration to
compute a digit sum.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import dra
&gt;&gt;&gt; dra(3110, 12)
8

References
==========

.. [1] https://en.wikipedia.org/wiki/Digital_root</pre> 
</div>
</div>
<a id="accd6ab738a2ba2a3636cb719097bd860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd6ab738a2ba2a3636cb719097bd860">&#9670;&nbsp;</a></span>drm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.drm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the multiplicative digital root of a natural number ``n`` in a given
base ``b`` which is a single digit value obtained by an iterative process of
multiplying digits, on each iteration using the result from the previous
iteration to compute the digit multiplication.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import drm
&gt;&gt;&gt; drm(9876, 10)
0

&gt;&gt;&gt; drm(49, 10)
8

References
==========

.. [1] https://mathworld.wolfram.com/MultiplicativeDigitalRoot.html</pre> 
</div>
</div>
<a id="a6549e4d5e91407a2ecea200e4e7feb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6549e4d5e91407a2ecea200e4e7feb27">&#9670;&nbsp;</a></span>factorint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.factorint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_trial</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_rho</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_pm1</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_ecm</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>visual</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiple</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a positive integer ``n``, ``factorint(n)`` returns a dict containing
the prime factors of ``n`` as keys and their respective multiplicities
as values. For example:

&gt;&gt;&gt; from sympy.ntheory import factorint
&gt;&gt;&gt; factorint(2000)    # 2000 = (2**4) * (5**3)
{2: 4, 5: 3}
&gt;&gt;&gt; factorint(65537)   # This number is prime
{65537: 1}

For input less than 2, factorint behaves as follows:

    - ``factorint(1)`` returns the empty factorization, ``{}``
    - ``factorint(0)`` returns ``{0:1}``
    - ``factorint(-n)`` adds ``-1:1`` to the factors and then factors ``n``

Partial Factorization:

If ``limit`` (&gt; 3) is specified, the search is stopped after performing
trial division up to (and including) the limit (or taking a
corresponding number of rho/p-1 steps). This is useful if one has
a large number and only is interested in finding small factors (if
any). Note that setting a limit does not prevent larger factors
from being found early; it simply means that the largest factor may
be composite. Since checking for perfect power is relatively cheap, it is
done regardless of the limit setting.

This number, for example, has two small factors and a huge
semi-prime factor that cannot be reduced easily:

&gt;&gt;&gt; from sympy.ntheory import isprime
&gt;&gt;&gt; a = 1407633717262338957430697921446883
&gt;&gt;&gt; f = factorint(a, limit=10000)
&gt;&gt;&gt; f == {991: 1, int(202916782076162456022877024859): 1, 7: 1}
True
&gt;&gt;&gt; isprime(max(f))
False

This number has a small factor and a residual perfect power whose
base is greater than the limit:

&gt;&gt;&gt; factorint(3*101**7, limit=5)
{3: 1, 101: 7}

List of Factors:

If ``multiple`` is set to ``True`` then a list containing the
prime factors including multiplicities is returned.

&gt;&gt;&gt; factorint(24, multiple=True)
[2, 2, 2, 3]

Visual Factorization:

If ``visual`` is set to ``True``, then it will return a visual
factorization of the integer.  For example:

&gt;&gt;&gt; from sympy import pprint
&gt;&gt;&gt; pprint(factorint(4200, visual=True))
 3  1  2  1
2 *3 *5 *7

Note that this is achieved by using the evaluate=False flag in Mul
and Pow. If you do other manipulations with an expression where
evaluate=False, it may evaluate.  Therefore, you should use the
visual option only for visualization, and use the normal dictionary
returned by visual=False if you want to perform operations on the
factors.

You can easily switch between the two forms by sending them back to
factorint:

&gt;&gt;&gt; from sympy import Mul
&gt;&gt;&gt; regular = factorint(1764); regular
{2: 2, 3: 2, 7: 2}
&gt;&gt;&gt; pprint(factorint(regular))
 2  2  2
2 *3 *7

&gt;&gt;&gt; visual = factorint(1764, visual=True); pprint(visual)
 2  2  2
2 *3 *7
&gt;&gt;&gt; print(factorint(visual))
{2: 2, 3: 2, 7: 2}

If you want to send a number to be factored in a partially factored form
you can do so with a dictionary or unevaluated expression:

&gt;&gt;&gt; factorint(factorint({4: 2, 12: 3})) # twice to toggle to dict form
{2: 10, 3: 3}
&gt;&gt;&gt; factorint(Mul(4, 12, evaluate=False))
{2: 4, 3: 1}

The table of the output logic is:

    ====== ====== ======= =======
                   Visual
    ------ ----------------------
    Input  True   False   other
    ====== ====== ======= =======
    dict    mul    dict    mul
    n       mul    dict    dict
    mul     mul    dict    dict
    ====== ====== ======= =======

Notes
=====

Algorithm:

The function switches between multiple algorithms. Trial division
quickly finds small factors (of the order 1-5 digits), and finds
all large factors if given enough time. The Pollard rho and p-1
algorithms are used to find large factors ahead of time; they
will often find factors of the order of 10 digits within a few
seconds:

&gt;&gt;&gt; factors = factorint(12345678910111213141516)
&gt;&gt;&gt; for base, exp in sorted(factors.items()):
...     print('%s %s' % (base, exp))
...
2 2
2507191691 1
1231026625769 1

Any of these methods can optionally be disabled with the following
boolean parameters:

    - ``use_trial``: Toggle use of trial division
    - ``use_rho``: Toggle use of Pollard's rho method
    - ``use_pm1``: Toggle use of Pollard's p-1 method

``factorint`` also periodically checks if the remaining part is
a prime number or a perfect power, and in those cases stops.

For unevaluated factorial, it uses Legendre's formula(theorem).


If ``verbose`` is set to ``True``, detailed progress is printed.

See Also
========

smoothness, smoothness_p, divisors</pre> 
</div>
</div>
<a id="a3dcac7384be01f1cf9c5dbfc2f8c9633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcac7384be01f1cf9c5dbfc2f8c9633">&#9670;&nbsp;</a></span>factorrat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.factorrat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_trial</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_rho</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_pm1</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>visual</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiple</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a Rational ``r``, ``factorrat(r)`` returns a dict containing
the prime factors of ``r`` as keys and their respective multiplicities
as values. For example:

&gt;&gt;&gt; from sympy import factorrat, S
&gt;&gt;&gt; factorrat(S(8)/9)    # 8/9 = (2**3) * (3**-2)
{2: 3, 3: -2}
&gt;&gt;&gt; factorrat(S(-1)/987)    # -1/789 = -1 * (3**-1) * (7**-1) * (47**-1)
{-1: 1, 3: -1, 7: -1, 47: -1}

Please see the docstring for ``factorint`` for detailed explanations
and examples of the following keywords:

    - ``limit``: Integer limit up to which trial division is done
    - ``use_trial``: Toggle use of trial division
    - ``use_rho``: Toggle use of Pollard's rho method
    - ``use_pm1``: Toggle use of Pollard's p-1 method
    - ``verbose``: Toggle detailed printing of progress
    - ``multiple``: Toggle returning a list of factors or dict
    - ``visual``: Toggle product form of output
</pre> 
</div>
</div>
<a id="a7a9e77c9fd4340e99aa31b0e6f568f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9e77c9fd4340e99aa31b0e6f568f30">&#9670;&nbsp;</a></span>find_carmichael_numbers_in_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.find_carmichael_numbers_in_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns a list of the number of Carmichael in the range

See Also
========

is_carmichael</pre> 
</div>
</div>
<a id="a10d9f6464ff088f23c9283c8f984e2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d9f6464ff088f23c9283c8f984e2b3">&#9670;&nbsp;</a></span>find_first_n_carmichaels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.find_first_n_carmichaels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns the first n Carmichael numbers.

Parameters
==========

n : Integer

See Also
========

is_carmichael</pre> 
</div>
</div>
<a id="a258af1f0b6d9f2de0fc6a185a85ab346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258af1f0b6d9f2de0fc6a185a85ab346">&#9670;&nbsp;</a></span>is_abundant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.is_abundant </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if ``n`` is an abundant number, else False.

A abundant number is smaller than the sum of its positive proper divisors.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import is_abundant
&gt;&gt;&gt; is_abundant(20)
True
&gt;&gt;&gt; is_abundant(15)
False

References
==========

.. [1] https://mathworld.wolfram.com/AbundantNumber.html</pre> 
</div>
</div>
<a id="a805d1569ad5032ce797994b8798d7ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805d1569ad5032ce797994b8798d7ba1">&#9670;&nbsp;</a></span>is_amicable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.is_amicable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the numbers `m` and `n` are "amicable", else False.

Amicable numbers are two different numbers so related that the sum
of the proper divisors of each is equal to that of the other.

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import divisor_sigma
&gt;&gt;&gt; from sympy.ntheory.factor_ import is_amicable
&gt;&gt;&gt; is_amicable(220, 284)
True
&gt;&gt;&gt; divisor_sigma(220) == divisor_sigma(284)
True

References
==========

.. [1] https://en.wikipedia.org/wiki/Amicable_numbers</pre> 
</div>
</div>
<a id="af6b0daba084d08fc7807b66b36e260a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b0daba084d08fc7807b66b36e260a5">&#9670;&nbsp;</a></span>is_carmichael()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.is_carmichael </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns True if the numbers `n` is Carmichael number, else False.

Parameters
==========

n : Integer

References
==========

.. [1] https://en.wikipedia.org/wiki/Carmichael_number
.. [2] https://oeis.org/A002997</pre> 
</div>
</div>
<a id="a14b7bfed7d056ed72c0620388c92017b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b7bfed7d056ed72c0620388c92017b">&#9670;&nbsp;</a></span>is_deficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.is_deficient </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if ``n`` is a deficient number, else False.

A deficient number is greater than the sum of its positive proper divisors.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import is_deficient
&gt;&gt;&gt; is_deficient(20)
False
&gt;&gt;&gt; is_deficient(15)
True

References
==========

.. [1] https://mathworld.wolfram.com/DeficientNumber.html</pre> 
</div>
</div>
<a id="a3615859080814379023577758b1f0c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3615859080814379023577758b1f0c5b">&#9670;&nbsp;</a></span>is_perfect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.is_perfect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if ``n`` is a perfect number, else False.

A perfect number is equal to the sum of its positive, proper divisors.

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import divisor_sigma
&gt;&gt;&gt; from sympy.ntheory.factor_ import is_perfect, divisors
&gt;&gt;&gt; is_perfect(20)
False
&gt;&gt;&gt; is_perfect(6)
True
&gt;&gt;&gt; 6 == divisor_sigma(6) - 6 == sum(divisors(6)[:-1])
True

References
==========

.. [1] https://mathworld.wolfram.com/PerfectNumber.html
.. [2] https://en.wikipedia.org/wiki/Perfect_number</pre> 
</div>
</div>
<a id="a97e075c84509b2074592a611a5ac00c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e075c84509b2074592a611a5ac00c0">&#9670;&nbsp;</a></span>mersenne_prime_exponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.mersenne_prime_exponent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the exponent ``i`` for the nth Mersenne prime (which
has the form `2^i - 1`).

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import mersenne_prime_exponent
&gt;&gt;&gt; mersenne_prime_exponent(1)
2
&gt;&gt;&gt; mersenne_prime_exponent(20)
4423
</pre> 
</div>
</div>
<a id="afdbddb8d645dc306183926a5e5a20268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbddb8d645dc306183926a5e5a20268">&#9670;&nbsp;</a></span>multiplicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.multiplicity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the greatest integer m such that p**m divides n.

Examples
========

&gt;&gt;&gt; from sympy import multiplicity, Rational
&gt;&gt;&gt; [multiplicity(5, n) for n in [8, 5, 25, 125, 250]]
[0, 1, 2, 3, 3]
&gt;&gt;&gt; multiplicity(3, Rational(1, 9))
-2

Note: when checking for the multiplicity of a number in a
large factorial it is most efficient to send it as an unevaluated
factorial or to call ``multiplicity_in_factorial`` directly:

&gt;&gt;&gt; from sympy.ntheory import multiplicity_in_factorial
&gt;&gt;&gt; from sympy import factorial
&gt;&gt;&gt; p = factorial(25)
&gt;&gt;&gt; n = 2**100
&gt;&gt;&gt; nfac = factorial(n, evaluate=False)
&gt;&gt;&gt; multiplicity(p, nfac)
52818775009509558395695966887
&gt;&gt;&gt; _ == multiplicity_in_factorial(p, n)
True

See Also
========

trailing</pre> 
</div>
</div>
<a id="aaa042833dfd1c848c633fbffa353d889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa042833dfd1c848c633fbffa353d889">&#9670;&nbsp;</a></span>multiplicity_in_factorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.multiplicity_in_factorial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">return the largest integer ``m`` such that ``p**m`` divides ``n!``
without calculating the factorial of ``n``.

Parameters
==========

p : Integer
    positive integer
n : Integer
    non-negative integer

Examples
========

&gt;&gt;&gt; from sympy.ntheory import multiplicity_in_factorial
&gt;&gt;&gt; from sympy import factorial

&gt;&gt;&gt; multiplicity_in_factorial(2, 3)
1

An instructive use of this is to tell how many trailing zeros
a given factorial has. For example, there are 6 in 25!:

&gt;&gt;&gt; factorial(25)
15511210043330985984000000
&gt;&gt;&gt; multiplicity_in_factorial(10, 25)
6

For large factorials, it is much faster/feasible to use
this function rather than computing the actual factorial:

&gt;&gt;&gt; multiplicity_in_factorial(factorial(25), 2**100)
52818775009509558395695966887

See Also
========

multiplicity</pre> 
</div>
</div>
<a id="a21c0883e3f0aaff8839a12e217bd279f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c0883e3f0aaff8839a12e217bd279f">&#9670;&nbsp;</a></span>perfect_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.perfect_power </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>candidates</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>big</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factor</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``(b, e)`` such that ``n`` == ``b**e`` if ``n`` is a unique
perfect power with ``e &gt; 1``, else ``False`` (e.g. 1 is not a
perfect power). A ValueError is raised if ``n`` is not Rational.

By default, the base is recursively decomposed and the exponents
collected so the largest possible ``e`` is sought. If ``big=False``
then the smallest possible ``e`` (thus prime) will be chosen.

If ``factor=True`` then simultaneous factorization of ``n`` is
attempted since finding a factor indicates the only possible root
for ``n``. This is True by default since only a few small factors will
be tested in the course of searching for the perfect power.

The use of ``candidates`` is primarily for internal use; if provided,
False will be returned if ``n`` cannot be written as a power with one
of the candidates as an exponent and factoring (beyond testing for
a factor of 2) will not be attempted.

Examples
========

&gt;&gt;&gt; from sympy import perfect_power, Rational
&gt;&gt;&gt; perfect_power(16)
(2, 4)
&gt;&gt;&gt; perfect_power(16, big=False)
(4, 2)

Negative numbers can only have odd perfect powers:

&gt;&gt;&gt; perfect_power(-4)
False
&gt;&gt;&gt; perfect_power(-8)
(-2, 3)

Rationals are also recognized:

&gt;&gt;&gt; perfect_power(Rational(1, 2)**3)
(1/2, 3)
&gt;&gt;&gt; perfect_power(Rational(-3, 2)**3)
(-3/2, 3)

Notes
=====

To know whether an integer is a perfect power of 2 use

    &gt;&gt;&gt; is2pow = lambda n: bool(n and not n &amp; (n - 1))
    &gt;&gt;&gt; [(i, is2pow(i)) for i in range(5)]
    [(0, False), (1, True), (2, True), (3, False), (4, True)]

It is not necessary to provide ``candidates``. When provided
it will be assumed that they are ints. The first one that is
larger than the computed maximum possible exponent will signal
failure for the routine.

    &gt;&gt;&gt; perfect_power(3**8, [9])
    False
    &gt;&gt;&gt; perfect_power(3**8, [2, 4, 8])
    (3, 8)
    &gt;&gt;&gt; perfect_power(3**8, [4, 8], big=False)
    (9, 4)

See Also
========
sympy.core.intfunc.integer_nthroot
sympy.ntheory.primetest.is_square
</pre> 
</div>
</div>
<a id="a84006e530fd1ff88ee0eb15d5cd63fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84006e530fd1ff88ee0eb15d5cd63fef">&#9670;&nbsp;</a></span>pollard_pm1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.pollard_pm1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>retries</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>1234</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Use Pollard's p-1 method to try to extract a nontrivial factor
of ``n``. Either a divisor (perhaps composite) or ``None`` is returned.

The value of ``a`` is the base that is used in the test gcd(a**M - 1, n).
The default is 2.  If ``retries`` &gt; 0 then if no factor is found after the
first attempt, a new ``a`` will be generated randomly (using the ``seed``)
and the process repeated.

Note: the value of M is lcm(1..B) = reduce(ilcm, range(2, B + 1)).

A search is made for factors next to even numbers having a power smoothness
less than ``B``. Choosing a larger B increases the likelihood of finding a
larger factor but takes longer. Whether a factor of n is found or not
depends on ``a`` and the power smoothness of the even number just less than
the factor p (hence the name p - 1).

Although some discussion of what constitutes a good ``a`` some
descriptions are hard to interpret. At the modular.math site referenced
below it is stated that if gcd(a**M - 1, n) = N then a**M % q**r is 1
for every prime power divisor of N. But consider the following:

    &gt;&gt;&gt; from sympy.ntheory.factor_ import smoothness_p, pollard_pm1
    &gt;&gt;&gt; n=257*1009
    &gt;&gt;&gt; smoothness_p(n)
    (-1, [(257, (1, 2, 256)), (1009, (1, 7, 16))])

So we should (and can) find a root with B=16:

    &gt;&gt;&gt; pollard_pm1(n, B=16, a=3)
    1009

If we attempt to increase B to 256 we find that it does not work:

    &gt;&gt;&gt; pollard_pm1(n, B=256)
    &gt;&gt;&gt;

But if the value of ``a`` is changed we find that only multiples of
257 work, e.g.:

    &gt;&gt;&gt; pollard_pm1(n, B=256, a=257)
    1009

Checking different ``a`` values shows that all the ones that did not
work had a gcd value not equal to ``n`` but equal to one of the
factors:

    &gt;&gt;&gt; from sympy import ilcm, igcd, factorint, Pow
    &gt;&gt;&gt; M = 1
    &gt;&gt;&gt; for i in range(2, 256):
    ...     M = ilcm(M, i)
    ...
    &gt;&gt;&gt; set([igcd(pow(a, M, n) - 1, n) for a in range(2, 256) if
    ...      igcd(pow(a, M, n) - 1, n) != n])
    {1009}

But does aM % d for every divisor of n give 1?

    &gt;&gt;&gt; aM = pow(255, M, n)
    &gt;&gt;&gt; [(d, aM%Pow(*d.args)) for d in factorint(n, visual=True).args]
    [(257**1, 1), (1009**1, 1)]

No, only one of them. So perhaps the principle is that a root will
be found for a given value of B provided that:

1) the power smoothness of the p - 1 value next to the root
   does not exceed B
2) a**M % p != 1 for any of the divisors of n.

By trying more than one ``a`` it is possible that one of them
will yield a factor.

Examples
========

With the default smoothness bound, this number cannot be cracked:

    &gt;&gt;&gt; from sympy.ntheory import pollard_pm1
    &gt;&gt;&gt; pollard_pm1(21477639576571)

Increasing the smoothness bound helps:

    &gt;&gt;&gt; pollard_pm1(21477639576571, B=2000)
    4410317

Looking at the smoothness of the factors of this number we find:

    &gt;&gt;&gt; from sympy.ntheory.factor_ import smoothness_p, factorint
    &gt;&gt;&gt; print(smoothness_p(21477639576571, visual=1))
    p**i=4410317**1 has p-1 B=1787, B-pow=1787
    p**i=4869863**1 has p-1 B=2434931, B-pow=2434931

The B and B-pow are the same for the p - 1 factorizations of the divisors
because those factorizations had a very large prime factor:

    &gt;&gt;&gt; factorint(4410317 - 1)
    {2: 2, 617: 1, 1787: 1}
    &gt;&gt;&gt; factorint(4869863-1)
    {2: 1, 2434931: 1}

Note that until B reaches the B-pow value of 1787, the number is not cracked;

    &gt;&gt;&gt; pollard_pm1(21477639576571, B=1786)
    &gt;&gt;&gt; pollard_pm1(21477639576571, B=1787)
    4410317

The B value has to do with the factors of the number next to the divisor,
not the divisors themselves. A worst case scenario is that the number next
to the factor p has a large prime divisisor or is a perfect power. If these
conditions apply then the power-smoothness will be about p/2 or p. The more
realistic is that there will be a large prime factor next to p requiring
a B value on the order of p/2. Although primes may have been searched for
up to this level, the p/2 is a factor of p - 1, something that we do not
know. The modular.math reference below states that 15% of numbers in the
range of 10**15 to 15**15 + 10**4 are 10**6 power smooth so a B of 10**6
will fail 85% of the time in that range. From 10**8 to 10**8 + 10**3 the
percentages are nearly reversed...but in that range the simple trial
division is quite fast.

References
==========

.. [1] Richard Crandall &amp; Carl Pomerance (2005), "Prime Numbers:
       A Computational Perspective", Springer, 2nd edition, 236-238
.. [2] https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html
.. [3] https://www.cs.toronto.edu/~yuvalf/Factorization.pdf
</pre> 
</div>
</div>
<a id="a9b1b84e473c181a861821a4812c23bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1b84e473c181a861821a4812c23bf5">&#9670;&nbsp;</a></span>pollard_rho()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.pollard_rho </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>retries</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>1234</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_steps</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>F</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Use Pollard's rho method to try to extract a nontrivial factor
of ``n``. The returned factor may be a composite number. If no
factor is found, ``None`` is returned.

The algorithm generates pseudo-random values of x with a generator
function, replacing x with F(x). If F is not supplied then the
function x**2 + ``a`` is used. The first value supplied to F(x) is ``s``.
Upon failure (if ``retries`` is &gt; 0) a new ``a`` and ``s`` will be
supplied; the ``a`` will be ignored if F was supplied.

The sequence of numbers generated by such functions generally have a
a lead-up to some number and then loop around back to that number and
begin to repeat the sequence, e.g. 1, 2, 3, 4, 5, 3, 4, 5 -- this leader
and loop look a bit like the Greek letter rho, and thus the name, 'rho'.

For a given function, very different leader-loop values can be obtained
so it is a good idea to allow for retries:

&gt;&gt;&gt; from sympy.ntheory.generate import cycle_length
&gt;&gt;&gt; n = 16843009
&gt;&gt;&gt; F = lambda x:(2048*pow(x, 2, n) + 32767) % n
&gt;&gt;&gt; for s in range(5):
...     print('loop length = %4i; leader length = %3i' % next(cycle_length(F, s)))
...
loop length = 2489; leader length =  43
loop length =   78; leader length = 121
loop length = 1482; leader length = 100
loop length = 1482; leader length = 286
loop length = 1482; leader length = 101

Here is an explicit example where there is a three element leadup to
a sequence of 3 numbers (11, 14, 4) that then repeat:

&gt;&gt;&gt; x=2
&gt;&gt;&gt; for i in range(9):
...     print(x)
...     x=(x**2+12)%17
...
2
16
13
11
14
4
11
14
4
&gt;&gt;&gt; next(cycle_length(lambda x: (x**2+12)%17, 2))
(3, 3)
&gt;&gt;&gt; list(cycle_length(lambda x: (x**2+12)%17, 2, values=True))
[2, 16, 13, 11, 14, 4]

Instead of checking the differences of all generated values for a gcd
with n, only the kth and 2*kth numbers are checked, e.g. 1st and 2nd,
2nd and 4th, 3rd and 6th until it has been detected that the loop has been
traversed. Loops may be many thousands of steps long before rho finds a
factor or reports failure. If ``max_steps`` is specified, the iteration
is cancelled with a failure after the specified number of steps.

Examples
========

&gt;&gt;&gt; from sympy import pollard_rho
&gt;&gt;&gt; n=16843009
&gt;&gt;&gt; F=lambda x:(2048*pow(x,2,n) + 32767) % n
&gt;&gt;&gt; pollard_rho(n, F=F)
257

Use the default setting with a bad value of ``a`` and no retries:

&gt;&gt;&gt; pollard_rho(n, a=n-2, retries=0)

If retries is &gt; 0 then perhaps the problem will correct itself when
new values are generated for a:

&gt;&gt;&gt; pollard_rho(n, a=n-2, retries=1)
257

References
==========

.. [1] Richard Crandall &amp; Carl Pomerance (2005), "Prime Numbers:
       A Computational Perspective", Springer, 2nd edition, 229-231</pre> 
</div>
</div>
<a id="a03caadb45d631e60f8a19ea5aca64b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03caadb45d631e60f8a19ea5aca64b04">&#9670;&nbsp;</a></span>primefactors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.primefactors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sorted list of n's prime factors, ignoring multiplicity
and any composite factor that remains if the limit was set too low
for complete factorization. Unlike factorint(), primefactors() does
not return -1 or 0.

Parameters
==========

n : integer
limit, verbose, **kwargs :
    Additional keyword arguments to be passed to ``factorint``.
    Since ``kwargs`` is new in version 1.13,
    ``limit`` and ``verbose`` are retained for compatibility purposes.

Returns
=======

list(int) : List of prime numbers dividing ``n``

Examples
========

&gt;&gt;&gt; from sympy.ntheory import primefactors, factorint, isprime
&gt;&gt;&gt; primefactors(6)
[2, 3]
&gt;&gt;&gt; primefactors(-5)
[5]

&gt;&gt;&gt; sorted(factorint(123456).items())
[(2, 6), (3, 1), (643, 1)]
&gt;&gt;&gt; primefactors(123456)
[2, 3, 643]

&gt;&gt;&gt; sorted(factorint(10000000001, limit=200).items())
[(101, 1), (99009901, 1)]
&gt;&gt;&gt; isprime(99009901)
False
&gt;&gt;&gt; primefactors(10000000001, limit=300)
[101]

See Also
========

factorint, divisors</pre> 
</div>
</div>
<a id="a7c079b5184deb9596f8a19ecbdb5fdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c079b5184deb9596f8a19ecbdb5fdf1">&#9670;&nbsp;</a></span>primenu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.primenu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the number of distinct prime factors for a positive integer n.

.. deprecated:: 1.13

    The ``primenu`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.primenu`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

If n's prime factorization is:

.. math ::
    n = \prod_{i=1}^k p_i^{m_i},

then ``primenu(n)`` or `\nu(n)` is:

.. math ::
    \nu(n) = k.

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import primenu
&gt;&gt;&gt; primenu(1)
0
&gt;&gt;&gt; primenu(30)
3

See Also
========

factorint

References
==========

.. [1] https://mathworld.wolfram.com/PrimeFactor.html</pre> 
</div>
</div>
<a id="a5e9e37de8c9577fe896174ee23474fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9e37de8c9577fe896174ee23474fe5">&#9670;&nbsp;</a></span>primeomega()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.primeomega </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the number of prime factors counting multiplicities for a
positive integer n.

.. deprecated:: 1.13

    The ``primeomega`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.primeomega`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

If n's prime factorization is:

.. math ::
    n = \prod_{i=1}^k p_i^{m_i},

then ``primeomega(n)``  or `\Omega(n)` is:

.. math ::
    \Omega(n) = \sum_{i=1}^k m_i.

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import primeomega
&gt;&gt;&gt; primeomega(1)
0
&gt;&gt;&gt; primeomega(20)
3

See Also
========

factorint

References
==========

.. [1] https://mathworld.wolfram.com/PrimeFactor.html</pre> 
</div>
</div>
<a id="ab05701c46806227834bf07695a10a0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05701c46806227834bf07695a10a0f6">&#9670;&nbsp;</a></span>proper_divisor_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.proper_divisor_count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>modulus</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of proper divisors of ``n``.

Examples
========

&gt;&gt;&gt; from sympy import proper_divisor_count
&gt;&gt;&gt; proper_divisor_count(6)
3
&gt;&gt;&gt; proper_divisor_count(6, modulus=2)
1

See Also
========

divisors, proper_divisors, divisor_count</pre> 
</div>
</div>
<a id="aa6fdd96724122af24d343c1f573eb268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fdd96724122af24d343c1f573eb268">&#9670;&nbsp;</a></span>proper_divisors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.proper_divisors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>generator</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return all divisors of n except n, sorted by default.
If generator is ``True`` an unordered generator is returned.

Examples
========

&gt;&gt;&gt; from sympy import proper_divisors, proper_divisor_count
&gt;&gt;&gt; proper_divisors(24)
[1, 2, 3, 4, 6, 8, 12]
&gt;&gt;&gt; proper_divisor_count(24)
7
&gt;&gt;&gt; list(proper_divisors(120, generator=True))
[1, 2, 4, 8, 3, 6, 12, 24, 5, 10, 20, 40, 15, 30, 60]

See Also
========

factorint, divisors, proper_divisor_count</pre> 
</div>
</div>
<a id="a3ff5822c0b0320f4b14d2aed3f856b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff5822c0b0320f4b14d2aed3f856b9a">&#9670;&nbsp;</a></span>reduced_totient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.reduced_totient </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the Carmichael reduced totient function lambda(n)

.. deprecated:: 1.13

    The ``reduced_totient`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.reduced_totient`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

``reduced_totient(n)`` or `\lambda(n)` is the smallest m &gt; 0 such that
`k^m \equiv 1 \mod n` for all k relatively prime to n.

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import reduced_totient
&gt;&gt;&gt; reduced_totient(1)
1
&gt;&gt;&gt; reduced_totient(8)
2
&gt;&gt;&gt; reduced_totient(30)
4

See Also
========

totient

References
==========

.. [1] https://en.wikipedia.org/wiki/Carmichael_function
.. [2] https://mathworld.wolfram.com/CarmichaelFunction.html</pre> 
</div>
</div>
<a id="a8e610ad5f7802ea011d2fc4cb0b59942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e610ad5f7802ea011d2fc4cb0b59942">&#9670;&nbsp;</a></span>smoothness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.smoothness </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the B-smooth and B-power smooth values of n.

The smoothness of n is the largest prime factor of n; the power-
smoothness is the largest divisor raised to its multiplicity.

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import smoothness
&gt;&gt;&gt; smoothness(2**7*3**2)
(3, 128)
&gt;&gt;&gt; smoothness(2**4*13)
(13, 16)
&gt;&gt;&gt; smoothness(2)
(2, 2)

See Also
========

factorint, smoothness_p
</pre> 
</div>
</div>
<a id="a018867189444f6dac899e369a41f2def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018867189444f6dac899e369a41f2def">&#9670;&nbsp;</a></span>smoothness_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.smoothness_p </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>power</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>visual</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of [m, (p, (M, sm(p + m), psm(p + m)))...]
where:

1. p**M is the base-p divisor of n
2. sm(p + m) is the smoothness of p + m (m = -1 by default)
3. psm(p + m) is the power smoothness of p + m

The list is sorted according to smoothness (default) or by power smoothness
if power=1.

The smoothness of the numbers to the left (m = -1) or right (m = 1) of a
factor govern the results that are obtained from the p +/- 1 type factoring
methods.

    &gt;&gt;&gt; from sympy.ntheory.factor_ import smoothness_p, factorint
    &gt;&gt;&gt; smoothness_p(10431, m=1)
    (1, [(3, (2, 2, 4)), (19, (1, 5, 5)), (61, (1, 31, 31))])
    &gt;&gt;&gt; smoothness_p(10431)
    (-1, [(3, (2, 2, 2)), (19, (1, 3, 9)), (61, (1, 5, 5))])
    &gt;&gt;&gt; smoothness_p(10431, power=1)
    (-1, [(3, (2, 2, 2)), (61, (1, 5, 5)), (19, (1, 3, 9))])

If visual=True then an annotated string will be returned:

    &gt;&gt;&gt; print(smoothness_p(21477639576571, visual=1))
    p**i=4410317**1 has p-1 B=1787, B-pow=1787
    p**i=4869863**1 has p-1 B=2434931, B-pow=2434931

This string can also be generated directly from a factorization dictionary
and vice versa:

    &gt;&gt;&gt; factorint(17*9)
    {3: 2, 17: 1}
    &gt;&gt;&gt; smoothness_p(_)
    'p**i=3**2 has p-1 B=2, B-pow=2\\np**i=17**1 has p-1 B=2, B-pow=16'
    &gt;&gt;&gt; smoothness_p(_)
    {3: 2, 17: 1}

The table of the output logic is:

    ====== ====== ======= =======
    |              Visual
    ------ ----------------------
    Input  True   False   other
    ====== ====== ======= =======
    dict    str    tuple   str
    str     str    tuple   dict
    tuple   str    tuple   str
    n       str    tuple   tuple
    mul     str    tuple   tuple
    ====== ====== ======= =======

See Also
========

factorint, smoothness
</pre> 
</div>
</div>
<a id="a732ce72ee3e0ed02c8293a36637990e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732ce72ee3e0ed02c8293a36637990e1">&#9670;&nbsp;</a></span>totient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.totient </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the Euler totient function phi(n)

.. deprecated:: 1.13

    The ``totient`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.totient`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

``totient(n)`` or `\phi(n)` is the number of positive integers `\leq` n
that are relatively prime to n.

Parameters
==========

n : integer

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import totient
&gt;&gt;&gt; totient(1)
1
&gt;&gt;&gt; totient(25)
20
&gt;&gt;&gt; totient(45) == totient(5)*totient(9)
True

See Also
========

divisor_count

References
==========

.. [1] https://en.wikipedia.org/wiki/Euler%27s_totient_function
.. [2] https://mathworld.wolfram.com/TotientFunction.html</pre> 
</div>
</div>
<a id="a89fb8b7bb95f4f4a5a3f36e699857831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fb8b7bb95f4f4a5a3f36e699857831">&#9670;&nbsp;</a></span>udivisor_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.udivisor_count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of unitary divisors of ``n``.

Parameters
==========

n : integer

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import udivisor_count
&gt;&gt;&gt; udivisor_count(120)
8

See Also
========

factorint, divisors, udivisors, divisor_count, totient

References
==========

.. [1] https://mathworld.wolfram.com/UnitaryDivisorFunction.html</pre> 
</div>
</div>
<a id="ac8f17b4724fab08c97f8f60eec2a2685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f17b4724fab08c97f8f60eec2a2685">&#9670;&nbsp;</a></span>udivisor_sigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.udivisor_sigma </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the unitary divisor function `\sigma_k^*(n)` for positive integer n

.. deprecated:: 1.13

    The ``udivisor_sigma`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.udivisor_sigma`
    instead. See its documentation for more information. See
    :ref:`deprecated-ntheory-symbolic-functions` for details.

``udivisor_sigma(n, k)`` is equal to ``sum([x**k for x in udivisors(n)])``

If n's prime factorization is:

.. math ::
    n = \prod_{i=1}^\omega p_i^{m_i},

then

.. math ::
    \sigma_k^*(n) = \prod_{i=1}^\omega (1+ p_i^{m_ik}).

Parameters
==========

k : power of divisors in the sum

    for k = 0, 1:
    ``udivisor_sigma(n, 0)`` is equal to ``udivisor_count(n)``
    ``udivisor_sigma(n, 1)`` is equal to ``sum(udivisors(n))``

    Default for k is 1.

Examples
========

&gt;&gt;&gt; from sympy.functions.combinatorial.numbers import udivisor_sigma
&gt;&gt;&gt; udivisor_sigma(18, 0)
4
&gt;&gt;&gt; udivisor_sigma(74, 1)
114
&gt;&gt;&gt; udivisor_sigma(36, 3)
47450
&gt;&gt;&gt; udivisor_sigma(111)
152

See Also
========

divisor_count, totient, divisors, udivisors, udivisor_count, divisor_sigma,
factorint

References
==========

.. [1] https://mathworld.wolfram.com/UnitaryDivisorFunction.html</pre> 
</div>
</div>
<a id="a2d2327b076d65cf273145355157ac9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2327b076d65cf273145355157ac9ea">&#9670;&nbsp;</a></span>udivisors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.ntheory.factor_.udivisors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>generator</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return all unitary divisors of n sorted from 1..n by default.
If generator is ``True`` an unordered generator is returned.

The number of unitary divisors of n can be quite large if there are many
prime factors. If only the number of unitary divisors is desired use
udivisor_count(n).

Examples
========

&gt;&gt;&gt; from sympy.ntheory.factor_ import udivisors, udivisor_count
&gt;&gt;&gt; udivisors(15)
[1, 3, 5, 15]
&gt;&gt;&gt; udivisor_count(15)
4

&gt;&gt;&gt; sorted(udivisors(120, generator=True))
[1, 3, 5, 8, 15, 24, 40, 120]

See Also
========

primefactors, factorint, divisors, divisor_count, udivisor_count

References
==========

.. [1] https://en.wikipedia.org/wiki/Unitary_divisor
.. [2] https://mathworld.wolfram.com/UnitaryDivisor.html</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7ed8f827f9bdd6cf536124f52e5cd304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed8f827f9bdd6cf536124f52e5cd304">&#9670;&nbsp;</a></span>complete_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string sympy.ntheory.factor_.complete_msg = 'Factorization is complete.'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0793622e325faa829c3f02814ce504b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0793622e325faa829c3f02814ce504b3">&#9670;&nbsp;</a></span>ecm_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string sympy.ntheory.factor_.ecm_msg = &quot;Elliptic <a class="el" href="classsympy_1_1geometry_1_1curve_1_1Curve.html">Curve</a> with B1 bound %i, B2 bound %i, num_curves %i&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd79e91b7f2bbf4abcb5c693032d558c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd79e91b7f2bbf4abcb5c693032d558c">&#9670;&nbsp;</a></span>factor_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string sympy.ntheory.factor_.factor_msg = '\t%i ** %i'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a165ed32e673dbac47b23146e199cfb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165ed32e673dbac47b23146e199cfb0e">&#9670;&nbsp;</a></span>fermat_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string sympy.ntheory.factor_.fermat_msg = 'Close factors satisying Fermat condition found.'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe03bfd1fb0606a3ca958d6a168a8f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe03bfd1fb0606a3ca958d6a168a8f81">&#9670;&nbsp;</a></span>pm1_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string sympy.ntheory.factor_.pm1_msg = &quot;Pollard's p-1 with <a class="el" href="namespacesympy_1_1ntheory_1_1factor__.html#a8e610ad5f7802ea011d2fc4cb0b59942">smoothness</a> bound %i and seed %i&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa70384238f79926a461c5bc16aaa3b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70384238f79926a461c5bc16aaa3b8f">&#9670;&nbsp;</a></span>rho_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string sympy.ntheory.factor_.rho_msg = &quot;Pollard's rho with retries %i, max_steps %i and seed %i&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7bedd789a619274847d45ae12dd7a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bedd789a619274847d45ae12dd7a29">&#9670;&nbsp;</a></span>trial_int_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string sympy.ntheory.factor_.trial_int_msg = &quot;Trial division with ints [%i ... %i] and fail_max=%i&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf7c75d944d44da94b50962b9fdd7f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7c75d944d44da94b50962b9fdd7f88">&#9670;&nbsp;</a></span>trial_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string sympy.ntheory.factor_.trial_msg = &quot;Trial division with primes [%i ... %i]&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
