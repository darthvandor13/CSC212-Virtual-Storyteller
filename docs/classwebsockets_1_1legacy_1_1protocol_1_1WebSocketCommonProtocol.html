<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: websockets.legacy.protocol.WebSocketCommonProtocol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewebsockets.html">websockets</a></li><li class="navelem"><a class="el" href="namespacewebsockets_1_1legacy.html">legacy</a></li><li class="navelem"><a class="el" href="namespacewebsockets_1_1legacy_1_1protocol.html">protocol</a></li><li class="navelem"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html">WebSocketCommonProtocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">websockets.legacy.protocol.WebSocketCommonProtocol Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for websockets.legacy.protocol.WebSocketCommonProtocol:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol__inherit__graph.png" border="0" usemap="#awebsockets_8legacy_8protocol_8WebSocketCommonProtocol_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for websockets.legacy.protocol.WebSocketCommonProtocol:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol__coll__graph.png" border="0" usemap="#awebsockets_8legacy_8protocol_8WebSocketCommonProtocol_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a24e557bbfc786f68b3e5714962dd70e4"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a24e557bbfc786f68b3e5714962dd70e4">__init__</a> (self, *LoggerLike|None logger=None, float|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae44cfcae3e52105d2abf638b8913d30d">ping_interval</a>=20, float|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a15e2df1d741aaf84eb8aff18e2242441">ping_timeout</a>=20, float|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a66fdf2c1fccc0c99ad47e517f5f40839">close_timeout</a>=None, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a8a18b02f4e2e35da3462d2876d38a72b">max_size</a>=2 **20, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ade76d0e9021caf7a6373948a7a1c9042">max_queue</a>=2 **5, int <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a17a59c2a80e467c0370a304b8ac3c32c">read_limit</a>=2 **16, int <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a930f01b4d89fc6946b8e79e455f6fdac">write_limit</a>=2 **16, <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a>|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a7610c6eb8c8fe7ebb03424aa7c2d8966">host</a>=None, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#af2784c9b87aba34d6254a03361b0c4b0">port</a>=None, bool|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ad58a69fed90d91f67e2b4872f251f2b9">secure</a>=None, bool <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a45668ae9194cdb9060c2fc2a6d9474e2">legacy_recv</a>=False, asyncio.AbstractEventLoop|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a97a81b2b0626245f973f2e8cc73cb903">loop</a>=None, float|None timeout=None)</td></tr>
<tr class="separator:a24e557bbfc786f68b3e5714962dd70e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84455422ed747abc2313be6138a87c5f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a84455422ed747abc2313be6138a87c5f">connection_open</a> (self)</td></tr>
<tr class="separator:a84455422ed747abc2313be6138a87c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7610c6eb8c8fe7ebb03424aa7c2d8966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a7610c6eb8c8fe7ebb03424aa7c2d8966">host</a> (self)</td></tr>
<tr class="separator:a7610c6eb8c8fe7ebb03424aa7c2d8966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2784c9b87aba34d6254a03361b0c4b0"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#af2784c9b87aba34d6254a03361b0c4b0">port</a> (self)</td></tr>
<tr class="separator:af2784c9b87aba34d6254a03361b0c4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58a69fed90d91f67e2b4872f251f2b9"><td class="memItemLeft" align="right" valign="top">bool|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ad58a69fed90d91f67e2b4872f251f2b9">secure</a> (self)</td></tr>
<tr class="separator:ad58a69fed90d91f67e2b4872f251f2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90aaadbdb48e66440599f96f305c161"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac90aaadbdb48e66440599f96f305c161">local_address</a> (self)</td></tr>
<tr class="separator:ac90aaadbdb48e66440599f96f305c161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf996533f4b7b30d37d1909c83d676"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a9dbf996533f4b7b30d37d1909c83d676">remote_address</a> (self)</td></tr>
<tr class="separator:a9dbf996533f4b7b30d37d1909c83d676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d29b6fb0452130aa5404c50eb57044"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#af2d29b6fb0452130aa5404c50eb57044">open</a> (self)</td></tr>
<tr class="separator:af2d29b6fb0452130aa5404c50eb57044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90d097c978aea651f3a9f8805c81bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac90d097c978aea651f3a9f8805c81bf3">closed</a> (self)</td></tr>
<tr class="separator:ac90d097c978aea651f3a9f8805c81bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5376765011b733422126011375bfa1"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#aaf5376765011b733422126011375bfa1">close_code</a> (self)</td></tr>
<tr class="separator:aaf5376765011b733422126011375bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f79a65844f4c5c444371b8f1288aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a71f79a65844f4c5c444371b8f1288aac">close_reason</a> (self)</td></tr>
<tr class="separator:a71f79a65844f4c5c444371b8f1288aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac646be31cd26b87bd76fbaf34d19a130"><td class="memItemLeft" align="right" valign="top">AsyncIterator[Data]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac646be31cd26b87bd76fbaf34d19a130">__aiter__</a> (self)</td></tr>
<tr class="separator:ac646be31cd26b87bd76fbaf34d19a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204cda1c777ce1fc1a099d1a1c56880c"><td class="memItemLeft" align="right" valign="top">Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a204cda1c777ce1fc1a099d1a1c56880c">recv</a> (self)</td></tr>
<tr class="separator:a204cda1c777ce1fc1a099d1a1c56880c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3e69e7be36cd7d6e18ffb619f0bff9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a1e3e69e7be36cd7d6e18ffb619f0bff9">send</a> (self, Data|Iterable[Data]|AsyncIterable[Data] message)</td></tr>
<tr class="separator:a1e3e69e7be36cd7d6e18ffb619f0bff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9736dd62f6e54f5b4c5ac8e5044a2d41"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a9736dd62f6e54f5b4c5ac8e5044a2d41">close</a> (self, int code=<a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#af4e8be37b7ef43e1d1b3a8d105f0ed48">CloseCode.NORMAL_CLOSURE</a>, <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> reason=&quot;&quot;)</td></tr>
<tr class="separator:a9736dd62f6e54f5b4c5ac8e5044a2d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8153b1f616fbc30c55f909b136836a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a1b8153b1f616fbc30c55f909b136836a">wait_closed</a> (self)</td></tr>
<tr class="separator:a1b8153b1f616fbc30c55f909b136836a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ebad887bddcd4b733a80401594d9c1"><td class="memItemLeft" align="right" valign="top">Awaitable[float]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae6ebad887bddcd4b733a80401594d9c1">ping</a> (self, Data|None data=None)</td></tr>
<tr class="separator:ae6ebad887bddcd4b733a80401594d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351ae54b7c302671ec2397214c9b118a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a351ae54b7c302671ec2397214c9b118a">pong</a> (self, Data data=b&quot;&quot;)</td></tr>
<tr class="separator:a351ae54b7c302671ec2397214c9b118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e68b98ff68e5de797c11147b8a3657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1exceptions_1_1ConnectionClosed.html">ConnectionClosed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#af7e68b98ff68e5de797c11147b8a3657">connection_closed_exc</a> (self)</td></tr>
<tr class="separator:af7e68b98ff68e5de797c11147b8a3657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfc82dc3bdf4b6aa1cd7dd4a12290a3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a6dfc82dc3bdf4b6aa1cd7dd4a12290a3">ensure_open</a> (self)</td></tr>
<tr class="separator:a6dfc82dc3bdf4b6aa1cd7dd4a12290a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e0c1738444d6bd1de5f321a0356e3d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a00e0c1738444d6bd1de5f321a0356e3d">transfer_data</a> (self)</td></tr>
<tr class="separator:a00e0c1738444d6bd1de5f321a0356e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e51f72e4bf12d032bbbb068bcce3ee4"><td class="memItemLeft" align="right" valign="top">Data|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a7e51f72e4bf12d032bbbb068bcce3ee4">read_message</a> (self)</td></tr>
<tr class="separator:a7e51f72e4bf12d032bbbb068bcce3ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bf9e5d805d0072affc6eb534d72fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1legacy_1_1framing_1_1Frame.html">Frame</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a54bf9e5d805d0072affc6eb534d72fc7">read_data_frame</a> (self, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a8a18b02f4e2e35da3462d2876d38a72b">max_size</a>)</td></tr>
<tr class="separator:a54bf9e5d805d0072affc6eb534d72fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988314cb1640b8ddbfc71165945265bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1legacy_1_1framing_1_1Frame.html">Frame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a988314cb1640b8ddbfc71165945265bc">read_frame</a> (self, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a8a18b02f4e2e35da3462d2876d38a72b">max_size</a>)</td></tr>
<tr class="separator:a988314cb1640b8ddbfc71165945265bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36537e16d6dedaed78d19c33ca8474b"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ad36537e16d6dedaed78d19c33ca8474b">write_frame_sync</a> (self, bool fin, int opcode, bytes data)</td></tr>
<tr class="separator:ad36537e16d6dedaed78d19c33ca8474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d159c6a35ca97a0bca60ea73f80d0a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a49d159c6a35ca97a0bca60ea73f80d0a">drain</a> (self)</td></tr>
<tr class="separator:a49d159c6a35ca97a0bca60ea73f80d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf17cdf53fae8a12f9df3521563e97a6"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#adf17cdf53fae8a12f9df3521563e97a6">write_frame</a> (self, bool fin, int opcode, bytes data, *int _state=<a class="el" href="classwebsockets_1_1protocol_1_1State.html#a3130411fdfdb2b56c4916d8c7209ce1e">State.OPEN</a>)</td></tr>
<tr class="separator:adf17cdf53fae8a12f9df3521563e97a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cc1e33aba0b97e031877b25f0f11bd"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a53cc1e33aba0b97e031877b25f0f11bd">write_close_frame</a> (self, <a class="el" href="classwebsockets_1_1frames_1_1Close.html">Close</a> <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a9736dd62f6e54f5b4c5ac8e5044a2d41">close</a>, bytes|None data=None)</td></tr>
<tr class="separator:a53cc1e33aba0b97e031877b25f0f11bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15b54c81067e7533c50bb08258098d0"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac15b54c81067e7533c50bb08258098d0">keepalive_ping</a> (self)</td></tr>
<tr class="separator:ac15b54c81067e7533c50bb08258098d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3a7b3767714657479530afadc6a63"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a9da3a7b3767714657479530afadc6a63">close_connection</a> (self)</td></tr>
<tr class="separator:a9da3a7b3767714657479530afadc6a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117567b78496f9c1a5de4e29fea111a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a7117567b78496f9c1a5de4e29fea111a">close_transport</a> (self)</td></tr>
<tr class="separator:a7117567b78496f9c1a5de4e29fea111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd51bf6ff7f8f3c578059ad0dd014c88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#acd51bf6ff7f8f3c578059ad0dd014c88">wait_for_connection_lost</a> (self)</td></tr>
<tr class="separator:acd51bf6ff7f8f3c578059ad0dd014c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60961832bfe8821c6dd5ce88d75b37d1"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a60961832bfe8821c6dd5ce88d75b37d1">fail_connection</a> (self, int code=<a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#a8870ac2858ee74d48598c9b58eff1667">CloseCode.ABNORMAL_CLOSURE</a>, <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> reason=&quot;&quot;)</td></tr>
<tr class="separator:a60961832bfe8821c6dd5ce88d75b37d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe3cf4dc28c519bf3ac65c3addba3e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a76fe3cf4dc28c519bf3ac65c3addba3e">abort_pings</a> (self)</td></tr>
<tr class="separator:a76fe3cf4dc28c519bf3ac65c3addba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983288e761fc1602e126140fe1fdad4e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a983288e761fc1602e126140fe1fdad4e">connection_made</a> (self, asyncio.BaseTransport <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a3a7471413a8e11166b1dcf432b22dae9">transport</a>)</td></tr>
<tr class="separator:a983288e761fc1602e126140fe1fdad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2613175a26be2de8ab6f4f7bb62d3df"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae2613175a26be2de8ab6f4f7bb62d3df">connection_lost</a> (self, Exception|None exc)</td></tr>
<tr class="separator:ae2613175a26be2de8ab6f4f7bb62d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347bd8cfa89ea853a2da046f733d6683"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a347bd8cfa89ea853a2da046f733d6683">pause_writing</a> (self)</td></tr>
<tr class="separator:a347bd8cfa89ea853a2da046f733d6683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24f2bb19345e6f3de5e7f056baa88e0"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ad24f2bb19345e6f3de5e7f056baa88e0">resume_writing</a> (self)</td></tr>
<tr class="separator:ad24f2bb19345e6f3de5e7f056baa88e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee68ef0fb534b8b4c77f0cc69269140"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#aeee68ef0fb534b8b4c77f0cc69269140">data_received</a> (self, bytes data)</td></tr>
<tr class="separator:aeee68ef0fb534b8b4c77f0cc69269140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390525e7d67ee7296d0b6d3e7a0e7d9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ab390525e7d67ee7296d0b6d3e7a0e7d9">eof_received</a> (self)</td></tr>
<tr class="separator:ab390525e7d67ee7296d0b6d3e7a0e7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e557bbfc786f68b3e5714962dd70e4"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a24e557bbfc786f68b3e5714962dd70e4">__init__</a> (self, *LoggerLike|None logger=None, float|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae44cfcae3e52105d2abf638b8913d30d">ping_interval</a>=20, float|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a15e2df1d741aaf84eb8aff18e2242441">ping_timeout</a>=20, float|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a66fdf2c1fccc0c99ad47e517f5f40839">close_timeout</a>=None, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a8a18b02f4e2e35da3462d2876d38a72b">max_size</a>=2 **20, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ade76d0e9021caf7a6373948a7a1c9042">max_queue</a>=2 **5, int <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a17a59c2a80e467c0370a304b8ac3c32c">read_limit</a>=2 **16, int <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a930f01b4d89fc6946b8e79e455f6fdac">write_limit</a>=2 **16, <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a>|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a7610c6eb8c8fe7ebb03424aa7c2d8966">host</a>=None, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#af2784c9b87aba34d6254a03361b0c4b0">port</a>=None, bool|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ad58a69fed90d91f67e2b4872f251f2b9">secure</a>=None, bool <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a45668ae9194cdb9060c2fc2a6d9474e2">legacy_recv</a>=False, asyncio.AbstractEventLoop|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a97a81b2b0626245f973f2e8cc73cb903">loop</a>=None, float|None timeout=None)</td></tr>
<tr class="separator:a24e557bbfc786f68b3e5714962dd70e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84455422ed747abc2313be6138a87c5f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a84455422ed747abc2313be6138a87c5f">connection_open</a> (self)</td></tr>
<tr class="separator:a84455422ed747abc2313be6138a87c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7610c6eb8c8fe7ebb03424aa7c2d8966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a7610c6eb8c8fe7ebb03424aa7c2d8966">host</a> (self)</td></tr>
<tr class="separator:a7610c6eb8c8fe7ebb03424aa7c2d8966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2784c9b87aba34d6254a03361b0c4b0"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#af2784c9b87aba34d6254a03361b0c4b0">port</a> (self)</td></tr>
<tr class="separator:af2784c9b87aba34d6254a03361b0c4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58a69fed90d91f67e2b4872f251f2b9"><td class="memItemLeft" align="right" valign="top">bool|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ad58a69fed90d91f67e2b4872f251f2b9">secure</a> (self)</td></tr>
<tr class="separator:ad58a69fed90d91f67e2b4872f251f2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90aaadbdb48e66440599f96f305c161"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac90aaadbdb48e66440599f96f305c161">local_address</a> (self)</td></tr>
<tr class="separator:ac90aaadbdb48e66440599f96f305c161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf996533f4b7b30d37d1909c83d676"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a9dbf996533f4b7b30d37d1909c83d676">remote_address</a> (self)</td></tr>
<tr class="separator:a9dbf996533f4b7b30d37d1909c83d676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d29b6fb0452130aa5404c50eb57044"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#af2d29b6fb0452130aa5404c50eb57044">open</a> (self)</td></tr>
<tr class="separator:af2d29b6fb0452130aa5404c50eb57044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90d097c978aea651f3a9f8805c81bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac90d097c978aea651f3a9f8805c81bf3">closed</a> (self)</td></tr>
<tr class="separator:ac90d097c978aea651f3a9f8805c81bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5376765011b733422126011375bfa1"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#aaf5376765011b733422126011375bfa1">close_code</a> (self)</td></tr>
<tr class="separator:aaf5376765011b733422126011375bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f79a65844f4c5c444371b8f1288aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a71f79a65844f4c5c444371b8f1288aac">close_reason</a> (self)</td></tr>
<tr class="separator:a71f79a65844f4c5c444371b8f1288aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac646be31cd26b87bd76fbaf34d19a130"><td class="memItemLeft" align="right" valign="top">AsyncIterator[Data]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac646be31cd26b87bd76fbaf34d19a130">__aiter__</a> (self)</td></tr>
<tr class="separator:ac646be31cd26b87bd76fbaf34d19a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204cda1c777ce1fc1a099d1a1c56880c"><td class="memItemLeft" align="right" valign="top">Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a204cda1c777ce1fc1a099d1a1c56880c">recv</a> (self)</td></tr>
<tr class="separator:a204cda1c777ce1fc1a099d1a1c56880c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3e69e7be36cd7d6e18ffb619f0bff9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a1e3e69e7be36cd7d6e18ffb619f0bff9">send</a> (self, Data|Iterable[Data]|AsyncIterable[Data] message)</td></tr>
<tr class="separator:a1e3e69e7be36cd7d6e18ffb619f0bff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9736dd62f6e54f5b4c5ac8e5044a2d41"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a9736dd62f6e54f5b4c5ac8e5044a2d41">close</a> (self, int code=<a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#af4e8be37b7ef43e1d1b3a8d105f0ed48">CloseCode.NORMAL_CLOSURE</a>, <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> reason=&quot;&quot;)</td></tr>
<tr class="separator:a9736dd62f6e54f5b4c5ac8e5044a2d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8153b1f616fbc30c55f909b136836a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a1b8153b1f616fbc30c55f909b136836a">wait_closed</a> (self)</td></tr>
<tr class="separator:a1b8153b1f616fbc30c55f909b136836a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ebad887bddcd4b733a80401594d9c1"><td class="memItemLeft" align="right" valign="top">Awaitable[float]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae6ebad887bddcd4b733a80401594d9c1">ping</a> (self, Data|None data=None)</td></tr>
<tr class="separator:ae6ebad887bddcd4b733a80401594d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351ae54b7c302671ec2397214c9b118a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a351ae54b7c302671ec2397214c9b118a">pong</a> (self, Data data=b&quot;&quot;)</td></tr>
<tr class="separator:a351ae54b7c302671ec2397214c9b118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e68b98ff68e5de797c11147b8a3657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1exceptions_1_1ConnectionClosed.html">ConnectionClosed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#af7e68b98ff68e5de797c11147b8a3657">connection_closed_exc</a> (self)</td></tr>
<tr class="separator:af7e68b98ff68e5de797c11147b8a3657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfc82dc3bdf4b6aa1cd7dd4a12290a3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a6dfc82dc3bdf4b6aa1cd7dd4a12290a3">ensure_open</a> (self)</td></tr>
<tr class="separator:a6dfc82dc3bdf4b6aa1cd7dd4a12290a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e0c1738444d6bd1de5f321a0356e3d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a00e0c1738444d6bd1de5f321a0356e3d">transfer_data</a> (self)</td></tr>
<tr class="separator:a00e0c1738444d6bd1de5f321a0356e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e51f72e4bf12d032bbbb068bcce3ee4"><td class="memItemLeft" align="right" valign="top">Data|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a7e51f72e4bf12d032bbbb068bcce3ee4">read_message</a> (self)</td></tr>
<tr class="separator:a7e51f72e4bf12d032bbbb068bcce3ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bf9e5d805d0072affc6eb534d72fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1legacy_1_1framing_1_1Frame.html">Frame</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a54bf9e5d805d0072affc6eb534d72fc7">read_data_frame</a> (self, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a8a18b02f4e2e35da3462d2876d38a72b">max_size</a>)</td></tr>
<tr class="separator:a54bf9e5d805d0072affc6eb534d72fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988314cb1640b8ddbfc71165945265bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsockets_1_1legacy_1_1framing_1_1Frame.html">Frame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a988314cb1640b8ddbfc71165945265bc">read_frame</a> (self, int|None <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a8a18b02f4e2e35da3462d2876d38a72b">max_size</a>)</td></tr>
<tr class="separator:a988314cb1640b8ddbfc71165945265bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36537e16d6dedaed78d19c33ca8474b"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ad36537e16d6dedaed78d19c33ca8474b">write_frame_sync</a> (self, bool fin, int opcode, bytes data)</td></tr>
<tr class="separator:ad36537e16d6dedaed78d19c33ca8474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d159c6a35ca97a0bca60ea73f80d0a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a49d159c6a35ca97a0bca60ea73f80d0a">drain</a> (self)</td></tr>
<tr class="separator:a49d159c6a35ca97a0bca60ea73f80d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf17cdf53fae8a12f9df3521563e97a6"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#adf17cdf53fae8a12f9df3521563e97a6">write_frame</a> (self, bool fin, int opcode, bytes data, *int _state=<a class="el" href="classwebsockets_1_1protocol_1_1State.html#a3130411fdfdb2b56c4916d8c7209ce1e">State.OPEN</a>)</td></tr>
<tr class="separator:adf17cdf53fae8a12f9df3521563e97a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cc1e33aba0b97e031877b25f0f11bd"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a53cc1e33aba0b97e031877b25f0f11bd">write_close_frame</a> (self, <a class="el" href="classwebsockets_1_1frames_1_1Close.html">Close</a> <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a9736dd62f6e54f5b4c5ac8e5044a2d41">close</a>, bytes|None data=None)</td></tr>
<tr class="separator:a53cc1e33aba0b97e031877b25f0f11bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15b54c81067e7533c50bb08258098d0"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac15b54c81067e7533c50bb08258098d0">keepalive_ping</a> (self)</td></tr>
<tr class="separator:ac15b54c81067e7533c50bb08258098d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3a7b3767714657479530afadc6a63"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a9da3a7b3767714657479530afadc6a63">close_connection</a> (self)</td></tr>
<tr class="separator:a9da3a7b3767714657479530afadc6a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117567b78496f9c1a5de4e29fea111a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a7117567b78496f9c1a5de4e29fea111a">close_transport</a> (self)</td></tr>
<tr class="separator:a7117567b78496f9c1a5de4e29fea111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd51bf6ff7f8f3c578059ad0dd014c88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#acd51bf6ff7f8f3c578059ad0dd014c88">wait_for_connection_lost</a> (self)</td></tr>
<tr class="separator:acd51bf6ff7f8f3c578059ad0dd014c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60961832bfe8821c6dd5ce88d75b37d1"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a60961832bfe8821c6dd5ce88d75b37d1">fail_connection</a> (self, int code=<a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#a8870ac2858ee74d48598c9b58eff1667">CloseCode.ABNORMAL_CLOSURE</a>, <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> reason=&quot;&quot;)</td></tr>
<tr class="separator:a60961832bfe8821c6dd5ce88d75b37d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe3cf4dc28c519bf3ac65c3addba3e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a76fe3cf4dc28c519bf3ac65c3addba3e">abort_pings</a> (self)</td></tr>
<tr class="separator:a76fe3cf4dc28c519bf3ac65c3addba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983288e761fc1602e126140fe1fdad4e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a983288e761fc1602e126140fe1fdad4e">connection_made</a> (self, asyncio.BaseTransport <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a3a7471413a8e11166b1dcf432b22dae9">transport</a>)</td></tr>
<tr class="separator:a983288e761fc1602e126140fe1fdad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2613175a26be2de8ab6f4f7bb62d3df"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae2613175a26be2de8ab6f4f7bb62d3df">connection_lost</a> (self, Exception|None exc)</td></tr>
<tr class="separator:ae2613175a26be2de8ab6f4f7bb62d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347bd8cfa89ea853a2da046f733d6683"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a347bd8cfa89ea853a2da046f733d6683">pause_writing</a> (self)</td></tr>
<tr class="separator:a347bd8cfa89ea853a2da046f733d6683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24f2bb19345e6f3de5e7f056baa88e0"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ad24f2bb19345e6f3de5e7f056baa88e0">resume_writing</a> (self)</td></tr>
<tr class="separator:ad24f2bb19345e6f3de5e7f056baa88e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee68ef0fb534b8b4c77f0cc69269140"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#aeee68ef0fb534b8b4c77f0cc69269140">data_received</a> (self, bytes data)</td></tr>
<tr class="separator:aeee68ef0fb534b8b4c77f0cc69269140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390525e7d67ee7296d0b6d3e7a0e7d9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ab390525e7d67ee7296d0b6d3e7a0e7d9">eof_received</a> (self)</td></tr>
<tr class="separator:ab390525e7d67ee7296d0b6d3e7a0e7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae44cfcae3e52105d2abf638b8913d30d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae44cfcae3e52105d2abf638b8913d30d">ping_interval</a></td></tr>
<tr class="separator:ae44cfcae3e52105d2abf638b8913d30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e2df1d741aaf84eb8aff18e2242441"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a15e2df1d741aaf84eb8aff18e2242441">ping_timeout</a></td></tr>
<tr class="separator:a15e2df1d741aaf84eb8aff18e2242441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fdf2c1fccc0c99ad47e517f5f40839"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a66fdf2c1fccc0c99ad47e517f5f40839">close_timeout</a></td></tr>
<tr class="separator:a66fdf2c1fccc0c99ad47e517f5f40839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a18b02f4e2e35da3462d2876d38a72b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a8a18b02f4e2e35da3462d2876d38a72b">max_size</a></td></tr>
<tr class="separator:a8a18b02f4e2e35da3462d2876d38a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade76d0e9021caf7a6373948a7a1c9042"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ade76d0e9021caf7a6373948a7a1c9042">max_queue</a></td></tr>
<tr class="separator:ade76d0e9021caf7a6373948a7a1c9042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a59c2a80e467c0370a304b8ac3c32c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a17a59c2a80e467c0370a304b8ac3c32c">read_limit</a></td></tr>
<tr class="separator:a17a59c2a80e467c0370a304b8ac3c32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930f01b4d89fc6946b8e79e455f6fdac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a930f01b4d89fc6946b8e79e455f6fdac">write_limit</a></td></tr>
<tr class="separator:a930f01b4d89fc6946b8e79e455f6fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23439bdad1d9f46b708e3ae8d810e93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae23439bdad1d9f46b708e3ae8d810e93">debug</a></td></tr>
<tr class="separator:ae23439bdad1d9f46b708e3ae8d810e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a81b2b0626245f973f2e8cc73cb903"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a97a81b2b0626245f973f2e8cc73cb903">loop</a></td></tr>
<tr class="separator:a97a81b2b0626245f973f2e8cc73cb903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45668ae9194cdb9060c2fc2a6d9474e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a45668ae9194cdb9060c2fc2a6d9474e2">legacy_recv</a></td></tr>
<tr class="separator:a45668ae9194cdb9060c2fc2a6d9474e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62174ef508d03c3a530aec6cf0244f6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a62174ef508d03c3a530aec6cf0244f6e">reader</a></td></tr>
<tr class="separator:a62174ef508d03c3a530aec6cf0244f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5ba76dca3acd85108a21f1ff38613c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a2c5ba76dca3acd85108a21f1ff38613c">state</a></td></tr>
<tr class="separator:a2c5ba76dca3acd85108a21f1ff38613c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04695d8639b7699e337c0704a901f630"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a04695d8639b7699e337c0704a901f630">transfer_data_task</a></td></tr>
<tr class="separator:a04695d8639b7699e337c0704a901f630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a45abcd68cdd4b9901d3b6beb37c43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a73a45abcd68cdd4b9901d3b6beb37c43">keepalive_ping_task</a></td></tr>
<tr class="separator:a73a45abcd68cdd4b9901d3b6beb37c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4b797c0cd216ddff445f01f1a51776"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a4a4b797c0cd216ddff445f01f1a51776">close_connection_task</a></td></tr>
<tr class="separator:a4a4b797c0cd216ddff445f01f1a51776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171a828dc4c9de2d2ff2492f601f6b7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a171a828dc4c9de2d2ff2492f601f6b7b">transfer_data_exc</a></td></tr>
<tr class="separator:a171a828dc4c9de2d2ff2492f601f6b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2490e5dd1ee0245868133f24c8b3f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a2d2490e5dd1ee0245868133f24c8b3f0">close_rcvd</a></td></tr>
<tr class="separator:a2d2490e5dd1ee0245868133f24c8b3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d994ed30074531cd3c0af7dd5c8038"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ae9d994ed30074531cd3c0af7dd5c8038">close_rcvd_then_sent</a></td></tr>
<tr class="separator:ae9d994ed30074531cd3c0af7dd5c8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6c1d63686041f10655648b9f36dcd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a8d6c1d63686041f10655648b9f36dcd0">latency</a></td></tr>
<tr class="separator:a8d6c1d63686041f10655648b9f36dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b841c3cc7094af126e92f3964b1e70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#aa3b841c3cc7094af126e92f3964b1e70">close_sent</a></td></tr>
<tr class="separator:aa3b841c3cc7094af126e92f3964b1e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7471413a8e11166b1dcf432b22dae9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#a3a7471413a8e11166b1dcf432b22dae9">transport</a></td></tr>
<tr class="separator:a3a7471413a8e11166b1dcf432b22dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac12438bd8ba6e4c32db75cd03eb071a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a></td></tr>
<tr class="separator:ac12438bd8ba6e4c32db75cd03eb071a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">WebSocket connection.

:class:`WebSocketCommonProtocol` provides APIs shared between WebSocket
servers and clients. You shouldn't use it directly. Instead, use
:class:`~websockets.legacy.client.WebSocketClientProtocol` or
:class:`~websockets.legacy.server.WebSocketServerProtocol`.

This documentation focuses on low-level details that aren't covered in the
documentation of :class:`~websockets.legacy.client.WebSocketClientProtocol`
and :class:`~websockets.legacy.server.WebSocketServerProtocol` for the sake
of simplicity.

Once the connection is open, a Ping_ frame is sent every ``ping_interval``
seconds. This serves as a keepalive. It helps keeping the connection open,
especially in the presence of proxies with short timeouts on inactive
connections. Set ``ping_interval`` to :obj:`None` to disable this behavior.

.. _Ping: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.2

If the corresponding Pong_ frame isn't received within ``ping_timeout``
seconds, the connection is considered unusable and is closed with code 1011.
This ensures that the remote endpoint remains responsive. Set
``ping_timeout`` to :obj:`None` to disable this behavior.

.. _Pong: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.3

See the discussion of :doc:`keepalive &lt;../../topics/keepalive&gt;` for details.

The ``close_timeout`` parameter defines a maximum wait time for completing
the closing handshake and terminating the TCP connection. For legacy
reasons, :meth:`close` completes in at most ``5 * close_timeout`` seconds
for clients and ``4 * close_timeout`` for servers.

``close_timeout`` is a parameter of the protocol because websockets usually
calls :meth:`close` implicitly upon exit:

* on the client side, when using :func:`~websockets.legacy.client.connect`
  as a context manager;
* on the server side, when the connection handler terminates.

To apply a timeout to any other API, wrap it in :func:`~asyncio.timeout` or
:func:`~asyncio.wait_for`.

The ``max_size`` parameter enforces the maximum size for incoming messages
in bytes. The default value is 1 MiB. If a larger message is received,
:meth:`recv` will raise :exc:`~websockets.exceptions.ConnectionClosedError`
and the connection will be closed with code 1009.

The ``max_queue`` parameter sets the maximum length of the queue that
holds incoming messages. The default value is ``32``. Messages are added
to an in-memory queue when they're received; then :meth:`recv` pops from
that queue. In order to prevent excessive memory consumption when
messages are received faster than they can be processed, the queue must
be bounded. If the queue fills up, the protocol stops processing incoming
data until :meth:`recv` is called. In this situation, various receive
buffers (at least in :mod:`asyncio` and in the OS) will fill up, then the
TCP receive window will shrink, slowing down transmission to avoid packet
loss.

Since Python can use up to 4 bytes of memory to represent a single
character, each connection may use up to ``4 * max_size * max_queue``
bytes of memory to store incoming messages. By default, this is 128 MiB.
You may want to lower the limits, depending on your application's
requirements.

The ``read_limit`` argument sets the high-water limit of the buffer for
incoming bytes. The low-water limit is half the high-water limit. The
default value is 64 KiB, half of asyncio's default (based on the current
implementation of :class:`~asyncio.StreamReader`).

The ``write_limit`` argument sets the high-water limit of the buffer for
outgoing bytes. The low-water limit is a quarter of the high-water limit.
The default value is 64 KiB, equal to asyncio's default (based on the
current implementation of ``FlowControlMixin``).

See the discussion of :doc:`memory usage &lt;../../topics/memory&gt;` for details.

Args:
    logger: Logger for this server.
        It defaults to ``logging.getLogger("websockets.protocol")``.
        See the :doc:`logging guide &lt;../../topics/logging&gt;` for details.
    ping_interval: Interval between keepalive pings in seconds.
        :obj:`None` disables keepalive.
    ping_timeout: Timeout for keepalive pings in seconds.
        :obj:`None` disables timeouts.
    close_timeout: Timeout for closing the connection in seconds.
        For legacy reasons, the actual timeout is 4 or 5 times larger.
    max_size: Maximum size of incoming messages in bytes.
        :obj:`None` disables the limit.
    max_queue: Maximum number of incoming messages in receive buffer.
        :obj:`None` disables the limit.
    read_limit: High-water mark of read buffer in bytes.
    write_limit: High-water mark of write buffer in bytes.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a24e557bbfc786f68b3e5714962dd70e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e557bbfc786f68b3e5714962dd70e4">&#9670;&nbsp;</a></span>__init__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*LoggerLike | None &#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>ping_interval</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>ping_timeout</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>close_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_size</em> = <code>2**20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_queue</em> = <code>2**5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>read_limit</em> = <code>2**16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>write_limit</em> = <code>2**16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> | None &#160;</td>
          <td class="paramname"><em>host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>secure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>legacy_recv</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asyncio.AbstractEventLoop | None &#160;</td>
          <td class="paramname"><em>loop</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24e557bbfc786f68b3e5714962dd70e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e557bbfc786f68b3e5714962dd70e4">&#9670;&nbsp;</a></span>__init__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*LoggerLike | None &#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>ping_interval</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>ping_timeout</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>close_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_size</em> = <code>2**20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>max_queue</em> = <code>2**5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>read_limit</em> = <code>2**16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>write_limit</em> = <code>2**16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> | None &#160;</td>
          <td class="paramname"><em>host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>secure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>legacy_recv</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asyncio.AbstractEventLoop | None &#160;</td>
          <td class="paramname"><em>loop</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac646be31cd26b87bd76fbaf34d19a130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac646be31cd26b87bd76fbaf34d19a130">&#9670;&nbsp;</a></span>__aiter__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> AsyncIterator[Data] websockets.legacy.protocol.WebSocketCommonProtocol.__aiter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate on incoming messages.

The iterator exits normally when the connection is closed with the close
code 1000 (OK) or 1001 (going away) or without a close code.

It raises a :exc:`~websockets.exceptions.ConnectionClosedError`
exception when the connection is closed with any other code.</pre> 
</div>
</div>
<a id="ac646be31cd26b87bd76fbaf34d19a130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac646be31cd26b87bd76fbaf34d19a130">&#9670;&nbsp;</a></span>__aiter__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> AsyncIterator[Data] websockets.legacy.protocol.WebSocketCommonProtocol.__aiter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate on incoming messages.

The iterator exits normally when the connection is closed with the close
code 1000 (OK) or 1001 (going away) or without a close code.

It raises a :exc:`~websockets.exceptions.ConnectionClosedError`
exception when the connection is closed with any other code.</pre> 
</div>
</div>
<a id="a76fe3cf4dc28c519bf3ac65c3addba3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fe3cf4dc28c519bf3ac65c3addba3e">&#9670;&nbsp;</a></span>abort_pings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.abort_pings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Raise ConnectionClosed in pending keepalive pings.

They'll never receive a pong once the connection is closed.</pre> 
</div>
</div>
<a id="a76fe3cf4dc28c519bf3ac65c3addba3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fe3cf4dc28c519bf3ac65c3addba3e">&#9670;&nbsp;</a></span>abort_pings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.abort_pings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Raise ConnectionClosed in pending keepalive pings.

They'll never receive a pong once the connection is closed.</pre> 
</div>
</div>
<a id="a9736dd62f6e54f5b4c5ac8e5044a2d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9736dd62f6e54f5b4c5ac8e5044a2d41">&#9670;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>code</em> = <code><a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#af4e8be37b7ef43e1d1b3a8d105f0ed48">CloseCode.NORMAL_CLOSURE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> &#160;</td>
          <td class="paramname"><em>reason</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the closing handshake.

:meth:`close` waits for the other end to complete the handshake and
for the TCP connection to terminate. As a consequence, there's no need
to await :meth:`wait_closed` after :meth:`close`.

:meth:`close` is idempotent: it doesn't do anything once the
connection is closed.

Wrapping :func:`close` in :func:`~asyncio.create_task` is safe, given
that errors during connection termination aren't particularly useful.

Canceling :meth:`close` is discouraged. If it takes too long, you can
set a shorter ``close_timeout``. If you don't want to wait, let the
Python process exit, then the OS will take care of closing the TCP
connection.

Args:
    code: WebSocket close code.
    reason: WebSocket close reason.</pre> 
</div>
</div>
<a id="a9736dd62f6e54f5b4c5ac8e5044a2d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9736dd62f6e54f5b4c5ac8e5044a2d41">&#9670;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>code</em> = <code><a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#af4e8be37b7ef43e1d1b3a8d105f0ed48">CloseCode.NORMAL_CLOSURE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> &#160;</td>
          <td class="paramname"><em>reason</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the closing handshake.

:meth:`close` waits for the other end to complete the handshake and
for the TCP connection to terminate. As a consequence, there's no need
to await :meth:`wait_closed` after :meth:`close`.

:meth:`close` is idempotent: it doesn't do anything once the
connection is closed.

Wrapping :func:`close` in :func:`~asyncio.create_task` is safe, given
that errors during connection termination aren't particularly useful.

Canceling :meth:`close` is discouraged. If it takes too long, you can
set a shorter ``close_timeout``. If you don't want to wait, let the
Python process exit, then the OS will take care of closing the TCP
connection.

Args:
    code: WebSocket close code.
    reason: WebSocket close reason.</pre> 
</div>
</div>
<a id="aaf5376765011b733422126011375bfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5376765011b733422126011375bfa1">&#9670;&nbsp;</a></span>close_code() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None websockets.legacy.protocol.WebSocketCommonProtocol.close_code </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">WebSocket close code, defined in `section 7.1.5 of RFC 6455`_.

.. _section 7.1.5 of RFC 6455:
    https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5

:obj:`None` if the connection isn't closed yet.</pre> 
</div>
</div>
<a id="aaf5376765011b733422126011375bfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5376765011b733422126011375bfa1">&#9670;&nbsp;</a></span>close_code() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None websockets.legacy.protocol.WebSocketCommonProtocol.close_code </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">WebSocket close code, defined in `section 7.1.5 of RFC 6455`_.

.. _section 7.1.5 of RFC 6455:
    https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5

:obj:`None` if the connection isn't closed yet.</pre> 
</div>
</div>
<a id="a9da3a7b3767714657479530afadc6a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da3a7b3767714657479530afadc6a63">&#9670;&nbsp;</a></span>close_connection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.close_connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.1. Close the WebSocket Connection

When the opening handshake succeeds, :meth:`connection_open` starts
this coroutine in a task. It waits for the data transfer phase to
complete then it closes the TCP connection cleanly.

When the opening handshake fails, :meth:`fail_connection` does the
same. There's no data transfer phase in that case.</pre> 
</div>
</div>
<a id="a9da3a7b3767714657479530afadc6a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da3a7b3767714657479530afadc6a63">&#9670;&nbsp;</a></span>close_connection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.close_connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.1. Close the WebSocket Connection

When the opening handshake succeeds, :meth:`connection_open` starts
this coroutine in a task. It waits for the data transfer phase to
complete then it closes the TCP connection cleanly.

When the opening handshake fails, :meth:`fail_connection` does the
same. There's no data transfer phase in that case.</pre> 
</div>
</div>
<a id="a71f79a65844f4c5c444371b8f1288aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f79a65844f4c5c444371b8f1288aac">&#9670;&nbsp;</a></span>close_reason() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> | None websockets.legacy.protocol.WebSocketCommonProtocol.close_reason </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">WebSocket close reason, defined in `section 7.1.6 of RFC 6455`_.

.. _section 7.1.6 of RFC 6455:
    https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6

:obj:`None` if the connection isn't closed yet.</pre> 
</div>
</div>
<a id="a71f79a65844f4c5c444371b8f1288aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f79a65844f4c5c444371b8f1288aac">&#9670;&nbsp;</a></span>close_reason() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> | None websockets.legacy.protocol.WebSocketCommonProtocol.close_reason </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">WebSocket close reason, defined in `section 7.1.6 of RFC 6455`_.

.. _section 7.1.6 of RFC 6455:
    https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6

:obj:`None` if the connection isn't closed yet.</pre> 
</div>
</div>
<a id="a7117567b78496f9c1a5de4e29fea111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117567b78496f9c1a5de4e29fea111a">&#9670;&nbsp;</a></span>close_transport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.close_transport </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close the TCP connection.</pre> 
</div>
</div>
<a id="a7117567b78496f9c1a5de4e29fea111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117567b78496f9c1a5de4e29fea111a">&#9670;&nbsp;</a></span>close_transport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.close_transport </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close the TCP connection.</pre> 
</div>
</div>
<a id="ac90d097c978aea651f3a9f8805c81bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90d097c978aea651f3a9f8805c81bf3">&#9670;&nbsp;</a></span>closed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool websockets.legacy.protocol.WebSocketCommonProtocol.closed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:obj:`True` when the connection is closed; :obj:`False` otherwise.

Be aware that both :attr:`open` and :attr:`closed` are :obj:`False`
during the opening and closing sequences.</pre> 
</div>
</div>
<a id="ac90d097c978aea651f3a9f8805c81bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90d097c978aea651f3a9f8805c81bf3">&#9670;&nbsp;</a></span>closed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool websockets.legacy.protocol.WebSocketCommonProtocol.closed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:obj:`True` when the connection is closed; :obj:`False` otherwise.

Be aware that both :attr:`open` and :attr:`closed` are :obj:`False`
during the opening and closing sequences.</pre> 
</div>
</div>
<a id="af7e68b98ff68e5de797c11147b8a3657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e68b98ff68e5de797c11147b8a3657">&#9670;&nbsp;</a></span>connection_closed_exc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1exceptions_1_1ConnectionClosed.html">ConnectionClosed</a> websockets.legacy.protocol.WebSocketCommonProtocol.connection_closed_exc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7e68b98ff68e5de797c11147b8a3657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e68b98ff68e5de797c11147b8a3657">&#9670;&nbsp;</a></span>connection_closed_exc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1exceptions_1_1ConnectionClosed.html">ConnectionClosed</a> websockets.legacy.protocol.WebSocketCommonProtocol.connection_closed_exc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2613175a26be2de8ab6f4f7bb62d3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2613175a26be2de8ab6f4f7bb62d3df">&#9670;&nbsp;</a></span>connection_lost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.connection_lost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Exception | None&#160;</td>
          <td class="paramname"><em>exc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.4. The WebSocket Connection is Closed.</pre> 
</div>
</div>
<a id="ae2613175a26be2de8ab6f4f7bb62d3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2613175a26be2de8ab6f4f7bb62d3df">&#9670;&nbsp;</a></span>connection_lost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.connection_lost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Exception | None&#160;</td>
          <td class="paramname"><em>exc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.4. The WebSocket Connection is Closed.</pre> 
</div>
</div>
<a id="a983288e761fc1602e126140fe1fdad4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983288e761fc1602e126140fe1fdad4e">&#9670;&nbsp;</a></span>connection_made() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.connection_made </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asyncio.BaseTransport&#160;</td>
          <td class="paramname"><em>transport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Configure write buffer limits.

The high-water limit is defined by ``self.write_limit``.

The low-water limit currently defaults to ``self.write_limit // 4`` in
:meth:`~asyncio.WriteTransport.set_write_buffer_limits`, which should
be all right for reasonable use cases of this library.

This is the earliest point where we can get hold of the transport,
which means it's the best point for configuring it.</pre> 
<p>Reimplemented in <a class="el" href="classwebsockets_1_1legacy_1_1server_1_1WebSocketServerProtocol.html#af5b7a36f5557d6c7cad138672dc971c3">websockets.legacy.server.WebSocketServerProtocol</a>, and <a class="el" href="classwebsockets_1_1legacy_1_1server_1_1WebSocketServerProtocol.html#af5b7a36f5557d6c7cad138672dc971c3">websockets.legacy.server.WebSocketServerProtocol</a>.</p>

</div>
</div>
<a id="a983288e761fc1602e126140fe1fdad4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983288e761fc1602e126140fe1fdad4e">&#9670;&nbsp;</a></span>connection_made() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.connection_made </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asyncio.BaseTransport&#160;</td>
          <td class="paramname"><em>transport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Configure write buffer limits.

The high-water limit is defined by ``self.write_limit``.

The low-water limit currently defaults to ``self.write_limit // 4`` in
:meth:`~asyncio.WriteTransport.set_write_buffer_limits`, which should
be all right for reasonable use cases of this library.

This is the earliest point where we can get hold of the transport,
which means it's the best point for configuring it.</pre> 
<p>Reimplemented in <a class="el" href="classwebsockets_1_1legacy_1_1server_1_1WebSocketServerProtocol.html#af5b7a36f5557d6c7cad138672dc971c3">websockets.legacy.server.WebSocketServerProtocol</a>, and <a class="el" href="classwebsockets_1_1legacy_1_1server_1_1WebSocketServerProtocol.html#af5b7a36f5557d6c7cad138672dc971c3">websockets.legacy.server.WebSocketServerProtocol</a>.</p>

</div>
</div>
<a id="a84455422ed747abc2313be6138a87c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84455422ed747abc2313be6138a87c5f">&#9670;&nbsp;</a></span>connection_open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.connection_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Callback when the WebSocket opening handshake completes.

Enter the OPEN state and start the data transfer phase.</pre> 
</div>
</div>
<a id="a84455422ed747abc2313be6138a87c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84455422ed747abc2313be6138a87c5f">&#9670;&nbsp;</a></span>connection_open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.connection_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Callback when the WebSocket opening handshake completes.

Enter the OPEN state and start the data transfer phase.</pre> 
</div>
</div>
<a id="aeee68ef0fb534b8b4c77f0cc69269140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee68ef0fb534b8b4c77f0cc69269140">&#9670;&nbsp;</a></span>data_received() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.data_received </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeee68ef0fb534b8b4c77f0cc69269140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee68ef0fb534b8b4c77f0cc69269140">&#9670;&nbsp;</a></span>data_received() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.data_received </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49d159c6a35ca97a0bca60ea73f80d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d159c6a35ca97a0bca60ea73f80d0a">&#9670;&nbsp;</a></span>drain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.drain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49d159c6a35ca97a0bca60ea73f80d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d159c6a35ca97a0bca60ea73f80d0a">&#9670;&nbsp;</a></span>drain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.drain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dfc82dc3bdf4b6aa1cd7dd4a12290a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfc82dc3bdf4b6aa1cd7dd4a12290a3">&#9670;&nbsp;</a></span>ensure_open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.ensure_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the WebSocket connection is open.

Raise :exc:`~websockets.exceptions.ConnectionClosed` if it isn't.</pre> 
</div>
</div>
<a id="a6dfc82dc3bdf4b6aa1cd7dd4a12290a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfc82dc3bdf4b6aa1cd7dd4a12290a3">&#9670;&nbsp;</a></span>ensure_open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.ensure_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the WebSocket connection is open.

Raise :exc:`~websockets.exceptions.ConnectionClosed` if it isn't.</pre> 
</div>
</div>
<a id="ab390525e7d67ee7296d0b6d3e7a0e7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab390525e7d67ee7296d0b6d3e7a0e7d9">&#9670;&nbsp;</a></span>eof_received() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.eof_received </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close the transport after receiving EOF.

The WebSocket protocol has its own closing handshake: endpoints close
the TCP or TLS connection after sending and receiving a close frame.

As a consequence, they never need to write after receiving EOF, so
there's no reason to keep the transport open by returning :obj:`True`.

Besides, that doesn't work on TLS connections.</pre> 
</div>
</div>
<a id="ab390525e7d67ee7296d0b6d3e7a0e7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab390525e7d67ee7296d0b6d3e7a0e7d9">&#9670;&nbsp;</a></span>eof_received() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.eof_received </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close the transport after receiving EOF.

The WebSocket protocol has its own closing handshake: endpoints close
the TCP or TLS connection after sending and receiving a close frame.

As a consequence, they never need to write after receiving EOF, so
there's no reason to keep the transport open by returning :obj:`True`.

Besides, that doesn't work on TLS connections.</pre> 
</div>
</div>
<a id="a60961832bfe8821c6dd5ce88d75b37d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60961832bfe8821c6dd5ce88d75b37d1">&#9670;&nbsp;</a></span>fail_connection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.fail_connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>code</em> = <code><a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#a8870ac2858ee74d48598c9b58eff1667">CloseCode.ABNORMAL_CLOSURE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> &#160;</td>
          <td class="paramname"><em>reason</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.7. Fail the WebSocket Connection

This requires:

1. Stopping all processing of incoming data, which means cancelling
   :attr:`transfer_data_task`. The close code will be 1006 unless a
   close frame was received earlier.

2. Sending a close frame with an appropriate code if the opening
   handshake succeeded and the other side is likely to process it.

3. Closing the connection. :meth:`close_connection` takes care of
   this once :attr:`transfer_data_task` exits after being canceled.

(The specification describes these steps in the opposite order.)</pre> 
</div>
</div>
<a id="a60961832bfe8821c6dd5ce88d75b37d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60961832bfe8821c6dd5ce88d75b37d1">&#9670;&nbsp;</a></span>fail_connection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.fail_connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>code</em> = <code><a class="el" href="classwebsockets_1_1frames_1_1CloseCode.html#a8870ac2858ee74d48598c9b58eff1667">CloseCode.ABNORMAL_CLOSURE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> &#160;</td>
          <td class="paramname"><em>reason</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.7. Fail the WebSocket Connection

This requires:

1. Stopping all processing of incoming data, which means cancelling
   :attr:`transfer_data_task`. The close code will be 1006 unless a
   close frame was received earlier.

2. Sending a close frame with an appropriate code if the opening
   handshake succeeded and the other side is likely to process it.

3. Closing the connection. :meth:`close_connection` takes care of
   this once :attr:`transfer_data_task` exits after being canceled.

(The specification describes these steps in the opposite order.)</pre> 
</div>
</div>
<a id="a7610c6eb8c8fe7ebb03424aa7c2d8966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7610c6eb8c8fe7ebb03424aa7c2d8966">&#9670;&nbsp;</a></span>host() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> | None websockets.legacy.protocol.WebSocketCommonProtocol.host </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7610c6eb8c8fe7ebb03424aa7c2d8966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7610c6eb8c8fe7ebb03424aa7c2d8966">&#9670;&nbsp;</a></span>host() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1legacy_1_1protocol_1_1WebSocketCommonProtocol.html#ac12438bd8ba6e4c32db75cd03eb071a0">str</a> | None websockets.legacy.protocol.WebSocketCommonProtocol.host </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac15b54c81067e7533c50bb08258098d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15b54c81067e7533c50bb08258098d0">&#9670;&nbsp;</a></span>keepalive_ping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.keepalive_ping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Ping frame and wait for a Pong frame at regular intervals.

This coroutine exits when the connection terminates and one of the
following happens:

- :meth:`ping` raises :exc:`ConnectionClosed`, or
- :meth:`close_connection` cancels :attr:`keepalive_ping_task`.</pre> 
</div>
</div>
<a id="ac15b54c81067e7533c50bb08258098d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15b54c81067e7533c50bb08258098d0">&#9670;&nbsp;</a></span>keepalive_ping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.keepalive_ping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Ping frame and wait for a Pong frame at regular intervals.

This coroutine exits when the connection terminates and one of the
following happens:

- :meth:`ping` raises :exc:`ConnectionClosed`, or
- :meth:`close_connection` cancels :attr:`keepalive_ping_task`.</pre> 
</div>
</div>
<a id="ac90aaadbdb48e66440599f96f305c161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90aaadbdb48e66440599f96f305c161">&#9670;&nbsp;</a></span>local_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any websockets.legacy.protocol.WebSocketCommonProtocol.local_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Local address of the connection.

For IPv4 connections, this is a ``(host, port)`` tuple.

The format of the address depends on the address family;
see :meth:`~socket.socket.getsockname`.

:obj:`None` if the TCP connection isn't established yet.</pre> 
</div>
</div>
<a id="ac90aaadbdb48e66440599f96f305c161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90aaadbdb48e66440599f96f305c161">&#9670;&nbsp;</a></span>local_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any websockets.legacy.protocol.WebSocketCommonProtocol.local_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Local address of the connection.

For IPv4 connections, this is a ``(host, port)`` tuple.

The format of the address depends on the address family;
see :meth:`~socket.socket.getsockname`.

:obj:`None` if the TCP connection isn't established yet.</pre> 
</div>
</div>
<a id="af2d29b6fb0452130aa5404c50eb57044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d29b6fb0452130aa5404c50eb57044">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool websockets.legacy.protocol.WebSocketCommonProtocol.open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:obj:`True` when the connection is open; :obj:`False` otherwise.

This attribute may be used to detect disconnections. However, this
approach is discouraged per the EAFP_ principle. Instead, you should
handle :exc:`~websockets.exceptions.ConnectionClosed` exceptions.

.. _EAFP: https://docs.python.org/3/glossary.html#term-eafp</pre> 
</div>
</div>
<a id="af2d29b6fb0452130aa5404c50eb57044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d29b6fb0452130aa5404c50eb57044">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool websockets.legacy.protocol.WebSocketCommonProtocol.open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:obj:`True` when the connection is open; :obj:`False` otherwise.

This attribute may be used to detect disconnections. However, this
approach is discouraged per the EAFP_ principle. Instead, you should
handle :exc:`~websockets.exceptions.ConnectionClosed` exceptions.

.. _EAFP: https://docs.python.org/3/glossary.html#term-eafp</pre> 
</div>
</div>
<a id="a347bd8cfa89ea853a2da046f733d6683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347bd8cfa89ea853a2da046f733d6683">&#9670;&nbsp;</a></span>pause_writing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.pause_writing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a347bd8cfa89ea853a2da046f733d6683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347bd8cfa89ea853a2da046f733d6683">&#9670;&nbsp;</a></span>pause_writing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.pause_writing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6ebad887bddcd4b733a80401594d9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ebad887bddcd4b733a80401594d9c1">&#9670;&nbsp;</a></span>ping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Awaitable[float] websockets.legacy.protocol.WebSocketCommonProtocol.ping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data | None &#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Ping_.

.. _Ping: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.2

A ping may serve as a keepalive, as a check that the remote endpoint
received all messages up to this point, or to measure :attr:`latency`.

Canceling :meth:`ping` is discouraged. If :meth:`ping` doesn't return
immediately, it means the write buffer is full. If you don't want to
wait, you should close the connection.

Canceling the :class:`~asyncio.Future` returned by :meth:`ping` has no
effect.

Args:
    data: Payload of the ping. A string will be encoded to UTF-8.
        If ``data`` is :obj:`None`, the payload is four random bytes.

Returns:
    A future that will be completed when the corresponding pong is
    received. You can ignore it if you don't intend to wait. The result
    of the future is the latency of the connection in seconds.

    ::

        pong_waiter = await ws.ping()
        # only if you want to wait for the corresponding pong
        latency = await pong_waiter

Raises:
    ConnectionClosed: When the connection is closed.
    RuntimeError: If another ping was sent with the same data and
        the corresponding pong wasn't received yet.</pre> 
</div>
</div>
<a id="ae6ebad887bddcd4b733a80401594d9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ebad887bddcd4b733a80401594d9c1">&#9670;&nbsp;</a></span>ping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Awaitable[float] websockets.legacy.protocol.WebSocketCommonProtocol.ping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data | None &#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Ping_.

.. _Ping: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.2

A ping may serve as a keepalive, as a check that the remote endpoint
received all messages up to this point, or to measure :attr:`latency`.

Canceling :meth:`ping` is discouraged. If :meth:`ping` doesn't return
immediately, it means the write buffer is full. If you don't want to
wait, you should close the connection.

Canceling the :class:`~asyncio.Future` returned by :meth:`ping` has no
effect.

Args:
    data: Payload of the ping. A string will be encoded to UTF-8.
        If ``data`` is :obj:`None`, the payload is four random bytes.

Returns:
    A future that will be completed when the corresponding pong is
    received. You can ignore it if you don't intend to wait. The result
    of the future is the latency of the connection in seconds.

    ::

        pong_waiter = await ws.ping()
        # only if you want to wait for the corresponding pong
        latency = await pong_waiter

Raises:
    ConnectionClosed: When the connection is closed.
    RuntimeError: If another ping was sent with the same data and
        the corresponding pong wasn't received yet.</pre> 
</div>
</div>
<a id="a351ae54b7c302671ec2397214c9b118a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351ae54b7c302671ec2397214c9b118a">&#9670;&nbsp;</a></span>pong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.pong </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data &#160;</td>
          <td class="paramname"><em>data</em> = <code>b&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Pong_.

.. _Pong: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.3

An unsolicited pong may serve as a unidirectional heartbeat.

Canceling :meth:`pong` is discouraged. If :meth:`pong` doesn't return
immediately, it means the write buffer is full. If you don't want to
wait, you should close the connection.

Args:
    data: Payload of the pong. A string will be encoded to UTF-8.

Raises:
    ConnectionClosed: When the connection is closed.</pre> 
</div>
</div>
<a id="a351ae54b7c302671ec2397214c9b118a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351ae54b7c302671ec2397214c9b118a">&#9670;&nbsp;</a></span>pong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.pong </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data &#160;</td>
          <td class="paramname"><em>data</em> = <code>b&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a Pong_.

.. _Pong: https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.3

An unsolicited pong may serve as a unidirectional heartbeat.

Canceling :meth:`pong` is discouraged. If :meth:`pong` doesn't return
immediately, it means the write buffer is full. If you don't want to
wait, you should close the connection.

Args:
    data: Payload of the pong. A string will be encoded to UTF-8.

Raises:
    ConnectionClosed: When the connection is closed.</pre> 
</div>
</div>
<a id="af2784c9b87aba34d6254a03361b0c4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2784c9b87aba34d6254a03361b0c4b0">&#9670;&nbsp;</a></span>port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None websockets.legacy.protocol.WebSocketCommonProtocol.port </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2784c9b87aba34d6254a03361b0c4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2784c9b87aba34d6254a03361b0c4b0">&#9670;&nbsp;</a></span>port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None websockets.legacy.protocol.WebSocketCommonProtocol.port </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54bf9e5d805d0072affc6eb534d72fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bf9e5d805d0072affc6eb534d72fc7">&#9670;&nbsp;</a></span>read_data_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1legacy_1_1framing_1_1Frame.html">Frame</a> | None websockets.legacy.protocol.WebSocketCommonProtocol.read_data_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single data frame from the connection.

Process control frames received before the next data frame.

Return :obj:`None` if a close frame is encountered before any data frame.</pre> 
</div>
</div>
<a id="a54bf9e5d805d0072affc6eb534d72fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bf9e5d805d0072affc6eb534d72fc7">&#9670;&nbsp;</a></span>read_data_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1legacy_1_1framing_1_1Frame.html">Frame</a> | None websockets.legacy.protocol.WebSocketCommonProtocol.read_data_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single data frame from the connection.

Process control frames received before the next data frame.

Return :obj:`None` if a close frame is encountered before any data frame.</pre> 
</div>
</div>
<a id="a988314cb1640b8ddbfc71165945265bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988314cb1640b8ddbfc71165945265bc">&#9670;&nbsp;</a></span>read_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1legacy_1_1framing_1_1Frame.html">Frame</a> websockets.legacy.protocol.WebSocketCommonProtocol.read_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single frame from the connection.</pre> 
</div>
</div>
<a id="a988314cb1640b8ddbfc71165945265bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988314cb1640b8ddbfc71165945265bc">&#9670;&nbsp;</a></span>read_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classwebsockets_1_1legacy_1_1framing_1_1Frame.html">Frame</a> websockets.legacy.protocol.WebSocketCommonProtocol.read_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single frame from the connection.</pre> 
</div>
</div>
<a id="a7e51f72e4bf12d032bbbb068bcce3ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e51f72e4bf12d032bbbb068bcce3ee4">&#9670;&nbsp;</a></span>read_message() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Data | None websockets.legacy.protocol.WebSocketCommonProtocol.read_message </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single message from the connection.

Re-assemble data frames if the message is fragmented.

Return :obj:`None` when the closing handshake is started.</pre> 
</div>
</div>
<a id="a7e51f72e4bf12d032bbbb068bcce3ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e51f72e4bf12d032bbbb068bcce3ee4">&#9670;&nbsp;</a></span>read_message() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Data | None websockets.legacy.protocol.WebSocketCommonProtocol.read_message </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single message from the connection.

Re-assemble data frames if the message is fragmented.

Return :obj:`None` when the closing handshake is started.</pre> 
</div>
</div>
<a id="a204cda1c777ce1fc1a099d1a1c56880c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204cda1c777ce1fc1a099d1a1c56880c">&#9670;&nbsp;</a></span>recv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Data websockets.legacy.protocol.WebSocketCommonProtocol.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive the next message.

When the connection is closed, :meth:`recv` raises
:exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it raises
:exc:`~websockets.exceptions.ConnectionClosedOK` after a normal
connection closure and
:exc:`~websockets.exceptions.ConnectionClosedError` after a protocol
error or a network failure. This is how you detect the end of the
message stream.

Canceling :meth:`recv` is safe. There's no risk of losing the next
message. The next invocation of :meth:`recv` will return it.

This makes it possible to enforce a timeout by wrapping :meth:`recv` in
:func:`~asyncio.timeout` or :func:`~asyncio.wait_for`.

Returns:
    A string (:class:`str`) for a Text_ frame. A bytestring
    (:class:`bytes`) for a Binary_ frame.

    .. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
    .. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

Raises:
    ConnectionClosed: When the connection is closed.
    RuntimeError: If two coroutines call :meth:`recv` concurrently.</pre> 
</div>
</div>
<a id="a204cda1c777ce1fc1a099d1a1c56880c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204cda1c777ce1fc1a099d1a1c56880c">&#9670;&nbsp;</a></span>recv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Data websockets.legacy.protocol.WebSocketCommonProtocol.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Receive the next message.

When the connection is closed, :meth:`recv` raises
:exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it raises
:exc:`~websockets.exceptions.ConnectionClosedOK` after a normal
connection closure and
:exc:`~websockets.exceptions.ConnectionClosedError` after a protocol
error or a network failure. This is how you detect the end of the
message stream.

Canceling :meth:`recv` is safe. There's no risk of losing the next
message. The next invocation of :meth:`recv` will return it.

This makes it possible to enforce a timeout by wrapping :meth:`recv` in
:func:`~asyncio.timeout` or :func:`~asyncio.wait_for`.

Returns:
    A string (:class:`str`) for a Text_ frame. A bytestring
    (:class:`bytes`) for a Binary_ frame.

    .. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
    .. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

Raises:
    ConnectionClosed: When the connection is closed.
    RuntimeError: If two coroutines call :meth:`recv` concurrently.</pre> 
</div>
</div>
<a id="a9dbf996533f4b7b30d37d1909c83d676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbf996533f4b7b30d37d1909c83d676">&#9670;&nbsp;</a></span>remote_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any websockets.legacy.protocol.WebSocketCommonProtocol.remote_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remote address of the connection.

For IPv4 connections, this is a ``(host, port)`` tuple.

The format of the address depends on the address family;
see :meth:`~socket.socket.getpeername`.

:obj:`None` if the TCP connection isn't established yet.</pre> 
</div>
</div>
<a id="a9dbf996533f4b7b30d37d1909c83d676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbf996533f4b7b30d37d1909c83d676">&#9670;&nbsp;</a></span>remote_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any websockets.legacy.protocol.WebSocketCommonProtocol.remote_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remote address of the connection.

For IPv4 connections, this is a ``(host, port)`` tuple.

The format of the address depends on the address family;
see :meth:`~socket.socket.getpeername`.

:obj:`None` if the TCP connection isn't established yet.</pre> 
</div>
</div>
<a id="ad24f2bb19345e6f3de5e7f056baa88e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24f2bb19345e6f3de5e7f056baa88e0">&#9670;&nbsp;</a></span>resume_writing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.resume_writing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad24f2bb19345e6f3de5e7f056baa88e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24f2bb19345e6f3de5e7f056baa88e0">&#9670;&nbsp;</a></span>resume_writing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.resume_writing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad58a69fed90d91f67e2b4872f251f2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58a69fed90d91f67e2b4872f251f2b9">&#9670;&nbsp;</a></span>secure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool | None websockets.legacy.protocol.WebSocketCommonProtocol.secure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad58a69fed90d91f67e2b4872f251f2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58a69fed90d91f67e2b4872f251f2b9">&#9670;&nbsp;</a></span>secure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool | None websockets.legacy.protocol.WebSocketCommonProtocol.secure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e3e69e7be36cd7d6e18ffb619f0bff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3e69e7be36cd7d6e18ffb619f0bff9">&#9670;&nbsp;</a></span>send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.send </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data | Iterable[Data] | AsyncIterable[Data]&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a message.

A string (:class:`str`) is sent as a Text_ frame. A bytestring or
bytes-like object (:class:`bytes`, :class:`bytearray`, or
:class:`memoryview`) is sent as a Binary_ frame.

.. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
.. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

:meth:`send` also accepts an iterable or an asynchronous iterable of
strings, bytestrings, or bytes-like objects to enable fragmentation_.
Each item is treated as a message fragment and sent in its own frame.
All items must be of the same type, or else :meth:`send` will raise a
:exc:`TypeError` and the connection will be closed.

.. _fragmentation: https://datatracker.ietf.org/doc/html/rfc6455#section-5.4

:meth:`send` rejects dict-like objects because this is often an error.
(If you want to send the keys of a dict-like object as fragments, call
its :meth:`~dict.keys` method and pass the result to :meth:`send`.)

Canceling :meth:`send` is discouraged. Instead, you should close the
connection with :meth:`close`. Indeed, there are only two situations
where :meth:`send` may yield control to the event loop and then get
canceled; in both cases, :meth:`close` has the same effect and is
more clear:

1. The write buffer is full. If you don't want to wait until enough
   data is sent, your only alternative is to close the connection.
   :meth:`close` will likely time out then abort the TCP connection.
2. ``message`` is an asynchronous iterator that yields control.
   Stopping in the middle of a fragmented message will cause a
   protocol error and the connection will be closed.

When the connection is closed, :meth:`send` raises
:exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it
raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal
connection closure and
:exc:`~websockets.exceptions.ConnectionClosedError` after a protocol
error or a network failure.

Args:
    message: Message to send.

Raises:
    ConnectionClosed: When the connection is closed.
    TypeError: If ``message`` doesn't have a supported type.</pre> 
</div>
</div>
<a id="a1e3e69e7be36cd7d6e18ffb619f0bff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3e69e7be36cd7d6e18ffb619f0bff9">&#9670;&nbsp;</a></span>send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.send </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data | Iterable[Data] | AsyncIterable[Data]&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a message.

A string (:class:`str`) is sent as a Text_ frame. A bytestring or
bytes-like object (:class:`bytes`, :class:`bytearray`, or
:class:`memoryview`) is sent as a Binary_ frame.

.. _Text: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6
.. _Binary: https://datatracker.ietf.org/doc/html/rfc6455#section-5.6

:meth:`send` also accepts an iterable or an asynchronous iterable of
strings, bytestrings, or bytes-like objects to enable fragmentation_.
Each item is treated as a message fragment and sent in its own frame.
All items must be of the same type, or else :meth:`send` will raise a
:exc:`TypeError` and the connection will be closed.

.. _fragmentation: https://datatracker.ietf.org/doc/html/rfc6455#section-5.4

:meth:`send` rejects dict-like objects because this is often an error.
(If you want to send the keys of a dict-like object as fragments, call
its :meth:`~dict.keys` method and pass the result to :meth:`send`.)

Canceling :meth:`send` is discouraged. Instead, you should close the
connection with :meth:`close`. Indeed, there are only two situations
where :meth:`send` may yield control to the event loop and then get
canceled; in both cases, :meth:`close` has the same effect and is
more clear:

1. The write buffer is full. If you don't want to wait until enough
   data is sent, your only alternative is to close the connection.
   :meth:`close` will likely time out then abort the TCP connection.
2. ``message`` is an asynchronous iterator that yields control.
   Stopping in the middle of a fragmented message will cause a
   protocol error and the connection will be closed.

When the connection is closed, :meth:`send` raises
:exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it
raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal
connection closure and
:exc:`~websockets.exceptions.ConnectionClosedError` after a protocol
error or a network failure.

Args:
    message: Message to send.

Raises:
    ConnectionClosed: When the connection is closed.
    TypeError: If ``message`` doesn't have a supported type.</pre> 
</div>
</div>
<a id="a00e0c1738444d6bd1de5f321a0356e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e0c1738444d6bd1de5f321a0356e3d">&#9670;&nbsp;</a></span>transfer_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.transfer_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read incoming messages and put them in a queue.

This coroutine runs in a task until the closing handshake is started.</pre> 
</div>
</div>
<a id="a00e0c1738444d6bd1de5f321a0356e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e0c1738444d6bd1de5f321a0356e3d">&#9670;&nbsp;</a></span>transfer_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.transfer_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read incoming messages and put them in a queue.

This coroutine runs in a task until the closing handshake is started.</pre> 
</div>
</div>
<a id="a1b8153b1f616fbc30c55f909b136836a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8153b1f616fbc30c55f909b136836a">&#9670;&nbsp;</a></span>wait_closed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.wait_closed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait until the connection is closed.

This coroutine is identical to the :attr:`closed` attribute, except it
can be awaited.

This can make it easier to detect connection termination, regardless
of its cause, in tasks that interact with the WebSocket connection.</pre> 
</div>
</div>
<a id="a1b8153b1f616fbc30c55f909b136836a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8153b1f616fbc30c55f909b136836a">&#9670;&nbsp;</a></span>wait_closed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.wait_closed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait until the connection is closed.

This coroutine is identical to the :attr:`closed` attribute, except it
can be awaited.

This can make it easier to detect connection termination, regardless
of its cause, in tasks that interact with the WebSocket connection.</pre> 
</div>
</div>
<a id="acd51bf6ff7f8f3c578059ad0dd014c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd51bf6ff7f8f3c578059ad0dd014c88">&#9670;&nbsp;</a></span>wait_for_connection_lost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool websockets.legacy.protocol.WebSocketCommonProtocol.wait_for_connection_lost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait until the TCP connection is closed or ``self.close_timeout`` elapses.

Return :obj:`True` if the connection is closed and :obj:`False`
otherwise.</pre> 
</div>
</div>
<a id="acd51bf6ff7f8f3c578059ad0dd014c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd51bf6ff7f8f3c578059ad0dd014c88">&#9670;&nbsp;</a></span>wait_for_connection_lost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool websockets.legacy.protocol.WebSocketCommonProtocol.wait_for_connection_lost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait until the TCP connection is closed or ``self.close_timeout`` elapses.

Return :obj:`True` if the connection is closed and :obj:`False`
otherwise.</pre> 
</div>
</div>
<a id="a53cc1e33aba0b97e031877b25f0f11bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cc1e33aba0b97e031877b25f0f11bd">&#9670;&nbsp;</a></span>write_close_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.write_close_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1frames_1_1Close.html">Close</a>&#160;</td>
          <td class="paramname"><em>close</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes | None &#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write a close frame if and only if the connection state is OPEN.

This dedicated coroutine must be used for writing close frames to
ensure that at most one close frame is sent on a given connection.</pre> 
</div>
</div>
<a id="a53cc1e33aba0b97e031877b25f0f11bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cc1e33aba0b97e031877b25f0f11bd">&#9670;&nbsp;</a></span>write_close_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.write_close_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsockets_1_1frames_1_1Close.html">Close</a>&#160;</td>
          <td class="paramname"><em>close</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes | None &#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write a close frame if and only if the connection state is OPEN.

This dedicated coroutine must be used for writing close frames to
ensure that at most one close frame is sent on a given connection.</pre> 
</div>
</div>
<a id="adf17cdf53fae8a12f9df3521563e97a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf17cdf53fae8a12f9df3521563e97a6">&#9670;&nbsp;</a></span>write_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.write_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int &#160;</td>
          <td class="paramname"><em>_state</em> = <code><a class="el" href="classwebsockets_1_1protocol_1_1State.html#a3130411fdfdb2b56c4916d8c7209ce1e">State.OPEN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf17cdf53fae8a12f9df3521563e97a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf17cdf53fae8a12f9df3521563e97a6">&#9670;&nbsp;</a></span>write_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.write_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int &#160;</td>
          <td class="paramname"><em>_state</em> = <code><a class="el" href="classwebsockets_1_1protocol_1_1State.html#a3130411fdfdb2b56c4916d8c7209ce1e">State.OPEN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad36537e16d6dedaed78d19c33ca8474b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36537e16d6dedaed78d19c33ca8474b">&#9670;&nbsp;</a></span>write_frame_sync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.write_frame_sync </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad36537e16d6dedaed78d19c33ca8474b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36537e16d6dedaed78d19c33ca8474b">&#9670;&nbsp;</a></span>write_frame_sync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None websockets.legacy.protocol.WebSocketCommonProtocol.write_frame_sync </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytes&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4a4b797c0cd216ddff445f01f1a51776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4b797c0cd216ddff445f01f1a51776">&#9670;&nbsp;</a></span>close_connection_task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.close_connection_task</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d2490e5dd1ee0245868133f24c8b3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2490e5dd1ee0245868133f24c8b3f0">&#9670;&nbsp;</a></span>close_rcvd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.close_rcvd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9d994ed30074531cd3c0af7dd5c8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d994ed30074531cd3c0af7dd5c8038">&#9670;&nbsp;</a></span>close_rcvd_then_sent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.close_rcvd_then_sent</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b841c3cc7094af126e92f3964b1e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b841c3cc7094af126e92f3964b1e70">&#9670;&nbsp;</a></span>close_sent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.close_sent</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66fdf2c1fccc0c99ad47e517f5f40839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fdf2c1fccc0c99ad47e517f5f40839">&#9670;&nbsp;</a></span>close_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.close_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae23439bdad1d9f46b708e3ae8d810e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23439bdad1d9f46b708e3ae8d810e93">&#9670;&nbsp;</a></span>debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.debug</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73a45abcd68cdd4b9901d3b6beb37c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a45abcd68cdd4b9901d3b6beb37c43">&#9670;&nbsp;</a></span>keepalive_ping_task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.keepalive_ping_task</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d6c1d63686041f10655648b9f36dcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6c1d63686041f10655648b9f36dcd0">&#9670;&nbsp;</a></span>latency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.latency</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45668ae9194cdb9060c2fc2a6d9474e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45668ae9194cdb9060c2fc2a6d9474e2">&#9670;&nbsp;</a></span>legacy_recv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.legacy_recv</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97a81b2b0626245f973f2e8cc73cb903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a81b2b0626245f973f2e8cc73cb903">&#9670;&nbsp;</a></span>loop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.loop</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade76d0e9021caf7a6373948a7a1c9042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade76d0e9021caf7a6373948a7a1c9042">&#9670;&nbsp;</a></span>max_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.max_queue</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a18b02f4e2e35da3462d2876d38a72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18b02f4e2e35da3462d2876d38a72b">&#9670;&nbsp;</a></span>max_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae44cfcae3e52105d2abf638b8913d30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44cfcae3e52105d2abf638b8913d30d">&#9670;&nbsp;</a></span>ping_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.ping_interval</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15e2df1d741aaf84eb8aff18e2242441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e2df1d741aaf84eb8aff18e2242441">&#9670;&nbsp;</a></span>ping_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.ping_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17a59c2a80e467c0370a304b8ac3c32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a59c2a80e467c0370a304b8ac3c32c">&#9670;&nbsp;</a></span>read_limit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.read_limit</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62174ef508d03c3a530aec6cf0244f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62174ef508d03c3a530aec6cf0244f6e">&#9670;&nbsp;</a></span>reader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.reader</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c5ba76dca3acd85108a21f1ff38613c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5ba76dca3acd85108a21f1ff38613c">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.state</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac12438bd8ba6e4c32db75cd03eb071a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12438bd8ba6e4c32db75cd03eb071a0">&#9670;&nbsp;</a></span>str</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.str</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a171a828dc4c9de2d2ff2492f601f6b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171a828dc4c9de2d2ff2492f601f6b7b">&#9670;&nbsp;</a></span>transfer_data_exc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.transfer_data_exc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04695d8639b7699e337c0704a901f630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04695d8639b7699e337c0704a901f630">&#9670;&nbsp;</a></span>transfer_data_task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.transfer_data_task</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a7471413a8e11166b1dcf432b22dae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7471413a8e11166b1dcf432b22dae9">&#9670;&nbsp;</a></span>transport</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.transport</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a930f01b4d89fc6946b8e79e455f6fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930f01b4d89fc6946b8e79e455f6fdac">&#9670;&nbsp;</a></span>write_limit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websockets.legacy.protocol.WebSocketCommonProtocol.write_limit</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/websockets/legacy/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2websockets_2legacy_2protocol_8py.html">protocol.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
