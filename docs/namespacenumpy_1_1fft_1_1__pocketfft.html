<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: numpy.fft._pocketfft Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>numpy</b></li><li class="navelem"><a class="el" href="namespacenumpy_1_1fft.html">fft</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html">_pocketfft</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">numpy.fft._pocketfft Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1ccb797bb0d4b68f1ae509eb5fccf41f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a1ccb797bb0d4b68f1ae509eb5fccf41f">fft</a> (a, n=None, axis=-1, norm=None, out=None)</td></tr>
<tr class="separator:a1ccb797bb0d4b68f1ae509eb5fccf41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9a46e7316c4656e2cb9262f517cbec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a9a9a46e7316c4656e2cb9262f517cbec">ifft</a> (a, n=None, axis=-1, norm=None, out=None)</td></tr>
<tr class="separator:a9a9a46e7316c4656e2cb9262f517cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57516413deef042a84558ee366ce479a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a57516413deef042a84558ee366ce479a">rfft</a> (a, n=None, axis=-1, norm=None, out=None)</td></tr>
<tr class="separator:a57516413deef042a84558ee366ce479a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc450630e6b434f00092a6296db6223"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a6fc450630e6b434f00092a6296db6223">irfft</a> (a, n=None, axis=-1, norm=None, out=None)</td></tr>
<tr class="separator:a6fc450630e6b434f00092a6296db6223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa773290d8844f1e9c573b3d4e063d22c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#aa773290d8844f1e9c573b3d4e063d22c">hfft</a> (a, n=None, axis=-1, norm=None, out=None)</td></tr>
<tr class="separator:aa773290d8844f1e9c573b3d4e063d22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7147b00e83f4d3246459e1bec3bd3b57"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a7147b00e83f4d3246459e1bec3bd3b57">ihfft</a> (a, n=None, axis=-1, norm=None, out=None)</td></tr>
<tr class="separator:a7147b00e83f4d3246459e1bec3bd3b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5f4b12ac497a08717eccaaa0e24494"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a9d5f4b12ac497a08717eccaaa0e24494">fftn</a> (a, s=None, axes=None, norm=None, out=None)</td></tr>
<tr class="separator:a9d5f4b12ac497a08717eccaaa0e24494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17819dbb61d7f3ad805390af815adef7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a17819dbb61d7f3ad805390af815adef7">ifftn</a> (a, s=None, axes=None, norm=None, out=None)</td></tr>
<tr class="separator:a17819dbb61d7f3ad805390af815adef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c5674e89b7fb31cb69fe08e8e8a4dd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#ae1c5674e89b7fb31cb69fe08e8e8a4dd">fft2</a> (a, s=None, axes=(-2, -1), norm=None, out=None)</td></tr>
<tr class="separator:ae1c5674e89b7fb31cb69fe08e8e8a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708bdfd7600e7c2eaa05b0ef328022df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a708bdfd7600e7c2eaa05b0ef328022df">ifft2</a> (a, s=None, axes=(-2, -1), norm=None, out=None)</td></tr>
<tr class="separator:a708bdfd7600e7c2eaa05b0ef328022df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b013deb378336c1591e58c8442da4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#aa1b013deb378336c1591e58c8442da4e">rfftn</a> (a, s=None, axes=None, norm=None, out=None)</td></tr>
<tr class="separator:aa1b013deb378336c1591e58c8442da4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae848712488b3b585999b793d58d6e944"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#ae848712488b3b585999b793d58d6e944">rfft2</a> (a, s=None, axes=(-2, -1), norm=None, out=None)</td></tr>
<tr class="separator:ae848712488b3b585999b793d58d6e944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70970da42e3f49491aad9a612dabe128"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#a70970da42e3f49491aad9a612dabe128">irfftn</a> (a, s=None, axes=None, norm=None, out=None)</td></tr>
<tr class="separator:a70970da42e3f49491aad9a612dabe128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20518d8aa726e3053a6ba792afe780a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#ae20518d8aa726e3053a6ba792afe780a">irfft2</a> (a, s=None, axes=(-2, -1), norm=None, out=None)</td></tr>
<tr class="separator:ae20518d8aa726e3053a6ba792afe780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac165d2501f6b926b97841274eec90812"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1fft_1_1__pocketfft.html#ac165d2501f6b926b97841274eec90812">array_function_dispatch</a></td></tr>
<tr class="separator:ac165d2501f6b926b97841274eec90812"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Discrete Fourier Transforms

Routines in this module:

fft(a, n=None, axis=-1, norm="backward")
ifft(a, n=None, axis=-1, norm="backward")
rfft(a, n=None, axis=-1, norm="backward")
irfft(a, n=None, axis=-1, norm="backward")
hfft(a, n=None, axis=-1, norm="backward")
ihfft(a, n=None, axis=-1, norm="backward")
fftn(a, s=None, axes=None, norm="backward")
ifftn(a, s=None, axes=None, norm="backward")
rfftn(a, s=None, axes=None, norm="backward")
irfftn(a, s=None, axes=None, norm="backward")
fft2(a, s=None, axes=(-2,-1), norm="backward")
ifft2(a, s=None, axes=(-2, -1), norm="backward")
rfft2(a, s=None, axes=(-2,-1), norm="backward")
irfft2(a, s=None, axes=(-2, -1), norm="backward")

i = inverse transform
r = transform of purely real data
h = Hermite transform
n = n-dimensional transform
2 = 2-dimensional transform
(Note: 2D routines are just nD routines with different default
behavior.)</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a1ccb797bb0d4b68f1ae509eb5fccf41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccb797bb0d4b68f1ae509eb5fccf41f">&#9670;&nbsp;</a></span>fft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.fft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the one-dimensional discrete Fourier Transform.

This function computes the one-dimensional *n*-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [CT].

Parameters
----------
a : array_like
    Input array, can be complex.
n : int, optional
    Length of the transformed axis of the output.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros.  If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the FFT.  If not given, the last axis is
    used.
norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.
out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype.

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.

Raises
------
IndexError
    If `axis` is not a valid axis of `a`.

See Also
--------
numpy.fft : for definition of the DFT and conventions used.
ifft : The inverse of `fft`.
fft2 : The two-dimensional FFT.
fftn : The *n*-dimensional FFT.
rfftn : The *n*-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.

Notes
-----
FFT (Fast Fourier Transform) refers to a way the discrete Fourier
Transform (DFT) can be calculated efficiently, by using symmetries in the
calculated terms.  The symmetry is highest when `n` is a power of 2, and
the transform is therefore most efficient for these sizes.

The DFT is defined, with the conventions used in this implementation, in
the documentation for the `numpy.fft` module.

References
----------
.. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
        machine calculation of complex Fourier series," *Math. Comput.*
        19: 297-301.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])

In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part, as described in
the `numpy.fft` documentation:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.arange(256)
&gt;&gt;&gt; sp = np.fft.fft(np.sin(t))
&gt;&gt;&gt; freq = np.fft.fftfreq(t.shape[-1])
&gt;&gt;&gt; plt.plot(freq, sp.real, freq, sp.imag)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;, &lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.show()</pre> 
</div>
</div>
<a id="ae1c5674e89b7fb31cb69fe08e8e8a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c5674e89b7fb31cb69fe08e8e8a4dd">&#9670;&nbsp;</a></span>fft2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.fft2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>(-2,&#160;-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the 2-dimensional discrete Fourier Transform.

This function computes the *n*-dimensional discrete Fourier Transform
over any axes in an *M*-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.

Parameters
----------
a : array_like
    Input array, can be complex
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``fft(x, n)``.
    Along each axis, if the given shape is smaller than that of the input,
    the input is cropped. If it is larger, the input is padded with zeros.

    .. versionchanged:: 2.0

        If it is ``-1``, the whole input is used (no padding/trimming).

    If `s` is not given, the shape of the input along the axes specified
    by `axes` is used.

    .. deprecated:: 2.0

        If `s` is not ``None``, `axes` must not be ``None`` either.

    .. deprecated:: 2.0

        `s` must contain only ``int`` s, not ``None`` values. ``None``
        values currently mean that the default value for ``n`` is used
        in the corresponding 1-D transform, but this behaviour is
        deprecated.

axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last two
    axes are used.  A repeated index in `axes` means the transform over
    that axis is performed multiple times.  A one-element sequence means
    that a one-dimensional FFT is performed. Default: ``(-2, -1)``.

    .. deprecated:: 2.0

        If `s` is specified, the corresponding `axes` to be transformed
        must not be ``None``.

norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype for all axes (and hence only the
    last axis can have ``s`` not equal to the shape at that axis).

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or the last two axes if `axes` is not given.

Raises
------
ValueError
    If `s` and `axes` have different length, or `axes` not given and
    ``len(s) != 2``.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
ifft2 : The inverse two-dimensional FFT.
fft : The one-dimensional FFT.
fftn : The *n*-dimensional FFT.
fftshift : Shifts zero-frequency terms to the center of the array.
    For two-dimensional input, swaps first and third quadrants, and second
    and fourth quadrants.

Notes
-----
`fft2` is just `fftn` with a different default for `axes`.

The output, analogously to `fft`, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.

See `fftn` for details and a plotting example, and `numpy.fft` for
definitions and conventions used.


Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.mgrid[:5, :5][0]
&gt;&gt;&gt; np.fft.fft2(a)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ]])</pre> 
</div>
</div>
<a id="a9d5f4b12ac497a08717eccaaa0e24494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5f4b12ac497a08717eccaaa0e24494">&#9670;&nbsp;</a></span>fftn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.fftn </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the N-dimensional discrete Fourier Transform.

This function computes the *N*-dimensional discrete Fourier Transform over
any number of axes in an *M*-dimensional array by means of the Fast Fourier
Transform (FFT).

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``fft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped. If it is larger, the input is padded with zeros.

    .. versionchanged:: 2.0

        If it is ``-1``, the whole input is used (no padding/trimming).

    If `s` is not given, the shape of the input along the axes specified
    by `axes` is used.

    .. deprecated:: 2.0

        If `s` is not ``None``, `axes` must not be ``None`` either.

    .. deprecated:: 2.0

        `s` must contain only ``int`` s, not ``None`` values. ``None``
        values currently mean that the default value for ``n`` is used
        in the corresponding 1-D transform, but this behaviour is
        deprecated.

axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the transform over that axis is
    performed multiple times.

    .. deprecated:: 2.0

        If `s` is specified, the corresponding `axes` to be transformed
        must be explicitly specified too.

norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype for all axes (and hence is
    incompatible with passing in all but the trivial ``s``).

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` and `a`,
    as explained in the parameters section above.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
    and conventions used.
ifftn : The inverse of `fftn`, the inverse *n*-dimensional FFT.
fft : The one-dimensional FFT, with definitions and conventions used.
rfftn : The *n*-dimensional FFT of real input.
fft2 : The two-dimensional FFT.
fftshift : Shifts zero-frequency terms to centre of array

Notes
-----
The output, analogously to `fft`, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.

See `numpy.fft` for details, definitions and conventions used.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.mgrid[:3, :3, :3][0]
&gt;&gt;&gt; np.fft.fftn(a, axes=(1, 2))
array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]],
       [[ 9.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]],
       [[18.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]]])
&gt;&gt;&gt; np.fft.fftn(a, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
        [ 0.+0.j,  0.+0.j,  0.+0.j]],
       [[-2.+0.j, -2.+0.j, -2.+0.j],
        [ 0.+0.j,  0.+0.j,  0.+0.j]]])

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
&gt;&gt;&gt; S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
&gt;&gt;&gt; FS = np.fft.fftn(S)
&gt;&gt;&gt; plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))
&lt;matplotlib.image.AxesImage object at 0x...&gt;
&gt;&gt;&gt; plt.show()</pre> 
</div>
</div>
<a id="aa773290d8844f1e9c573b3d4e063d22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa773290d8844f1e9c573b3d4e063d22c">&#9670;&nbsp;</a></span>hfft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.hfft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.

Parameters
----------
a : array_like
    The input array.
n : int, optional
    Length of the transformed axis of the output. For `n` output
    points, ``n//2 + 1`` input points are necessary.  If the input is
    longer than this, it is cropped.  If it is shorter than this, it is
    padded with zeros.  If `n` is not given, it is taken to be ``2*(m-1)``
    where ``m`` is the length of the input along the axis specified by
    `axis`.
axis : int, optional
    Axis over which to compute the FFT. If not given, the last
    axis is used.
norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype.

    .. versionadded:: 2.0.0

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    The length of the transformed axis is `n`, or, if `n` is not given,
    ``2*m - 2`` where ``m`` is the length of the transformed axis of
    the input. To get an odd number of output points, `n` must be
    specified, for instance as ``2*m - 1`` in the typical case,

Raises
------
IndexError
    If `axis` is not a valid axis of `a`.

See also
--------
rfft : Compute the one-dimensional FFT for real input.
ihfft : The inverse of `hfft`.

Notes
-----
`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's `hfft` for
which you must supply the length of the result if it is to be odd.

* even: ``ihfft(hfft(a, 2*len(a) - 2)) == a``, within roundoff error,
* odd: ``ihfft(hfft(a, 2*len(a) - 1)) == a``, within roundoff error.

The correct interpretation of the hermitian input depends on the length of
the original data, as given by `n`. This is because each input shape could
correspond to either an odd or even length signal. By default, `hfft`
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
shape of the full signal **must** be given.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; signal = np.array([1, 2, 3, 4, 3, 2])
&gt;&gt;&gt; np.fft.fft(signal)
array([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary
&gt;&gt;&gt; np.fft.hfft(signal[:4]) # Input first half of signal
array([15.,  -4.,   0.,  -1.,   0.,  -4.])
&gt;&gt;&gt; np.fft.hfft(signal, 6)  # Input entire signal and truncate
array([15.,  -4.,   0.,  -1.,   0.,  -4.])


&gt;&gt;&gt; signal = np.array([[1, 1.j], [-1.j, 2]])
&gt;&gt;&gt; np.conj(signal.T) - signal   # check Hermitian symmetry
array([[ 0.-0.j,  -0.+0.j], # may vary
       [ 0.+0.j,  0.-0.j]])
&gt;&gt;&gt; freq_spectrum = np.fft.hfft(signal)
&gt;&gt;&gt; freq_spectrum
array([[ 1.,  1.],
       [ 2., -2.]])</pre> 
</div>
</div>
<a id="a9a9a46e7316c4656e2cb9262f517cbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9a46e7316c4656e2cb9262f517cbec">&#9670;&nbsp;</a></span>ifft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.ifft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the one-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the one-dimensional *n*-point
discrete Fourier transform computed by `fft`.  In other words,
``ifft(fft(a)) == a`` to within numerical accuracy.
For a general description of the algorithm and definitions,
see `numpy.fft`.

The input should be ordered in the same way as is returned by `fft`,
i.e.,

* ``a[0]`` should contain the zero frequency term,
* ``a[1:n//2]`` should contain the positive-frequency terms,
* ``a[n//2 + 1:]`` should contain the negative-frequency terms, in
  increasing order starting from the most negative frequency.

For an even number of input points, ``A[n//2]`` represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See `numpy.fft` for details.

Parameters
----------
a : array_like
    Input array, can be complex.
n : int, optional
    Length of the transformed axis of the output.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros.  If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
    See notes about padding issues.
axis : int, optional
    Axis over which to compute the inverse DFT.  If not given, the last
    axis is used.
norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype.

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.

Raises
------
IndexError
    If `axis` is not a valid axis of `a`.

See Also
--------
numpy.fft : An introduction, with definitions and general explanations.
fft : The one-dimensional (forward) FFT, of which `ifft` is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.

Notes
-----
If the input parameter `n` is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling `ifft`.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary

Create and plot a band-limited signal with random phases:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.arange(400)
&gt;&gt;&gt; n = np.zeros((400,), dtype=complex)
&gt;&gt;&gt; n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))
&gt;&gt;&gt; s = np.fft.ifft(n)
&gt;&gt;&gt; plt.plot(t, s.real, label='real')
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; plt.plot(t, s.imag, '--', label='imaginary')
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; plt.legend()
&lt;matplotlib.legend.Legend object at ...&gt;
&gt;&gt;&gt; plt.show()</pre> 
</div>
</div>
<a id="a708bdfd7600e7c2eaa05b0ef328022df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708bdfd7600e7c2eaa05b0ef328022df">&#9670;&nbsp;</a></span>ifft2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.ifft2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>(-2,&#160;-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the 2-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.

The input, analogously to `ifft`, should be ordered in the same way as is
returned by `fft2`, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each axis) of the output (``s[0]`` refers to axis 0,
    ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.
    Along each axis, if the given shape is smaller than that of the input,
    the input is cropped. If it is larger, the input is padded with zeros.

    .. versionchanged:: 2.0

        If it is ``-1``, the whole input is used (no padding/trimming).

    If `s` is not given, the shape of the input along the axes specified
    by `axes` is used.  See notes for issue on `ifft` zero padding.

    .. deprecated:: 2.0

        If `s` is not ``None``, `axes` must not be ``None`` either.

    .. deprecated:: 2.0

        `s` must contain only ``int`` s, not ``None`` values. ``None``
        values currently mean that the default value for ``n`` is used
        in the corresponding 1-D transform, but this behaviour is
        deprecated.

axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last two
    axes are used.  A repeated index in `axes` means the transform over
    that axis is performed multiple times.  A one-element sequence means
    that a one-dimensional FFT is performed. Default: ``(-2, -1)``.

    .. deprecated:: 2.0

        If `s` is specified, the corresponding `axes` to be transformed
        must not be ``None``.

norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype for all axes (and hence is
    incompatible with passing in all but the trivial ``s``).

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or the last two axes if `axes` is not given.

Raises
------
ValueError
    If `s` and `axes` have different length, or `axes` not given and
    ``len(s) != 2``.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
fft2 : The forward 2-dimensional FFT, of which `ifft2` is the inverse.
ifftn : The inverse of the *n*-dimensional FFT.
fft : The one-dimensional FFT.
ifft : The one-dimensional inverse FFT.

Notes
-----
`ifft2` is just `ifftn` with a different default for `axes`.

See `ifftn` for details and a plotting example, and `numpy.fft` for
definition and conventions used.

Zero-padding, analogously with `ifft`, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before `ifft2` is called.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = 4 * np.eye(4)
&gt;&gt;&gt; np.fft.ifft2(a)
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])</pre> 
</div>
</div>
<a id="a17819dbb61d7f3ad805390af815adef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17819dbb61d7f3ad805390af815adef7">&#9670;&nbsp;</a></span>ifftn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.ifftn </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the N-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
``ifftn(fftn(a)) == a`` to within numerical accuracy.
For a description of the definitions and conventions used, see `numpy.fft`.

The input, analogously to `ifft`, should be ordered in the same way as is
returned by `fftn`, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``ifft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped. If it is larger, the input is padded with zeros.

    .. versionchanged:: 2.0

        If it is ``-1``, the whole input is used (no padding/trimming).

    If `s` is not given, the shape of the input along the axes specified
    by `axes` is used. See notes for issue on `ifft` zero padding.

    .. deprecated:: 2.0

        If `s` is not ``None``, `axes` must not be ``None`` either.

    .. deprecated:: 2.0

        `s` must contain only ``int`` s, not ``None`` values. ``None``
        values currently mean that the default value for ``n`` is used
        in the corresponding 1-D transform, but this behaviour is
        deprecated.

axes : sequence of ints, optional
    Axes over which to compute the IFFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the inverse transform over that
    axis is performed multiple times.

    .. deprecated:: 2.0

        If `s` is specified, the corresponding `axes` to be transformed
        must be explicitly specified too.

norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype for all axes (and hence is
    incompatible with passing in all but the trivial ``s``).

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` or `a`,
    as explained in the parameters section above.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
fftn : The forward *n*-dimensional FFT, of which `ifftn` is the inverse.
ifft : The one-dimensional inverse FFT.
ifft2 : The two-dimensional inverse FFT.
ifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning
    of array.

Notes
-----
See `numpy.fft` for definitions and conventions used.

Zero-padding, analogously with `ifft`, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before `ifftn` is called.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.eye(4)
&gt;&gt;&gt; np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])


Create and plot an image with band-limited frequency content:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; n = np.zeros((200,200), dtype=complex)
&gt;&gt;&gt; n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))
&gt;&gt;&gt; im = np.fft.ifftn(n).real
&gt;&gt;&gt; plt.imshow(im)
&lt;matplotlib.image.AxesImage object at 0x...&gt;
&gt;&gt;&gt; plt.show()</pre> 
</div>
</div>
<a id="a7147b00e83f4d3246459e1bec3bd3b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7147b00e83f4d3246459e1bec3bd3b57">&#9670;&nbsp;</a></span>ihfft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.ihfft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the inverse FFT of a signal that has Hermitian symmetry.

Parameters
----------
a : array_like
    Input array.
n : int, optional
    Length of the inverse FFT, the number of points along
    transformation axis in the input to use.  If `n` is smaller than
    the length of the input, the input is cropped.  If it is larger,
    the input is padded with zeros. If `n` is not given, the length of
    the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the inverse FFT. If not given, the last
    axis is used.
norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype.

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    The length of the transformed axis is ``n//2 + 1``.

See also
--------
hfft, irfft

Notes
-----
`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's `hfft` for
which you must supply the length of the result if it is to be odd:

* even: ``ihfft(hfft(a, 2*len(a) - 2)) == a``, within roundoff error,
* odd: ``ihfft(hfft(a, 2*len(a) - 1)) == a``, within roundoff error.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; spectrum = np.array([ 15, -4, 0, -1, 0, -4])
&gt;&gt;&gt; np.fft.ifft(spectrum)
array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
&gt;&gt;&gt; np.fft.ihfft(spectrum)
array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary</pre> 
</div>
</div>
<a id="a6fc450630e6b434f00092a6296db6223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc450630e6b434f00092a6296db6223">&#9670;&nbsp;</a></span>irfft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.irfft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the inverse of `rfft`.

This function computes the inverse of the one-dimensional *n*-point
discrete Fourier Transform of real input computed by `rfft`.
In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical
accuracy. (See Notes below for why ``len(a)`` is necessary here.)

The input is expected to be in the form returned by `rfft`, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.

Parameters
----------
a : array_like
    The input array.
n : int, optional
    Length of the transformed axis of the output.
    For `n` output points, ``n//2+1`` input points are necessary.  If the
    input is longer than this, it is cropped.  If it is shorter than this,
    it is padded with zeros.  If `n` is not given, it is taken to be
    ``2*(m-1)`` where ``m`` is the length of the input along the axis
    specified by `axis`.
axis : int, optional
    Axis over which to compute the inverse FFT. If not given, the last
    axis is used.
norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype.

    .. versionadded:: 2.0.0

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    The length of the transformed axis is `n`, or, if `n` is not given,
    ``2*(m-1)`` where ``m`` is the length of the transformed axis of the
    input. To get an odd number of output points, `n` must be specified.

Raises
------
IndexError
    If `axis` is not a valid axis of `a`.

See Also
--------
numpy.fft : For definition of the DFT and conventions used.
rfft : The one-dimensional FFT of real input, of which `irfft` is inverse.
fft : The one-dimensional FFT.
irfft2 : The inverse of the two-dimensional FFT of real input.
irfftn : The inverse of the *n*-dimensional FFT of real input.

Notes
-----
Returns the real valued `n`-point inverse discrete Fourier transform
of `a`, where `a` contains the non-negative frequency terms of a
Hermitian-symmetric sequence. `n` is the length of the result, not the
input.

If you specify an `n` such that `a` must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to `m` points via Fourier interpolation by:
``a_resamp = irfft(rfft(a), m)``.

The correct interpretation of the hermitian input depends on the length of
the original data, as given by `n`. This is because each input shape could
correspond to either an odd or even length signal. By default, `irfft`
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
correct length of the real input **must** be given.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
&gt;&gt;&gt; np.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.])

Notice how the last term in the input to the ordinary `ifft` is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling `irfft`, the negative frequencies are not
specified, and the output array is purely real.</pre> 
</div>
</div>
<a id="ae20518d8aa726e3053a6ba792afe780a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20518d8aa726e3053a6ba792afe780a">&#9670;&nbsp;</a></span>irfft2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.irfft2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>(-2,&#160;-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the inverse of `rfft2`.

Parameters
----------
a : array_like
    The input array
s : sequence of ints, optional
    Shape of the real output to the inverse FFT.

    .. versionchanged:: 2.0

        If it is ``-1``, the whole input is used (no padding/trimming).

    .. deprecated:: 2.0

        If `s` is not ``None``, `axes` must not be ``None`` either.

    .. deprecated:: 2.0

        `s` must contain only ``int`` s, not ``None`` values. ``None``
        values currently mean that the default value for ``n`` is used
        in the corresponding 1-D transform, but this behaviour is
        deprecated.

axes : sequence of ints, optional
    The axes over which to compute the inverse fft.
    Default: ``(-2, -1)``, the last two axes.

    .. deprecated:: 2.0

        If `s` is specified, the corresponding `axes` to be transformed
        must not be ``None``.

norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype for the last transformation.

    .. versionadded:: 2.0.0

Returns
-------
out : ndarray
    The result of the inverse real 2-D FFT.

See Also
--------
rfft2 : The forward two-dimensional FFT of real input,
        of which `irfft2` is the inverse.
rfft : The one-dimensional FFT for real input.
irfft : The inverse of the one-dimensional FFT of real input.
irfftn : Compute the inverse of the N-dimensional FFT of real input.

Notes
-----
This is really `irfftn` with different defaults.
For more details see `irfftn`.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.mgrid[:5, :5][0]
&gt;&gt;&gt; A = np.fft.rfft2(a)
&gt;&gt;&gt; np.fft.irfft2(A, s=a.shape)
array([[0., 0., 0., 0., 0.],
       [1., 1., 1., 1., 1.],
       [2., 2., 2., 2., 2.],
       [3., 3., 3., 3., 3.],
       [4., 4., 4., 4., 4.]])
</pre> 
</div>
</div>
<a id="a70970da42e3f49491aad9a612dabe128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70970da42e3f49491aad9a612dabe128">&#9670;&nbsp;</a></span>irfftn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.irfftn </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the inverse of `rfftn`.

This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical
accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,
and for the same reason.)

The input should be ordered in the same way as is returned by `rfftn`,
i.e. as for `irfft` for the final transformation axis, and as for `ifftn`
along all the other axes.

Parameters
----------
a : array_like
    Input array.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the
    number of input points used along this axis, except for the last axis,
    where ``s[-1]//2+1`` points of the input are used.
    Along any axis, if the shape indicated by `s` is smaller than that of
    the input, the input is cropped.  If it is larger, the input is padded
    with zeros.

    .. versionchanged:: 2.0

        If it is ``-1``, the whole input is used (no padding/trimming).

    If `s` is not given, the shape of the input along the axes
    specified by axes is used. Except for the last axis which is taken to
    be ``2*(m-1)`` where ``m`` is the length of the input along that axis.

    .. deprecated:: 2.0

        If `s` is not ``None``, `axes` must not be ``None`` either.

    .. deprecated:: 2.0

        `s` must contain only ``int`` s, not ``None`` values. ``None``
        values currently mean that the default value for ``n`` is used
        in the corresponding 1-D transform, but this behaviour is
        deprecated.

axes : sequence of ints, optional
    Axes over which to compute the inverse FFT. If not given, the last
    `len(s)` axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the inverse transform over that
    axis is performed multiple times.

    .. deprecated:: 2.0

        If `s` is specified, the corresponding `axes` to be transformed
        must be explicitly specified too.

norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype for the last transformation.

    .. versionadded:: 2.0.0

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` or `a`,
    as explained in the parameters section above.
    The length of each transformed axis is as given by the corresponding
    element of `s`, or the length of the input in every axis except for the
    last one if `s` is not given.  In the final transformed axis the length
    of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the
    length of the final transformed axis of the input.  To get an odd
    number of output points in the final axis, `s` must be specified.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
rfftn : The forward n-dimensional FFT of real input,
        of which `ifftn` is the inverse.
fft : The one-dimensional FFT, with definitions and conventions used.
irfft : The inverse of the one-dimensional FFT of real input.
irfft2 : The inverse of the two-dimensional FFT of real input.

Notes
-----
See `fft` for definitions and conventions used.

See `rfft` for definitions and conventions used for real input.

The correct interpretation of the hermitian input depends on the shape of
the original data, as given by `s`. This is because each input shape could
correspond to either an odd or even length signal. By default, `irfftn`
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. When performing the
final complex to real transform, the last value is thus treated as purely
real. To avoid losing information, the correct shape of the real input
**must** be given.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.zeros((3, 2, 2))
&gt;&gt;&gt; a[0, 0, 0] = 3 * 2 * 2
&gt;&gt;&gt; np.fft.irfftn(a)
array([[[1.,  1.],
        [1.,  1.]],
       [[1.,  1.],
        [1.,  1.]],
       [[1.,  1.],
        [1.,  1.]]])</pre> 
</div>
</div>
<a id="a57516413deef042a84558ee366ce479a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57516413deef042a84558ee366ce479a">&#9670;&nbsp;</a></span>rfft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.rfft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the one-dimensional discrete Fourier Transform for real input.

This function computes the one-dimensional *n*-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).

Parameters
----------
a : array_like
    Input array
n : int, optional
    Number of points along transformation axis in the input to use.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros. If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the FFT. If not given, the last axis is
    used.
norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype.

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    If `n` is even, the length of the transformed axis is ``(n/2)+1``.
    If `n` is odd, the length is ``(n+1)/2``.

Raises
------
IndexError
    If `axis` is not a valid axis of `a`.

See Also
--------
numpy.fft : For definition of the DFT and conventions used.
irfft : The inverse of `rfft`.
fft : The one-dimensional FFT of general (complex) input.
fftn : The *n*-dimensional FFT.
rfftn : The *n*-dimensional FFT of real input.

Notes
-----
When the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is therefore ``n//2 + 1``.

When ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.

If `n` is even, ``A[-1]`` contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.

If the input `a` contains an imaginary part, it is silently discarded.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.fft.fft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
&gt;&gt;&gt; np.fft.rfft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary

Notice how the final element of the `fft` output is the complex conjugate
of the second element, for real input. For `rfft`, this symmetry is
exploited to compute only the non-negative frequency terms.</pre> 
</div>
</div>
<a id="ae848712488b3b585999b793d58d6e944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae848712488b3b585999b793d58d6e944">&#9670;&nbsp;</a></span>rfft2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.rfft2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>(-2,&#160;-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the 2-dimensional FFT of a real array.

Parameters
----------
a : array
    Input array, taken to be real.
s : sequence of ints, optional
    Shape of the FFT.

    .. versionchanged:: 2.0

        If it is ``-1``, the whole input is used (no padding/trimming).

    .. deprecated:: 2.0

        If `s` is not ``None``, `axes` must not be ``None`` either.

    .. deprecated:: 2.0

        `s` must contain only ``int`` s, not ``None`` values. ``None``
        values currently mean that the default value for ``n`` is used
        in the corresponding 1-D transform, but this behaviour is
        deprecated.

axes : sequence of ints, optional
    Axes over which to compute the FFT. Default: ``(-2, -1)``.

    .. deprecated:: 2.0

        If `s` is specified, the corresponding `axes` to be transformed
        must not be ``None``.

norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype for the last inverse transform.
    incompatible with passing in all but the trivial ``s``).

    .. versionadded:: 2.0.0

Returns
-------
out : ndarray
    The result of the real 2-D FFT.

See Also
--------
rfftn : Compute the N-dimensional discrete Fourier Transform for real
        input.

Notes
-----
This is really just `rfftn` with different default behavior.
For more details see `rfftn`.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.mgrid[:5, :5][0]
&gt;&gt;&gt; np.fft.rfft2(a)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        ],
       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ],
       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],
       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],
       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ]])
</pre> 
</div>
</div>
<a id="aa1b013deb378336c1591e58c8442da4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b013deb378336c1591e58c8442da4e">&#9670;&nbsp;</a></span>rfftn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.fft._pocketfft.rfftn </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the N-dimensional discrete Fourier Transform for real input.

This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.

Parameters
----------
a : array_like
    Input array, taken to be real.
s : sequence of ints, optional
    Shape (length along each transformed axis) to use from the input.
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    The final element of `s` corresponds to `n` for ``rfft(x, n)``, while
    for the remaining axes, it corresponds to `n` for ``fft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped. If it is larger, the input is padded with zeros.

    .. versionchanged:: 2.0

        If it is ``-1``, the whole input is used (no padding/trimming).

    If `s` is not given, the shape of the input along the axes specified
    by `axes` is used.

    .. deprecated:: 2.0

        If `s` is not ``None``, `axes` must not be ``None`` either.

    .. deprecated:: 2.0

        `s` must contain only ``int`` s, not ``None`` values. ``None``
        values currently mean that the default value for ``n`` is used
        in the corresponding 1-D transform, but this behaviour is
        deprecated.

axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.

    .. deprecated:: 2.0

        If `s` is specified, the corresponding `axes` to be transformed
        must be explicitly specified too.

norm : {"backward", "ortho", "forward"}, optional
    Normalization mode (see `numpy.fft`). Default is "backward".
    Indicates which direction of the forward/backward pair of transforms
    is scaled and with what normalization factor.

    .. versionadded:: 1.20.0

        The "backward", "forward" values were added.

out : complex ndarray, optional
    If provided, the result will be placed in this array. It should be
    of the appropriate shape and dtype for all axes (and hence is
    incompatible with passing in all but the trivial ``s``).

    .. versionadded:: 2.0.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` and `a`,
    as explained in the parameters section above.
    The length of the last axis transformed will be ``s[-1]//2+1``,
    while the remaining transformed axes will have lengths according to
    `s`, or unchanged from the input.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
irfftn : The inverse of `rfftn`, i.e. the inverse of the n-dimensional FFT
     of real input.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : The one-dimensional FFT of real input.
fftn : The n-dimensional FFT.
rfft2 : The two-dimensional FFT of real input.

Notes
-----
The transform for real input is performed over the last transformation
axis, as by `rfft`, then the transform over the remaining axes is
performed as by `fftn`.  The order of the output is as for `rfft` for the
final transformation axis, and as for `fftn` for the remaining
transformation axes.

See `fft` for details, definitions and conventions used.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.ones((2, 2, 2))
&gt;&gt;&gt; np.fft.rfftn(a)
array([[[8.+0.j,  0.+0.j], # may vary
        [0.+0.j,  0.+0.j]],
       [[0.+0.j,  0.+0.j],
        [0.+0.j,  0.+0.j]]])

&gt;&gt;&gt; np.fft.rfftn(a, axes=(2, 0))
array([[[4.+0.j,  0.+0.j], # may vary
        [4.+0.j,  0.+0.j]],
       [[0.+0.j,  0.+0.j],
        [0.+0.j,  0.+0.j]]])</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac165d2501f6b926b97841274eec90812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac165d2501f6b926b97841274eec90812">&#9670;&nbsp;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.fft._pocketfft.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  functools.partial(</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy.fft&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
