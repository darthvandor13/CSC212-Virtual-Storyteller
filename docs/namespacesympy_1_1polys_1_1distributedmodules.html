<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.polys.distributedmodules Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys.html">polys</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html">distributedmodules</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.polys.distributedmodules Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a52f91d50b3c747626672df32fc99e167"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a52f91d50b3c747626672df32fc99e167">sdm_monomial_mul</a> (M, X)</td></tr>
<tr class="separator:a52f91d50b3c747626672df32fc99e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbdbe95b69948aa0ea8788f59717154"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#abfbdbe95b69948aa0ea8788f59717154">sdm_monomial_deg</a> (M)</td></tr>
<tr class="separator:abfbdbe95b69948aa0ea8788f59717154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97969b563c735fba9ff6c8824916a5a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a97969b563c735fba9ff6c8824916a5a5">sdm_monomial_lcm</a> (A, B)</td></tr>
<tr class="separator:a97969b563c735fba9ff6c8824916a5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558ab90285cf14c70a7ca68ca120e003"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a558ab90285cf14c70a7ca68ca120e003">sdm_monomial_divides</a> (A, B)</td></tr>
<tr class="separator:a558ab90285cf14c70a7ca68ca120e003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a57accc225810ed593caca4503941c8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a1a57accc225810ed593caca4503941c8">sdm_LC</a> (f, K)</td></tr>
<tr class="separator:a1a57accc225810ed593caca4503941c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fe10d7d9051910b1a17b9f40d4fe4c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#ac7fe10d7d9051910b1a17b9f40d4fe4c">sdm_to_dict</a> (f)</td></tr>
<tr class="separator:ac7fe10d7d9051910b1a17b9f40d4fe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9fa3290a9f555007ccc63450b00793"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#abf9fa3290a9f555007ccc63450b00793">sdm_from_dict</a> (d, O)</td></tr>
<tr class="separator:abf9fa3290a9f555007ccc63450b00793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1df6e7797fbee28c09361c9798cbc3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a5c1df6e7797fbee28c09361c9798cbc3">sdm_sort</a> (f, O)</td></tr>
<tr class="separator:a5c1df6e7797fbee28c09361c9798cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8be865ffcf82377ab63ec9797f44bde"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#aa8be865ffcf82377ab63ec9797f44bde">sdm_strip</a> (f)</td></tr>
<tr class="separator:aa8be865ffcf82377ab63ec9797f44bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6e822d9bc3e032c5835cf8e85deea8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a1f6e822d9bc3e032c5835cf8e85deea8">sdm_add</a> (f, g, O, K)</td></tr>
<tr class="separator:a1f6e822d9bc3e032c5835cf8e85deea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae444bb78b03a2b7917fae37240480f74"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#ae444bb78b03a2b7917fae37240480f74">sdm_LM</a> (f)</td></tr>
<tr class="separator:ae444bb78b03a2b7917fae37240480f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ef4b407e3d13d5384ddb796bb8759"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a398ef4b407e3d13d5384ddb796bb8759">sdm_LT</a> (f)</td></tr>
<tr class="separator:a398ef4b407e3d13d5384ddb796bb8759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c2bc0e56535feb623518cdd28b8c33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#ab1c2bc0e56535feb623518cdd28b8c33">sdm_mul_term</a> (f, term, O, K)</td></tr>
<tr class="separator:ab1c2bc0e56535feb623518cdd28b8c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc03bb8e8d54c8d720403a7e34e5025"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#aacc03bb8e8d54c8d720403a7e34e5025">sdm_zero</a> ()</td></tr>
<tr class="separator:aacc03bb8e8d54c8d720403a7e34e5025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987f8b3e0ad7da809224a3238e2bf43a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a987f8b3e0ad7da809224a3238e2bf43a">sdm_deg</a> (f)</td></tr>
<tr class="separator:a987f8b3e0ad7da809224a3238e2bf43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe2d32bc1f7ebb56a323c94189d3c4d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a8fe2d32bc1f7ebb56a323c94189d3c4d">sdm_from_vector</a> (vec, O, K, **opts)</td></tr>
<tr class="separator:a8fe2d32bc1f7ebb56a323c94189d3c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdbb2cd053f68b4a6c97e92e23e932b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#aabdbb2cd053f68b4a6c97e92e23e932b">sdm_to_vector</a> (f, gens, K, n=None)</td></tr>
<tr class="separator:aabdbb2cd053f68b4a6c97e92e23e932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589b26fc0d90df22bd529c0b19766315"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a589b26fc0d90df22bd529c0b19766315">sdm_spoly</a> (f, g, O, K, phantom=None)</td></tr>
<tr class="separator:a589b26fc0d90df22bd529c0b19766315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9889926b9a6a4e94085c1b4baba0a67b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a9889926b9a6a4e94085c1b4baba0a67b">sdm_ecart</a> (f)</td></tr>
<tr class="separator:a9889926b9a6a4e94085c1b4baba0a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026c3c1481947918976327e28b303b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#ae026c3c1481947918976327e28b303b7">sdm_nf_mora</a> (f, G, O, K, phantom=None)</td></tr>
<tr class="separator:ae026c3c1481947918976327e28b303b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e970aa9c207a037dcb05f8c36da3cab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a2e970aa9c207a037dcb05f8c36da3cab">sdm_nf_buchberger</a> (f, G, O, K, phantom=None)</td></tr>
<tr class="separator:a2e970aa9c207a037dcb05f8c36da3cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa35f443fbb53573831fb2d12da8736"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#aafa35f443fbb53573831fb2d12da8736">sdm_nf_buchberger_reduced</a> (f, G, O, K)</td></tr>
<tr class="separator:aafa35f443fbb53573831fb2d12da8736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a853e5e53a28ad2d61d22d271433b19"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1polys_1_1distributedmodules.html#a1a853e5e53a28ad2d61d22d271433b19">sdm_groebner</a> (G, NF, O, K, extended=False)</td></tr>
<tr class="separator:a1a853e5e53a28ad2d61d22d271433b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Sparse distributed elements of free modules over multivariate (generalized)
polynomial rings.

This code and its data structures are very much like the distributed
polynomials, except that the first "exponent" of the monomial is
a module generator index. That is, the multi-exponent ``(i, e_1, ..., e_n)``
represents the "monomial" `x_1^{e_1} \cdots x_n^{e_n} f_i` of the free module
`F` generated by `f_1, \ldots, f_r` over (a localization of) the ring
`K[x_1, \ldots, x_n]`. A module element is simply stored as a list of terms
ordered by the monomial order. Here a term is a pair of a multi-exponent and a
coefficient. In general, this coefficient should never be zero (since it can
then be omitted). The zero module element is stored as an empty list.

The main routines are ``sdm_nf_mora`` and ``sdm_groebner`` which can be used
to compute, respectively, weak normal forms and standard bases. They work with
arbitrary (not necessarily global) monomial orders.

In general, product orders have to be used to construct valid monomial orders
for modules. However, ``lex`` can be used as-is.

Note that the "level" (number of variables, i.e. parameter u+1 in
distributedpolys.py) is never needed in this code.

The main reference for this file is [SCA],
"A Singular Introduction to Commutative Algebra".
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a1f6e822d9bc3e032c5835cf8e85deea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6e822d9bc3e032c5835cf8e85deea8">&#9670;&nbsp;</a></span>sdm_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_add </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add two module elements ``f``, ``g``.

Addition is done over the ground field ``K``, monomials are ordered
according to ``O``.

Examples
========

All examples use lexicographic order.

`(xy f_1) + (f_2) = f_2 + xy f_1`

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_add
&gt;&gt;&gt; from sympy.polys import lex, QQ
&gt;&gt;&gt; sdm_add([((1, 1, 1), QQ(1))], [((2, 0, 0), QQ(1))], lex, QQ)
[((2, 0, 0), 1), ((1, 1, 1), 1)]

`(xy f_1) + (-xy f_1)` = 0`

&gt;&gt;&gt; sdm_add([((1, 1, 1), QQ(1))], [((1, 1, 1), QQ(-1))], lex, QQ)
[]

`(f_1) + (2f_1) = 3f_1`

&gt;&gt;&gt; sdm_add([((1, 0, 0), QQ(1))], [((1, 0, 0), QQ(2))], lex, QQ)
[((1, 0, 0), 3)]

`(yf_1) + (xf_1) = xf_1 + yf_1`

&gt;&gt;&gt; sdm_add([((1, 0, 1), QQ(1))], [((1, 1, 0), QQ(1))], lex, QQ)
[((1, 1, 0), 1), ((1, 0, 1), 1)]
</pre> 
</div>
</div>
<a id="a987f8b3e0ad7da809224a3238e2bf43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987f8b3e0ad7da809224a3238e2bf43a">&#9670;&nbsp;</a></span>sdm_deg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_deg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Degree of ``f``.

This is the maximum of the degrees of all its monomials.
Invalid if ``f`` is zero.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_deg
&gt;&gt;&gt; sdm_deg([((1, 2, 3), 1), ((10, 0, 1), 1), ((2, 3, 4), 4)])
7
</pre> 
</div>
</div>
<a id="a9889926b9a6a4e94085c1b4baba0a67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9889926b9a6a4e94085c1b4baba0a67b">&#9670;&nbsp;</a></span>sdm_ecart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_ecart </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the ecart of ``f``.

This is defined to be the difference of the total degree of `f` and the
total degree of the leading monomial of `f` [SCA, defn 2.3.7].

Invalid if f is zero.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_ecart
&gt;&gt;&gt; sdm_ecart([((1, 2, 3), 1), ((1, 0, 1), 1)])
0
&gt;&gt;&gt; sdm_ecart([((2, 2, 1), 1), ((1, 5, 1), 1)])
3
</pre> 
</div>
</div>
<a id="abf9fa3290a9f555007ccc63450b00793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9fa3290a9f555007ccc63450b00793">&#9670;&nbsp;</a></span>sdm_from_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_from_dict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create an sdm from a dictionary.

Here ``O`` is the monomial order to use.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_from_dict
&gt;&gt;&gt; from sympy.polys import QQ, lex
&gt;&gt;&gt; dic = {(1, 1, 0): QQ(1), (1, 0, 0): QQ(2), (0, 1, 0): QQ(0)}
&gt;&gt;&gt; sdm_from_dict(dic, lex)
[((1, 1, 0), 1), ((1, 0, 0), 2)]
</pre> 
</div>
</div>
<a id="a8fe2d32bc1f7ebb56a323c94189d3c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe2d32bc1f7ebb56a323c94189d3c4d">&#9670;&nbsp;</a></span>sdm_from_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_from_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create an sdm from an iterable of expressions.

Coefficients are created in the ground field ``K``, and terms are ordered
according to monomial order ``O``. Named arguments are passed on to the
polys conversion code and can be used to specify for example generators.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_from_vector
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; from sympy.polys import QQ, lex
&gt;&gt;&gt; sdm_from_vector([x**2+y**2, 2*z], lex, QQ)
[((1, 0, 0, 1), 2), ((0, 2, 0, 0), 1), ((0, 0, 2, 0), 1)]
</pre> 
</div>
</div>
<a id="a1a853e5e53a28ad2d61d22d271433b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a853e5e53a28ad2d61d22d271433b19">&#9670;&nbsp;</a></span>sdm_groebner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_groebner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>NF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extended</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a minimal standard basis of ``G`` with respect to order ``O``.

The algorithm uses a normal form ``NF``, for example ``sdm_nf_mora``.
The ground field is assumed to be ``K``, and monomials ordered according
to ``O``.

Let `N` denote the submodule generated by elements of `G`. A standard
basis for `N` is a subset `S` of `N`, such that `in(S) = in(N)`, where for
any subset `X` of `F`, `in(X)` denotes the submodule generated by the
initial forms of elements of `X`. [SCA, defn 2.3.2]

A standard basis is called minimal if no subset of it is a standard basis.

One may show that standard bases are always generating sets.

Minimal standard bases are not unique. This algorithm computes a
deterministic result, depending on the particular order of `G`.

If ``extended=True``, also compute the transition matrix from the initial
generators to the groebner basis. That is, return a list of coefficient
vectors, expressing the elements of the groebner basis in terms of the
elements of ``G``.

This functions implements the "sugar" strategy, see

Giovini et al: "One sugar cube, please" OR Selection strategies in
Buchberger algorithm.
</pre> 
</div>
</div>
<a id="a1a57accc225810ed593caca4503941c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a57accc225810ed593caca4503941c8">&#9670;&nbsp;</a></span>sdm_LC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_LC </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the leading coefficient of ``f``. </pre> 
</div>
</div>
<a id="ae444bb78b03a2b7917fae37240480f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae444bb78b03a2b7917fae37240480f74">&#9670;&nbsp;</a></span>sdm_LM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_LM </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the leading monomial of ``f``.

Only valid if `f \ne 0`.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_LM, sdm_from_dict
&gt;&gt;&gt; from sympy.polys import QQ, lex
&gt;&gt;&gt; dic = {(1, 2, 3): QQ(1), (4, 0, 0): QQ(1), (4, 0, 1): QQ(1)}
&gt;&gt;&gt; sdm_LM(sdm_from_dict(dic, lex))
(4, 0, 1)
</pre> 
</div>
</div>
<a id="a398ef4b407e3d13d5384ddb796bb8759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398ef4b407e3d13d5384ddb796bb8759">&#9670;&nbsp;</a></span>sdm_LT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_LT </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the leading term of ``f``.

Only valid if `f \ne 0`.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_LT, sdm_from_dict
&gt;&gt;&gt; from sympy.polys import QQ, lex
&gt;&gt;&gt; dic = {(1, 2, 3): QQ(1), (4, 0, 0): QQ(2), (4, 0, 1): QQ(3)}
&gt;&gt;&gt; sdm_LT(sdm_from_dict(dic, lex))
((4, 0, 1), 3)
</pre> 
</div>
</div>
<a id="abfbdbe95b69948aa0ea8788f59717154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbdbe95b69948aa0ea8788f59717154">&#9670;&nbsp;</a></span>sdm_monomial_deg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_monomial_deg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the total degree of ``M``.

Examples
========

For example, the total degree of `x^2 y f_5` is 3:

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_monomial_deg
&gt;&gt;&gt; sdm_monomial_deg((5, 2, 1))
3
</pre> 
</div>
</div>
<a id="a558ab90285cf14c70a7ca68ca120e003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558ab90285cf14c70a7ca68ca120e003">&#9670;&nbsp;</a></span>sdm_monomial_divides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_monomial_divides </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Does there exist a (polynomial) monomial X such that XA = B?

Examples
========

Positive examples:

In the following examples, the monomial is given in terms of x, y and the
generator(s), f_1, f_2 etc. The tuple form of that monomial is used in
the call to sdm_monomial_divides.
Note: the generator appears last in the expression but first in the tuple
and other factors appear in the same order that they appear in the monomial
expression.

`A = f_1` divides `B = f_1`

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_monomial_divides
&gt;&gt;&gt; sdm_monomial_divides((1, 0, 0), (1, 0, 0))
True

`A = f_1` divides `B = x^2 y f_1`

&gt;&gt;&gt; sdm_monomial_divides((1, 0, 0), (1, 2, 1))
True

`A = xy f_5` divides `B = x^2 y f_5`

&gt;&gt;&gt; sdm_monomial_divides((5, 1, 1), (5, 2, 1))
True

Negative examples:

`A = f_1` does not divide `B = f_2`

&gt;&gt;&gt; sdm_monomial_divides((1, 0, 0), (2, 0, 0))
False

`A = x f_1` does not divide `B = f_1`

&gt;&gt;&gt; sdm_monomial_divides((1, 1, 0), (1, 0, 0))
False

`A = xy^2 f_5` does not divide `B = y f_5`

&gt;&gt;&gt; sdm_monomial_divides((5, 1, 2), (5, 0, 1))
False
</pre> 
</div>
</div>
<a id="a97969b563c735fba9ff6c8824916a5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97969b563c735fba9ff6c8824916a5a5">&#9670;&nbsp;</a></span>sdm_monomial_lcm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_monomial_lcm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the "least common multiple" of ``A`` and ``B``.

IF `A = M e_j` and `B = N e_j`, where `M` and `N` are polynomial monomials,
this returns `\lcm(M, N) e_j`. Note that ``A`` and ``B`` involve distinct
monomials.

Otherwise the result is undefined.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_monomial_lcm
&gt;&gt;&gt; sdm_monomial_lcm((1, 2, 3), (1, 0, 5))
(1, 2, 5)
</pre> 
</div>
</div>
<a id="a52f91d50b3c747626672df32fc99e167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f91d50b3c747626672df32fc99e167">&#9670;&nbsp;</a></span>sdm_monomial_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_monomial_mul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multiply tuple ``X`` representing a monomial of `K[X]` into the tuple
``M`` representing a monomial of `F`.

Examples
========

Multiplying `xy^3` into `x f_1` yields `x^2 y^3 f_1`:

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_monomial_mul
&gt;&gt;&gt; sdm_monomial_mul((1, 1, 0), (1, 3))
(1, 2, 3)
</pre> 
</div>
</div>
<a id="ab1c2bc0e56535feb623518cdd28b8c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c2bc0e56535feb623518cdd28b8c33">&#9670;&nbsp;</a></span>sdm_mul_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_mul_term </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multiply a distributed module element ``f`` by a (polynomial) term ``term``.

Multiplication of coefficients is done over the ground field ``K``, and
monomials are ordered according to ``O``.

Examples
========

`0 f_1 = 0`

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_mul_term
&gt;&gt;&gt; from sympy.polys import lex, QQ
&gt;&gt;&gt; sdm_mul_term([((1, 0, 0), QQ(1))], ((0, 0), QQ(0)), lex, QQ)
[]

`x 0 = 0`

&gt;&gt;&gt; sdm_mul_term([], ((1, 0), QQ(1)), lex, QQ)
[]

`(x) (f_1) = xf_1`

&gt;&gt;&gt; sdm_mul_term([((1, 0, 0), QQ(1))], ((1, 0), QQ(1)), lex, QQ)
[((1, 1, 0), 1)]

`(2xy) (3x f_1 + 4y f_2) = 8xy^2 f_2 + 6x^2y f_1`

&gt;&gt;&gt; f = [((2, 0, 1), QQ(4)), ((1, 1, 0), QQ(3))]
&gt;&gt;&gt; sdm_mul_term(f, ((1, 1), QQ(2)), lex, QQ)
[((2, 1, 2), 8), ((1, 2, 1), 6)]
</pre> 
</div>
</div>
<a id="a2e970aa9c207a037dcb05f8c36da3cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e970aa9c207a037dcb05f8c36da3cab">&#9670;&nbsp;</a></span>sdm_nf_buchberger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_nf_buchberger </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>phantom</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a weak normal form of ``f`` with respect to ``G`` and order ``O``.

The ground field is assumed to be ``K``, and monomials ordered according to
``O``.

This is the standard Buchberger algorithm for computing weak normal forms with
respect to *global* monomial orders [SCA, algorithm 1.6.10].

If ``phantom`` is not ``None``, it should be a pair of "phantom" arguments
on which to perform the same computations as on ``f``, ``G``, both results
are then returned.
</pre> 
</div>
</div>
<a id="aafa35f443fbb53573831fb2d12da8736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa35f443fbb53573831fb2d12da8736">&#9670;&nbsp;</a></span>sdm_nf_buchberger_reduced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_nf_buchberger_reduced </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a reduced normal form of ``f`` with respect to ``G`` and order ``O``.

The ground field is assumed to be ``K``, and monomials ordered according to
``O``.

In contrast to weak normal forms, reduced normal forms *are* unique, but
their computation is more expensive.

This is the standard Buchberger algorithm for computing reduced normal forms
with respect to *global* monomial orders [SCA, algorithm 1.6.11].

The ``pantom`` option is not supported, so this normal form cannot be used
as a normal form for the "extended" groebner algorithm.
</pre> 
</div>
</div>
<a id="ae026c3c1481947918976327e28b303b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae026c3c1481947918976327e28b303b7">&#9670;&nbsp;</a></span>sdm_nf_mora()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_nf_mora </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>phantom</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a weak normal form of ``f`` with respect to ``G`` and order ``O``.

The ground field is assumed to be ``K``, and monomials ordered according to
``O``.

Weak normal forms are defined in [SCA, defn 2.3.3]. They are not unique.
This function deterministically computes a weak normal form, depending on
the order of `G`.

The most important property of a weak normal form is the following: if
`R` is the ring associated with the monomial ordering (if the ordering is
global, we just have `R = K[x_1, \ldots, x_n]`, otherwise it is a certain
localization thereof), `I` any ideal of `R` and `G` a standard basis for
`I`, then for any `f \in R`, we have `f \in I` if and only if
`NF(f | G) = 0`.

This is the generalized Mora algorithm for computing weak normal forms with
respect to arbitrary monomial orders [SCA, algorithm 2.3.9].

If ``phantom`` is not ``None``, it should be a pair of "phantom" arguments
on which to perform the same computations as on ``f``, ``G``, both results
are then returned.
</pre> 
</div>
</div>
<a id="a5c1df6e7797fbee28c09361c9798cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1df6e7797fbee28c09361c9798cbc3">&#9670;&nbsp;</a></span>sdm_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sort terms in ``f`` using the given monomial order ``O``. </pre> 
</div>
</div>
<a id="a589b26fc0d90df22bd529c0b19766315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589b26fc0d90df22bd529c0b19766315">&#9670;&nbsp;</a></span>sdm_spoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_spoly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>phantom</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the generalized s-polynomial of ``f`` and ``g``.

The ground field is assumed to be ``K``, and monomials ordered according to
``O``.

This is invalid if either of ``f`` or ``g`` is zero.

If the leading terms of `f` and `g` involve different basis elements of
`F`, their s-poly is defined to be zero. Otherwise it is a certain linear
combination of `f` and `g` in which the leading terms cancel.
See [SCA, defn 2.3.6] for details.

If ``phantom`` is not ``None``, it should be a pair of module elements on
which to perform the same operation(s) as on ``f`` and ``g``. The in this
case both results are returned.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_spoly
&gt;&gt;&gt; from sympy.polys import QQ, lex
&gt;&gt;&gt; f = [((2, 1, 1), QQ(1)), ((1, 0, 1), QQ(1))]
&gt;&gt;&gt; g = [((2, 3, 0), QQ(1))]
&gt;&gt;&gt; h = [((1, 2, 3), QQ(1))]
&gt;&gt;&gt; sdm_spoly(f, h, lex, QQ)
[]
&gt;&gt;&gt; sdm_spoly(f, g, lex, QQ)
[((1, 2, 1), 1)]
</pre> 
</div>
</div>
<a id="aa8be865ffcf82377ab63ec9797f44bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8be865ffcf82377ab63ec9797f44bde">&#9670;&nbsp;</a></span>sdm_strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_strip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove terms with zero coefficients from ``f`` in ``K[X]``. </pre> 
</div>
</div>
<a id="ac7fe10d7d9051910b1a17b9f40d4fe4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fe10d7d9051910b1a17b9f40d4fe4c">&#9670;&nbsp;</a></span>sdm_to_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_to_dict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a dictionary from a distributed polynomial. </pre> 
</div>
</div>
<a id="aabdbb2cd053f68b4a6c97e92e23e932b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdbb2cd053f68b4a6c97e92e23e932b">&#9670;&nbsp;</a></span>sdm_to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_to_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert sdm ``f`` into a list of polynomial expressions.

The generators for the polynomial ring are specified via ``gens``. The rank
of the module is guessed, or passed via ``n``. The ground field is assumed
to be ``K``.

Examples
========

&gt;&gt;&gt; from sympy.polys.distributedmodules import sdm_to_vector
&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; from sympy.polys import QQ
&gt;&gt;&gt; f = [((1, 0, 0, 1), QQ(2)), ((0, 2, 0, 0), QQ(1)), ((0, 0, 2, 0), QQ(1))]
&gt;&gt;&gt; sdm_to_vector(f, [x, y, z], QQ)
[x**2 + y**2, 2*z]
</pre> 
</div>
</div>
<a id="aacc03bb8e8d54c8d720403a7e34e5025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc03bb8e8d54c8d720403a7e34e5025">&#9670;&nbsp;</a></span>sdm_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.polys.distributedmodules.sdm_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the zero module element.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
