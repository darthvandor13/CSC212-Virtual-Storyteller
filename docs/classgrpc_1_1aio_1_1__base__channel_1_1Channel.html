<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: grpc.aio._base_channel.Channel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegrpc.html">grpc</a></li><li class="navelem"><a class="el" href="namespacegrpc_1_1aio.html">aio</a></li><li class="navelem"><a class="el" href="namespacegrpc_1_1aio_1_1__base__channel.html">_base_channel</a></li><li class="navelem"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html">Channel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgrpc_1_1aio_1_1__base__channel_1_1Channel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">grpc.aio._base_channel.Channel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for grpc.aio._base_channel.Channel:</div>
<div class="dyncontent">
<div class="center"><img src="classgrpc_1_1aio_1_1__base__channel_1_1Channel__inherit__graph.png" border="0" usemap="#agrpc_8aio_8__base__channel_8Channel_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for grpc.aio._base_channel.Channel:</div>
<div class="dyncontent">
<div class="center"><img src="classgrpc_1_1aio_1_1__base__channel_1_1Channel__coll__graph.png" border="0" usemap="#agrpc_8aio_8__base__channel_8Channel_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01b7a20a0b6693497bcfc86a652ab8b9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a01b7a20a0b6693497bcfc86a652ab8b9">__aenter__</a> (self)</td></tr>
<tr class="separator:a01b7a20a0b6693497bcfc86a652ab8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5739decce51beebd1412955b87818631"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a5739decce51beebd1412955b87818631">__aexit__</a> (self, exc_type, exc_val, exc_tb)</td></tr>
<tr class="separator:a5739decce51beebd1412955b87818631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6986d715cafdfc16c8a11af3b75e8942"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a6986d715cafdfc16c8a11af3b75e8942">close</a> (self, Optional[float] grace=None)</td></tr>
<tr class="separator:a6986d715cafdfc16c8a11af3b75e8942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8bfcefd569da465fa665c5c50aa1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1ChannelConnectivity.html">grpc.ChannelConnectivity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a2a8bfcefd569da465fa665c5c50aa1d9">get_state</a> (self, bool try_to_connect=False)</td></tr>
<tr class="separator:a2a8bfcefd569da465fa665c5c50aa1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb3a965137c7c749c00bcacd0ee54b"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a0fbb3a965137c7c749c00bcacd0ee54b">wait_for_state_change</a> (self, <a class="el" href="classgrpc_1_1ChannelConnectivity.html">grpc.ChannelConnectivity</a> last_observed_state)</td></tr>
<tr class="separator:a0fbb3a965137c7c749c00bcacd0ee54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0377e733b41198519b214c98f3e335d4"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a0377e733b41198519b214c98f3e335d4">channel_ready</a> (self)</td></tr>
<tr class="separator:a0377e733b41198519b214c98f3e335d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdef2e0c4f1c875d1950b59fc834d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1UnaryUnaryMultiCallable.html">UnaryUnaryMultiCallable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a7cdef2e0c4f1c875d1950b59fc834d89">unary_unary</a> (self, str method, Optional[SerializingFunction] request_serializer=None, Optional[DeserializingFunction] response_deserializer=None, Optional[bool] _registered_method=False)</td></tr>
<tr class="separator:a7cdef2e0c4f1c875d1950b59fc834d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf4962f0cdfe14494ab809148668e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1UnaryStreamMultiCallable.html">UnaryStreamMultiCallable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#aebf4962f0cdfe14494ab809148668e2f">unary_stream</a> (self, str method, Optional[SerializingFunction] request_serializer=None, Optional[DeserializingFunction] response_deserializer=None, Optional[bool] _registered_method=False)</td></tr>
<tr class="separator:aebf4962f0cdfe14494ab809148668e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec246e6db7da49b021be5ccfa155b5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1StreamUnaryMultiCallable.html">StreamUnaryMultiCallable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#aec246e6db7da49b021be5ccfa155b5f2">stream_unary</a> (self, str method, Optional[SerializingFunction] request_serializer=None, Optional[DeserializingFunction] response_deserializer=None, Optional[bool] _registered_method=False)</td></tr>
<tr class="separator:aec246e6db7da49b021be5ccfa155b5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29afe11509cc0252bded6d987ffee3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1StreamStreamMultiCallable.html">StreamStreamMultiCallable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a29afe11509cc0252bded6d987ffee3f4">stream_stream</a> (self, str method, Optional[SerializingFunction] request_serializer=None, Optional[DeserializingFunction] response_deserializer=None, Optional[bool] _registered_method=False)</td></tr>
<tr class="separator:a29afe11509cc0252bded6d987ffee3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b7a20a0b6693497bcfc86a652ab8b9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a01b7a20a0b6693497bcfc86a652ab8b9">__aenter__</a> (self)</td></tr>
<tr class="separator:a01b7a20a0b6693497bcfc86a652ab8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5739decce51beebd1412955b87818631"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a5739decce51beebd1412955b87818631">__aexit__</a> (self, exc_type, exc_val, exc_tb)</td></tr>
<tr class="separator:a5739decce51beebd1412955b87818631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6986d715cafdfc16c8a11af3b75e8942"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a6986d715cafdfc16c8a11af3b75e8942">close</a> (self, Optional[float] grace=None)</td></tr>
<tr class="separator:a6986d715cafdfc16c8a11af3b75e8942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8bfcefd569da465fa665c5c50aa1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1ChannelConnectivity.html">grpc.ChannelConnectivity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a2a8bfcefd569da465fa665c5c50aa1d9">get_state</a> (self, bool try_to_connect=False)</td></tr>
<tr class="separator:a2a8bfcefd569da465fa665c5c50aa1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb3a965137c7c749c00bcacd0ee54b"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a0fbb3a965137c7c749c00bcacd0ee54b">wait_for_state_change</a> (self, <a class="el" href="classgrpc_1_1ChannelConnectivity.html">grpc.ChannelConnectivity</a> last_observed_state)</td></tr>
<tr class="separator:a0fbb3a965137c7c749c00bcacd0ee54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0377e733b41198519b214c98f3e335d4"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a0377e733b41198519b214c98f3e335d4">channel_ready</a> (self)</td></tr>
<tr class="separator:a0377e733b41198519b214c98f3e335d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdef2e0c4f1c875d1950b59fc834d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1UnaryUnaryMultiCallable.html">UnaryUnaryMultiCallable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a7cdef2e0c4f1c875d1950b59fc834d89">unary_unary</a> (self, str method, Optional[SerializingFunction] request_serializer=None, Optional[DeserializingFunction] response_deserializer=None, Optional[bool] _registered_method=False)</td></tr>
<tr class="separator:a7cdef2e0c4f1c875d1950b59fc834d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf4962f0cdfe14494ab809148668e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1UnaryStreamMultiCallable.html">UnaryStreamMultiCallable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#aebf4962f0cdfe14494ab809148668e2f">unary_stream</a> (self, str method, Optional[SerializingFunction] request_serializer=None, Optional[DeserializingFunction] response_deserializer=None, Optional[bool] _registered_method=False)</td></tr>
<tr class="separator:aebf4962f0cdfe14494ab809148668e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec246e6db7da49b021be5ccfa155b5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1StreamUnaryMultiCallable.html">StreamUnaryMultiCallable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#aec246e6db7da49b021be5ccfa155b5f2">stream_unary</a> (self, str method, Optional[SerializingFunction] request_serializer=None, Optional[DeserializingFunction] response_deserializer=None, Optional[bool] _registered_method=False)</td></tr>
<tr class="separator:aec246e6db7da49b021be5ccfa155b5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29afe11509cc0252bded6d987ffee3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1StreamStreamMultiCallable.html">StreamStreamMultiCallable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1Channel.html#a29afe11509cc0252bded6d987ffee3f4">stream_stream</a> (self, str method, Optional[SerializingFunction] request_serializer=None, Optional[DeserializingFunction] response_deserializer=None, Optional[bool] _registered_method=False)</td></tr>
<tr class="separator:a29afe11509cc0252bded6d987ffee3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Enables asynchronous RPC invocation as a client.

Channel objects implement the Asynchronous Context Manager (aka. async
with) type, although they are not supported to be entered and exited
multiple times.
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a01b7a20a0b6693497bcfc86a652ab8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b7a20a0b6693497bcfc86a652ab8b9">&#9670;&nbsp;</a></span>__aenter__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def grpc.aio._base_channel.Channel.__aenter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enables asynchronous RPC invocation as a client.

Channel objects implement the Asynchronous Context Manager (aka. async
with) type, although they are not supported to be entered and exited
multiple times.
</pre><pre class="fragment">Starts an asynchronous context manager.

Returns:
  Channel the channel that was instantiated.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a5c06f078f3e4cb65cd964db103d7271f">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a5c06f078f3e4cb65cd964db103d7271f">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a01b7a20a0b6693497bcfc86a652ab8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b7a20a0b6693497bcfc86a652ab8b9">&#9670;&nbsp;</a></span>__aenter__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def grpc.aio._base_channel.Channel.__aenter__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enables asynchronous RPC invocation as a client.

Channel objects implement the Asynchronous Context Manager (aka. async
with) type, although they are not supported to be entered and exited
multiple times.
</pre><pre class="fragment">Starts an asynchronous context manager.

Returns:
  Channel the channel that was instantiated.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a5c06f078f3e4cb65cd964db103d7271f">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a5c06f078f3e4cb65cd964db103d7271f">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a5739decce51beebd1412955b87818631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5739decce51beebd1412955b87818631">&#9670;&nbsp;</a></span>__aexit__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def grpc.aio._base_channel.Channel.__aexit__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc_tb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finishes the asynchronous context manager by closing the channel.

Still active RPCs will be cancelled.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a9db5413c737e25814e1e9c212d33c55f">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a9db5413c737e25814e1e9c212d33c55f">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a5739decce51beebd1412955b87818631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5739decce51beebd1412955b87818631">&#9670;&nbsp;</a></span>__aexit__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def grpc.aio._base_channel.Channel.__aexit__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc_tb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finishes the asynchronous context manager by closing the channel.

Still active RPCs will be cancelled.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a9db5413c737e25814e1e9c212d33c55f">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a9db5413c737e25814e1e9c212d33c55f">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a0377e733b41198519b214c98f3e335d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0377e733b41198519b214c98f3e335d4">&#9670;&nbsp;</a></span>channel_ready() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None grpc.aio._base_channel.Channel.channel_ready </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a coroutine that blocks until the Channel is READY.</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a3a70de9533534d4505809cf5f563527c">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a3a70de9533534d4505809cf5f563527c">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a0377e733b41198519b214c98f3e335d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0377e733b41198519b214c98f3e335d4">&#9670;&nbsp;</a></span>channel_ready() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None grpc.aio._base_channel.Channel.channel_ready </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a coroutine that blocks until the Channel is READY.</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a3a70de9533534d4505809cf5f563527c">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a3a70de9533534d4505809cf5f563527c">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a6986d715cafdfc16c8a11af3b75e8942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6986d715cafdfc16c8a11af3b75e8942">&#9670;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def grpc.aio._base_channel.Channel.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[float] &#160;</td>
          <td class="paramname"><em>grace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Closes this Channel and releases all resources held by it.

This method immediately stops the channel from executing new RPCs in
all cases.

If a grace period is specified, this method waits until all active
RPCs are finished or until the grace period is reached. RPCs that haven't
been terminated within the grace period are aborted.
If a grace period is not specified (by passing None for grace),
all existing RPCs are cancelled immediately.

This method is idempotent.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a3b2942b2db05f6869c8dd2e40926398d">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a3b2942b2db05f6869c8dd2e40926398d">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a6986d715cafdfc16c8a11af3b75e8942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6986d715cafdfc16c8a11af3b75e8942">&#9670;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def grpc.aio._base_channel.Channel.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[float] &#160;</td>
          <td class="paramname"><em>grace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Closes this Channel and releases all resources held by it.

This method immediately stops the channel from executing new RPCs in
all cases.

If a grace period is specified, this method waits until all active
RPCs are finished or until the grace period is reached. RPCs that haven't
been terminated within the grace period are aborted.
If a grace period is not specified (by passing None for grace),
all existing RPCs are cancelled immediately.

This method is idempotent.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a3b2942b2db05f6869c8dd2e40926398d">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a3b2942b2db05f6869c8dd2e40926398d">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a2a8bfcefd569da465fa665c5c50aa1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8bfcefd569da465fa665c5c50aa1d9">&#9670;&nbsp;</a></span>get_state() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1ChannelConnectivity.html">grpc.ChannelConnectivity</a> grpc.aio._base_channel.Channel.get_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>try_to_connect</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks the connectivity state of a channel.

This is an EXPERIMENTAL API.

If the channel reaches a stable connectivity state, it is guaranteed
that the return value of this function will eventually converge to that
state.

Args:
  try_to_connect: a bool indicate whether the Channel should try to
    connect to peer or not.

Returns: A ChannelConnectivity object.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#afab5a84a0943717c5974a092859bad8b">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#afab5a84a0943717c5974a092859bad8b">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a2a8bfcefd569da465fa665c5c50aa1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8bfcefd569da465fa665c5c50aa1d9">&#9670;&nbsp;</a></span>get_state() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1ChannelConnectivity.html">grpc.ChannelConnectivity</a> grpc.aio._base_channel.Channel.get_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>try_to_connect</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks the connectivity state of a channel.

This is an EXPERIMENTAL API.

If the channel reaches a stable connectivity state, it is guaranteed
that the return value of this function will eventually converge to that
state.

Args:
  try_to_connect: a bool indicate whether the Channel should try to
    connect to peer or not.

Returns: A ChannelConnectivity object.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#afab5a84a0943717c5974a092859bad8b">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#afab5a84a0943717c5974a092859bad8b">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a29afe11509cc0252bded6d987ffee3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29afe11509cc0252bded6d987ffee3f4">&#9670;&nbsp;</a></span>stream_stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1StreamStreamMultiCallable.html">StreamStreamMultiCallable</a> grpc.aio._base_channel.Channel.stream_stream </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[SerializingFunction] &#160;</td>
          <td class="paramname"><em>request_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[DeserializingFunction] &#160;</td>
          <td class="paramname"><em>response_deserializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_registered_method</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a StreamStreamMultiCallable for a stream-stream method.

Args:
  method: The name of the RPC method.
  request_serializer: Optional :term:`serializer` for serializing the request
    message. Request goes unserialized in case None is passed.
  response_deserializer: Optional :term:`deserializer` for deserializing the
    response message. Response goes undeserialized in case None
    is passed.
  _registered_method: Implementation Private. Optional: A bool representing
    whether the method is registered.

Returns:
  A StreamStreamMultiCallable value for the named stream-stream method.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a8bd27bc6a6dd84b1337c3e33ef00dfa1">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a8bd27bc6a6dd84b1337c3e33ef00dfa1">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a29afe11509cc0252bded6d987ffee3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29afe11509cc0252bded6d987ffee3f4">&#9670;&nbsp;</a></span>stream_stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1StreamStreamMultiCallable.html">StreamStreamMultiCallable</a> grpc.aio._base_channel.Channel.stream_stream </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[SerializingFunction] &#160;</td>
          <td class="paramname"><em>request_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[DeserializingFunction] &#160;</td>
          <td class="paramname"><em>response_deserializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_registered_method</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a StreamStreamMultiCallable for a stream-stream method.

Args:
  method: The name of the RPC method.
  request_serializer: Optional :term:`serializer` for serializing the request
    message. Request goes unserialized in case None is passed.
  response_deserializer: Optional :term:`deserializer` for deserializing the
    response message. Response goes undeserialized in case None
    is passed.
  _registered_method: Implementation Private. Optional: A bool representing
    whether the method is registered.

Returns:
  A StreamStreamMultiCallable value for the named stream-stream method.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a8bd27bc6a6dd84b1337c3e33ef00dfa1">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a8bd27bc6a6dd84b1337c3e33ef00dfa1">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="aec246e6db7da49b021be5ccfa155b5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec246e6db7da49b021be5ccfa155b5f2">&#9670;&nbsp;</a></span>stream_unary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1StreamUnaryMultiCallable.html">StreamUnaryMultiCallable</a> grpc.aio._base_channel.Channel.stream_unary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[SerializingFunction] &#160;</td>
          <td class="paramname"><em>request_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[DeserializingFunction] &#160;</td>
          <td class="paramname"><em>response_deserializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_registered_method</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a StreamUnaryMultiCallable for a stream-unary method.

Args:
  method: The name of the RPC method.
  request_serializer: Optional :term:`serializer` for serializing the request
    message. Request goes unserialized in case None is passed.
  response_deserializer: Optional :term:`deserializer` for deserializing the
    response message. Response goes undeserialized in case None
    is passed.
  _registered_method: Implementation Private. Optional: A bool representing
    whether the method is registered.

Returns:
  A StreamUnaryMultiCallable value for the named stream-unary method.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#ae2472208bb4a330bfa529414e8566f58">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#ae2472208bb4a330bfa529414e8566f58">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="aec246e6db7da49b021be5ccfa155b5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec246e6db7da49b021be5ccfa155b5f2">&#9670;&nbsp;</a></span>stream_unary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1StreamUnaryMultiCallable.html">StreamUnaryMultiCallable</a> grpc.aio._base_channel.Channel.stream_unary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[SerializingFunction] &#160;</td>
          <td class="paramname"><em>request_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[DeserializingFunction] &#160;</td>
          <td class="paramname"><em>response_deserializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_registered_method</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a StreamUnaryMultiCallable for a stream-unary method.

Args:
  method: The name of the RPC method.
  request_serializer: Optional :term:`serializer` for serializing the request
    message. Request goes unserialized in case None is passed.
  response_deserializer: Optional :term:`deserializer` for deserializing the
    response message. Response goes undeserialized in case None
    is passed.
  _registered_method: Implementation Private. Optional: A bool representing
    whether the method is registered.

Returns:
  A StreamUnaryMultiCallable value for the named stream-unary method.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#ae2472208bb4a330bfa529414e8566f58">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#ae2472208bb4a330bfa529414e8566f58">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="aebf4962f0cdfe14494ab809148668e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf4962f0cdfe14494ab809148668e2f">&#9670;&nbsp;</a></span>unary_stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1UnaryStreamMultiCallable.html">UnaryStreamMultiCallable</a> grpc.aio._base_channel.Channel.unary_stream </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[SerializingFunction] &#160;</td>
          <td class="paramname"><em>request_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[DeserializingFunction] &#160;</td>
          <td class="paramname"><em>response_deserializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_registered_method</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a UnaryStreamMultiCallable for a unary-stream method.

Args:
  method: The name of the RPC method.
  request_serializer: Optional :term:`serializer` for serializing the request
    message. Request goes unserialized in case None is passed.
  response_deserializer: Optional :term:`deserializer` for deserializing the
    response message. Response goes undeserialized in case None
    is passed.
  _registered_method: Implementation Private. Optional: A bool representing
    whether the method is registered.

Returns:
  A UnaryStreamMultiCallable value for the named unary-stream method.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a16071bcf008e7de69ac9ca8a76d2c429">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a16071bcf008e7de69ac9ca8a76d2c429">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="aebf4962f0cdfe14494ab809148668e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf4962f0cdfe14494ab809148668e2f">&#9670;&nbsp;</a></span>unary_stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1UnaryStreamMultiCallable.html">UnaryStreamMultiCallable</a> grpc.aio._base_channel.Channel.unary_stream </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[SerializingFunction] &#160;</td>
          <td class="paramname"><em>request_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[DeserializingFunction] &#160;</td>
          <td class="paramname"><em>response_deserializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_registered_method</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a UnaryStreamMultiCallable for a unary-stream method.

Args:
  method: The name of the RPC method.
  request_serializer: Optional :term:`serializer` for serializing the request
    message. Request goes unserialized in case None is passed.
  response_deserializer: Optional :term:`deserializer` for deserializing the
    response message. Response goes undeserialized in case None
    is passed.
  _registered_method: Implementation Private. Optional: A bool representing
    whether the method is registered.

Returns:
  A UnaryStreamMultiCallable value for the named unary-stream method.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a16071bcf008e7de69ac9ca8a76d2c429">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a16071bcf008e7de69ac9ca8a76d2c429">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a7cdef2e0c4f1c875d1950b59fc834d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdef2e0c4f1c875d1950b59fc834d89">&#9670;&nbsp;</a></span>unary_unary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1UnaryUnaryMultiCallable.html">UnaryUnaryMultiCallable</a> grpc.aio._base_channel.Channel.unary_unary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[SerializingFunction] &#160;</td>
          <td class="paramname"><em>request_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[DeserializingFunction] &#160;</td>
          <td class="paramname"><em>response_deserializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_registered_method</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a UnaryUnaryMultiCallable for a unary-unary method.

Args:
  method: The name of the RPC method.
  request_serializer: Optional :term:`serializer` for serializing the request
    message. Request goes unserialized in case None is passed.
  response_deserializer: Optional :term:`deserializer` for deserializing the
    response message. Response goes undeserialized in case None
    is passed.
  _registered_method: Implementation Private. Optional: A bool representing
    whether the method is registered.

Returns:
  A UnaryUnaryMultiCallable value for the named unary-unary method.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a6d64f09a15938dda93ad4ddff5676e6b">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a6d64f09a15938dda93ad4ddff5676e6b">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a7cdef2e0c4f1c875d1950b59fc834d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdef2e0c4f1c875d1950b59fc834d89">&#9670;&nbsp;</a></span>unary_unary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classgrpc_1_1aio_1_1__base__channel_1_1UnaryUnaryMultiCallable.html">UnaryUnaryMultiCallable</a> grpc.aio._base_channel.Channel.unary_unary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[SerializingFunction] &#160;</td>
          <td class="paramname"><em>request_serializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[DeserializingFunction] &#160;</td>
          <td class="paramname"><em>response_deserializer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[bool] &#160;</td>
          <td class="paramname"><em>_registered_method</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a UnaryUnaryMultiCallable for a unary-unary method.

Args:
  method: The name of the RPC method.
  request_serializer: Optional :term:`serializer` for serializing the request
    message. Request goes unserialized in case None is passed.
  response_deserializer: Optional :term:`deserializer` for deserializing the
    response message. Response goes undeserialized in case None
    is passed.
  _registered_method: Implementation Private. Optional: A bool representing
    whether the method is registered.

Returns:
  A UnaryUnaryMultiCallable value for the named unary-unary method.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a6d64f09a15938dda93ad4ddff5676e6b">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a6d64f09a15938dda93ad4ddff5676e6b">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a0fbb3a965137c7c749c00bcacd0ee54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbb3a965137c7c749c00bcacd0ee54b">&#9670;&nbsp;</a></span>wait_for_state_change() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None grpc.aio._base_channel.Channel.wait_for_state_change </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc_1_1ChannelConnectivity.html">grpc.ChannelConnectivity</a>&#160;</td>
          <td class="paramname"><em>last_observed_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Waits for a change in connectivity state.

This is an EXPERIMENTAL API.

The function blocks until there is a change in the channel connectivity
state from the "last_observed_state". If the state is already
different, this function will return immediately.

There is an inherent race between the invocation of
"Channel.wait_for_state_change" and "Channel.get_state". The state can
change arbitrary many times during the race, so there is no way to
observe every state transition.

If there is a need to put a timeout for this function, please refer to
"asyncio.wait_for".

Args:
  last_observed_state: A grpc.ChannelConnectivity object representing
    the last known state.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a37e8a9e46e0e3635a8df020aa46b5036">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a37e8a9e46e0e3635a8df020aa46b5036">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<a id="a0fbb3a965137c7c749c00bcacd0ee54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbb3a965137c7c749c00bcacd0ee54b">&#9670;&nbsp;</a></span>wait_for_state_change() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None grpc.aio._base_channel.Channel.wait_for_state_change </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc_1_1ChannelConnectivity.html">grpc.ChannelConnectivity</a>&#160;</td>
          <td class="paramname"><em>last_observed_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Waits for a change in connectivity state.

This is an EXPERIMENTAL API.

The function blocks until there is a change in the channel connectivity
state from the "last_observed_state". If the state is already
different, this function will return immediately.

There is an inherent race between the invocation of
"Channel.wait_for_state_change" and "Channel.get_state". The state can
change arbitrary many times during the race, so there is no way to
observe every state transition.

If there is a need to put a timeout for this function, please refer to
"asyncio.wait_for".

Args:
  last_observed_state: A grpc.ChannelConnectivity object representing
    the last known state.
</pre> 
<p>Reimplemented in <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a37e8a9e46e0e3635a8df020aa46b5036">grpc.aio._channel.Channel</a>, and <a class="el" href="classgrpc_1_1aio_1_1__channel_1_1Channel.html#a37e8a9e46e0e3635a8df020aa46b5036">grpc.aio._channel.Channel</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>chromadb_rest_wrapper/venv/lib/python3.10/site-packages/grpc/aio/<a class="el" href="chromadb__rest__wrapper_2venv_2lib_2python3_810_2site-packages_2grpc_2aio_2__base__channel_8py.html">_base_channel.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
