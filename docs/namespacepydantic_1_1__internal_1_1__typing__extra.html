<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: pydantic._internal._typing_extra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepydantic.html">pydantic</a></li><li class="navelem"><a class="el" href="namespacepydantic_1_1__internal.html">_internal</a></li><li class="navelem"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html">_typing_extra</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pydantic._internal._typing_extra Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b4a5909279b10792a8d6cd5fe6a07af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a9b4a5909279b10792a8d6cd5fe6a07af">is_annotated</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a9b4a5909279b10792a8d6cd5fe6a07af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239aee914c45a225e79847d9d798ba18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a239aee914c45a225e79847d9d798ba18">annotated_type</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a239aee914c45a225e79847d9d798ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7dce5ecb4caa71da372db616e24fb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#adc7dce5ecb4caa71da372db616e24fb9">unpack_type</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:adc7dce5ecb4caa71da372db616e24fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393477963f75721246af9bd1466a4faa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a393477963f75721246af9bd1466a4faa">is_hashable</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a393477963f75721246af9bd1466a4faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae515f10a1513b05aa3f7d33e00260ce3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#ae515f10a1513b05aa3f7d33e00260ce3">is_callable</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:ae515f10a1513b05aa3f7d33e00260ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47b522fc4dc32e5957e323afff1d008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#af47b522fc4dc32e5957e323afff1d008">is_classvar_annotation</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:af47b522fc4dc32e5957e323afff1d008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32a136cbac17ac5c83d9753a78a8f5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#ad32a136cbac17ac5c83d9753a78a8f5b">is_finalvar</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:ad32a136cbac17ac5c83d9753a78a8f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cd7a314837e9e1232787f3161391a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#af7cd7a314837e9e1232787f3161391a5">is_none_type</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:af7cd7a314837e9e1232787f3161391a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6ef975998d72ad4837cc7e9e979314"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a7c6ef975998d72ad4837cc7e9e979314">is_namedtuple</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a7c6ef975998d72ad4837cc7e9e979314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173334add57027e065780c504208bb23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a173334add57027e065780c504208bb23">is_generic_alias</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a173334add57027e065780c504208bb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d8ca24fb20c47b99b7842e69cd2055"><td class="memItemLeft" align="right" valign="top">dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a23d8ca24fb20c47b99b7842e69cd2055">parent_frame_namespace</a> (*int parent_depth=2, bool force=False)</td></tr>
<tr class="memdesc:a23d8ca24fb20c47b99b7842e69cd2055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation evaluations functions:  <a href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a23d8ca24fb20c47b99b7842e69cd2055">More...</a><br /></td></tr>
<tr class="separator:a23d8ca24fb20c47b99b7842e69cd2055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3653fba4ab245519ae308f455bcf91"><td class="memItemLeft" align="right" valign="top">dict[str, tuple[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>, bool]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a6b3653fba4ab245519ae308f455bcf91">get_model_type_hints</a> (type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>] obj, *<a class="el" href="classpydantic_1_1__internal_1_1__namespace__utils_1_1NsResolver.html">NsResolver</a>|None ns_resolver=None)</td></tr>
<tr class="separator:a6b3653fba4ab245519ae308f455bcf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace98ad260c392bba81d267e79a8cf32"><td class="memItemLeft" align="right" valign="top">dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#aace98ad260c392bba81d267e79a8cf32">get_cls_type_hints</a> (type[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] obj, *<a class="el" href="classpydantic_1_1__internal_1_1__namespace__utils_1_1NsResolver.html">NsResolver</a>|None ns_resolver=None)</td></tr>
<tr class="separator:aace98ad260c392bba81d267e79a8cf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e006ee81f2e61286fbae800a51a85b2"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>, bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a5e006ee81f2e61286fbae800a51a85b2">try_eval_type</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</td></tr>
<tr class="separator:a5e006ee81f2e61286fbae800a51a85b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064ea6b2afd5bc74d8709edcd7d6643b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a064ea6b2afd5bc74d8709edcd7d6643b">eval_type</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</td></tr>
<tr class="separator:a064ea6b2afd5bc74d8709edcd7d6643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90999eec8149bd4b1f4ea57954bde601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a90999eec8149bd4b1f4ea57954bde601">eval_type_lenient</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</td></tr>
<tr class="separator:a90999eec8149bd4b1f4ea57954bde601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d08f462e48910443a543936538610b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a3d08f462e48910443a543936538610b0">eval_type_backport</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None, tuple[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>,...]|None type_params=None)</td></tr>
<tr class="separator:a3d08f462e48910443a543936538610b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c50b9f48a4a8d6f80bbef8f6d6cab7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a19c50b9f48a4a8d6f80bbef8f6d6cab7">is_backport_fixable_error</a> (TypeError e)</td></tr>
<tr class="separator:a19c50b9f48a4a8d6f80bbef8f6d6cab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec571e800756c5d905efc59aac191bc"><td class="memItemLeft" align="right" valign="top">dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a7ec571e800756c5d905efc59aac191bc">get_function_type_hints</a> (Callable[..., <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] function, *set[str]|None include_keys=None, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</td></tr>
<tr class="separator:a7ec571e800756c5d905efc59aac191bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b3e02aeaab5f00fae0d35d7ddfebda"><td class="memItemLeft" align="right" valign="top">dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#ab2b3e02aeaab5f00fae0d35d7ddfebda">get_type_hints</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> obj, dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]|None globalns=None, dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]|None localns=None, bool include_extras=False)</td></tr>
<tr class="separator:ab2b3e02aeaab5f00fae0d35d7ddfebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac165ce5c6e82b8e1fcc2cde8c8fad32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#aac165ce5c6e82b8e1fcc2cde8c8fad32">is_any</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:aac165ce5c6e82b8e1fcc2cde8c8fad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76194699199a31ad6aa939396743f217"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a76194699199a31ad6aa939396743f217">is_union</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a76194699199a31ad6aa939396743f217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f46f313b73f99816c6562df7f3022e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#ae1f46f313b73f99816c6562df7f3022e">is_literal</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:ae1f46f313b73f99816c6562df7f3022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6ad0002adc2399f21e572567999544"><td class="memItemLeft" align="right" valign="top">list[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a3e6ad0002adc2399f21e572567999544">literal_values</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a3e6ad0002adc2399f21e572567999544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded88373e8f1928ef31ab0ccb1adb31a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#aded88373e8f1928ef31ab0ccb1adb31a">is_unpack</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:aded88373e8f1928ef31ab0ccb1adb31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637c4a2675f7b3c6e05548492362891e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a637c4a2675f7b3c6e05548492362891e">is_self</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a637c4a2675f7b3c6e05548492362891e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2baa7bc0811f8d6cb1ed9992762385"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a3f2baa7bc0811f8d6cb1ed9992762385">is_new_type</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a3f2baa7bc0811f8d6cb1ed9992762385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542c01d8ccf61970891635464081dceb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a542c01d8ccf61970891635464081dceb">is_paramspec</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a542c01d8ccf61970891635464081dceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948d4fa12578eb8f23060d726c84a6c8"><td class="memItemLeft" align="right" valign="top">TypeIs[<a class="el" href="classtyping__extensions_1_1TypeAliasType.html">typing_extensions.TypeAliasType</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a948d4fa12578eb8f23060d726c84a6c8">is_type_alias_type</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a948d4fa12578eb8f23060d726c84a6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba710c80b3236c2096c9c0de8f2d6a6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#aba710c80b3236c2096c9c0de8f2d6a6b">is_classvar</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:aba710c80b3236c2096c9c0de8f2d6a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca37eef8aa3137dd1845bf967de0712"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a8ca37eef8aa3137dd1845bf967de0712">is_required</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a8ca37eef8aa3137dd1845bf967de0712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf75f0d36aee4f073932eeed6aa93aaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#abf75f0d36aee4f073932eeed6aa93aaa">is_not_required</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:abf75f0d36aee4f073932eeed6aa93aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dba81d6863bef2578db7ccc525d6ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#aa0dba81d6863bef2578db7ccc525d6ff">is_no_return</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:aa0dba81d6863bef2578db7ccc525d6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75376e5680c84f3e7f74bd5f2f7abb75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a75376e5680c84f3e7f74bd5f2f7abb75">is_never</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a75376e5680c84f3e7f74bd5f2f7abb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829ada6651f3619239c9f1aeee331df8"><td class="memItemLeft" align="right" valign="top">TypeIs[<a class="el" href="classtyping__extensions_1_1deprecated.html">deprecated</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a829ada6651f3619239c9f1aeee331df8">is_deprecated_instance</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> obj)</td></tr>
<tr class="separator:a829ada6651f3619239c9f1aeee331df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03291bd35ad2695f6c4a4c3ee40521e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a03291bd35ad2695f6c4a4c3ee40521e6">is_zoneinfo_type</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a03291bd35ad2695f6c4a4c3ee40521e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873b939f647e9d419b9e6998cb611f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a873b939f647e9d419b9e6998cb611f02">origin_is_union</a> (<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> tp)</td></tr>
<tr class="separator:a873b939f647e9d419b9e6998cb611f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aca35eaa02ca3942334dfb67fb34cda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a4aca35eaa02ca3942334dfb67fb34cda">is_generic_alias</a> (type[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] type_)</td></tr>
<tr class="separator:a4aca35eaa02ca3942334dfb67fb34cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa17a793985242eb23b25e177bcd614d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#aa17a793985242eb23b25e177bcd614d4">NoneType</a> = type(None)</td></tr>
<tr class="separator:aa17a793985242eb23b25e177bcd614d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de812f438e3a8c14dbed15d4b24cb3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a1de812f438e3a8c14dbed15d4b24cb3d">EllipsisType</a> = type(Ellipsis)</td></tr>
<tr class="separator:a1de812f438e3a8c14dbed15d4b24cb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ad56c6b1e0483511ad2f8c6342f280"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a91ad56c6b1e0483511ad2f8c6342f280">origin_is_union</a> = is_union_origin</td></tr>
<tr class="separator:a91ad56c6b1e0483511ad2f8c6342f280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060b158482dfb1e38fde182fea174d46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a></td></tr>
<tr class="separator:a060b158482dfb1e38fde182fea174d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ba279b2237d6f69b9f7272595c98fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#af9ba279b2237d6f69b9f7272595c98fb">get_type_hints</a> = typing.get_type_hints</td></tr>
<tr class="separator:af9ba279b2237d6f69b9f7272595c98fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a239aee914c45a225e79847d9d798ba18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239aee914c45a225e79847d9d798ba18">&#9670;&nbsp;</a></span>annotated_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> None pydantic._internal._typing_extra.annotated_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the type of the `Annotated` special form, or `None`.</pre> 
</div>
</div>
<a id="a064ea6b2afd5bc74d8709edcd7d6643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064ea6b2afd5bc74d8709edcd7d6643b">&#9670;&nbsp;</a></span>eval_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> pydantic._internal._typing_extra.eval_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None &#160;</td>
          <td class="paramname"><em>globalns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None &#160;</td>
          <td class="paramname"><em>localns</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate the annotation using the provided namespaces.

Args:
    value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance
        of `str`, it will be converted to a `ForwardRef`.
    localns: The global namespace to use during annotation evaluation.
    globalns: The local namespace to use during annotation evaluation.
</pre> 
</div>
</div>
<a id="a3d08f462e48910443a543936538610b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d08f462e48910443a543936538610b0">&#9670;&nbsp;</a></span>eval_type_backport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> pydantic._internal._typing_extra.eval_type_backport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None &#160;</td>
          <td class="paramname"><em>globalns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None &#160;</td>
          <td class="paramname"><em>localns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>, ...] | None &#160;</td>
          <td class="paramname"><em>type_params</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An enhanced version of `typing._eval_type` which will fall back to using the `eval_type_backport`
package if it's installed to let older Python versions use newer typing constructs.

Specifically, this transforms `X | Y` into `typing.Union[X, Y]` and `list[X]` into `typing.List[X]`
(as well as all the types made generic in PEP 585) if the original syntax is not supported in the
current Python version.

This function will also display a helpful error if the value passed fails to evaluate.
</pre> 
</div>
</div>
<a id="a90999eec8149bd4b1f4ea57954bde601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90999eec8149bd4b1f4ea57954bde601">&#9670;&nbsp;</a></span>eval_type_lenient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> pydantic._internal._typing_extra.eval_type_lenient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None &#160;</td>
          <td class="paramname"><em>globalns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None &#160;</td>
          <td class="paramname"><em>localns</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aace98ad260c392bba81d267e79a8cf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace98ad260c392bba81d267e79a8cf32">&#9670;&nbsp;</a></span>get_cls_type_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] pydantic._internal._typing_extra.get_cls_type_hints </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classpydantic_1_1__internal_1_1__namespace__utils_1_1NsResolver.html">NsResolver</a> | None &#160;</td>
          <td class="paramname"><em>ns_resolver</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Collect annotations from a class, including those from parent classes.

Args:
    obj: The class to inspect.
    ns_resolver: A namespace resolver instance to use. Defaults to an empty instance.
</pre> 
</div>
</div>
<a id="a7ec571e800756c5d905efc59aac191bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec571e800756c5d905efc59aac191bc">&#9670;&nbsp;</a></span>get_function_type_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] pydantic._internal._typing_extra.get_function_type_hints </td>
          <td>(</td>
          <td class="paramtype">Callable[..., <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*set[str] | None &#160;</td>
          <td class="paramname"><em>include_keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None &#160;</td>
          <td class="paramname"><em>globalns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None &#160;</td>
          <td class="paramname"><em>localns</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return type hints for a function.

This is similar to the `typing.get_type_hints` function, with a few differences:
- Support `functools.partial` by using the underlying `func` attribute.
- Do not wrap type annotation of a parameter with `Optional` if it has a default value of `None`
  (related bug: https://github.com/python/cpython/issues/90353, only fixed in 3.11+).
</pre><pre class="fragment">Return type hints for a function.

This is similar to the `typing.get_type_hints` function, with a few differences:
- Support `functools.partial` by using the underlying `func` attribute.
- If `function` happens to be a built-in type (e.g. `int`), assume it doesn't have annotations
  but specify the `return` key as being the actual type.
- Do not wrap type annotation of a parameter with `Optional` if it has a default value of `None`
  (related bug: https://github.com/python/cpython/issues/90353, only fixed in 3.11+).
</pre> 
</div>
</div>
<a id="a6b3653fba4ab245519ae308f455bcf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3653fba4ab245519ae308f455bcf91">&#9670;&nbsp;</a></span>get_model_type_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, tuple[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>, bool]] pydantic._internal._typing_extra.get_model_type_hints </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1BaseModel.html">BaseModel</a>]&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="classpydantic_1_1__internal_1_1__namespace__utils_1_1NsResolver.html">NsResolver</a> | None &#160;</td>
          <td class="paramname"><em>ns_resolver</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Collect annotations from a Pydantic model class, including those from parent classes.

Args:
    obj: The Pydantic model to inspect.
    ns_resolver: A namespace resolver instance to use. Defaults to an empty instance.

Returns:
    A dictionary mapping annotation names to a two-tuple: the first element is the evaluated
    type or the original annotation if a `NameError` occurred, the second element is a boolean
    indicating if whether the evaluation succeeded.
</pre> 
</div>
</div>
<a id="ab2b3e02aeaab5f00fae0d35d7ddfebda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b3e02aeaab5f00fae0d35d7ddfebda">&#9670;&nbsp;</a></span>get_type_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] pydantic._internal._typing_extra.get_type_hints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] | None &#160;</td>
          <td class="paramname"><em>globalns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] | None &#160;</td>
          <td class="paramname"><em>localns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>include_extras</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Taken verbatim from python 3.10.8 unchanged, except:
* type annotations of the function definition above.
* prefixing `typing.` where appropriate
* Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument.

https://github.com/python/cpython/blob/aaaf5174241496afca7ce4d4584570190ff972fe/Lib/typing.py#L1773-L1875

DO NOT CHANGE THIS METHOD UNLESS ABSOLUTELY NECESSARY.
======================================================

Return type hints for an object.

This is often the same as obj.__annotations__, but it handles
forward references encoded as string literals, adds Optional[t] if a
default value equal to None is set and recursively replaces all
'Annotated[T, ...]' with 'T' (unless 'include_extras=True').

The argument may be a module, class, method, or function. The annotations
are returned as a dictionary. For classes, annotations include also
inherited members.

TypeError is raised if the argument is not of a type that can contain
annotations, and an empty dictionary is returned if no annotations are
present.

BEWARE -- the behavior of globalns and localns is counterintuitive
(unless you are familiar with how eval() and exec() work).  The
search order is locals first, then globals.

- If no dict arguments are passed, an attempt is made to use the
  globals from obj (or the respective module's globals for classes),
  and these are also used as the locals.  If the object does not appear
  to have globals, an empty dictionary is used.  For classes, the search
  order is globals first then locals.

- If one dict argument is passed, it is used for both globals and
  locals.

- If two dict arguments are passed, they specify globals and
  locals, respectively.
</pre> 
</div>
</div>
<a id="a9b4a5909279b10792a8d6cd5fe6a07af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4a5909279b10792a8d6cd5fe6a07af">&#9670;&nbsp;</a></span>is_annotated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_annotated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Annotated` special form.

```python {test="skip" lint="skip"}
is_annotated(Annotated[int, ...])
#&gt; True
```
</pre> 
</div>
</div>
<a id="aac165ce5c6e82b8e1fcc2cde8c8fad32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac165ce5c6e82b8e1fcc2cde8c8fad32">&#9670;&nbsp;</a></span>is_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_any </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `Any` special form.

```python {test="skip" lint="skip"}
is_any(Any)
#&gt; True
```
</pre> 
</div>
</div>
<a id="a19c50b9f48a4a8d6f80bbef8f6d6cab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c50b9f48a4a8d6f80bbef8f6d6cab7">&#9670;&nbsp;</a></span>is_backport_fixable_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_backport_fixable_error </td>
          <td>(</td>
          <td class="paramtype">TypeError&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae515f10a1513b05aa3f7d33e00260ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae515f10a1513b05aa3f7d33e00260ce3">&#9670;&nbsp;</a></span>is_callable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_callable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Callable`, parametrized or not.

```python {test="skip" lint="skip"}
is_callable(Callable[[int], str])
#&gt; True
is_callable(typing.Callable)
#&gt; True
is_callable(collections.abc.Callable)
#&gt; True
```
</pre> 
</div>
</div>
<a id="aba710c80b3236c2096c9c0de8f2d6a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba710c80b3236c2096c9c0de8f2d6a6b">&#9670;&nbsp;</a></span>is_classvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_classvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `ClassVar` special form, parametrized or not.

Note that in most cases, you will want to use the `is_classvar_annotation` function,
which is used to check if an annotation (in the context of a Pydantic model or dataclass)
should be treated as being a class variable.

```python {test="skip" lint="skip"}
is_classvar(ClassVar[int])
#&gt; True
is_classvar(ClassVar)
#&gt; True
</pre> 
</div>
</div>
<a id="af47b522fc4dc32e5957e323afff1d008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47b522fc4dc32e5957e323afff1d008">&#9670;&nbsp;</a></span>is_classvar_annotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_classvar_annotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument represents a class variable annotation.

Although not explicitly stated by the typing specification, `ClassVar` can be used
inside `Annotated` and as such, this function checks for this specific scenario.

Because this function is used to detect class variables before evaluating forward references
(or because evaluation failed), we also implement a naive regex match implementation. This is
required because class variables are inspected before fields are collected, so we try to be
as accurate as possible.
</pre> 
</div>
</div>
<a id="a829ada6651f3619239c9f1aeee331df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829ada6651f3619239c9f1aeee331df8">&#9670;&nbsp;</a></span>is_deprecated_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> TypeIs[<a class="el" href="classtyping__extensions_1_1deprecated.html">deprecated</a>] pydantic._internal._typing_extra.is_deprecated_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the argument is an instance of the `warnings.deprecated` class or the `typing_extensions` backport.</pre> 
</div>
</div>
<a id="ad32a136cbac17ac5c83d9753a78a8f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32a136cbac17ac5c83d9753a78a8f5b">&#9670;&nbsp;</a></span>is_finalvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_finalvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Final` special form, parametrized or not.

```python {test="skip" lint="skip"}
is_finalvar(Final[int])
#&gt; True
is_finalvar(Final)
#&gt; True
</pre> 
</div>
</div>
<a id="a173334add57027e065780c504208bb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173334add57027e065780c504208bb23">&#9670;&nbsp;</a></span>is_generic_alias() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_generic_alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aca35eaa02ca3942334dfb67fb34cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aca35eaa02ca3942334dfb67fb34cda">&#9670;&nbsp;</a></span>is_generic_alias() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_generic_alias </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>]&#160;</td>
          <td class="paramname"><em>type_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a393477963f75721246af9bd1466a4faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393477963f75721246af9bd1466a4faa">&#9670;&nbsp;</a></span>is_hashable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_hashable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `Hashable` class.

```python {test="skip" lint="skip"}
is_hashable(Hashable)
#&gt; True
```
</pre> 
</div>
</div>
<a id="ae1f46f313b73f99816c6562df7f3022e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f46f313b73f99816c6562df7f3022e">&#9670;&nbsp;</a></span>is_literal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Literal` special form.

```python {test="skip" lint="skip"}
is_literal(Literal[42])
#&gt; True
```
</pre> 
</div>
</div>
<a id="a7c6ef975998d72ad4837cc7e9e979314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6ef975998d72ad4837cc7e9e979314">&#9670;&nbsp;</a></span>is_namedtuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_namedtuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a named tuple class.

The class can be created using `typing.NamedTuple` or `collections.namedtuple`.
Parametrized generic classes are *not* assumed to be named tuples.
</pre> 
</div>
</div>
<a id="a75376e5680c84f3e7f74bd5f2f7abb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75376e5680c84f3e7f74bd5f2f7abb75">&#9670;&nbsp;</a></span>is_never()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_never </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `Never` special form.

```python {test="skip" lint="skip"}
is_never(Never)
#&gt; True
```
</pre> 
</div>
</div>
<a id="a3f2baa7bc0811f8d6cb1ed9992762385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2baa7bc0811f8d6cb1ed9992762385">&#9670;&nbsp;</a></span>is_new_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_new_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `NewType`.

```python {test="skip" lint="skip"}
is_new_type(NewType('MyInt', int))
#&gt; True
```
</pre> 
</div>
</div>
<a id="aa0dba81d6863bef2578db7ccc525d6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0dba81d6863bef2578db7ccc525d6ff">&#9670;&nbsp;</a></span>is_no_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_no_return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `NoReturn` special form.

```python {test="skip" lint="skip"}
is_no_return(NoReturn)
#&gt; True
```
</pre> 
</div>
</div>
<a id="af7cd7a314837e9e1232787f3161391a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7cd7a314837e9e1232787f3161391a5">&#9670;&nbsp;</a></span>is_none_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.is_none_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the argument represents the `None` type as part of an annotation.

```python {test="skip" lint="skip"}
is_none_type(None)
#&gt; True
is_none_type(NoneType)
#&gt; True
is_none_type(Literal[None])
#&gt; True
is_none_type(type[None])
#&gt; False
</pre> 
</div>
</div>
<a id="abf75f0d36aee4f073932eeed6aa93aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf75f0d36aee4f073932eeed6aa93aaa">&#9670;&nbsp;</a></span>is_not_required()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_not_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `NotRequired` special form.

```python {test="skip" lint="skip"}
is_required(Required[int])
#&gt; True
</pre> 
</div>
</div>
<a id="a542c01d8ccf61970891635464081dceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542c01d8ccf61970891635464081dceb">&#9670;&nbsp;</a></span>is_paramspec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_paramspec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `ParamSpec`.

```python {test="skip" lint="skip"}
P = ParamSpec('P')
is_paramspec(P)
#&gt; True
```
</pre> 
</div>
</div>
<a id="a8ca37eef8aa3137dd1845bf967de0712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca37eef8aa3137dd1845bf967de0712">&#9670;&nbsp;</a></span>is_required()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Required` special form.

```python {test="skip" lint="skip"}
is_required(Required[int])
#&gt; True
</pre> 
</div>
</div>
<a id="a637c4a2675f7b3c6e05548492362891e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637c4a2675f7b3c6e05548492362891e">&#9670;&nbsp;</a></span>is_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_self </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `Self` special form.

```python {test="skip" lint="skip"}
is_self(Self)
#&gt; True
```
</pre> 
</div>
</div>
<a id="a948d4fa12578eb8f23060d726c84a6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948d4fa12578eb8f23060d726c84a6c8">&#9670;&nbsp;</a></span>is_type_alias_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> TypeIs[<a class="el" href="classtyping__extensions_1_1TypeAliasType.html">typing_extensions.TypeAliasType</a>] pydantic._internal._typing_extra.is_type_alias_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is an instance of `TypeAliasType`.

```python {test="skip" lint="skip"}
type Int = int
is_type_alias_type(Int)
#&gt; True
Str = TypeAliasType('Str', str)
is_type_alias_type(Str)
#&gt; True
```
</pre> 
</div>
</div>
<a id="a76194699199a31ad6aa939396743f217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76194699199a31ad6aa939396743f217">&#9670;&nbsp;</a></span>is_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Union` special form.

```python {test="skip" lint="skip"}
is_union(Union[int, str])
#&gt; True
is_union(int | str)
#&gt; False
```
</pre> 
</div>
</div>
<a id="aded88373e8f1928ef31ab0ccb1adb31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded88373e8f1928ef31ab0ccb1adb31a">&#9670;&nbsp;</a></span>is_unpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Unpack` special form.

```python {test="skip" lint="skip"}
is_unpack(Unpack[Ts])
#&gt; True
```
</pre> 
</div>
</div>
<a id="a03291bd35ad2695f6c4a4c3ee40521e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03291bd35ad2695f6c4a4c3ee40521e6">&#9670;&nbsp;</a></span>is_zoneinfo_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_zoneinfo_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `zoneinfo.ZoneInfo` type.</pre> 
</div>
</div>
<a id="a3e6ad0002adc2399f21e572567999544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6ad0002adc2399f21e572567999544">&#9670;&nbsp;</a></span>literal_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] pydantic._internal._typing_extra.literal_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the values contained in the provided `Literal` special form.</pre> 
</div>
</div>
<a id="a873b939f647e9d419b9e6998cb611f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873b939f647e9d419b9e6998cb611f02">&#9670;&nbsp;</a></span>origin_is_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.origin_is_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `Union` special form.</pre><pre class="fragment">Return whether the provided argument is the `Union` special form or the `UnionType`.</pre> 
</div>
</div>
<a id="a23d8ca24fb20c47b99b7842e69cd2055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d8ca24fb20c47b99b7842e69cd2055">&#9670;&nbsp;</a></span>parent_frame_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, <a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>] | None pydantic._internal._typing_extra.parent_frame_namespace </td>
          <td>(</td>
          <td class="paramtype">*int &#160;</td>
          <td class="paramname"><em>parent_depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>force</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotation evaluations functions: </p>
<pre class="fragment">Fetch the local namespace of the parent frame where this function is called.

Using this function is mostly useful to resolve forward annotations pointing to members defined in a local namespace,
such as assignments inside a function. Using the standard library tools, it is currently not possible to resolve
such annotations:

```python {lint="skip" test="skip"}
from typing import get_type_hints

def func() -&gt; None:
    Alias = int

    class C:
        a: 'Alias'

    # Raises a `NameError: 'Alias' is not defined`
    get_type_hints(C)
```

Pydantic uses this function when a Pydantic model is being defined to fetch the parent frame locals. However,
this only allows us to fetch the parent frame namespace and not other parents (e.g. a model defined in a function,
itself defined in another function). Inspecting the next outer frames (using `f_back`) is not reliable enough
(see https://discuss.python.org/t/20659).

Because this function is mostly used to better resolve forward annotations, nothing is returned if the parent frame's
code object is defined at the module level. In this case, the locals of the frame will be the same as the module
globals where the class is defined (see `_namespace_utils.get_module_ns_of`). However, if you still want to fetch
the module globals (e.g. when rebuilding a model, where the frame where the rebuild call is performed might contain
members that you want to use for forward annotations evaluation), you can use the `force` parameter.

Args:
    parent_depth: The depth at which to get the frame. Defaults to 2, meaning the parent frame where this function
        is called will be used.
    force: Whether to always return the frame locals, even if the frame's code object is defined at the module level.

Returns:
    The locals of the namespace, or `None` if it was skipped as per the described logic.
</pre><pre class="fragment">We allow use of items in parent namespace to get around the issue with `get_type_hints` only looking in the
global module namespace. See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -&gt; Scope
and suggestion at the end of the next comment by @gvanrossum.

WARNING 1: it matters exactly where this is called. By default, this function will build a namespace from the
parent of where it is called.

WARNING 2: this only looks in the parent namespace, not other parents since (AFAIK) there's no way to collect a
dict of exactly what's in scope. Using `f_back` would work sometimes but would be very wrong and confusing in many
other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.

There are some cases where we want to force fetching the parent namespace, ex: during a `model_rebuild` call.
In this case, we want both the namespace of the class' module, if applicable, and the parent namespace of the
module where the rebuild is called.

In other cases, like during initial schema build, if a class is defined at the top module level, we don't need to
fetch that module's namespace, because the class' __module__ attribute can be used to access the parent namespace.
This is done in `_namespace_utils.get_module_ns_of`. Thus, there's no need to cache the parent frame namespace in this case.
</pre> 
</div>
</div>
<a id="a5e006ee81f2e61286fbae800a51a85b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e006ee81f2e61286fbae800a51a85b2">&#9670;&nbsp;</a></span>try_eval_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>, bool] pydantic._internal._typing_extra.try_eval_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None &#160;</td>
          <td class="paramname"><em>globalns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None &#160;</td>
          <td class="paramname"><em>localns</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try evaluating the annotation using the provided namespaces.

Args:
    value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance
        of `str`, it will be converted to a `ForwardRef`.
    localns: The global namespace to use during annotation evaluation.
    globalns: The local namespace to use during annotation evaluation.

Returns:
    A two-tuple containing the possibly evaluated type and a boolean indicating
        whether the evaluation succeeded or not.
</pre> 
</div>
</div>
<a id="adc7dce5ecb4caa71da372db616e24fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7dce5ecb4caa71da372db616e24fb9">&#9670;&nbsp;</a></span>unpack_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a> None pydantic._internal._typing_extra.unpack_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepydantic_1_1__internal_1_1__typing__extra.html#a060b158482dfb1e38fde182fea174d46">Any</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the type wrapped by the `Unpack` special form, or `None`.</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a060b158482dfb1e38fde182fea174d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060b158482dfb1e38fde182fea174d46">&#9670;&nbsp;</a></span>Any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra.Any</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1de812f438e3a8c14dbed15d4b24cb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de812f438e3a8c14dbed15d4b24cb3d">&#9670;&nbsp;</a></span>EllipsisType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra.EllipsisType = type(Ellipsis)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9ba279b2237d6f69b9f7272595c98fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ba279b2237d6f69b9f7272595c98fb">&#9670;&nbsp;</a></span>get_type_hints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra.get_type_hints = typing.get_type_hints</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa17a793985242eb23b25e177bcd614d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17a793985242eb23b25e177bcd614d4">&#9670;&nbsp;</a></span>NoneType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra.NoneType = type(None)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91ad56c6b1e0483511ad2f8c6342f280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ad56c6b1e0483511ad2f8c6342f280">&#9670;&nbsp;</a></span>origin_is_union</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pydantic._internal._typing_extra.origin_is_union = is_union_origin</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `Union` special form or the `UnionType`.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
