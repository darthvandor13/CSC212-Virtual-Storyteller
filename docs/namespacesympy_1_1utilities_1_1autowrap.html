<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.utilities.autowrap Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1utilities.html">utilities</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1utilities_1_1autowrap.html">autowrap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.utilities.autowrap Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1autowrap_1_1CodeWrapError.html">CodeWrapError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1autowrap_1_1CodeWrapper.html">CodeWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1autowrap_1_1DummyWrapper.html">DummyWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1autowrap_1_1CythonCodeWrapper.html">CythonCodeWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1autowrap_1_1F2PyCodeWrapper.html">F2PyCodeWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1utilities_1_1autowrap_1_1UfuncifyCodeWrapper.html">UfuncifyCodeWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae370710ac67a6747555e27bec8794a0c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1autowrap.html#ae370710ac67a6747555e27bec8794a0c">autowrap</a> (expr, language=None, backend='f2py', tempdir=None, args=None, flags=None, verbose=False, helpers=None, code_gen=None, **kwargs)</td></tr>
<tr class="separator:ae370710ac67a6747555e27bec8794a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23e7d71cd98754352f77c4ff8bbf6a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1autowrap.html#ad23e7d71cd98754352f77c4ff8bbf6a7">binary_function</a> (symfunc, expr, **kwargs)</td></tr>
<tr class="separator:ad23e7d71cd98754352f77c4ff8bbf6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07bb5adcd0541cb2e413e9f10a0764d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1utilities_1_1autowrap.html#af07bb5adcd0541cb2e413e9f10a0764d">ufuncify</a> (args, expr, language=None, backend='numpy', tempdir=None, flags=None, verbose=False, helpers=None, **kwargs)</td></tr>
<tr class="separator:af07bb5adcd0541cb2e413e9f10a0764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Module for compiling codegen output, and wrap the binary for use in
python.

.. note:: To use the autowrap module it must first be imported

   &gt;&gt;&gt; from sympy.utilities.autowrap import autowrap

This module provides a common interface for different external backends, such
as f2py, fwrap, Cython, SWIG(?) etc. (Currently only f2py and Cython are
implemented) The goal is to provide access to compiled binaries of acceptable
performance with a one-button user interface, e.g.,

    &gt;&gt;&gt; from sympy.abc import x,y
    &gt;&gt;&gt; expr = (x - y)**25
    &gt;&gt;&gt; flat = expr.expand()
    &gt;&gt;&gt; binary_callable = autowrap(flat)
    &gt;&gt;&gt; binary_callable(2, 3)
    -1.0

Although a SymPy user might primarily be interested in working with
mathematical expressions and not in the details of wrapping tools
needed to evaluate such expressions efficiently in numerical form,
the user cannot do so without some understanding of the
limits in the target language. For example, the expanded expression
contains large coefficients which result in loss of precision when
computing the expression:

    &gt;&gt;&gt; binary_callable(3, 2)
    0.0
    &gt;&gt;&gt; binary_callable(4, 5), binary_callable(5, 4)
    (-22925376.0, 25165824.0)

Wrapping the unexpanded expression gives the expected behavior:

    &gt;&gt;&gt; e = autowrap(expr)
    &gt;&gt;&gt; e(4, 5), e(5, 4)
    (-1.0, 1.0)

The callable returned from autowrap() is a binary Python function, not a
SymPy object.  If it is desired to use the compiled function in symbolic
expressions, it is better to use binary_function() which returns a SymPy
Function object.  The binary callable is attached as the _imp_ attribute and
invoked when a numerical evaluation is requested with evalf(), or with
lambdify().

    &gt;&gt;&gt; from sympy.utilities.autowrap import binary_function
    &gt;&gt;&gt; f = binary_function('f', expr)
    &gt;&gt;&gt; 2*f(x, y) + y
    y + 2*f(x, y)
    &gt;&gt;&gt; (2*f(x, y) + y).evalf(2, subs={x: 1, y:2})
    0.e-110

When is this useful?

    1) For computations on large arrays, Python iterations may be too slow,
       and depending on the mathematical expression, it may be difficult to
       exploit the advanced index operations provided by NumPy.

    2) For *really* long expressions that will be called repeatedly, the
       compiled binary should be significantly faster than SymPy's .evalf()

    3) If you are generating code with the codegen utility in order to use
       it in another project, the automatic Python wrappers let you test the
       binaries immediately from within SymPy.

    4) To create customized ufuncs for use with numpy arrays.
       See *ufuncify*.

When is this module NOT the best approach?

    1) If you are really concerned about speed or memory optimizations,
       you will probably get better results by working directly with the
       wrapper tools and the low level code.  However, the files generated
       by this utility may provide a useful starting point and reference
       code. Temporary files will be left intact if you supply the keyword
       tempdir="path/to/files/".

    2) If the array computation can be handled easily by numpy, and you
       do not need the binaries for another project.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ae370710ac67a6747555e27bec8794a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae370710ac67a6747555e27bec8794a0c">&#9670;&nbsp;</a></span>autowrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.autowrap.autowrap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>language</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>backend</em> = <code>'f2py'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tempdir</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>helpers</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>code_gen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates Python callable binaries based on the math expression.

Parameters
==========

expr
    The SymPy expression that should be wrapped as a binary routine.
language : string, optional
    If supplied, (options: 'C' or 'F95'), specifies the language of the
    generated code. If ``None`` [default], the language is inferred based
    upon the specified backend.
backend : string, optional
    Backend used to wrap the generated code. Either 'f2py' [default],
    or 'cython'.
tempdir : string, optional
    Path to directory for temporary files. If this argument is supplied,
    the generated code and the wrapper input files are left intact in the
    specified path.
args : iterable, optional
    An ordered iterable of symbols. Specifies the argument sequence for the
    function.
flags : iterable, optional
    Additional option flags that will be passed to the backend.
verbose : bool, optional
    If True, autowrap will not mute the command line backends. This can be
    helpful for debugging.
helpers : 3-tuple or iterable of 3-tuples, optional
    Used to define auxiliary expressions needed for the main expr. If the
    main expression needs to call a specialized function it should be
    passed in via ``helpers``. Autowrap will then make sure that the
    compiled main expression can link to the helper routine. Items should
    be 3-tuples with (&lt;function_name&gt;, &lt;sympy_expression&gt;,
    &lt;argument_tuple&gt;). It is mandatory to supply an argument sequence to
    helper routines.
code_gen : CodeGen instance
    An instance of a CodeGen subclass. Overrides ``language``.
include_dirs : [string]
    A list of directories to search for C/C++ header files (in Unix form
    for portability).
library_dirs : [string]
    A list of directories to search for C/C++ libraries at link time.
libraries : [string]
    A list of library names (not filenames or paths) to link against.
extra_compile_args : [string]
    Any extra platform- and compiler-specific information to use when
    compiling the source files in 'sources'.  For platforms and compilers
    where "command line" makes sense, this is typically a list of
    command-line arguments, but for other platforms it could be anything.
extra_link_args : [string]
    Any extra platform- and compiler-specific information to use when
    linking object files together to create the extension (or to create a
    new static Python interpreter).  Similar interpretation as for
    'extra_compile_args'.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y, z
&gt;&gt;&gt; from sympy.utilities.autowrap import autowrap
&gt;&gt;&gt; expr = ((x - y + z)**(13)).expand()
&gt;&gt;&gt; binary_func = autowrap(expr)
&gt;&gt;&gt; binary_func(1, 4, 2)
-1.0</pre> 
</div>
</div>
<a id="ad23e7d71cd98754352f77c4ff8bbf6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23e7d71cd98754352f77c4ff8bbf6a7">&#9670;&nbsp;</a></span>binary_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.autowrap.binary_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a SymPy function with expr as binary implementation

This is a convenience function that automates the steps needed to
autowrap the SymPy expression and attaching it to a Function object
with implemented_function().

Parameters
==========

symfunc : SymPy Function
    The function to bind the callable to.
expr : SymPy Expression
    The expression used to generate the function.
kwargs : dict
    Any kwargs accepted by autowrap.

Examples
========

&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; from sympy.utilities.autowrap import binary_function
&gt;&gt;&gt; expr = ((x - y)**(25)).expand()
&gt;&gt;&gt; f = binary_function('f', expr)
&gt;&gt;&gt; type(f)
&lt;class 'sympy.core.function.UndefinedFunction'&gt;
&gt;&gt;&gt; 2*f(x, y)
2*f(x, y)
&gt;&gt;&gt; f(x, y).evalf(2, subs={x: 1, y: 2})
-1.0</pre> 
</div>
</div>
<a id="af07bb5adcd0541cb2e413e9f10a0764d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07bb5adcd0541cb2e413e9f10a0764d">&#9670;&nbsp;</a></span>ufuncify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.utilities.autowrap.ufuncify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>language</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>backend</em> = <code>'numpy'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tempdir</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>helpers</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates a binary function that supports broadcasting on numpy arrays.

Parameters
==========

args : iterable
    Either a Symbol or an iterable of symbols. Specifies the argument
    sequence for the function.
expr
    A SymPy expression that defines the element wise operation.
language : string, optional
    If supplied, (options: 'C' or 'F95'), specifies the language of the
    generated code. If ``None`` [default], the language is inferred based
    upon the specified backend.
backend : string, optional
    Backend used to wrap the generated code. Either 'numpy' [default],
    'cython', or 'f2py'.
tempdir : string, optional
    Path to directory for temporary files. If this argument is supplied,
    the generated code and the wrapper input files are left intact in
    the specified path.
flags : iterable, optional
    Additional option flags that will be passed to the backend.
verbose : bool, optional
    If True, autowrap will not mute the command line backends. This can
    be helpful for debugging.
helpers : iterable, optional
    Used to define auxiliary expressions needed for the main expr. If
    the main expression needs to call a specialized function it should
    be put in the ``helpers`` iterable. Autowrap will then make sure
    that the compiled main expression can link to the helper routine.
    Items should be tuples with (&lt;funtion_name&gt;, &lt;sympy_expression&gt;,
    &lt;arguments&gt;). It is mandatory to supply an argument sequence to
    helper routines.
kwargs : dict
    These kwargs will be passed to autowrap if the `f2py` or `cython`
    backend is used and ignored if the `numpy` backend is used.

Notes
=====

The default backend ('numpy') will create actual instances of
``numpy.ufunc``. These support ndimensional broadcasting, and implicit type
conversion. Use of the other backends will result in a "ufunc-like"
function, which requires equal length 1-dimensional arrays for all
arguments, and will not perform any type conversions.

References
==========

.. [1] https://numpy.org/doc/stable/reference/ufuncs.html

Examples
========

&gt;&gt;&gt; from sympy.utilities.autowrap import ufuncify
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; f = ufuncify((x, y), y + x**2)
&gt;&gt;&gt; type(f)
&lt;class 'numpy.ufunc'&gt;
&gt;&gt;&gt; f([1, 2, 3], 2)
array([  3.,   6.,  11.])
&gt;&gt;&gt; f(np.arange(5), 3)
array([  3.,   4.,   7.,  12.,  19.])

For the 'f2py' and 'cython' backends, inputs are required to be equal length
1-dimensional arrays. The 'f2py' backend will perform type conversion, but
the Cython backend will error if the inputs are not of the expected type.

&gt;&gt;&gt; f_fortran = ufuncify((x, y), y + x**2, backend='f2py')
&gt;&gt;&gt; f_fortran(1, 2)
array([ 3.])
&gt;&gt;&gt; f_fortran(np.array([1, 2, 3]), np.array([1.0, 2.0, 3.0]))
array([  2.,   6.,  12.])
&gt;&gt;&gt; f_cython = ufuncify((x, y), y + x**2, backend='Cython')
&gt;&gt;&gt; f_cython(1, 2)  # doctest: +ELLIPSIS
Traceback (most recent call last):
  ...
TypeError: Argument '_x' has incorrect type (expected numpy.ndarray, got int)
&gt;&gt;&gt; f_cython(np.array([1.0]), np.array([2.0]))
array([ 3.])</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
