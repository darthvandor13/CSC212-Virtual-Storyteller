<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.tensor.index_methods Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1tensor.html">tensor</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1tensor_1_1index__methods.html">index_methods</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.tensor.index_methods Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1tensor_1_1index__methods_1_1IndexConformanceException.html">IndexConformanceException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a741e9be33dba5d8bed950c55f2ed0fb7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1index__methods.html#a741e9be33dba5d8bed950c55f2ed0fb7">get_indices</a> (expr)</td></tr>
<tr class="separator:a741e9be33dba5d8bed950c55f2ed0fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a305af9b6543dac3eb5262c783d9373"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1tensor_1_1index__methods.html#a6a305af9b6543dac3eb5262c783d9373">get_contraction_structure</a> (expr)</td></tr>
<tr class="separator:a6a305af9b6543dac3eb5262c783d9373"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Module with functions operating on IndexedBase, Indexed and Idx objects

    - Check shape conformance
    - Determine indices in resulting expression

    etc.

    Methods in this module could be implemented by calling methods on Expr
    objects instead.  When things stabilize this could be a useful
    refactoring.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6a305af9b6543dac3eb5262c783d9373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a305af9b6543dac3eb5262c783d9373">&#9670;&nbsp;</a></span>get_contraction_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.tensor.index_methods.get_contraction_structure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine dummy indices of ``expr`` and describe its structure

By *dummy* we mean indices that are summation indices.

The structure of the expression is determined and described as follows:

1) A conforming summation of Indexed objects is described with a dict where
   the keys are summation indices and the corresponding values are sets
   containing all terms for which the summation applies.  All Add objects
   in the SymPy expression tree are described like this.

2) For all nodes in the SymPy expression tree that are *not* of type Add, the
   following applies:

   If a node discovers contractions in one of its arguments, the node
   itself will be stored as a key in the dict.  For that key, the
   corresponding value is a list of dicts, each of which is the result of a
   recursive call to get_contraction_structure().  The list contains only
   dicts for the non-trivial deeper contractions, omitting dicts with None
   as the one and only key.

.. Note:: The presence of expressions among the dictionary keys indicates
   multiple levels of index contractions.  A nested dict displays nested
   contractions and may itself contain dicts from a deeper level.  In
   practical calculations the summation in the deepest nested level must be
   calculated first so that the outer expression can access the resulting
   indexed object.

Examples
========

&gt;&gt;&gt; from sympy.tensor.index_methods import get_contraction_structure
&gt;&gt;&gt; from sympy import default_sort_key
&gt;&gt;&gt; from sympy.tensor import IndexedBase, Idx
&gt;&gt;&gt; x, y, A = map(IndexedBase, ['x', 'y', 'A'])
&gt;&gt;&gt; i, j, k, l = map(Idx, ['i', 'j', 'k', 'l'])
&gt;&gt;&gt; get_contraction_structure(x[i]*y[i] + A[j, j])
{(i,): {x[i]*y[i]}, (j,): {A[j, j]}}
&gt;&gt;&gt; get_contraction_structure(x[i]*y[j])
{None: {x[i]*y[j]}}

A multiplication of contracted factors results in nested dicts representing
the internal contractions.

&gt;&gt;&gt; d = get_contraction_structure(x[i, i]*y[j, j])
&gt;&gt;&gt; sorted(d.keys(), key=default_sort_key)
[None, x[i, i]*y[j, j]]

In this case, the product has no contractions:

&gt;&gt;&gt; d[None]
{x[i, i]*y[j, j]}

Factors are contracted "first":

&gt;&gt;&gt; sorted(d[x[i, i]*y[j, j]], key=default_sort_key)
[{(i,): {x[i, i]}}, {(j,): {y[j, j]}}]

A parenthesized Add object is also returned as a nested dictionary.  The
term containing the parenthesis is a Mul with a contraction among the
arguments, so it will be found as a key in the result.  It stores the
dictionary resulting from a recursive call on the Add expression.

&gt;&gt;&gt; d = get_contraction_structure(x[i]*(y[i] + A[i, j]*x[j]))
&gt;&gt;&gt; sorted(d.keys(), key=default_sort_key)
[(A[i, j]*x[j] + y[i])*x[i], (i,)]
&gt;&gt;&gt; d[(i,)]
{(A[i, j]*x[j] + y[i])*x[i]}
&gt;&gt;&gt; d[x[i]*(A[i, j]*x[j] + y[i])]
[{None: {y[i]}, (j,): {A[i, j]*x[j]}}]

Powers with contractions in either base or exponent will also be found as
keys in the dictionary, mapping to a list of results from recursive calls:

&gt;&gt;&gt; d = get_contraction_structure(A[j, j]**A[i, i])
&gt;&gt;&gt; d[None]
{A[j, j]**A[i, i]}
&gt;&gt;&gt; nested_contractions = d[A[j, j]**A[i, i]]
&gt;&gt;&gt; nested_contractions[0]
{(j,): {A[j, j]}}
&gt;&gt;&gt; nested_contractions[1]
{(i,): {A[i, i]}}

The description of the contraction structure may appear complicated when
represented with a string in the above examples, but it is easy to iterate
over:

&gt;&gt;&gt; from sympy import Expr
&gt;&gt;&gt; for key in d:
...     if isinstance(key, Expr):
...         continue
...     for term in d[key]:
...         if term in d:
...             # treat deepest contraction first
...             pass
...     # treat outermost contactions here</pre> 
</div>
</div>
<a id="a741e9be33dba5d8bed950c55f2ed0fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741e9be33dba5d8bed950c55f2ed0fb7">&#9670;&nbsp;</a></span>get_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.tensor.index_methods.get_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine the outer indices of expression ``expr``

By *outer* we mean indices that are not summation indices.  Returns a set
and a dict.  The set contains outer indices and the dict contains
information about index symmetries.

Examples
========

&gt;&gt;&gt; from sympy.tensor.index_methods import get_indices
&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from sympy.tensor import IndexedBase
&gt;&gt;&gt; x, y, A = map(IndexedBase, ['x', 'y', 'A'])
&gt;&gt;&gt; i, j, a, z = symbols('i j a z', integer=True)

The indices of the total expression is determined, Repeated indices imply a
summation, for instance the trace of a matrix A:

&gt;&gt;&gt; get_indices(A[i, i])
(set(), {})

In the case of many terms, the terms are required to have identical
outer indices.  Else an IndexConformanceException is raised.

&gt;&gt;&gt; get_indices(x[i] + A[i, j]*y[j])
({i}, {})

:Exceptions:

An IndexConformanceException means that the terms ar not compatible, e.g.

&gt;&gt;&gt; get_indices(x[i] + y[j])                #doctest: +SKIP
        (...)
IndexConformanceException: Indices are not consistent: x(i) + y(j)

.. warning::
   The concept of *outer* indices applies recursively, starting on the deepest
   level.  This implies that dummies inside parenthesis are assumed to be
   summed first, so that the following expression is handled gracefully:

   &gt;&gt;&gt; get_indices((x[i] + A[i, j]*y[j])*x[j])
   ({i, j}, {})

   This is correct and may appear convenient, but you need to be careful
   with this as SymPy will happily .expand() the product, if requested.  The
   resulting expression would mix the outer ``j`` with the dummies inside
   the parenthesis, which makes it a different expression.  To be on the
   safe side, it is best to avoid such ambiguities by using unique indices
   for all contractions that should be held separate.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
