<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: numpy._core.strings Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>numpy</b></li><li class="navelem"><a class="el" href="namespacenumpy_1_1__core.html">_core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html">strings</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">numpy._core.strings Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15fdf36ce22bb7d1406705f3296f475a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a15fdf36ce22bb7d1406705f3296f475a">multiply</a> (a, i)</td></tr>
<tr class="separator:a15fdf36ce22bb7d1406705f3296f475a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdb560d387765090174cbb85f8121bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a8fdb560d387765090174cbb85f8121bf">mod</a> (a, values)</td></tr>
<tr class="separator:a8fdb560d387765090174cbb85f8121bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4597f8dd040a52a3fdc81fad70fb14"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#acf4597f8dd040a52a3fdc81fad70fb14">find</a> (a, sub, start=0, end=None)</td></tr>
<tr class="separator:acf4597f8dd040a52a3fdc81fad70fb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be2da3311b749d990106f298bbeeb9c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a0be2da3311b749d990106f298bbeeb9c">rfind</a> (a, sub, start=0, end=None)</td></tr>
<tr class="separator:a0be2da3311b749d990106f298bbeeb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4285280f817cfd7f6bb774e2dea02a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#abc4285280f817cfd7f6bb774e2dea02a">index</a> (a, sub, start=0, end=None)</td></tr>
<tr class="separator:abc4285280f817cfd7f6bb774e2dea02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee24ac10bb7d3b2ae3bafd63a41646c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a3ee24ac10bb7d3b2ae3bafd63a41646c">rindex</a> (a, sub, start=0, end=None)</td></tr>
<tr class="separator:a3ee24ac10bb7d3b2ae3bafd63a41646c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2cc3fb466cfe1eded226063421898f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a9b2cc3fb466cfe1eded226063421898f">count</a> (a, sub, start=0, end=None)</td></tr>
<tr class="separator:a9b2cc3fb466cfe1eded226063421898f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380915407a7bf49d870460e5349b70a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a380915407a7bf49d870460e5349b70a7">startswith</a> (a, prefix, start=0, end=None)</td></tr>
<tr class="separator:a380915407a7bf49d870460e5349b70a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6332c9342a97e0311afe4426ace9219"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#ab6332c9342a97e0311afe4426ace9219">endswith</a> (a, suffix, start=0, end=None)</td></tr>
<tr class="separator:ab6332c9342a97e0311afe4426ace9219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db83a90c094f7372ca6dba4fae9ce34"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a2db83a90c094f7372ca6dba4fae9ce34">decode</a> (a, encoding=None, errors=None)</td></tr>
<tr class="separator:a2db83a90c094f7372ca6dba4fae9ce34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f060ed36b76d16a7f8ffa7f96d9a545"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a7f060ed36b76d16a7f8ffa7f96d9a545">encode</a> (a, encoding=None, errors=None)</td></tr>
<tr class="separator:a7f060ed36b76d16a7f8ffa7f96d9a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42cccf73b3551d62219fdf3be5924a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#ac42cccf73b3551d62219fdf3be5924a2">expandtabs</a> (a, tabsize=8)</td></tr>
<tr class="separator:ac42cccf73b3551d62219fdf3be5924a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41c4b72d958a148d59f67473d1329b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a5c41c4b72d958a148d59f67473d1329b">center</a> (a, width, fillchar=' ')</td></tr>
<tr class="separator:a5c41c4b72d958a148d59f67473d1329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab547e52cdf028b1f48923b14918b6366"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#ab547e52cdf028b1f48923b14918b6366">ljust</a> (a, width, fillchar=' ')</td></tr>
<tr class="separator:ab547e52cdf028b1f48923b14918b6366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdee847f7bbf1b4b74f4999e438f4b09"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#abdee847f7bbf1b4b74f4999e438f4b09">rjust</a> (a, width, fillchar=' ')</td></tr>
<tr class="separator:abdee847f7bbf1b4b74f4999e438f4b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8770f9d8231047579b38196200299df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#ab8770f9d8231047579b38196200299df">zfill</a> (a, width)</td></tr>
<tr class="separator:ab8770f9d8231047579b38196200299df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77e0711d6ea2aa3917a8df050a3e0c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#ae77e0711d6ea2aa3917a8df050a3e0c5">lstrip</a> (a, chars=None)</td></tr>
<tr class="separator:ae77e0711d6ea2aa3917a8df050a3e0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c7489d7b3a0c1187276b5a90615ff6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#af6c7489d7b3a0c1187276b5a90615ff6">rstrip</a> (a, chars=None)</td></tr>
<tr class="separator:af6c7489d7b3a0c1187276b5a90615ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3688316f407bd9b428b3ba53f225de0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#ae3688316f407bd9b428b3ba53f225de0">strip</a> (a, chars=None)</td></tr>
<tr class="separator:ae3688316f407bd9b428b3ba53f225de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0318cc9d5fd59110681bcdff86b50667"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a0318cc9d5fd59110681bcdff86b50667">upper</a> (a)</td></tr>
<tr class="separator:a0318cc9d5fd59110681bcdff86b50667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0ba212c12310691599f91daaa19b3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a0f0ba212c12310691599f91daaa19b3f">lower</a> (a)</td></tr>
<tr class="separator:a0f0ba212c12310691599f91daaa19b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d047bf90f9330390de9d4835713d2a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a7d047bf90f9330390de9d4835713d2a9">swapcase</a> (a)</td></tr>
<tr class="separator:a7d047bf90f9330390de9d4835713d2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ed09dc24e833b3eb2450afbbbf7e5c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a55ed09dc24e833b3eb2450afbbbf7e5c">capitalize</a> (a)</td></tr>
<tr class="separator:a55ed09dc24e833b3eb2450afbbbf7e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ba3032922f8447b6bb16cb89fecf80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a82ba3032922f8447b6bb16cb89fecf80">title</a> (a)</td></tr>
<tr class="separator:a82ba3032922f8447b6bb16cb89fecf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2df2b4d88864ee121bf9cbb4358095f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#ac2df2b4d88864ee121bf9cbb4358095f">replace</a> (a, old, new, <a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a9b2cc3fb466cfe1eded226063421898f">count</a>=-1)</td></tr>
<tr class="separator:ac2df2b4d88864ee121bf9cbb4358095f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158736e4d88f2df38c647b0cc3fdfa89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a158736e4d88f2df38c647b0cc3fdfa89">partition</a> (a, sep)</td></tr>
<tr class="separator:a158736e4d88f2df38c647b0cc3fdfa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050df280dcbb44c7b1bc4e29d95af950"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a050df280dcbb44c7b1bc4e29d95af950">rpartition</a> (a, sep)</td></tr>
<tr class="separator:a050df280dcbb44c7b1bc4e29d95af950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8debf59b6388d5d3705cf6d1cba4e4be"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#a8debf59b6388d5d3705cf6d1cba4e4be">translate</a> (a, table, deletechars=None)</td></tr>
<tr class="separator:a8debf59b6388d5d3705cf6d1cba4e4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af7f74353ea73b97718520ebfdcb164ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1__core_1_1strings.html#af7f74353ea73b97718520ebfdcb164ce">MAX</a> = np.iinfo(np.int64).max</td></tr>
<tr class="separator:af7f74353ea73b97718520ebfdcb164ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module contains a set of functions for vectorized string
operations.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a55ed09dc24e833b3eb2450afbbbf7e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ed09dc24e833b3eb2450afbbbf7e5c">&#9670;&nbsp;</a></span>capitalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.capitalize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a copy of ``a`` with only the first character of each element
capitalized.

Calls :meth:`str.capitalize` element-wise.

For byte strings, this method is locale-dependent.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array of strings to capitalize.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.capitalize

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c
array(['a1b2', '1b2a', 'b2a1', '2a1b'],
    dtype='|S4')
&gt;&gt;&gt; np.strings.capitalize(c)
array(['A1b2', '1b2a', 'B2a1', '2a1b'],
    dtype='|S4')</pre> 
</div>
</div>
<a id="a5c41c4b72d958a148d59f67473d1329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c41c4b72d958a148d59f67473d1329b">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.center </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a copy of `a` with its elements centered in a string of
length `width`.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

width : array_like, with any integer dtype
    The length of the resulting strings, unless ``width &lt; str_len(a)``.
fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Optional padding character to use (default is space).

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.center

Notes
-----
While it is possible for ``a`` and ``fillchar`` to have different dtypes,
passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype "S"
is not allowed, and a ``ValueError`` is raised.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['a1b2','1b2a','b2a1','2a1b']); c
array(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='&lt;U4')
&gt;&gt;&gt; np.strings.center(c, width=9)
array(['   a1b2  ', '   1b2a  ', '   b2a1  ', '   2a1b  '], dtype='&lt;U9')
&gt;&gt;&gt; np.strings.center(c, width=9, fillchar='*')
array(['***a1b2**', '***1b2a**', '***b2a1**', '***2a1b**'], dtype='&lt;U9')
&gt;&gt;&gt; np.strings.center(c, width=1)
array(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='&lt;U4')</pre> 
</div>
</div>
<a id="a9b2cc3fb466cfe1eded226063421898f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2cc3fb466cfe1eded226063421898f">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an array with the number of non-overlapping occurrences of
substring ``sub`` in the range [``start``, ``end``).

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
   The substring to search for.

start, end : array_like, with any integer dtype
    The range to look in, interpreted as in slice notation.

Returns
-------
y : ndarray
    Output array of ints

See Also
--------
str.count

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
&gt;&gt;&gt; c
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')
&gt;&gt;&gt; np.strings.count(c, 'A')
array([3, 1, 1])
&gt;&gt;&gt; np.strings.count(c, 'aA')
array([3, 1, 0])
&gt;&gt;&gt; np.strings.count(c, 'A', start=1, end=4)
array([2, 1, 1])
&gt;&gt;&gt; np.strings.count(c, 'A', start=1, end=3)
array([1, 0, 0])</pre> 
</div>
</div>
<a id="a2db83a90c094f7372ca6dba4fae9ce34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db83a90c094f7372ca6dba4fae9ce34">&#9670;&nbsp;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.decode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>errors</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calls :meth:`bytes.decode` element-wise.

The set of available codecs comes from the Python standard library,
and may be extended at runtime.  For more information, see the
:mod:`codecs` module.

Parameters
----------
a : array_like, with ``bytes_`` dtype

encoding : str, optional
   The name of an encoding

errors : str, optional
   Specifies how to handle encoding errors

Returns
-------
out : ndarray

See Also
--------
:py:meth:`bytes.decode`

Notes
-----
The type of the result will depend on the encoding specified.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@',
...               b'\x81\x82\xc2\xc1\xc2\x82\x81'])
&gt;&gt;&gt; c
array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@',
       b'\x81\x82\xc2\xc1\xc2\x82\x81'], dtype='|S7')
&gt;&gt;&gt; np.strings.decode(c, encoding='cp037')
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')</pre> 
</div>
</div>
<a id="a7f060ed36b76d16a7f8ffa7f96d9a545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f060ed36b76d16a7f8ffa7f96d9a545">&#9670;&nbsp;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.encode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>errors</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calls :meth:`str.encode` element-wise.

The set of available codecs comes from the Python standard library,
and may be extended at runtime. For more information, see the
:mod:`codecs` module.

Parameters
----------
a : array_like, with ``StringDType`` or ``str_`` dtype

encoding : str, optional
   The name of an encoding

errors : str, optional
   Specifies how to handle encoding errors

Returns
-------
out : ndarray

See Also
--------
str.encode

Notes
-----
The type of the result will depend on the encoding specified.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
&gt;&gt;&gt; np.strings.encode(a, encoding='cp037')
array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@',
   b'\x81\x82\xc2\xc1\xc2\x82\x81'], dtype='|S7')</pre> 
</div>
</div>
<a id="ab6332c9342a97e0311afe4426ace9219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6332c9342a97e0311afe4426ace9219">&#9670;&nbsp;</a></span>endswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.endswith </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a boolean array which is `True` where the string element
in ``a`` ends with ``suffix``, otherwise `False`.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

suffix : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

start, end : array_like, with any integer dtype
    With ``start``, test beginning at that position. With ``end``,
    stop comparing at that position.

Returns
-------
out : ndarray
    Output array of bools

See Also
--------
str.endswith

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; s = np.array(['foo', 'bar'])
&gt;&gt;&gt; s
array(['foo', 'bar'], dtype='&lt;U3')
&gt;&gt;&gt; np.strings.endswith(s, 'ar')
array([False,  True])
&gt;&gt;&gt; np.strings.endswith(s, 'a', start=1, end=2)
array([False,  True])</pre> 
</div>
</div>
<a id="ac42cccf73b3551d62219fdf3be5924a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42cccf73b3551d62219fdf3be5924a2">&#9670;&nbsp;</a></span>expandtabs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.expandtabs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tabsize</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a copy of each string element where all tab characters are
replaced by one or more spaces.

Calls :meth:`str.expandtabs` element-wise.

Return a copy of each string element where all tab characters are
replaced by one or more spaces, depending on the current column
and the given `tabsize`. The column number is reset to zero after
each newline occurring in the string. This doesn't understand other
non-printing characters or escape sequences.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array
tabsize : int, optional
    Replace tabs with `tabsize` number of spaces.  If not given defaults
    to 8 spaces.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input type

See Also
--------
str.expandtabs

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(['\t\tHello\tworld'])
&gt;&gt;&gt; np.strings.expandtabs(a, tabsize=4)  # doctest: +SKIP
array(['        Hello   world'], dtype='&lt;U21')  # doctest: +SKIP</pre> 
</div>
</div>
<a id="acf4597f8dd040a52a3fdc81fad70fb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4597f8dd040a52a3fdc81fad70fb14">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.find </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For each element, return the lowest index in the string where
substring ``sub`` is found, such that ``sub`` is contained in the
range [``start``, ``end``).

Parameters
----------
a : array_like, with ``StringDType``, ``bytes_`` or ``str_`` dtype

sub : array_like, with `np.bytes_` or `np.str_` dtype
    The substring to search for.

start, end : array_like, with any integer dtype
    The range to look in, interpreted as in slice notation.

Returns
-------
y : ndarray
    Output array of ints

See Also
--------
str.find

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(["NumPy is a Python library"])
&gt;&gt;&gt; np.strings.find(a, "Python")
array([11])</pre> 
</div>
</div>
<a id="abc4285280f817cfd7f6bb774e2dea02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4285280f817cfd7f6bb774e2dea02a">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like `find`, but raises :exc:`ValueError` when the substring is not found.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

start, end : array_like, with any integer dtype, optional

Returns
-------
out : ndarray
    Output array of ints.

See Also
--------
find, str.index

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(["Computer Science"])
&gt;&gt;&gt; np.strings.index(a, "Science", start=0, end=None)
array([9])</pre> 
</div>
</div>
<a id="ab547e52cdf028b1f48923b14918b6366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab547e52cdf028b1f48923b14918b6366">&#9670;&nbsp;</a></span>ljust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.ljust </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array with the elements of `a` left-justified in a
string of length `width`.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

width : array_like, with any integer dtype
    The length of the resulting strings, unless ``width &lt; str_len(a)``.
fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Optional character to use for padding (default is space).

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.ljust

Notes
-----
While it is possible for ``a`` and ``fillchar`` to have different dtypes,
passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype "S"
is not allowed, and a ``ValueError`` is raised.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
&gt;&gt;&gt; np.strings.ljust(c, width=3)
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')
&gt;&gt;&gt; np.strings.ljust(c, width=9)
array(['aAaAaA   ', '  aA     ', 'abBABba  '], dtype='&lt;U9')</pre> 
</div>
</div>
<a id="a0f0ba212c12310691599f91daaa19b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0ba212c12310691599f91daaa19b3f">&#9670;&nbsp;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.lower </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array with the elements converted to lowercase.

Call :meth:`str.lower` element-wise.

For 8-bit strings, this method is locale-dependent.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.lower

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['A1B C', '1BCA', 'BCA1']); c
array(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5')
&gt;&gt;&gt; np.strings.lower(c)
array(['a1b c', '1bca', 'bca1'], dtype='&lt;U5')</pre> 
</div>
</div>
<a id="ae77e0711d6ea2aa3917a8df050a3e0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77e0711d6ea2aa3917a8df050a3e0c5">&#9670;&nbsp;</a></span>lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.lstrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>chars</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For each element in `a`, return a copy with the leading characters
removed.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
chars : scalar with the same dtype as ``a``, optional
   The ``chars`` argument is a string specifying the set of
   characters to be removed. If ``None``, the ``chars``
   argument defaults to removing whitespace. The ``chars`` argument
   is not a prefix or suffix; rather, all combinations of its
   values are stripped.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.lstrip

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
&gt;&gt;&gt; c
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')
# The 'a' variable is unstripped from c[1] because of leading whitespace.
&gt;&gt;&gt; np.strings.lstrip(c, 'a')
array(['AaAaA', '  aA  ', 'bBABba'], dtype='&lt;U7')
&gt;&gt;&gt; np.strings.lstrip(c, 'A') # leaves c unchanged
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')
&gt;&gt;&gt; (np.strings.lstrip(c, ' ') == np.strings.lstrip(c, '')).all()
np.False_
&gt;&gt;&gt; (np.strings.lstrip(c, ' ') == np.strings.lstrip(c)).all()
np.True_</pre> 
</div>
</div>
<a id="a8fdb560d387765090174cbb85f8121bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdb560d387765090174cbb85f8121bf">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.mod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (a % i), that is pre-Python 2.6 string formatting
(interpolation), element-wise for a pair of array_likes of str
or unicode.

Parameters
----------
a : array_like, with `np.bytes_` or `np.str_` dtype

values : array_like of values
   These values will be element-wise interpolated into the string.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(["NumPy is a %s library"])
&gt;&gt;&gt; np.strings.mod(a, values=["Python"])
array(['NumPy is a Python library'], dtype='&lt;U25')

&gt;&gt;&gt; a = np.array([b'%d bytes', b'%d bits'])
&gt;&gt;&gt; values = np.array([8, 64])
&gt;&gt;&gt; np.strings.mod(a, values)
array([b'8 bytes', b'64 bits'], dtype='|S7')</pre> 
</div>
</div>
<a id="a15fdf36ce22bb7d1406705f3296f475a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fdf36ce22bb7d1406705f3296f475a">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.multiply </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return (a * i), that is string multiple concatenation,
element-wise.

Values in ``i`` of less than 0 are treated as 0 (which yields an
empty string).

Parameters
----------
a : array_like, with ``StringDType``, ``bytes_`` or ``str_`` dtype

i : array_like, with any integer dtype

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(["a", "b", "c"])
&gt;&gt;&gt; np.strings.multiply(a, 3)
array(['aaa', 'bbb', 'ccc'], dtype='&lt;U3')
&gt;&gt;&gt; i = np.array([1, 2, 3])
&gt;&gt;&gt; np.strings.multiply(a, i)
array(['a', 'bb', 'ccc'], dtype='&lt;U3')
&gt;&gt;&gt; np.strings.multiply(np.array(['a']), i)
array(['a', 'aa', 'aaa'], dtype='&lt;U3')
&gt;&gt;&gt; a = np.array(['a', 'b', 'c', 'd', 'e', 'f']).reshape((2, 3))
&gt;&gt;&gt; np.strings.multiply(a, 3)
array([['aaa', 'bbb', 'ccc'],
       ['ddd', 'eee', 'fff']], dtype='&lt;U3')
&gt;&gt;&gt; np.strings.multiply(a, i)
array([['a', 'bb', 'ccc'],
       ['d', 'ee', 'fff']], dtype='&lt;U3')</pre> 
</div>
</div>
<a id="a158736e4d88f2df38c647b0cc3fdfa89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158736e4d88f2df38c647b0cc3fdfa89">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.partition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Partition each element in ``a`` around ``sep``.

For each element in ``a``, split the element at the first
occurrence of ``sep``, and return a 3-tuple containing the part
before the separator, the separator itself, and the part after
the separator. If the separator is not found, the first item of
the tuple will contain the whole string, and the second and third
ones will be the empty string.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array
sep : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Separator to split each string element in ``a``.

Returns
-------
out : 3-tuple:
    - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
      part before the separator
    - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
      separator
    - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
      part after the separator

See Also
--------
str.partition

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.array(["Numpy is nice!"])
&gt;&gt;&gt; np.strings.partition(x, " ")
(array(['Numpy'], dtype='&lt;U5'),
 array([' '], dtype='&lt;U1'),
 array(['is nice!'], dtype='&lt;U8'))</pre> 
</div>
</div>
<a id="ac2df2b4d88864ee121bf9cbb4358095f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2df2b4d88864ee121bf9cbb4358095f">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.replace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For each element in ``a``, return a copy of the string with
occurrences of substring ``old`` replaced by ``new``.

Parameters
----------
a : array_like, with ``bytes_`` or ``str_`` dtype

old, new : array_like, with ``bytes_`` or ``str_`` dtype

count : array_like, with ``int_`` dtype
    If the optional argument ``count`` is given, only the first
    ``count`` occurrences are replaced.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.replace

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(["That is a mango", "Monkeys eat mangos"])
&gt;&gt;&gt; np.strings.replace(a, 'mango', 'banana')
array(['That is a banana', 'Monkeys eat bananas'], dtype='&lt;U19')

&gt;&gt;&gt; a = np.array(["The dish is fresh", "This is it"])
&gt;&gt;&gt; np.strings.replace(a, 'is', 'was')
array(['The dwash was fresh', 'Thwas was it'], dtype='&lt;U19')</pre> 
</div>
</div>
<a id="a0be2da3311b749d990106f298bbeeb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be2da3311b749d990106f298bbeeb9c">&#9670;&nbsp;</a></span>rfind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.rfind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For each element, return the highest index in the string where
substring ``sub`` is found, such that ``sub`` is contained in the
range [``start``, ``end``).

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    The substring to search for.

start, end : array_like, with any integer dtype
    The range to look in, interpreted as in slice notation.

Returns
-------
y : ndarray
    Output array of ints

See Also
--------
str.rfind

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(["Computer Science"])
&gt;&gt;&gt; np.strings.rfind(a, "Science", start=0, end=None)
array([9])
&gt;&gt;&gt; np.strings.rfind(a, "Science", start=0, end=8)
array([-1])
&gt;&gt;&gt; b = np.array(["Computer Science", "Science"])
&gt;&gt;&gt; np.strings.rfind(b, "Science", start=0, end=None)
array([9, 0])</pre> 
</div>
</div>
<a id="a3ee24ac10bb7d3b2ae3bafd63a41646c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee24ac10bb7d3b2ae3bafd63a41646c">&#9670;&nbsp;</a></span>rindex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.rindex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like `rfind`, but raises :exc:`ValueError` when the substring `sub` is
not found.

Parameters
----------
a : array-like, with `np.bytes_` or `np.str_` dtype

sub : array-like, with `np.bytes_` or `np.str_` dtype

start, end : array-like, with any integer dtype, optional

Returns
-------
out : ndarray
    Output array of ints.

See Also
--------
rfind, str.rindex

Examples
--------
&gt;&gt;&gt; a = np.array(["Computer Science"])
&gt;&gt;&gt; np.strings.rindex(a, "Science", start=0, end=None)
array([9])</pre> 
</div>
</div>
<a id="abdee847f7bbf1b4b74f4999e438f4b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdee847f7bbf1b4b74f4999e438f4b09">&#9670;&nbsp;</a></span>rjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.rjust </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array with the elements of `a` right-justified in a
string of length `width`.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

width : array_like, with any integer dtype
    The length of the resulting strings, unless ``width &lt; str_len(a)``.
fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Optional padding character to use (default is space).

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.rjust

Notes
-----
While it is possible for ``a`` and ``fillchar`` to have different dtypes,
passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype "S"
is not allowed, and a ``ValueError`` is raised.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
&gt;&gt;&gt; np.strings.rjust(a, width=3)
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')
&gt;&gt;&gt; np.strings.rjust(a, width=9)
array(['   aAaAaA', '     aA  ', '  abBABba'], dtype='&lt;U9')</pre> 
</div>
</div>
<a id="a050df280dcbb44c7b1bc4e29d95af950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050df280dcbb44c7b1bc4e29d95af950">&#9670;&nbsp;</a></span>rpartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.rpartition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Partition (split) each element around the right-most separator.

For each element in ``a``, split the element at the last
occurrence of ``sep``, and return a 3-tuple containing the part
before the separator, the separator itself, and the part after
the separator. If the separator is not found, the third item of
the tuple will contain the whole string, and the first and second
ones will be the empty string.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array
sep : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Separator to split each string element in ``a``.

Returns
-------
out : 3-tuple:
    - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
      part before the separator
    - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
      separator
    - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
      part after the separator

See Also
--------
str.rpartition

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
&gt;&gt;&gt; np.strings.rpartition(a, 'A')
(array(['aAaAa', '  a', 'abB'], dtype='&lt;U5'),
 array(['A', 'A', 'A'], dtype='&lt;U1'),
 array(['', '  ', 'Bba'], dtype='&lt;U3'))</pre> 
</div>
</div>
<a id="af6c7489d7b3a0c1187276b5a90615ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c7489d7b3a0c1187276b5a90615ff6">&#9670;&nbsp;</a></span>rstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.rstrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>chars</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For each element in `a`, return a copy with the trailing characters
removed.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
chars : scalar with the same dtype as ``a``, optional
   The ``chars`` argument is a string specifying the set of
   characters to be removed. If ``None``, the ``chars``
   argument defaults to removing whitespace. The ``chars`` argument
   is not a prefix or suffix; rather, all combinations of its
   values are stripped.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.rstrip

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['aAaAaA', 'abBABba'])
&gt;&gt;&gt; c
array(['aAaAaA', 'abBABba'], dtype='&lt;U7')
&gt;&gt;&gt; np.strings.rstrip(c, 'a')
array(['aAaAaA', 'abBABb'], dtype='&lt;U7')
&gt;&gt;&gt; np.strings.rstrip(c, 'A')
array(['aAaAa', 'abBABba'], dtype='&lt;U7')</pre> 
</div>
</div>
<a id="a380915407a7bf49d870460e5349b70a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380915407a7bf49d870460e5349b70a7">&#9670;&nbsp;</a></span>startswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.startswith </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a boolean array which is `True` where the string element
in ``a`` starts with ``prefix``, otherwise `False`.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

prefix : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

start, end : array_like, with any integer dtype
    With ``start``, test beginning at that position. With ``end``,
    stop comparing at that position.

Returns
-------
out : ndarray
    Output array of bools

See Also
--------
str.startswith

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; s = np.array(['foo', 'bar'])
&gt;&gt;&gt; s
array(['foo', 'bar'], dtype='&lt;U3')
&gt;&gt;&gt; np.strings.startswith(s, 'fo')
array([True,  False])
&gt;&gt;&gt; np.strings.startswith(s, 'o', start=1, end=2)
array([True,  False])</pre> 
</div>
</div>
<a id="ae3688316f407bd9b428b3ba53f225de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3688316f407bd9b428b3ba53f225de0">&#9670;&nbsp;</a></span>strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.strip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>chars</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For each element in `a`, return a copy with the leading and
trailing characters removed.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
chars : scalar with the same dtype as ``a``, optional
   The ``chars`` argument is a string specifying the set of
   characters to be removed. If ``None``, the ``chars``
   argument defaults to removing whitespace. The ``chars`` argument
   is not a prefix or suffix; rather, all combinations of its
   values are stripped.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.strip

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
&gt;&gt;&gt; c
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')
&gt;&gt;&gt; np.strings.strip(c)
array(['aAaAaA', 'aA', 'abBABba'], dtype='&lt;U7')
# 'a' unstripped from c[1] because of leading whitespace.
&gt;&gt;&gt; np.strings.strip(c, 'a')
array(['AaAaA', '  aA  ', 'bBABb'], dtype='&lt;U7')
# 'A' unstripped from c[1] because of trailing whitespace.
&gt;&gt;&gt; np.strings.strip(c, 'A')
array(['aAaAa', '  aA  ', 'abBABba'], dtype='&lt;U7')</pre> 
</div>
</div>
<a id="a7d047bf90f9330390de9d4835713d2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d047bf90f9330390de9d4835713d2a9">&#9670;&nbsp;</a></span>swapcase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.swapcase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return element-wise a copy of the string with
uppercase characters converted to lowercase and vice versa.

Calls :meth:`str.swapcase` element-wise.

For 8-bit strings, this method is locale-dependent.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.swapcase

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c
array(['a1B c', '1b Ca', 'b Ca1', 'cA1b'],
    dtype='|S5')
&gt;&gt;&gt; np.strings.swapcase(c)
array(['A1b C', '1B cA', 'B cA1', 'Ca1B'],
    dtype='|S5')</pre> 
</div>
</div>
<a id="a82ba3032922f8447b6bb16cb89fecf80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ba3032922f8447b6bb16cb89fecf80">&#9670;&nbsp;</a></span>title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.title </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return element-wise title cased version of string or unicode.

Title case words start with uppercase characters, all remaining cased
characters are lowercase.

Calls :meth:`str.title` element-wise.

For 8-bit strings, this method is locale-dependent.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.title

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c
array(['a1b c', '1b ca', 'b ca1', 'ca1b'],
    dtype='|S5')
&gt;&gt;&gt; np.strings.title(c)
array(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'],
    dtype='|S5')</pre> 
</div>
</div>
<a id="a8debf59b6388d5d3705cf6d1cba4e4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8debf59b6388d5d3705cf6d1cba4e4be">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.translate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deletechars</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For each element in `a`, return a copy of the string where all
characters occurring in the optional argument `deletechars` are
removed, and the remaining characters have been mapped through the
given translation table.

Calls :meth:`str.translate` element-wise.

Parameters
----------
a : array-like, with `np.bytes_` or `np.str_` dtype

table : str of length 256

deletechars : str

Returns
-------
out : ndarray
    Output array of str or unicode, depending on input type

See Also
--------
str.translate

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(['a1b c', '1bca', 'bca1'])
&gt;&gt;&gt; table = a[0].maketrans('abc', '123')
&gt;&gt;&gt; deletechars = ' '
&gt;&gt;&gt; np.char.translate(a, table, deletechars)
array(['112 3', '1231', '2311'], dtype='&lt;U5')</pre> 
</div>
</div>
<a id="a0318cc9d5fd59110681bcdff86b50667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0318cc9d5fd59110681bcdff86b50667">&#9670;&nbsp;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.upper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array with the elements converted to uppercase.

Calls :meth:`str.upper` element-wise.

For 8-bit strings, this method is locale-dependent.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
    Input array.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input types

See Also
--------
str.upper

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array(['a1b c', '1bca', 'bca1']); c
array(['a1b c', '1bca', 'bca1'], dtype='&lt;U5')
&gt;&gt;&gt; np.strings.upper(c)
array(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5')</pre> 
</div>
</div>
<a id="ab8770f9d8231047579b38196200299df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8770f9d8231047579b38196200299df">&#9670;&nbsp;</a></span>zfill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy._core.strings.zfill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the numeric string left-filled with zeros. A leading
sign prefix (``+``/``-``) is handled by inserting the padding
after the sign character rather than before.

Parameters
----------
a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype

width : array_like, with any integer dtype
    Width of string to left-fill elements in `a`.

Returns
-------
out : ndarray
    Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
    depending on input type

See Also
--------
str.zfill

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.strings.zfill(['1', '-1', '+1'], 3)
array(['001', '-01', '+01'], dtype='&lt;U3')</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af7f74353ea73b97718520ebfdcb164ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f74353ea73b97718520ebfdcb164ce">&#9670;&nbsp;</a></span>MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy._core.strings.MAX = np.iinfo(np.int64).max</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
