<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAO Virtual Storyteller: sympy.printing.codeprinter Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAO Virtual Storyteller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesympy.html">sympy</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1printing.html">printing</a></li><li class="navelem"><a class="el" href="namespacesympy_1_1printing_1_1codeprinter.html">codeprinter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sympy.printing.codeprinter Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1printing_1_1codeprinter_1_1requires.html">requires</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1printing_1_1codeprinter_1_1AssignmentError.html">AssignmentError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1printing_1_1codeprinter_1_1PrintMethodNotImplementedError.html">PrintMethodNotImplementedError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsympy_1_1printing_1_1codeprinter_1_1CodePrinter.html">CodePrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa18091f04a4473b20b0eb887d21ea907"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1printing_1_1codeprinter.html#aa18091f04a4473b20b0eb887d21ea907">ccode</a> (expr, assign_to=None, standard='c99', **settings)</td></tr>
<tr class="separator:aa18091f04a4473b20b0eb887d21ea907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3850d566c9f3c5295541580300b88008"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1printing_1_1codeprinter.html#a3850d566c9f3c5295541580300b88008">print_ccode</a> (expr, **settings)</td></tr>
<tr class="separator:a3850d566c9f3c5295541580300b88008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed936cf6ef34e76ab3d06caf411fd7c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1printing_1_1codeprinter.html#aed936cf6ef34e76ab3d06caf411fd7c5">fcode</a> (expr, assign_to=None, **settings)</td></tr>
<tr class="separator:aed936cf6ef34e76ab3d06caf411fd7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec97e2a573af394cac47a88f61034cc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1printing_1_1codeprinter.html#a3ec97e2a573af394cac47a88f61034cc">print_fcode</a> (expr, **settings)</td></tr>
<tr class="separator:a3ec97e2a573af394cac47a88f61034cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f9eb7543a52585e79167aa4d34ccec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesympy_1_1printing_1_1codeprinter.html#a75f9eb7543a52585e79167aa4d34ccec">cxxcode</a> (expr, assign_to=None, standard='c++11', **settings)</td></tr>
<tr class="separator:a75f9eb7543a52585e79167aa4d34ccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa18091f04a4473b20b0eb887d21ea907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18091f04a4473b20b0eb887d21ea907">&#9670;&nbsp;</a></span>ccode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.printing.codeprinter.ccode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assign_to</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>standard</em> = <code>'c99'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts an expr to a string of c code

Parameters
==========

expr : Expr
    A SymPy expression to be converted.
assign_to : optional
    When given, the argument is used as the name of the variable to which
    the expression is assigned. Can be a string, ``Symbol``,
    ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of
    line-wrapping, or for expressions that generate multi-line statements.
standard : str, optional
    String specifying the standard. If your compiler supports a more modern
    standard you may set this to 'c99' to allow the printer to use more math
    functions. [default='c89'].
precision : integer, optional
    The precision for numbers such as pi [default=17].
user_functions : dict, optional
    A dictionary where the keys are string representations of either
    ``FunctionClass`` or ``UndefinedFunction`` instances and the values
    are their desired C string representations. Alternatively, the
    dictionary value can be a list of tuples i.e. [(argument_test,
    cfunction_string)] or [(argument_test, cfunction_formater)]. See below
    for examples.
dereference : iterable, optional
    An iterable of symbols that should be dereferenced in the printed code
    expression. These would be values passed by address to the function.
    For example, if ``dereference=[a]``, the resulting code would print
    ``(*a)`` instead of ``a``.
human : bool, optional
    If True, the result is a single string that may contain some constant
    declarations for the number symbols. If False, the same information is
    returned in a tuple of (symbols_to_declare, not_supported_functions,
    code_text). [default=True].
contract: bool, optional
    If True, ``Indexed`` instances are assumed to obey tensor contraction
    rules and the corresponding nested loops over indices are generated.
    Setting contract=False will not generate loops, instead the user is
    responsible to provide values for the indices in the code.
    [default=True].

Examples
========

&gt;&gt;&gt; from sympy import ccode, symbols, Rational, sin, ceiling, Abs, Function
&gt;&gt;&gt; x, tau = symbols("x, tau")
&gt;&gt;&gt; expr = (2*tau)**Rational(7, 2)
&gt;&gt;&gt; ccode(expr)
'8*M_SQRT2*pow(tau, 7.0/2.0)'
&gt;&gt;&gt; ccode(expr, math_macros={})
'8*sqrt(2)*pow(tau, 7.0/2.0)'
&gt;&gt;&gt; ccode(sin(x), assign_to="s")
's = sin(x);'
&gt;&gt;&gt; from sympy.codegen.ast import real, float80
&gt;&gt;&gt; ccode(expr, type_aliases={real: float80})
'8*M_SQRT2l*powl(tau, 7.0L/2.0L)'

Simple custom printing can be defined for certain types by passing a
dictionary of {"type" : "function"} to the ``user_functions`` kwarg.
Alternatively, the dictionary value can be a list of tuples i.e.
[(argument_test, cfunction_string)].

&gt;&gt;&gt; custom_functions = {
...   "ceiling": "CEIL",
...   "Abs": [(lambda x: not x.is_integer, "fabs"),
...           (lambda x: x.is_integer, "ABS")],
...   "func": "f"
... }
&gt;&gt;&gt; func = Function('func')
&gt;&gt;&gt; ccode(func(Abs(x) + ceiling(x)), standard='C89', user_functions=custom_functions)
'f(fabs(x) + CEIL(x))'

or if the C-function takes a subset of the original arguments:

&gt;&gt;&gt; ccode(2**x + 3**x, standard='C99', user_functions={'Pow': [
...   (lambda b, e: b == 2, lambda b, e: 'exp2(%s)' % e),
...   (lambda b, e: b != 2, 'pow')]})
'exp2(x) + pow(3, x)'

``Piecewise`` expressions are converted into conditionals. If an
``assign_to`` variable is provided an if statement is created, otherwise
the ternary operator is used. Note that if the ``Piecewise`` lacks a
default term, represented by ``(expr, True)`` then an error will be thrown.
This is to prevent generating an expression that may not evaluate to
anything.

&gt;&gt;&gt; from sympy import Piecewise
&gt;&gt;&gt; expr = Piecewise((x + 1, x &gt; 0), (x, True))
&gt;&gt;&gt; print(ccode(expr, tau, standard='C89'))
if (x &gt; 0) {
tau = x + 1;
}
else {
tau = x;
}

Support for loops is provided through ``Indexed`` types. With
``contract=True`` these expressions will be turned into loops, whereas
``contract=False`` will just print the assignment expression that should be
looped over:

&gt;&gt;&gt; from sympy import Eq, IndexedBase, Idx
&gt;&gt;&gt; len_y = 5
&gt;&gt;&gt; y = IndexedBase('y', shape=(len_y,))
&gt;&gt;&gt; t = IndexedBase('t', shape=(len_y,))
&gt;&gt;&gt; Dy = IndexedBase('Dy', shape=(len_y-1,))
&gt;&gt;&gt; i = Idx('i', len_y-1)
&gt;&gt;&gt; e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))
&gt;&gt;&gt; ccode(e.rhs, assign_to=e.lhs, contract=False, standard='C89')
'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'

Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions
must be provided to ``assign_to``. Note that any expression that can be
generated normally can also exist inside a Matrix:

&gt;&gt;&gt; from sympy import Matrix, MatrixSymbol
&gt;&gt;&gt; mat = Matrix([x**2, Piecewise((x + 1, x &gt; 0), (x, True)), sin(x)])
&gt;&gt;&gt; A = MatrixSymbol('A', 3, 1)
&gt;&gt;&gt; print(ccode(mat, A, standard='C89'))
A[0] = pow(x, 2);
if (x &gt; 0) {
   A[1] = x + 1;
}
else {
   A[1] = x;
}
A[2] = sin(x);
</pre> 
</div>
</div>
<a id="a75f9eb7543a52585e79167aa4d34ccec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f9eb7543a52585e79167aa4d34ccec">&#9670;&nbsp;</a></span>cxxcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.printing.codeprinter.cxxcode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assign_to</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>standard</em> = <code>'c++11'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> C++ equivalent of :func:`~.ccode`. </pre> 
</div>
</div>
<a id="aed936cf6ef34e76ab3d06caf411fd7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed936cf6ef34e76ab3d06caf411fd7c5">&#9670;&nbsp;</a></span>fcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.printing.codeprinter.fcode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>assign_to</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts an expr to a string of fortran code

Parameters
==========

expr : Expr
    A SymPy expression to be converted.
assign_to : optional
    When given, the argument is used as the name of the variable to which
    the expression is assigned. Can be a string, ``Symbol``,
    ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of
    line-wrapping, or for expressions that generate multi-line statements.
precision : integer, optional
    DEPRECATED. Use type_mappings instead. The precision for numbers such
    as pi [default=17].
user_functions : dict, optional
    A dictionary where keys are ``FunctionClass`` instances and values are
    their string representations. Alternatively, the dictionary value can
    be a list of tuples i.e. [(argument_test, cfunction_string)]. See below
    for examples.
human : bool, optional
    If True, the result is a single string that may contain some constant
    declarations for the number symbols. If False, the same information is
    returned in a tuple of (symbols_to_declare, not_supported_functions,
    code_text). [default=True].
contract: bool, optional
    If True, ``Indexed`` instances are assumed to obey tensor contraction
    rules and the corresponding nested loops over indices are generated.
    Setting contract=False will not generate loops, instead the user is
    responsible to provide values for the indices in the code.
    [default=True].
source_format : optional
    The source format can be either 'fixed' or 'free'. [default='fixed']
standard : integer, optional
    The Fortran standard to be followed. This is specified as an integer.
    Acceptable standards are 66, 77, 90, 95, 2003, and 2008. Default is 77.
    Note that currently the only distinction internally is between
    standards before 95, and those 95 and after. This may change later as
    more features are added.
name_mangling : bool, optional
    If True, then the variables that would become identical in
    case-insensitive Fortran are mangled by appending different number
    of ``_`` at the end. If False, SymPy Will not interfere with naming of
    variables. [default=True]

Examples
========

&gt;&gt;&gt; from sympy import fcode, symbols, Rational, sin, ceiling, floor
&gt;&gt;&gt; x, tau = symbols("x, tau")
&gt;&gt;&gt; fcode((2*tau)**Rational(7, 2))
'      8*sqrt(2.0d0)*tau**(7.0d0/2.0d0)'
&gt;&gt;&gt; fcode(sin(x), assign_to="s")
'      s = sin(x)'

Custom printing can be defined for certain types by passing a dictionary of
"type" : "function" to the ``user_functions`` kwarg. Alternatively, the
dictionary value can be a list of tuples i.e. [(argument_test,
cfunction_string)].

&gt;&gt;&gt; custom_functions = {
...   "ceiling": "CEIL",
...   "floor": [(lambda x: not x.is_integer, "FLOOR1"),
...             (lambda x: x.is_integer, "FLOOR2")]
... }
&gt;&gt;&gt; fcode(floor(x) + ceiling(x), user_functions=custom_functions)
'      CEIL(x) + FLOOR1(x)'

``Piecewise`` expressions are converted into conditionals. If an
``assign_to`` variable is provided an if statement is created, otherwise
the ternary operator is used. Note that if the ``Piecewise`` lacks a
default term, represented by ``(expr, True)`` then an error will be thrown.
This is to prevent generating an expression that may not evaluate to
anything.

&gt;&gt;&gt; from sympy import Piecewise
&gt;&gt;&gt; expr = Piecewise((x + 1, x &gt; 0), (x, True))
&gt;&gt;&gt; print(fcode(expr, tau))
      if (x &gt; 0) then
         tau = x + 1
      else
         tau = x
      end if

Support for loops is provided through ``Indexed`` types. With
``contract=True`` these expressions will be turned into loops, whereas
``contract=False`` will just print the assignment expression that should be
looped over:

&gt;&gt;&gt; from sympy import Eq, IndexedBase, Idx
&gt;&gt;&gt; len_y = 5
&gt;&gt;&gt; y = IndexedBase('y', shape=(len_y,))
&gt;&gt;&gt; t = IndexedBase('t', shape=(len_y,))
&gt;&gt;&gt; Dy = IndexedBase('Dy', shape=(len_y-1,))
&gt;&gt;&gt; i = Idx('i', len_y-1)
&gt;&gt;&gt; e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))
&gt;&gt;&gt; fcode(e.rhs, assign_to=e.lhs, contract=False)
'      Dy(i) = (y(i + 1) - y(i))/(t(i + 1) - t(i))'

Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions
must be provided to ``assign_to``. Note that any expression that can be
generated normally can also exist inside a Matrix:

&gt;&gt;&gt; from sympy import Matrix, MatrixSymbol
&gt;&gt;&gt; mat = Matrix([x**2, Piecewise((x + 1, x &gt; 0), (x, True)), sin(x)])
&gt;&gt;&gt; A = MatrixSymbol('A', 3, 1)
&gt;&gt;&gt; print(fcode(mat, A))
      A(1, 1) = x**2
         if (x &gt; 0) then
      A(2, 1) = x + 1
         else
      A(2, 1) = x
         end if
      A(3, 1) = sin(x)
</pre> 
</div>
</div>
<a id="a3850d566c9f3c5295541580300b88008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3850d566c9f3c5295541580300b88008">&#9670;&nbsp;</a></span>print_ccode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.printing.codeprinter.print_ccode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Prints C representation of the given expression.</pre> 
</div>
</div>
<a id="a3ec97e2a573af394cac47a88f61034cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec97e2a573af394cac47a88f61034cc">&#9670;&nbsp;</a></span>print_fcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sympy.printing.codeprinter.print_fcode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Prints the Fortran representation of the given expression.

   See fcode for the meaning of the optional arguments.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
